
/var/folders/v9/f__p9fts3m97z080r3qqv_q00000gn/T/arduino_build_184109/JB_CPU_Usage_Basic1_Serial.ino.elf:     file format elf32-avr

Contents of section .data:
 800100 c0c62d00 00000000 f6005f00 8d004301  ..-......._...C.
 800110 be009c00 b0004c6f 6f70733a 20002e20  ......Loops: .. 
 800120 54696d65 3a200020 5b6d735d 000d0a00  Time: . [ms]....
Contents of section .text:
 0000 0c943500 0c945d00 0c945d00 0c945d00  ..5...]...]...].
 0010 0c945d00 0c945d00 0c945d00 0c945d00  ..]...]...]...].
 0020 0c945d00 0c945d00 0c945d00 0c945d00  ..]...]...]...].
 0030 0c945d00 0c945d00 0c945d00 0c945d00  ..]...]...]...].
 0040 0c94c401 0c945d00 0c943402 0c940e02  ......]...4.....
 0050 0c945d00 0c945d00 0c945d00 0c945d00  ..]...]...]...].
 0060 0c945d00 0c945d00 48031124 1fbecfef  ..]...].H..$....
 0070 d8e0debf cdbf11e0 a0e0b1e0 e8e4f7e0  ................
 0080 02c00590 0d92a033 b107d9f7 21e0a0e3  .......3....!...
 0090 b1e001c0 1d92aa3d b207e1f7 10e0c5e3  .......=........
 00a0 d0e004c0 2197fe01 0e949703 c433d107  ....!........3..
 00b0 c9f70e94 66020c94 a2030c94 0000cf92  ....f...........
 00c0 df92ef92 ff920f93 1f93cf93 df936c01  ..............l.
 00d0 7a018b01 c0e0d0e0 ce15df05 81f0d801  z...............
 00e0 6d918d01 d601ed91 fc910190 f081e02d  m..............-
 00f0 c6010995 892b11f0 2196eecf 7e01c701  .....+..!...~...
 0100 df91cf91 1f910f91 ff90ef90 df90cf90  ................
 0110 08950895 80e090e0 0895fc01 538d448d  ............S.D.
 0120 252f30e0 842f90e0 821b930b 541710f0  %/0../......T...
 0130 cf960895 01970895 fc01918d 828d9817  ................
 0140 61f0828d df01a80f b11d5d96 8c91928d  a.........].....
 0150 9f5f9f73 928f90e0 08958fef 9fef0895  ._.s............
 0160 fc01918d 828d9817 31f0828d e80ff11d  ........1.......
 0170 858d90e0 08958fef 9fef0895 fc01918d  ................
 0180 228d892f 90e0805c 9f4f821b 91098f73  "../...\.O.....s
 0190 99270895 8de391e0 0e94be00 21e0892b  .'..........!..+
 01a0 09f420e0 822f0895 fc01848d df01a80f  .. ../..........
 01b0 b11da35a bf4f2c91 848d90e0 01968f73  ...Z.O,........s
 01c0 9927848f a689b789 2c93a089 b1898c91  .'......,.......
 01d0 83708064 8c93938d 848d9813 06c00288  .p.d............
 01e0 f389e02d 80818f7d 80830895 ef92ff92  ...-...}........
 01f0 0f931f93 cf93df93 ec0181e0 888f9b8d  ................
 0200 8c8d9813 05c0e889 f9898081 85fd26c0  ..............&.
 0210 f62e0b8d 10e00f5f 1f4f0f73 1127e02e  ......._.O.s.'..
 0220 8c8de812 0cc00fb6 07fcfacf e889f989  ................
 0230 808185ff f5cfce01 0e94d400 f1cf8b8d  ................
 0240 fe01e80f f11de35a ff4ff082 9fb7f894  .......Z.O......
 0250 0b8fea89 fb898081 80620ac0 9fb7f894  .........b......
 0260 ee89ff89 6083e889 f9898081 83708064  ....`........p.d
 0270 80839fbf 81e090e0 df91cf91 1f910f91  ................
 0280 ff90ef90 0895cf93 df93ec01 888d8823  ...............#
 0290 c9f0ea89 fb898081 85fd05c0 a889b989  ................
 02a0 8c9186fd 0fc00fb6 07fcf5cf 808185ff  ................
 02b0 f2cfa889 b9898c91 85ffedcf ce010e94  ................
 02c0 d400e7cf df91cf91 089580e0 90e0892b  ...............+
 02d0 29f00e94 ca008111 0c940000 08950097  )...............
 02e0 69f0fc01 01900020 e9f73197 af01481b  i...... ..1...H.
 02f0 590bbc01 8de391e0 0c945f00 80e090e0  Y........._.....
 0300 08958f92 9f92af92 bf920f93 1f93cf93  ................
 0310 df93cdb7 deb7a197 0fb6f894 debf0fbe  ................
 0320 cdbf19a2 423008f4 4ae08e01 0f5d1f4f  ....B0..J....].O
 0330 842e912c a12cb12c a5019401 0e947503  ...,.,.,......u.
 0340 e62fb901 ca010150 1109ea30 14f4e05d  ./.....P...0...]
 0350 01c0e95c d801ec93 232b242b 252b61f7  ...\....#+$+%+a.
 0360 c8010e94 6f01a196 0fb6f894 debf0fbe  ....o...........
 0370 cdbfdf91 cf911f91 0f91bf90 af909f90  ................
 0380 8f900895 0e949d03 1f920f92 0fb60f92  ................
 0390 11242f93 3f938f93 9f93af93 bf938091  .$/.?...........
 03a0 39019091 3a01a091 3b01b091 3c013091  9...:...;...<.0.
 03b0 380123e0 230f2d37 20f40196 a11db11d  8.#.#.-7 .......
 03c0 05c026e8 230f0296 a11db11d 20933801  ..&.#....... .8.
 03d0 80933901 90933a01 a0933b01 b0933c01  ..9...:...;...<.
 03e0 80913401 90913501 a0913601 b0913701  ..4...5...6...7.
 03f0 0196a11d b11d8093 34019093 3501a093  ........4...5...
 0400 3601b093 3701bf91 af919f91 8f913f91  6...7.........?.
 0410 2f910f90 0fbe0f90 1f901895 1f920f92  /...............
 0420 0fb60f92 11242f93 3f934f93 5f936f93  .....$/.?.O._.o.
 0430 7f938f93 9f93af93 bf93ef93 ff938de3  ................
 0440 91e00e94 d400ff91 ef91bf91 af919f91  ................
 0450 8f917f91 6f915f91 4f913f91 2f910f90  ....o._.O.?./...
 0460 0fbe0f90 1f901895 1f920f92 0fb60f92  ................
 0470 11242f93 8f939f93 ef93ff93 e0914d01  .$/...........M.
 0480 f0914e01 8081e091 5301f091 540182fd  ..N.....S...T...
 0490 12c09081 80915601 8f5f8f73 20915701  ......V.._.s .W.
 04a0 821751f0 e0915601 f0e0e35c fe4f958f  ..Q...V....\.O..
 04b0 80935601 01c08081 ff91ef91 9f918f91  ..V.............
 04c0 2f910f90 0fbe0f90 1f901895 789484b5  /...........x...
 04d0 826084bd 84b58160 84bd85b5 826085bd  .`.....`.....`..
 04e0 85b58160 85bd8091 6e008160 80936e00  ...`....n..`..n.
 04f0 10928100 80918100 82608093 81008091  .........`......
 0500 81008160 80938100 80918000 81608093  ...`.........`..
 0510 80008091 b1008460 8093b100 8091b000  .......`........
 0520 81608093 b0008091 7a008460 80937a00  .`......z..`..z.
 0530 80917a00 82608093 7a008091 7a008160  ..z..`..z...z..`
 0540 80937a00 80917a00 80688093 7a001092  ..z...z..h..z...
 0550 c100e091 4d01f091 4e0182e0 8083e091  ....M...N.......
 0560 4d01f091 4e011082 e0914901 f0914a01  M...N.....I...J.
 0570 1082e091 4b01f091 4c0180e1 80831092  ....K...L.......
 0580 5501e091 5101f091 520186e0 8083e091  U...Q...R.......
 0590 4f01f091 50018081 80618083 e0914f01  O...P....a....O.
 05a0 f0915001 80818860 8083e091 4f01f091  ..P....`....O...
 05b0 50018081 80688083 e0914f01 f0915001  P....h....O...P.
 05c0 80818f7d 80832fb7 f8948091 39019091  ...}../.....9...
 05d0 3a01a091 3b01b091 3c012fbf 80933001  :...;...<./...0.
 05e0 90933101 a0933201 b0933301 80910001  ..1...2...3.....
 05f0 90910101 a0910201 b0910301 ac01bd01  ................
 0600 41505109 61097109 40930001 50930101  APQ.a.q.@...P...
 0610 60930201 70930301 892b8a2b 8b2ba9f5  `...p....+.+.+..
 0620 8fb7f894 c0903901 d0903a01 e0903b01  ......9...:...;.
 0630 f0903c01 8fbf86e1 91e00e94 6f014ae0  ..<.........o.J.
 0640 60ec76ec 8de290e0 0e948101 8ee191e0  `.v.............
 0650 0e946f01 80913001 90913101 a0913201  ..o...0...1...2.
 0660 b0913301 a7019601 281b390b 4a0b5b0b  ..3.....(.9.J.[.
 0670 ca01b901 4ae00e94 810187e2 91e00e94  ....J...........
 0680 6f018de2 91e00e94 6f010e94 6501aecf  o.......o...e...
 0690 ede3f1e0 13821282 88ee93e0 a0e0b0e0  ................
 06a0 84839583 a683b783 88e091e0 91838083  ................
 06b0 85ec90e0 95878487 84ec90e0 97878687  ................
 06c0 80ec90e0 918b808b 81ec90e0 938b828b  ................
 06d0 82ec90e0 958b848b 86ec90e0 978b868b  ................
 06e0 118e128e 138e148e 0895a1e2 1a2eaa1b  ................
 06f0 bb1bfd01 0dc0aa1f bb1fee1f ff1fa217  ................
 0700 b307e407 f50720f0 a21bb30b e40bf50b  ...... .........
 0710 661f771f 881f991f 1a9469f7 60957095  f.w.......i.`.p.
 0720 80959095 9b01ac01 bd01cf01 0895ee0f  ................
 0730 ff1f0590 f491e02d 099481e0 90e0f894  .......-........
 0740 0c94a203 f894ffcf                    ........        
Contents of section .comment:
 0000 4743433a 2028474e 55292035 2e342e30  GCC: (GNU) 5.4.0
 0010 00                                   .               
Contents of section .note.gnu.avr.deviceinfo:
 0000 04000000 2d000000 01000000 41565200  ....-.......AVR.
 0010 00000000 00800000 00010000 00080000  ................
 0020 00000000 00040000 08000000 01000000  ................
 0030 0061746d 65676133 32387000 00000000  .atmega328p.....
Contents of section .debug_aranges:
 0000 2c000000 0200f405 00000400 00000000  ,...............
 0010 be000000 0e040000 cc040000 c4010000  ................
 0020 90060000 5a000000 00000000 00000000  ....Z...........
 0030 1c000000 0200a218 00000400 00000000  ................
 0040 44070000 04000000 00000000 00000000  D...............
 0050 1c000000 02005019 00000400 00000000  ......P.........
 0060 ea060000 44000000 00000000 00000000  ....D...........
 0070 1c000000 0200fe19 00000400 00000000  ................
 0080 76000000 16000000 00000000 00000000  v...............
 0090 1c000000 0200ac1a 00000400 00000000  ................
 00a0 8c000000 10000000 00000000 00000000  ................
 00b0 1c000000 02005a1b 00000400 00000000  ......Z.........
 00c0 9c000000 16000000 00000000 00000000  ................
 00d0 1c000000 0200081c 00000400 00000000  ................
 00e0 2e070000 0c000000 00000000 00000000  ................
Contents of section .debug_info:
 0000 f0050000 02000000 00000401 00000000  ................
 0010 00000000 020f0000 00010803 17000000  ................
 0020 02070414 00000005 1b000000 ff030006  ................
 0030 20000000 00002200 00000105 03000081   .....".........
 0040 00072900 00000000 14000000 010503c6  ..).............
 0050 00800008 2e000000 00001400 00000105  ................
 0060 03c00080 00093500 00000000 14000000  ......5.........
 0070 010503c1 0080000a 3c000000 00001400  ........<.......
 0080 00000105 03c20080 000b4300 00000000  ..........C.....
 0090 1b000000 010503c4 0080000c 49000000  ............I...
 00a0 00001400 00000105 03bd0080 000d4f00  ..............O.
 00b0 00000000 14000000 010503b8 0080000e  ................
 00c0 54000000 00001400 00000105 03bc0080  T...............
 00d0 000f5900 00000000 14000000 010503b9  ..Y.............
 00e0 00800010 5e000000 00001400 00000105  ....^...........
 00f0 03bb0080 00116300 00000000 14000000  ......c.........
 0100 010503ba 00800012 68000000 00001400  ........h.......
 0110 00000105 036f0080 00136f00 00000000  .....o....o.....
 0120 14000000 01050336 00800014 75000000  .......6....u...
 0130 00001400 00000105 03800080 00157c00  ..............|.
 0140 00000000 14000000 01050381 00800016  ................
 0150 83000000 00001400 00000105 03820080  ................
 0160 00178a00 00000000 1b000000 01050384  ................
 0170 00800018 90000000 00001b00 00000105  ................
 0180 03880080 00199600 00000000 1b000000  ................
 0190 0105038a 0080001a 9c000000 00001b00  ................
 01a0 00000105 03860080 001ba100 00000000  ................
 01b0 14000000 01050343 0080001c a7000000  .......C........
 01c0 00001400 00000105 03700080 001dae00  .........p......
 01d0 00000000 14000000 01050337 0080001e  ...........7....
 01e0 b4000000 00001400 00000105 03b00080  ................
 01f0 001fbb00 00000000 14000000 010503b1  ................
 0200 00800020 c2000000 00001400 00000105  ... ............
 0210 03b20080 0021c800 00000000 14000000  .....!..........
 0220 010503b4 00800022 ce000000 00001400  ......."........
 0230 00000105 03b30080 0023d400 00000000  .........#......
 0240 14000000 010503b6 00800024 d9000000  ...........$....
 0250 00001400 00000105 03430080 0025df00  .........C...%..
 0260 00000000 14000000 0105037c 00800026  ...........|...&
 0270 e5000000 00001b00 00000105 03780080  .............x..
 0280 0027e900 00000000 14000000 0105037a  .'.............z
 0290 00800028 f0000000 00001400 00000105  ...(............
 02a0 037b0080 0029f700 00000000 14000000  .{...)..........
 02b0 0105037e 0080002a fd000000 00001400  ...~...*........
 02c0 00000105 03500080 002b0201 00000000  .....P...+......
 02d0 14000000 0105037f 0080002c 08010000  ...........,....
 02e0 00001400 00000105 03250080 002d0e01  .........%...-..
 02f0 00000000 14000000 01050324 0080002e  ...........$....
 0300 13010000 00001400 00000105 03230080  .............#..
 0310 002f1801 00000000 14000000 01050328  ./.............(
 0320 00800030 1e010000 00001400 00000105  ...0............
 0330 03270080 00312301 00000000 14000000  .'...1#.........
 0340 01050326 00800032 28010000 00001400  ...&...2(.......
 0350 00000105 032b0080 00332e01 00000000  .....+...3......
 0360 14000000 0105032a 00800034 33010000  .......*...43...
 0370 00001400 00000105 03290080 00353801  .........)...58.
 0380 00000000 14000000 01050348 00800036  ...........H...6
 0390 3e010000 00001400 00000105 03470080  >............G..
 03a0 00374401 00000000 14000000 01050346  .7D............F
 03b0 00800038 4a010000 00001400 00000105  ...8J...........
 03c0 03450080 00395101 00000000 14000000  .E...9Q.........
 03d0 01050344 0080003a 58010000 00001400  ...D...:X.......
 03e0 00000105 036e0080 003b5f01 00000000  .....n...;_.....
 03f0 14000000 01050335 0080003c 65010000  .......5...<e...
 0400 00001400 00000105 03430080 003d6b01  .........C...=k.
 0410 00000000 14000000 01050369 0080003e  ...........i...>
 0420 71010000 00001400 00000105 033d0080  q............=..
 0430 003f7701 00000000 14000000 0105033c  .?w............<
 0440 00800040 7c010000 00001400 00000105  ...@|...........
 0450 03680080 00418201 00000000 14000000  .h...A..........
 0460 0105036d 00800042 89010000 00001400  ...m...B........
 0470 00000105 036c0080 00439001 00000000  .....l...C......
 0480 14000000 0105036b 00800044 97010000  .......k...D....
 0490 00001400 00000105 033b0080 00459d01  .........;...E..
 04a0 00000000 14000000 0105034e 00800046  ...........N...F
 04b0 a2010000 00001400 00000105 034d0080  .............M..
 04c0 0047a701 00000000 14000000 0105034c  .G.............L
 04d0 00800048 ac010000 00001400 00000105  ...H............
 04e0 03600080 0049b301 00000000 14000000  .`...I..........
 04f0 01050364 0080004a b7010000 00001400  ...d...J........
 0500 00000105 03660080 004bbe01 00000000  .....f...K......
 0510 14000000 01050361 0080004c c4010000  .......a...L....
 0520 00001400 00000105 035f0080 004dc901  ........._...M..
 0530 00000000 1b000000 0105035d 0080004e  ...........]...N
 0540 cc010000 00001400 00000105 03570080  .............W..
 0550 004fd301 00000000 14000000 01050355  .O.............U
 0560 00800050 d9010000 00001400 00000105  ...P............
 0570 03540080 0051df01 00000000 14000000  .T...Q..........
 0580 01050353 00800052 e4010000 00001400  ...S...R........
 0590 00000105 034b0080 0053eb01 00000000  .....K...S......
 05a0 14000000 0105034a 00800054 f2010000  .......J...T....
 05b0 00001400 00000105 033e0080 0055f901  .........>...U..
 05c0 00000000 1b000000 01050341 00800056  ...........A...V
 05d0 fe010000 00001400 00000105 03400080  .............@..
 05e0 00570302 00000000 14000000 0105033f  .W.............?
 05f0 00800000 aa120000 0200a205 00000401  ................
 0600 18040000 028a0300 00000000 00000000  ................
 0610 00000000 001a0000 00020223 0600002f  ...........#.../
 0620 00000003 3a000000 3a000000 04000502  ....:...:.......
 0630 05696e74 00060d05 00000402 25410000  .int........%A..
 0640 00640100 00070705 00006401 00000223  .d........d....#
 0650 0001084d 02000002 283a0000 00022302  ...M....(:....#.
 0660 03097005 0000017e 016a0100 00018200  ..p....~.j......
 0670 00008900 00000a4c 07000001 00097005  .......L......p.
 0680 0000018a 016a0100 00019e00 0000aa00  .....j..........
 0690 00000a4c 07000001 0b3e0200 000009ed  ...L.....>......
 06a0 04000001 67016a01 000001bf 000000d0  ....g.j.........
 06b0 0000000a 4c070000 010b3702 00000b3a  ....L.....7....:
 06c0 00000000 09ed0400 00013e01 6a010000  ..........>.j...
 06d0 01e50000 00f10000 000a4c07 0000010b  ..........L.....
 06e0 3e020000 000ca903 000001cb 016a0100  >............j..
 06f0 00030107 01000018 0100000a 4c070000  ............L...
 0700 010b3702 00000b87 02000000 09280200  ..7..........(..
 0710 00023401 6a010000 012d0100 00390100  ..4.j....-...9..
 0720 000a4c07 0000010b 3e020000 000d2802  ..L.....>.....(.
 0730 00000122 016a0100 00010210 01410000  ...".j.......A..
 0740 00015201 00000a4c 07000001 0b740800  ..R....L.....t..
 0750 000b6a01 00000000 0e022500 00000f73  ..j.......%....s
 0760 0200000c d8750100 00100207 18050000  .....u..........
 0770 100106d5 03000006 4c050000 0c0a31cf  ........L.....1.
 0780 010000cf 01000011 cf010000 02230001  .............#..
 0790 08460600 000a3437 02000002 23040208  .F....47....#...
 07a0 c7060000 0a353702 00000223 08021251  .....57....#...Q
 07b0 0300000a 3f0101c7 0100000a 78060000  ....?.......x...
 07c0 01000013 0d050000 01370200 00142e02  .........7......
 07d0 0000025a 01010210 03cf0100 0001f201  ...Z............
 07e0 0000f901 00000ae4 08000001 00157103  ..............q.
 07f0 0000023f 013a0000 00010210 02cf0100  ...?.:..........
 0800 00011602 00001d02 00000ae4 08000001  ................
 0810 00160151 03000002 2e230300 0001012f  ...Q.....#...../
 0820 0200000a e4080000 01000010 04071305  ................
 0830 00000e02 44020000 177c0100 00064c05  ....D....|....L.
 0840 00000c0a 31810200 00810200 00118102  ....1...........
 0850 00000223 00010846 0600000a 34370200  ...#...F....47..
 0860 00022304 0208c706 00000a35 37020000  ..#........57...
 0870 02230802 00180d05 0000010f 0c030000  .#..............
 0880 0d7e9202 00001001 08cc0300 000fb006  .~..............
 0890 00000e3b 87020000 0fb50300 000e4087  ...;..........@.
 08a0 02000010 01023103 000006d4 0500009d  ......1.........
 08b0 0e5d8102 00000005 00001149 02000002  .].........I....
 08c0 23000108 83030000 0e600b05 00000223  #........`.....#
 08d0 0c02083f 0600000e 610b0500 0002230e  ...?....a.....#.
 08e0 02089b06 00000e62 0b050000 02231002  .......b.....#..
 08f0 08a20600 000e630b 05000002 23120208  ......c.....#...
 0900 a9060000 0e640b05 00000223 140208d4  .....d.....#....
 0910 0600000e 650b0500 00022316 02080207  ....e.....#.....
 0920 00000e67 af020000 02231802 08360300  ...g.....#...6..
 0930 000e6910 05000002 23190208 18020000  ..i.....#.......
 0940 0e6a1005 00000223 1a020808 0200000e  .j.....#........
 0950 6b150500 0002231b 0208f005 00000e6c  k.....#........l
 0960 15050000 02231c02 08d90600 000e711a  .....#........q.
 0970 05000002 231d0208 53050000 0e721a05  ....#...S....r..
 0980 00000223 5d0219a1 02000001 01021003  ...#]...........
 0990 b6020000 0101aa03 0000b103 00000a47  ...............G
 09a0 05000001 001a0006 0000016a 01000001  ...........j....
 09b0 021000b6 02000001 01cd0300 00d90300  ................
 09c0 000a4705 0000010b 87020000 001b8f02  ..G.............
 09d0 00000375 0101ea03 0000fb03 00000a47  ...u...........G
 09e0 05000001 0b370200 000b3105 00000015  .....7....1.....
 09f0 71030000 03c0013a 00000001 021002b6  q......:........
 0a00 02000001 18040000 1f040000 0a470500  .............G..
 0a10 00010015 4c030000 03b4013a 00000001  ....L......:....
 0a20 021005b6 02000001 3c040000 43040000  ........<...C...
 0a30 0a470500 00010015 5e030000 03ab013a  .G......^......:
 0a40 00000001 021006b6 02000001 60040000  ............`...
 0a50 67040000 0a470500 00010015 69020000  g....G......i...
 0a60 03a6013a 00000001 021004b6 02000001  ...:............
 0a70 84040000 8b040000 0a470500 0001001c  .........G......
 0a80 6b060000 0101019b 040000a2 0400000a  k...............
 0a90 47050000 01001b5e 05000003 590101b3  G......^....Y...
 0aa0 040000ba 0400000a 47050000 01001528  ........G......(
 0ab0 02000003 e1016a01 00000102 1000b602  ......j.........
 0ac0 000001d7 040000e3 0400000a 47050000  ............G...
 0ad0 010b8702 0000001d 2e020000 03cd0101  ................
 0ae0 021003b6 02000001 f8040000 0a470500  .............G..
 0af0 00010000 0e020605 00001e87 02000017  ................
 0b00 00050000 1ea40200 001e9902 00001f92  ................
 0b10 0200002a 05000020 2a050000 3f001002  ...*... *...?...
 0b20 07860200 000fa403 00000f7e 87020000  ...........~....
 0b30 0ffe0400 000d8075 0100000e 02b60200  .......u........
 0b40 00219203 000003cd 015d0500 00680500  .!.......]...h..
 0b50 0022ad05 00006805 00000100 17470500  ."....h......G..
 0b60 0021b103 000003e1 017d0500 00b40500  .!.......}......
 0b70 0022ad05 00006805 00000123 630003e1  ."....h....#c...
 0b80 87020000 24690003 fb990200 00252654  ....$i.......%&T
 0b90 06000003 11018702 000026cd 05000003  ..........&.....
 0ba0 11018702 00000000 13d40500 00012506  ..............%.
 0bb0 00001cda 03000001 0101ce05 0000d505  ................
 0bc0 00000a25 06000001 001b2505 00000b65  ...%......%....e
 0bd0 0101e605 0000ed05 00000a25 06000001  ...........%....
 0be0 00160151 0300000b 57c40200 000101ff  ...Q....W.......
 0bf0 0500000a 25060000 010b0005 00000b00  ....%...........
 0c00 0500000b 00050000 0b000500 000b0005  ................
 0c10 00000b00 05000000 000e02b4 05000021  ...............!
 0c20 be050000 0b65033b 0600005a 06000022  .....e.;...Z..."
 0c30 ad050000 5a060000 01252463 000b6a92  ....Z....%$c..j.
 0c40 02000024 69000b6b a4020000 00001725  ...$i..k.......%
 0c50 06000027 d5050000 036d0600 00780600  ...'.....m...x..
 0c60 0022ad05 00005a06 00000100 0e028301  ."....Z.........
 0c70 000027ba 01000003 8c060000 97060000  ..'.............
 0c80 22ad0500 00970600 00010017 78060000  "...........x...
 0c90 28780500 00010101 bf060000 29090400  (x..........)...
 0ca0 00044d3a 00000029 a2050000 044d3a00  ..M:...).....M:.
 0cb0 00000027 d9030000 01cd0600 00f90600  ...'............
 0cc0 0022ad05 00006805 00000129 c7030000  ."....h....)....
 0cd0 03753702 00002905 03000003 75310500  .u7...).....u1..
 0ce0 002ae305 00000378 3c050000 0013d405  .*.....x<.......
 0cf0 0000011d 07000012 8f020000 0e790101  .............y..
 0d00 10070000 0a1d0700 00010b37 02000000  ...........7....
 0d10 000e02f9 06000027 03070000 03310700  .......'.....1..
 0d20 00470700 0022ad05 00004707 00000129  .G..."....G....)
 0d30 c7030000 0e793702 00000017 1d070000  .....y7.........
 0d40 0e024100 0000276d 00000001 60070000  ..A...'m....`...
 0d50 6b070000 22ad0500 006b0700 00010017  k..."....k......
 0d60 4c070000 27890000 00017e07 00009b07  L...'.....~.....
 0d70 000022ad 0500006b 07000001 23630001  .."....k....#c..
 0d80 8a3e0200 00246e00 018c6a01 00000027  .>...$n...j....'
 0d90 aa000000 01a90700 00c80700 0022ad05  ............."..
 0da0 00006b07 00000123 6e000167 37020000  ..k....#n..g7...
 0db0 29ef0600 0001673a 00000000 27d00000  ).....g:....'...
 0dc0 0001d607 0000ec07 000022ad 0500006b  .........."....k
 0dd0 07000001 23737472 00013e3e 02000000  ....#str..>>....
 0de0 27f10000 0001fa07 00003a08 000022ad  '.........:...".
 0df0 0500006b 07000001 236e0001 cb370200  ...k....#n...7..
 0e00 0029ef06 000001cb 87020000 24627566  .)..........$buf
 0e10 0001cd3a 08000024 73747200 01ce4a08  ...:...$str...J.
 0e20 00002524 630001d6 7c010000 00001f7c  ..%$c...|......|
 0e30 0100004a 08000020 2a050000 20000e02  ...J... *... ...
 0e40 7c010000 27180100 00035e08 00007408  |...'.....^...t.
 0e50 000022ad 0500006b 07000001 23737472  .."....k....#str
 0e60 0002343e 02000000 0e027a08 00001787  ..4>......z.....
 0e70 0200002b 39010000 be000000 12010000  ...+9...........
 0e80 00000000 99080000 01e40800 002cad05  .............,..
 0e90 00006b07 0000017d 0000002d dd060000  ..k....}...-....
 0ea0 01227408 0000b300 00002d4f 06000001  ."t.......-O....
 0eb0 226a0100 00130100 002e6e00 01246a01  "j........n..$j.
 0ec0 00006f01 00002ff4 00000030 06689301  ..o.../....0.h..
 0ed0 69930102 7c000000 0e02cf01 000031d9  i...|.........1.
 0ee0 01000012 01000014 01000003 92200204  ............. ..
 0ef0 09000001 16090000 32ad0500 00160900  ........2.......
 0f00 00010668 93016993 010017e4 08000031  ...h..i........1
 0f10 f9010000 14010000 1a010000 03922002  .............. .
 0f20 35090000 01440900 002cad05 00001609  5....D...,......
 0f30 00000193 01000000 31fb0300 001a0100  ........1.......
 0f40 00380100 00039220 025e0900 00018709  .8..... .^......
 0f50 00002cad 05000068 05000001 b9010000  ..,....h........
 0f60 33410300 0003c299 02000001 65332302  3A..........e3#.
 0f70 000003c3 99020000 01640031 1f040000  .........d.1....
 0f80 38010000 60010000 03922002 a1090000  8...`..... .....
 0f90 01c70900 002cad05 00006805 000001e1  .....,....h.....
 0fa0 01000034 42010000 5a010000 2e630003  ...4B...Z....c..
 0fb0 ba920200 00090200 00000031 43040000  ...........1C...
 0fc0 60010000 7c010000 03922002 e1090000  `...|..... .....
 0fd0 01f00900 002cad05 00006805 0000011c  .....,....h.....
 0fe0 02000000 31670400 007c0100 00940100  ....1g...|......
 0ff0 00039220 020a0a00 0001190a 00002cad  ... ..........,.
 1000 05000068 05000001 62020000 00356102  ...h....b....5a.
 1010 0000044b 01af0200 00940100 00a80100  ...K............
 1020 00039220 02014f0a 0000369c 010000f0  ... ..O...6.....
 1030 09000030 06689301 69930105 033d0180  ...0.h..i....=..
 1040 00000021 8b040000 0359015f 0a000073  ...!.....Y._...s
 1050 0a000022 ad050000 68050000 01246300  ..."....h....$c.
 1060 035d9202 00000027 a2040000 01810a00  .].....'........
 1070 00a30a00 0022ad05 00006805 00000124  ....."....h....$
 1080 6300035d 92020000 25375f0a 00002538  c..]....%7_...%8
 1090 690a0000 00000039 730a0000 a8010000  i......9s.......
 10a0 ec010000 03922002 bd0a0000 01f00a00  ...... .........
 10b0 003a810a 00008a02 00003b8b 0a000001  .:........;.....
 10c0 6234de01 0000ec01 00003a5f 0a0000c0  b4........:_....
 10d0 02000034 de010000 ec010000 38690a00  ...4........8i..
 10e0 00000000 27ba0400 0001fe0a 0000560b  ....'.........V.
 10f0 000022ad 05000068 05000001 23630003  .."....h....#c..
 1100 e1870200 00246900 03fb9902 00003c3d  .....$i.......<=
 1110 0b000037 87050000 377d0500 00253890  ...7....7}...%8.
 1120 05000025 389a0500 0038a605 00000000  ...%8....8......
 1130 00252a54 06000003 f1870200 002acd05  .%*T.........*..
 1140 000003f1 87020000 00003df0 0a0000ec  ..........=.....
 1150 01000086 020000e6 02000070 0b000001  ...........p....
 1160 4d0c0000 3afe0a00 00490300 003a080b  M...:....I...:..
 1170 00007f03 00003811 0b00003e 5c020000  ......8....>\...
 1180 74020000 d80b0000 3f3e0b00 00b60300  t.......?>......
 1190 003f490b 0000c903 0000404d 0c00005e  .?I.......@M...^
 11a0 02000060 02000003 f1415a0c 00007202  ...`.....AZ...r.
 11b0 00007402 000003f1 425f5f73 00054474  ..t.....B__s..Dt
 11c0 08000006 f2321100 00000000 34120200  .....2......4...
 11d0 005c0200 003a8705 0000e903 00003a7d  .\...:........:}
 11e0 050000fc 03000034 12020000 5c020000  .......4....\...
 11f0 3f900500 00140400 003e4c02 00005c02  ?........>L...\.
 1200 0000350c 00003f9a 05000027 0400003f  ..5...?....'...?
 1210 a6050000 3a040000 434d0c00 004e0200  ....:...CM...N..
 1220 00500200 00031101 00363c02 0000730a  .P.......6<...s.
 1230 00003006 68930169 9301028c 00000000  ..0.h..i........
 1240 00445e06 00000530 01870200 000345f3  .D^....0......E.
 1250 04000005 44010327 e3040000 01710c00  ....D..'.....q..
 1260 00830c00 0022ad05 00006805 00000125  ....."....h....%
 1270 375d0500 0000003d 630c0000 86020000  7].....=c.......
 1280 ca020000 4e040000 9d0c0000 01cb0c00  ....N...........
 1290 003a710c 00007d04 00003492 020000c4  .:q...}...4.....
 12a0 02000037 5d050000 36c20200 00730a00  ...7]...6....s..
 12b0 00300668 93016993 01028c00 00000046  .0.h..i........F
 12c0 14030000 034001ca 020000de 02000003  .....@..........
 12d0 92200201 f40c0000 47d60200 00190a00  . ......G.......
 12e0 0048dc02 00000100 49500800 00de0200  .H......IP......
 12f0 00020300 00039220 0201450d 00003a68  ....... ..E...:h
 1300 080000b3 0400004a 5e080000 06033d01  .......J^.....=.
 1310 80009f4b fc020000 017f0800 00300668  ...K.........0.h
 1320 93016993 0105033d 01800030 06669301  ..i....=...0.f..
 1330 67930103 f3016800 004cec07 00000203  g.....h..L......
 1340 00008403 00000705 000001b7 0d00003a  ...............:
 1350 04080000 9c050000 3a0d0800 00e60500  ........:.......
 1360 003b1808 0000028c 013f2308 00000706  .;.......?#.....
 1370 00004afa 07000006 033d0180 009f3e30  ..J......=....>0
 1380 03000058 030000a1 0d00003f 2f080000  ...X.......?/...
 1390 2c060000 00366603 0000f40c 00003006  ,....6f.......0.
 13a0 68930169 93010280 0000004d f2020000  h..i.......M....
 13b0 06180101 84030000 88030000 03922002  .............. .
 13c0 01d70d00 004e8803 0000004f 01330600  .....N.....O.3..
 13d0 00072d01 88030000 1c040000 62060000  ..-.........b...
 13e0 010c0e00 002e6d00 07323702 0000df06  ......m..27.....
 13f0 00002e66 00073392 02000052 07000000  ...f..3....R....
 1400 45460300 00090c01 01459502 0000081c  EF.......E......
 1410 0101450b 07000007 f1010150 6a030000  ..E........Pj...
 1420 07410137 02000001 4d0e0000 246d0007  .A.7....M...$m..
 1430 43370200 002a5902 00000744 87020000  C7...*Y....D....
 1440 0045c206 00000913 01012841 02000001  .E........(A....
 1450 0101700e 0000252a e4060000 09173702  ..p...%*......7.
 1460 00000000 5101ed02 00000821 013a0000  ....Q......!.:..
 1470 0001cc04 00009006 00000392 2002011c  ............ ...
 1480 11000040 1e0e0000 cc040000 52050000  ...@........R...
 1490 0823520c 0e000052 050000ec 05000008  .#R....R........
 14a0 2b3a0f00 00522307 00005205 0000c605  +:...R#...R.....
 14b0 0000090e 0d0f0000 37310700 003a3b07  ........71...:;.
 14c0 00009707 000041bf 06000052 050000c6  ......A....R....
 14d0 0500000e 7937cd06 00003ad7 06000097  ....y7....:.....
 14e0 0700003a e2060000 ad070000 34520500  ...:........4R..
 14f0 00c60500 003fed06 0000c107 00000000  .....?..........
 1500 0041270e 0000c605 0000dc05 00000910  .A'.............
 1510 34c60500 00dc0500 003f380e 0000e207  4........?8.....
 1520 00003f41 0e000000 08000000 0000524d  ..?A..........RM
 1530 0e0000ec 0500008a 06000008 2e121100  ................
 1540 00342006 00008a06 00003b63 0e00000c  .4 .......;c....
 1550 5c93015d 93015e93 015f9301 52270e00  \..]..^.._..R'..
 1560 00200600 00360600 00091798 0f000034  . ...6.........4
 1570 20060000 36060000 3f380e00 00130800   ...6...?8......
 1580 003f410e 00003108 00000000 52c80700  .?A...1.....R...
 1590 00360600 003e0600 000919ce 0f000037  .6...>.........7
 15a0 d6070000 37e00700 00363e06 0000f40c  ....7....6>.....
 15b0 00003006 68930169 93010503 16018000  ..0.h..i........
 15c0 0000529b 0700003e 0600004c 06000009  ..R....>...L....
 15d0 1a1c1000 0037a907 00003abc 07000044  .....7....:....D
 15e0 0800003a b3070000 58080000 364c0600  ...:....X...6L..
 15f0 00450d00 00300c66 93016793 01689301  .E...0.f..g..h..
 1600 69930105 0cc0c62d 00300164 013a0000  i......-.0.d.:..
 1610 52c80700 004c0600 00540600 00091c52  R....L...T.....R
 1620 10000037 d6070000 37e00700 00365406  ...7....7....6T.
 1630 0000f40c 00003006 68930169 93010503  ......0.h..i....
 1640 1e018000 0000529b 07000054 0600007a  ......R....T...z
 1650 06000009 1d8c1000 0037a907 00003abc  .........7....:.
 1660 07000070 0800003a b3070000 84080000  ...p...:........
 1670 367a0600 00450d00 00300164 013a0000  6z...E...0.d.:..
 1680 41700700 007a0600 008a0600 00091e37  Ap...z.........7
 1690 7e070000 37880700 00347a06 00008a06  ~...7....4z.....
 16a0 00003891 07000052 c8070000 7a060000  ..8....R....z...
 16b0 82060000 018ce110 00005353 36820600  ..........SS6...
 16c0 00f40c00 00300668 93016993 01050327  .....0.h..i....'
 16d0 01800000 00415207 00008206 00008a06  .....AR.........
 16e0 0000018d 37600700 00368a06 0000f40c  ....7`...6......
 16f0 00003006 68930169 93010503 2d018000  ..0.h..i....-...
 1700 00000000 0000478e 060000cb 0c000000  ......G.........
 1710 54b20500 00010190 060000ea 06000003  T...............
 1720 92200201 a1110000 419c0600 00900600  . ......A.......
 1730 00ea0600 00044d3a a8060000 b6080000  ......M:........
 1740 3ab30600 00ca0800 0041a111 00009006  :........A......
 1750 0000ea06 00000446 55c655c2 55c155c0  .......FU.U.U.U.
 1760 55c455c5 5606033d 0180009f 417e0600  U.U.V..=....A~..
 1770 00900600 00a80600 000b5f37 8c060000  .........._7....
 1780 41a71100 00900600 00980600 000a3f53  A.............?S
 1790 00000000 0057ed05 00000357 1d020000  .....W.....W....
 17a0 034f017a 02000004 3b011c04 00006804  .O.z....;.....h.
 17b0 0000df08 000001e0 11000036 46040000  ...........6F...
 17c0 730a0000 30066893 01699301 05033d01  s...0.h..i....=.
 17d0 80000000 4f01c105 00000428 01680400  ....O......(.h..
 17e0 00cc0400 00aa0900 00013b12 0000415f  ..........;...A_
 17f0 0600007c 040000b8 04000004 31376d06  ...|........17m.
 1800 00003492 040000b6 04000037 3b060000  ..4........7;...
 1810 34920400 00b60400 003f4606 00001a0a  4........?F.....
 1820 00003f4f 0600002d 0a000000 00000033  ..?O...-.......3
 1830 f4060000 09083702 00000503 30018000  ......7.....0...
 1840 33970300 00090737 02000005 03000180  3......7........
 1850 00333605 00000726 75120000 05033401  .36....&u.....4.
 1860 80001004 07130500 001e6e12 00003334  ..........n...34
 1870 02000007 28920200 00050338 01800033  ....(......8...3
 1880 63030000 07277512 00000503 39018000  c....'u.....9...
 1890 33dc0500 000446b4 05000005 033d0180  3.....F......=..
 18a0 0000aa00 00000200 900a0000 04016d08  ..............m.
 18b0 00004407 00004807 00002e2e 2f2e2e2f  ..D...H...../../
 18c0 2e2e2f2e 2e2f6763 632f6c69 62676363  ../../gcc/libgcc
 18d0 2f636f6e 6669672f 6176722f 6c696231  /config/avr/lib1
 18e0 66756e63 732e5300 2f557365 72732f6a  funcs.S./Users/j
 18f0 656e6b69 6e732f6a 656e6b69 6e732f77  enkins/jenkins/w
 1900 6f726b73 70616365 2f617672 2d676363  orkspace/avr-gcc
 1910 2d737461 67696e67 2f6c6162 656c2f6d  -staging/label/m
 1920 61632d6d 696e692f 6763632d 6275696c  ac-mini/gcc-buil
 1930 642f6176 722f6176 72352f6c 69626763  d/avr/avr5/libgc
 1940 6300474e 55204153 20322e32 36000180  c.GNU AS 2.26...
 1950 aa000000 0200a40a 00000401 cf080000  ................
 1960 ea060000 2e070000 2e2e2f2e 2e2f2e2e  ........../../..
 1970 2f2e2e2f 6763632f 6c696267 63632f63  /../gcc/libgcc/c
 1980 6f6e6669 672f6176 722f6c69 62316675  onfig/avr/lib1fu
 1990 6e63732e 53002f55 73657273 2f6a656e  ncs.S./Users/jen
 19a0 6b696e73 2f6a656e 6b696e73 2f776f72  kins/jenkins/wor
 19b0 6b737061 63652f61 76722d67 63632d73  kspace/avr-gcc-s
 19c0 74616769 6e672f6c 6162656c 2f6d6163  taging/label/mac
 19d0 2d6d696e 692f6763 632d6275 696c642f  -mini/gcc-build/
 19e0 6176722f 61767235 2f6c6962 67636300  avr/avr5/libgcc.
 19f0 474e5520 41532032 2e323600 0180aa00  GNU AS 2.26.....
 1a00 00000200 b80a0000 0401f109 00007600  ..............v.
 1a10 00008c00 00002e2e 2f2e2e2f 2e2e2f2e  ......../../../.
 1a20 2e2f6763 632f6c69 62676363 2f636f6e  ./gcc/libgcc/con
 1a30 6669672f 6176722f 6c696231 66756e63  fig/avr/lib1func
 1a40 732e5300 2f557365 72732f6a 656e6b69  s.S./Users/jenki
 1a50 6e732f6a 656e6b69 6e732f77 6f726b73  ns/jenkins/works
 1a60 70616365 2f617672 2d676363 2d737461  pace/avr-gcc-sta
 1a70 67696e67 2f6c6162 656c2f6d 61632d6d  ging/label/mac-m
 1a80 696e692f 6763632d 6275696c 642f6176  ini/gcc-build/av
 1a90 722f6176 72352f6c 69626763 6300474e  r/avr5/libgcc.GN
 1aa0 55204153 20322e32 36000180 aa000000  U AS 2.26.......
 1ab0 0200cc0a 00000401 890a0000 8c000000  ................
 1ac0 9c000000 2e2e2f2e 2e2f2e2e 2f2e2e2f  ....../../../../
 1ad0 6763632f 6c696267 63632f63 6f6e6669  gcc/libgcc/confi
 1ae0 672f6176 722f6c69 62316675 6e63732e  g/avr/lib1funcs.
 1af0 53002f55 73657273 2f6a656e 6b696e73  S./Users/jenkins
 1b00 2f6a656e 6b696e73 2f776f72 6b737061  /jenkins/workspa
 1b10 63652f61 76722d67 63632d73 74616769  ce/avr-gcc-stagi
 1b20 6e672f6c 6162656c 2f6d6163 2d6d696e  ng/label/mac-min
 1b30 692f6763 632d6275 696c642f 6176722f  i/gcc-build/avr/
 1b40 61767235 2f6c6962 67636300 474e5520  avr5/libgcc.GNU 
 1b50 41532032 2e323600 0180aa00 00000200  AS 2.26.........
 1b60 e00a0000 04010f0b 00009c00 0000b200  ................
 1b70 00002e2e 2f2e2e2f 2e2e2f2e 2e2f6763  ..../../../../gc
 1b80 632f6c69 62676363 2f636f6e 6669672f  c/libgcc/config/
 1b90 6176722f 6c696231 66756e63 732e5300  avr/lib1funcs.S.
 1ba0 2f557365 72732f6a 656e6b69 6e732f6a  /Users/jenkins/j
 1bb0 656e6b69 6e732f77 6f726b73 70616365  enkins/workspace
 1bc0 2f617672 2d676363 2d737461 67696e67  /avr-gcc-staging
 1bd0 2f6c6162 656c2f6d 61632d6d 696e692f  /label/mac-mini/
 1be0 6763632d 6275696c 642f6176 722f6176  gcc-build/avr/av
 1bf0 72352f6c 69626763 6300474e 55204153  r5/libgcc.GNU AS
 1c00 20322e32 36000180 aa000000 0200f40a   2.26...........
 1c10 00000401 a10b0000 2e070000 3a070000  ............:...
 1c20 2e2e2f2e 2e2f2e2e 2f2e2e2f 6763632f  ../../../../gcc/
 1c30 6c696267 63632f63 6f6e6669 672f6176  libgcc/config/av
 1c40 722f6c69 62316675 6e63732e 53002f55  r/lib1funcs.S./U
 1c50 73657273 2f6a656e 6b696e73 2f6a656e  sers/jenkins/jen
 1c60 6b696e73 2f776f72 6b737061 63652f61  kins/workspace/a
 1c70 76722d67 63632d73 74616769 6e672f6c  vr-gcc-staging/l
 1c80 6162656c 2f6d6163 2d6d696e 692f6763  abel/mac-mini/gc
 1c90 632d6275 696c642f 6176722f 61767235  c-build/avr/avr5
 1ca0 2f6c6962 67636300 474e5520 41532032  /libgcc.GNU AS 2
 1cb0 2e323600 0180                        .26...          
Contents of section .debug_abbrev:
 0000 01110125 0e100600 00022400 030e0b0b  ...%......$.....
 0010 3e0b0000 03240003 0e0b0b3e 0b000004  >....$.....>....
 0020 01014913 00000521 0049132f 05000006  ..I....!.I./....
 0030 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0040 07340003 0e3a0b3b 0b49133f 0c020a00  .4...:.;.I.?....
 0050 00083400 030e3a0b 3b0b4913 3f0c020a  ..4...:.;.I.?...
 0060 00000934 00030e3a 0b3b0b49 133f0c02  ...4...:.;.I.?..
 0070 0a00000a 3400030e 3a0b3b0b 49133f0c  ....4...:.;.I.?.
 0080 020a0000 0b340003 0e3a0b3b 0b49133f  .....4...:.;.I.?
 0090 0c020a00 000c3400 030e3a0b 3b0b4913  ......4...:.;.I.
 00a0 3f0c020a 00000d34 00030e3a 0b3b0b49  ?......4...:.;.I
 00b0 133f0c02 0a00000e 3400030e 3a0b3b0b  .?......4...:.;.
 00c0 49133f0c 020a0000 0f340003 0e3a0b3b  I.?......4...:.;
 00d0 0b49133f 0c020a00 00103400 030e3a0b  .I.?......4...:.
 00e0 3b0b4913 3f0c020a 00001134 00030e3a  ;.I.?......4...:
 00f0 0b3b0b49 133f0c02 0a000012 3400030e  .;.I.?......4...
 0100 3a0b3b0b 49133f0c 020a0000 13340003  :.;.I.?......4..
 0110 0e3a0b3b 0b49133f 0c020a00 00143400  .:.;.I.?......4.
 0120 030e3a0b 3b0b4913 3f0c020a 00001534  ..:.;.I.?......4
 0130 00030e3a 0b3b0b49 133f0c02 0a000016  ...:.;.I.?......
 0140 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0150 17340003 0e3a0b3b 0b49133f 0c020a00  .4...:.;.I.?....
 0160 00183400 030e3a0b 3b0b4913 3f0c020a  ..4...:.;.I.?...
 0170 00001934 00030e3a 0b3b0b49 133f0c02  ...4...:.;.I.?..
 0180 0a00001a 3400030e 3a0b3b0b 49133f0c  ....4...:.;.I.?.
 0190 020a0000 1b340003 0e3a0b3b 0b49133f  .....4...:.;.I.?
 01a0 0c020a00 001c3400 030e3a0b 3b0b4913  ......4...:.;.I.
 01b0 3f0c020a 00001d34 00030e3a 0b3b0b49  ?......4...:.;.I
 01c0 133f0c02 0a00001e 3400030e 3a0b3b0b  .?......4...:.;.
 01d0 49133f0c 020a0000 1f340003 0e3a0b3b  I.?......4...:.;
 01e0 0b49133f 0c020a00 00203400 030e3a0b  .I.?..... 4...:.
 01f0 3b0b4913 3f0c020a 00002134 00030e3a  ;.I.?.....!4...:
 0200 0b3b0b49 133f0c02 0a000022 3400030e  .;.I.?....."4...
 0210 3a0b3b0b 49133f0c 020a0000 23340003  :.;.I.?.....#4..
 0220 0e3a0b3b 0b49133f 0c020a00 00243400  .:.;.I.?.....$4.
 0230 030e3a0b 3b0b4913 3f0c020a 00002534  ..:.;.I.?.....%4
 0240 00030e3a 0b3b0b49 133f0c02 0a000026  ...:.;.I.?.....&
 0250 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0260 27340003 0e3a0b3b 0b49133f 0c020a00  '4...:.;.I.?....
 0270 00283400 030e3a0b 3b0b4913 3f0c020a  .(4...:.;.I.?...
 0280 00002934 00030e3a 0b3b0b49 133f0c02  ..)4...:.;.I.?..
 0290 0a00002a 3400030e 3a0b3b0b 49133f0c  ...*4...:.;.I.?.
 02a0 020a0000 2b340003 0e3a0b3b 0b49133f  ....+4...:.;.I.?
 02b0 0c020a00 002c3400 030e3a0b 3b0b4913  .....,4...:.;.I.
 02c0 3f0c020a 00002d34 00030e3a 0b3b0b49  ?.....-4...:.;.I
 02d0 133f0c02 0a00002e 3400030e 3a0b3b0b  .?......4...:.;.
 02e0 49133f0c 020a0000 2f340003 0e3a0b3b  I.?...../4...:.;
 02f0 0b49133f 0c020a00 00303400 030e3a0b  .I.?.....04...:.
 0300 3b0b4913 3f0c020a 00003134 00030e3a  ;.I.?.....14...:
 0310 0b3b0b49 133f0c02 0a000032 3400030e  .;.I.?.....24...
 0320 3a0b3b0b 49133f0c 020a0000 33340003  :.;.I.?.....34..
 0330 0e3a0b3b 0b49133f 0c020a00 00343400  .:.;.I.?.....44.
 0340 030e3a0b 3b0b4913 3f0c020a 00003534  ..:.;.I.?.....54
 0350 00030e3a 0b3b0b49 133f0c02 0a000036  ...:.;.I.?.....6
 0360 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0370 37340003 0e3a0b3b 0b49133f 0c020a00  74...:.;.I.?....
 0380 00383400 030e3a0b 3b0b4913 3f0c020a  .84...:.;.I.?...
 0390 00003934 00030e3a 0b3b0b49 133f0c02  ..94...:.;.I.?..
 03a0 0a00003a 3400030e 3a0b3b0b 49133f0c  ...:4...:.;.I.?.
 03b0 020a0000 3b340003 0e3a0b3b 0b49133f  ....;4...:.;.I.?
 03c0 0c020a00 003c3400 030e3a0b 3b0b4913  .....<4...:.;.I.
 03d0 3f0c020a 00003d34 00030e3a 0b3b0b49  ?.....=4...:.;.I
 03e0 133f0c02 0a00003e 3400030e 3a0b3b0b  .?.....>4...:.;.
 03f0 49133f0c 020a0000 3f340003 0e3a0b3b  I.?.....?4...:.;
 0400 0b49133f 0c020a00 00403400 030e3a0b  .I.?.....@4...:.
 0410 3b0b4913 3f0c020a 00004134 00030e3a  ;.I.?.....A4...:
 0420 0b3b0b49 133f0c02 0a000042 3400030e  .;.I.?.....B4...
 0430 3a0b3b0b 49133f0c 020a0000 43340003  :.;.I.?.....C4..
 0440 0e3a0b3b 0b49133f 0c020a00 00443400  .:.;.I.?.....D4.
 0450 030e3a0b 3b0b4913 3f0c020a 00004534  ..:.;.I.?.....E4
 0460 00030e3a 0b3b0b49 133f0c02 0a000046  ...:.;.I.?.....F
 0470 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0480 47340003 0e3a0b3b 0b49133f 0c020a00  G4...:.;.I.?....
 0490 00483400 030e3a0b 3b0b4913 3f0c020a  .H4...:.;.I.?...
 04a0 00004934 00030e3a 0b3b0b49 133f0c02  ..I4...:.;.I.?..
 04b0 0a00004a 3400030e 3a0b3b0b 49133f0c  ...J4...:.;.I.?.
 04c0 020a0000 4b340003 0e3a0b3b 0b49133f  ....K4...:.;.I.?
 04d0 0c020a00 004c3400 030e3a0b 3b0b4913  .....L4...:.;.I.
 04e0 3f0c020a 00004d34 00030e3a 0b3b0b49  ?.....M4...:.;.I
 04f0 133f0c02 0a00004e 3400030e 3a0b3b0b  .?.....N4...:.;.
 0500 49133f0c 020a0000 4f340003 0e3a0b3b  I.?.....O4...:.;
 0510 0b49133f 0c020a00 00503400 030e3a0b  .I.?.....P4...:.
 0520 3b0b4913 3f0c020a 00005134 00030e3a  ;.I.?.....Q4...:
 0530 0b3b0b49 133f0c02 0a000052 3400030e  .;.I.?.....R4...
 0540 3a0b3b0b 49133f0c 020a0000 53340003  :.;.I.?.....S4..
 0550 0e3a0b3b 0b49133f 0c020a00 00543400  .:.;.I.?.....T4.
 0560 030e3a0b 3b0b4913 3f0c020a 00005534  ..:.;.I.?.....U4
 0570 00030e3a 0b3b0b49 133f0c02 0a000056  ...:.;.I.?.....V
 0580 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0590 57340003 0e3a0b3b 0b49133f 0c020a00  W4...:.;.I.?....
 05a0 00000111 01250e13 0b030e55 06110152  .....%.....U...R
 05b0 01100600 00020f00 0b0b030e 49130000  ............I...
 05c0 03150149 13011300 00041800 00000524  ...I...........$
 05d0 000b0b3e 0b030800 00061301 030e0b0b  ...>............
 05e0 3a0b3b0b 1d130113 0000070d 00030e49  :.;............I
 05f0 13380a34 0c000008 0d00030e 3a0b3b0b  .8.4........:.;.
 0600 4913380a 320b0000 092e0103 0e3a0b3b  I.8.2........:.;
 0610 0b270c49 133c0c64 13011300 000a0500  .'.I.<.d........
 0620 4913340c 00000b05 00491300 000c2e01  I.4......I......
 0630 030e3a0b 3b0b270c 4913320b 3c0c6413  ..:.;.'.I.2.<.d.
 0640 01130000 0d2e0103 0e3a0b3b 0b270c49  .........:.;.'.I
 0650 134c0b4d 0a1d133c 0c641300 000e0f00  .L.M...<.d......
 0660 0b0b4913 00000f16 00030e3a 0b3b0b49  ..I........:.;.I
 0670 13000010 24000b0b 3e0b030e 0000111c  ....$...>.......
 0680 00491338 0a320b00 00122e01 030e3a0b  .I.8.2........:.
 0690 3b0b270c 3c0c6413 00001313 01030e3c  ;.'.<.d........<
 06a0 0c011300 00142e01 030e3a0b 3b0b270c  ..........:.;.'.
 06b0 4c0b4d0a 1d133c0c 64130113 0000152e  L.M...<.d.......
 06c0 01030e3a 0b3b0b27 0c49134c 0b4d0a1d  ...:.;.'.I.L.M..
 06d0 133c0c64 13011300 00162e01 3f0c030e  .<.d........?...
 06e0 3a0b3b0b 87400e27 0c3c0c64 13000017  :.;..@.'.<.d....
 06f0 26004913 00001813 00030e3c 0c000019  &.I........<....
 0700 2e01030e 270c4c0b 4d0a1d13 340c3c0c  ....'.L.M...4.<.
 0710 64130113 00001a2e 01030e27 0c49134c  d..........'.I.L
 0720 0b4d0a1d 13340c3c 0c641301 1300001b  .M...4.<.d......
 0730 2e01030e 3a0b3b0b 270c3c0c 64130113  ....:.;.'.<.d...
 0740 00001c2e 01030e27 0c340c3c 0c641301  .......'.4.<.d..
 0750 1300001d 2e01030e 3a0b3b0b 270c4c0b  ........:.;.'.L.
 0760 4d0a1d13 3c0c6413 00001e35 00491300  M...<.d....5.I..
 0770 001f0101 49130113 00002021 0049132f  ....I..... !.I./
 0780 0b000021 2e014713 3a0b3b0b 200b6413  ...!..G.:.;. .d.
 0790 01130000 22050003 0e491334 0c000023  ...."....I.4...#
 07a0 05000308 3a0b3b0b 49130000 24340003  ....:.;.I...$4..
 07b0 083a0b3b 0b491300 00250b01 00002634  .:.;.I...%....&4
 07c0 00030e3a 0b3b0549 13000027 2e014713  ...:.;.I...'..G.
 07d0 200b6413 01130000 282e0103 0e270c34   .d.....(....'.4
 07e0 0c200b01 13000029 0500030e 3a0b3b0b  . .....)....:.;.
 07f0 49130000 2a340003 0e3a0b3b 0b491300  I...*4...:.;.I..
 0800 002b2e01 47131101 12014006 64139742  .+..G.....@.d..B
 0810 0c011300 002c0500 030e4913 340c0206  .....,....I.4...
 0820 00002d05 00030e3a 0b3b0b49 13020600  ..-....:.;.I....
 0830 002e3400 03083a0b 3b0b4913 02060000  ..4...:.;.I.....
 0840 2f898201 01110100 00308a82 0100020a  /........0......
 0850 91420a00 00312e01 47131101 1201400a  .B...1..G.....@.
 0860 64139742 0c011300 00320500 030e4913  d..B.....2....I.
 0870 340c020a 00003334 00030e3a 0b3b0b49  4.....34...:.;.I
 0880 13020a00 00340b01 11011201 0000352e  .....4........5.
 0890 01030e3a 0b3b0b27 0c491311 01120140  ...:.;.'.I.....@
 08a0 0a97420c 01130000 36898201 01110131  ..B.....6......1
 08b0 13000037 05003113 00003834 00311300  ...7..1...84.1..
 08c0 00392e01 31131101 1201400a 64139742  .9..1.....@.d..B
 08d0 0c011300 003a0500 31130206 00003b34  .....:..1.....;4
 08e0 00311302 0a00003c 0b010113 00003d2e  .1.....<......=.
 08f0 01311311 01120140 06641397 420c0113  .1.....@.d..B...
 0900 00003e0b 01110112 01011300 003f3400  ..>..........?4.
 0910 31130206 0000401d 00311311 01120158  1.....@..1.....X
 0920 0b590b00 00411d01 31131101 1201580b  .Y...A..1.....X.
 0930 590b0000 42340003 083a0b3b 0b491302  Y...B4...:.;.I..
 0940 0a000043 1d003113 11011201 580b5905  ...C..1.....X.Y.
 0950 0000442e 00030e3a 0b3b0b27 0c491320  ..D....:.;.'.I. 
 0960 0b000045 2e00030e 3a0b3b0b 270c200b  ...E....:.;.'. .
 0970 0000462e 01030e3a 0b3b0b27 0c110112  ..F....:.;.'....
 0980 01400a97 420c0113 00004789 82010011  .@..B.....G.....
 0990 01311300 00488982 01001101 95420c00  .1...H.......B..
 09a0 00492e01 31131101 1201400a 97420c01  .I..1.....@..B..
 09b0 1300004a 05003113 020a0000 4b898201  ...J..1.....K...
 09c0 01110195 420c3113 00004c2e 01311311  ....B.1...L..1..
 09d0 01120140 0697420c 01130000 4d2e0103  ...@..B.....M...
 09e0 0e3a0b3b 0b270c87 010c1101 1201400a  .:.;.'........@.
 09f0 97420c01 1300004e 89820100 11010000  .B.....N........
 0a00 4f2e013f 0c030e3a 0b3b0b27 0c110112  O..?...:.;.'....
 0a10 01400697 420c0113 0000502e 01030e3a  .@..B.....P....:
 0a20 0b3b0b27 0c491320 0b011300 00512e01  .;.'.I. .....Q..
 0a30 3f0c030e 3a0b3b0b 270c4913 87010c11  ?...:.;.'.I.....
 0a40 01120140 0a97420c 01130000 521d0131  ...@..B.....R..1
 0a50 13110112 01580b59 0b011300 00533400  .....X.Y.....S4.
 0a60 0000542e 01030e27 0c340c11 01120140  ..T....'.4.....@
 0a70 0a97420c 01130000 5534001c 0b000056  ..B.....U4.....V
 0a80 3400020a 0000572e 00471320 0b000000  4.....W..G. ....
 0a90 01110010 06110112 0103081b 08250813  .............%..
 0aa0 05000000 01110010 06110112 0103081b  ................
 0ab0 08250813 05000000 01110010 06110112  .%..............
 0ac0 0103081b 08250813 05000000 01110010  .....%..........
 0ad0 06110112 0103081b 08250813 05000000  .........%......
 0ae0 01110010 06110112 0103081b 08250813  .............%..
 0af0 05000000 01110010 06110112 0103081b  ................
 0b00 08250813 05000000                    .%......        
Contents of section .debug_line:
 0000 16000000 02001000 00000201 fb0e0a00  ................
 0010 01010101 00000001 00004f08 00000200  ..........O.....
 0020 40040000 0201fb0e 0a000101 01010000  @...............
 0030 00012f70 72697661 74652f76 61722f66  ../private/var/f
 0040 6f6c6465 72732f76 392f665f 5f703966  olders/v9/f__p9f
 0050 7473336d 39377a30 38307233 7171765f  ts3m97z080r3qqv_
 0060 71303030 3030676e 2f542f41 70705472  q00000gn/T/AppTr
 0070 616e736c 6f636174 696f6e2f 34463435  anslocation/4F45
 0080 46313536 2d333745 422d3438 34302d38  F156-37EB-4840-8
 0090 3343432d 42413943 46453031 39433533  3CC-BA9CFE019C53
 00a0 2f642f41 72647569 6e6f2031 2e382e39  /d/Arduino 1.8.9
 00b0 2e617070 2f436f6e 74656e74 732f4a61  .app/Contents/Ja
 00c0 76612f68 61726477 6172652f 61726475  va/hardware/ardu
 00d0 696e6f2f 6176722f 636f7265 732f6172  ino/avr/cores/ar
 00e0 6475696e 6f002f70 72697661 74652f76  duino./private/v
 00f0 61722f66 6f6c6465 72732f76 392f665f  ar/folders/v9/f_
 0100 5f703966 7473336d 39377a30 38307233  _p9fts3m97z080r3
 0110 7171765f 71303030 3030676e 2f542f41  qqv_q00000gn/T/A
 0120 70705472 616e736c 6f636174 696f6e2f  ppTranslocation/
 0130 34463435 46313536 2d333745 422d3438  4F45F156-37EB-48
 0140 34302d38 3343432d 42413943 46453031  40-83CC-BA9CFE01
 0150 39433533 2f642f41 72647569 6e6f2031  9C53/d/Arduino 1
 0160 2e382e39 2e617070 2f436f6e 74656e74  .8.9.app/Content
 0170 732f4a61 76612f68 61726477 6172652f  s/Java/hardware/
 0180 746f6f6c 732f6176 722f6176 722f696e  tools/avr/avr/in
 0190 636c7564 652f7574 696c002f 5f736861  clude/util./_sha
 01a0 7265645f 2f646576 2f646576 2e70726f  red_/dev/dev.pro
 01b0 6a656374 732f544f 432f4d49 44492d46  jects/TOC/MIDI-F
 01c0 4f4f542d 434f4e54 524f4c4c 45522e50  OOT-CONTROLLER.P
 01d0 55424c49 432e4749 542f6172 6475696e  UBLIC.GIT/arduin
 01e0 6f2f4a42 5f435055 5f557361 67655f42  o/JB_CPU_Usage_B
 01f0 61736963 315f5365 7269616c 002f7072  asic1_Serial./pr
 0200 69766174 652f7661 722f666f 6c646572  ivate/var/folder
 0210 732f7639 2f665f5f 70396674 73336d39  s/v9/f__p9fts3m9
 0220 377a3038 30723371 71765f71 30303030  7z080r3qqv_q0000
 0230 30676e2f 542f4170 70547261 6e736c6f  0gn/T/AppTranslo
 0240 63617469 6f6e2f34 46343546 3135362d  cation/4F45F156-
 0250 33374542 2d343834 302d3833 43432d42  37EB-4840-83CC-B
 0260 41394346 45303139 4335332f 642f4172  A9CFE019C53/d/Ar
 0270 6475696e 6f20312e 382e392e 6170702f  duino 1.8.9.app/
 0280 436f6e74 656e7473 2f4a6176 612f6861  Contents/Java/ha
 0290 72647761 72652f74 6f6f6c73 2f617672  rdware/tools/avr
 02a0 2f6c6962 2f676363 2f617672 2f352e34  /lib/gcc/avr/5.4
 02b0 2e302f69 6e636c75 6465002f 70726976  .0/include./priv
 02c0 6174652f 7661722f 666f6c64 6572732f  ate/var/folders/
 02d0 76392f66 5f5f7039 66747333 6d39377a  v9/f__p9fts3m97z
 02e0 30383072 33717176 5f713030 30303067  080r3qqv_q00000g
 02f0 6e2f542f 41707054 72616e73 6c6f6361  n/T/AppTransloca
 0300 74696f6e 2f344634 35463135 362d3337  tion/4F45F156-37
 0310 45422d34 3834302d 38334343 2d424139  EB-4840-83CC-BA9
 0320 43464530 31394335 332f642f 41726475  CFE019C53/d/Ardu
 0330 696e6f20 312e382e 392e6170 702f436f  ino 1.8.9.app/Co
 0340 6e74656e 74732f4a 6176612f 68617264  ntents/Java/hard
 0350 77617265 2f746f6f 6c732f61 76722f61  ware/tools/avr/a
 0360 76722f69 6e636c75 64650000 5072696e  vr/include..Prin
 0370 742e6370 70000100 00507269 6e742e68  t.cpp....Print.h
 0380 00010000 48617264 77617265 53657269  ....HardwareSeri
 0390 616c2e63 70700001 00004861 72647761  al.cpp....Hardwa
 03a0 72655365 7269616c 302e6370 70000100  reSerial0.cpp...
 03b0 0061746f 6d69632e 68000200 00616269  .atomic.h....abi
 03c0 2e637070 00010000 77697269 6e672e63  .cpp....wiring.c
 03d0 00010000 6d61696e 2e637070 00010000  ....main.cpp....
 03e0 4a425f43 50555f55 73616765 5f426173  JB_CPU_Usage_Bas
 03f0 6963315f 53657269 616c2e69 6e6f0003  ic1_Serial.ino..
 0400 00005374 7265616d 2e680001 00004861  ..Stream.h....Ha
 0410 72647761 72655365 7269616c 5f707269  rdwareSerial_pri
 0420 76617465 2e680001 00007374 64646566  vate.h....stddef
 0430 2e680004 00007374 64696e74 2e680005  .h....stdint.h..
 0440 00004861 72647761 72655365 7269616c  ..HardwareSerial
 0450 2e680001 00004172 6475696e 6f2e6800  .h....Arduino.h.
 0460 01000000 000502be 00000003 22010301  ............"...
 0470 09160001 03010904 00010301 09060001  ................
 0480 03040920 00010402 03300914 00010365  ... .....0.....e
 0490 09020001 03000900 00010403 03820109  ................
 04a0 06000103 05090000 01030109 04000103  ................
 04b0 02090a00 01030109 0c000103 01090200  ................
 04c0 01036a09 02000103 02090200 01030309  ..j.............
 04d0 08000103 01090c00 01030109 08000103  ................
 04e0 7c090400 01030609 04000103 6e090200  |...........n...
 04f0 01030109 02000103 03090800 01037e09  ..............~.
 0500 0c000103 04090400 01037509 02000103  ..........u.....
 0510 01090200 01030109 10000104 0403a27f  ................
 0520 09060001 03010900 00010301 09100001  ................
 0530 0403030d 09040001 03030902 00010301  ................
 0540 090e0001 0302090c 00010308 09060001  ................
 0550 0305090c 00010302 09080001 03f30009  ................
 0560 0e000103 01090e00 01030509 04000103  ................
 0570 13091400 01030409 0e000103 01090600  ................
 0580 01030509 06000103 01090a00 01030609  ................
 0590 08000103 05090e00 01040503 a17e0902  .............~..
 05a0 00010403 03e00109 02000103 01090200  ................
 05b0 01035e09 0a000104 0503c17e 09020001  ..^........~....
 05c0 040303c0 01090200 01030209 06000104  ................
 05d0 0503d27e 090c0001 03010902 00010403  ...~............
 05e0 03d00109 00000103 b77f0912 00010304  ................
 05f0 09060001 03030906 00010301 09140001  ................
 0600 0304090c 00010301 090a0001 03040908  ................
 0610 000103e2 7e090600 01030209 00000104  ....~...........
 0620 02037109 14000103 01090000 01030109  ..q.............
 0630 04000103 01091a00 01040103 94010906  ................
 0640 00010305 09200001 03030902 00010303  ..... ..........
 0650 090c0001 03010912 00010302 09040001  ................
 0660 037c0912 00010307 09080001 03010906  .|..............
 0670 00010406 03bb7e09 1e000103 03090000  ......~.........
 0680 01040703 14090400 01030309 16000103  ................
 0690 01091000 01030309 04000103 01090400  ................
 06a0 01037e09 04000103 03090800 01030109  ..~.............
 06b0 04000103 03090600 01030109 04000103  ................
 06c0 01091000 01030109 26000104 04030009  ........&.......
 06d0 16000103 01092200 01030109 08000103  ......".........
 06e0 6f092200 01040b03 37091400 01030309  o.".....7.......
 06f0 16000103 01090200 01030609 08000103  ................
 0700 01090800 01030109 0c000103 04090600  ................
 0710 01040403 bb7f0902 00010914 00000101  ................
 0720 04080005 02cc0400 00032101 040703d3  ..........!.....
 0730 01090000 01030609 02000103 01090600  ................
 0740 01030d09 06000103 01090600 01030d09  ................
 0750 06000103 0b090a00 01030309 04000103  ................
 0760 02090a00 01030a09 0a000103 07090a00  ................
 0770 01030909 0a000103 23090a00 01030109  ........#.......
 0780 0a000103 01090a00 01031709 0a000103  ................
 0790 09090a00 01040303 f37d0904 00010309  .........}......
 07a0 090c0001 0305090a 00010301 090a0001  ................
 07b0 0302090c 00010306 09040001 0302090c  ................
 07c0 00010301 090e0001 0301090e 00010301  ................
 07d0 090e0001 040703af 7f090e00 01030409  ................
 07e0 02000103 01090200 01030109 10000104  ................
 07f0 09034609 02000103 05091000 01040703  ..F.............
 0800 2f093400 01030409 02000103 01090200  /.4.............
 0810 01030109 10000104 01037609 02000103  ..........v.....
 0820 2a090800 01035609 0e000103 2a090800  *.....V.....*...
 0830 01035609 26000103 c0000908 00010408  ..V.&...........
 0840 03af7f09 08000104 04031e09 06000104  ................
 0850 02036109 00000104 0a031109 08000104  ..a.............
 0860 0b032009 10000109 42000001 015e0000  .. .....B....^..
 0870 00020041 00000002 01fb0e0a 00010101  ...A............
 0880 01000000 012e2e2f 2e2e2f2e 2e2f2e2e  ......./../../..
 0890 2f676363 2f6c6962 6763632f 636f6e66  /gcc/libgcc/conf
 08a0 69672f61 76720000 6c696231 66756e63  ig/avr..lib1func
 08b0 732e5300 01000000 00050244 07000003  s.S........D....
 08c0 e6110103 02090200 01090200 0001011e  ................
 08d0 01000002 00410000 000201fb 0e0a0001  .....A..........
 08e0 01010100 0000012e 2e2f2e2e 2f2e2e2f  ........./../../
 08f0 2e2e2f67 63632f6c 69626763 632f636f  ../gcc/libgcc/co
 0900 6e666967 2f617672 00006c69 62316675  nfig/avr..lib1fu
 0910 6e63732e 53000100 00000005 02ea0600  ncs.S...........
 0920 0003e60c 01030109 02000103 01090200  ................
 0930 01030109 02000103 01090200 01030209  ................
 0940 02000103 02090200 01030109 02000103  ................
 0950 01090200 01030109 02000103 01090200  ................
 0960 01030109 02000103 01090200 01030109  ................
 0970 02000103 01090200 01030109 02000103  ................
 0980 01090200 01030109 02000103 01090200  ................
 0990 01030209 02000103 01090200 01030109  ................
 09a0 02000103 01090200 01030109 02000103  ................
 09b0 01090200 01030209 02000103 01090200  ................
 09c0 01030109 02000103 01090200 01030209  ................
 09d0 02000103 02090200 01030209 02000103  ................
 09e0 02090200 01030209 02000109 02000001  ................
 09f0 01940000 00020041 00000002 01fb0e0a  .......A........
 0a00 00010101 01000000 012e2e2f 2e2e2f2e  .........../../.
 0a10 2e2f2e2e 2f676363 2f6c6962 6763632f  ./../gcc/libgcc/
 0a20 636f6e66 69672f61 76720000 6c696231  config/avr..lib1
 0a30 66756e63 732e5300 01000000 00050276  funcs.S........v
 0a40 00000003 e9120103 01090200 01030109  ................
 0a50 02000103 01090200 01030109 02000103  ................
 0a60 01090200 01030309 02000103 05090200  ................
 0a70 01030209 02000103 01090200 01030109  ................
 0a80 02000109 02000001 01820000 00020041  ...............A
 0a90 00000002 01fb0e0a 00010101 01000000  ................
 0aa0 012e2e2f 2e2e2f2e 2e2f2e2e 2f676363  .../../../../gcc
 0ab0 2f6c6962 6763632f 636f6e66 69672f61  /libgcc/config/a
 0ac0 76720000 6c696231 66756e63 732e5300  vr..lib1funcs.S.
 0ad0 01000000 0005028c 00000003 89130103  ................
 0ae0 01090200 01030109 02000103 01090200  ................
 0af0 01030209 02000103 02090200 01030109  ................
 0b00 02000103 01090200 01090200 0001018e  ................
 0b10 00000002 00410000 000201fb 0e0a0001  .....A..........
 0b20 01010100 0000012e 2e2f2e2e 2f2e2e2f  ........./../../
 0b30 2e2e2f67 63632f6c 69626763 632f636f  ../gcc/libgcc/co
 0b40 6e666967 2f617672 00006c69 62316675  nfig/avr..lib1fu
 0b50 6e63732e 53000100 00000005 029c0000  ncs.S...........
 0b60 0003a213 01030109 02000103 01090200  ................
 0b70 01030409 02000103 02090200 01030609  ................
 0b80 02000103 01090200 01030209 04000103  ................
 0b90 01090200 01030509 02000109 02000001  ................
 0ba0 01760000 00020041 00000002 01fb0e0a  .v.....A........
 0bb0 00010101 01000000 012e2e2f 2e2e2f2e  .........../../.
 0bc0 2e2f2e2e 2f676363 2f6c6962 6763632f  ./../gcc/libgcc/
 0bd0 636f6e66 69672f61 76720000 6c696231  config/avr..lib1
 0be0 66756e63 732e5300 01000000 0005022e  funcs.S.........
 0bf0 07000003 f8110103 01090200 01031f09  ................
 0c00 02000103 01090200 01030109 02000103  ................
 0c10 01090200 01090200 000101             ...........     
Contents of section .debug_frame:
 0000 10000000 ffffffff 0100027f 240c2002  ............$. .
 0010 a4010000 34000000 00000000 be000000  ....4...........
 0020 54000000 410e038c 02410e04 8d03410e  T...A....A....A.
 0030 058e0441 0e068f05 410e0790 06410e08  ...A....A....A..
 0040 9107410e 099c0841 0e0a9d09 0c000000  ..A....A........
 0050 00000000 12010000 02000000 0c000000  ................
 0060 00000000 14010000 06000000 0c000000  ................
 0070 00000000 1a010000 1e000000 0c000000  ................
 0080 00000000 38010000 28000000 0c000000  ....8...(.......
 0090 00000000 60010000 1c000000 0c000000  ....`...........
 00a0 00000000 7c010000 18000000 0c000000  ....|...........
 00b0 00000000 94010000 14000000 0c000000  ................
 00c0 00000000 a8010000 44000000 2c000000  ........D...,...
 00d0 00000000 ec010000 9a000000 410e038e  ............A...
 00e0 02410e04 8f03410e 05900441 0e069105  .A....A....A....
 00f0 410e079c 06410e08 9d070000 18000000  A....A..........
 0100 00000000 86020000 44000000 410e039c  ........D...A...
 0110 02410e04 9d030000 0c000000 00000000  .A..............
 0120 ca020000 14000000 0c000000 00000000  ................
 0130 de020000 24000000 3c000000 00000000  ....$...<.......
 0140 02030000 82000000 410e0388 02410e04  ........A....A..
 0150 8903410e 058a0441 0e068b05 410e0790  ..A....A....A...
 0160 06410e08 9107410e 099c0841 0e0a9d09  .A....A....A....
 0170 420d1c41 0e2b0000 0c000000 00000000  B..A.+..........
 0180 84030000 04000000 34000000 00000000  ........4.......
 0190 88030000 94000000 410e0381 02410e04  ........A....A..
 01a0 8003440e 05920441 0e069305 410e0798  ..D....A....A...
 01b0 06410e08 9907410e 099a0841 0e0a9b09  .A....A....A....
 01c0 0c000000 00000000 cc040000 c4010000  ................
 01d0 0c000000 00000000 90060000 5a000000  ............Z...
 01e0 54000000 00000000 1c040000 4c000000  T...........L...
 01f0 410e0381 02410e04 8003440e 05920441  A....A....D....A
 0200 0e069305 410e0794 06410e08 9507410e  ....A....A....A.
 0210 09960841 0e0a9709 410e0b98 0a410e0c  ...A....A....A..
 0220 990b410e 0d9a0c41 0e0e9b0d 410e0f9e  ..A....A....A...
 0230 0e410e10 9f0f0000 30000000 00000000  .A......0.......
 0240 68040000 64000000 410e0381 02410e04  h...d...A....A..
 0250 8003440e 05920441 0e069805 410e0799  ..D....A....A...
 0260 06410e08 9e07410e 099f0800           .A....A.....    
Contents of section .debug_str:
 0000 6176722d 6c696263 20322e30 2e300075  avr-libc 2.0.0.u
 0010 696e7438 5f740075 696e7431 365f7400  int8_t.uint16_t.
 0020 5f5f6565 70726f6d 00554452 30005543  __eeprom.UDR0.UC
 0030 53523041 00554353 52304200 55435352  SR0A.UCSR0B.UCSR
 0040 30430055 42525230 00545741 4d520054  0C.UBRR0.TWAMR.T
 0050 57425200 54574352 00545753 52005457  WBR.TWCR.TWSR.TW
 0060 44520054 57415200 54494d53 4b310054  DR.TWAR.TIMSK1.T
 0070 49465231 00544343 52314100 54434352  IFR1.TCCR1A.TCCR
 0080 31420054 43435231 43005443 4e543100  1B.TCCR1C.TCNT1.
 0090 4f435231 41004f43 52314200 49435231  OCR1A.OCR1B.ICR1
 00a0 00475443 43520054 494d534b 32005449  .GTCCR.TIMSK2.TI
 00b0 46523200 54434352 32410054 43435232  FR2.TCCR2A.TCCR2
 00c0 42005443 4e543200 4f435232 42004f43  B.TCNT2.OCR2B.OC
 00d0 52324100 41535352 00475443 43520041  R2A.ASSR.GTCCR.A
 00e0 444d5558 00414443 00414443 53524100  DMUX.ADC.ADCSRA.
 00f0 41444353 52420044 49445230 00414353  ADCSRB.DIDR0.ACS
 0100 52004449 44523100 504f5254 42004444  R.DIDR1.PORTB.DD
 0110 52420050 494e4200 504f5254 43004444  RB.PINB.PORTC.DD
 0120 52430050 494e4300 504f5254 44004444  RC.PINC.PORTD.DD
 0130 52440050 494e4400 4f435230 42004f43  RD.PIND.OCR0B.OC
 0140 52304100 54434e54 30005443 43523042  R0A.TCNT0.TCCR0B
 0150 00544343 52304100 54494d53 4b300054  .TCCR0A.TIMSK0.T
 0160 49465230 00475443 43520045 49435241  IFR0.GTCCR.EICRA
 0170 0045494d 534b0045 49465200 50434943  .EIMSK.EIFR.PCIC
 0180 52005043 4d534b32 0050434d 534b3100  R.PCMSK2.PCMSK1.
 0190 50434d53 4b300050 43494652 00535044  PCMSK0.PCIFR.SPD
 01a0 52005350 53520053 50435200 57445443  R.SPSR.SPCR.WDTC
 01b0 53520050 5252004f 53434341 4c00434c  SR.PRR.OSCCAL.CL
 01c0 4b505200 53524547 00535000 53504d43  KPR.SREG.SP.SPMC
 01d0 5352004d 43554352 004d4355 53520053  SR.MCUCR.MCUSR.S
 01e0 4d435200 4750494f 52320047 50494f52  MCR.GPIOR2.GPIOR
 01f0 31004750 494f5230 00454541 52004545  1.GPIOR0.EEAR.EE
 0200 44520045 45435200 5f74785f 62756666  DR.EECR._tx_buff
 0210 65725f68 65616400 5f72785f 62756666  er_head._rx_buff
 0220 65725f74 61696c00 77726974 6500666c  er_tail.write.fl
 0230 75736800 74696d65 72305f66 72616374  ush.timer0_fract
 0240 006c6f6f 702e7061 72742e30 00777269  .loop.part.0.wri
 0250 74655f65 72726f72 006f6c64 53524547  te_error.oldSREG
 0260 00536572 69616c30 5f617661 696c6162  .Serial0_availab
 0270 6c650073 697a655f 74005f5f 76656374  le.size_t.__vect
 0280 6f725f31 39007369 7a657479 70650062  or_19.sizetype.b
 0290 6567696e 00696e69 74566172 69616e74  egin.initVariant
 02a0 005f5a4e 31344861 72647761 72655365  ._ZN14HardwareSe
 02b0 7269616c 35666c75 73684576 2e706172  rial5flushEv.par
 02c0 742e3200 5f5a4e31 34486172 64776172  t.2._ZN14Hardwar
 02d0 65536572 69616c43 32455056 6853315f  eSerialC2EPVhS1_
 02e0 53315f53 315f5331 5f53315f 006d6169  S1_S1_S1_S1_.mai
 02f0 6e005f5f 6378615f 70757265 5f766972  n.__cxa_pure_vir
 0300 7475616c 00636f6e 66696700 75696e74  tual.config.uint
 0310 385f7400 73657269 616c4576 656e7452  8_t.serialEventR
 0320 756e005f 5a4e3550 72696e74 43324576  un._ZN5PrintC2Ev
 0330 00626f6f 6c005f72 785f6275 66666572  .bool._rx_buffer
 0340 5f686561 64007365 74757000 72656164  _head.setup.read
 0350 005f5f62 6173655f 63746f72 20007065  .__base_ctor .pe
 0360 656b0074 696d6572 305f6d69 6c6c6973  ek.timer0_millis
 0370 00617661 696c6162 6c65466f 72577269  .availableForWri
 0380 7465005f 75627272 68003c61 72746966  te._ubrrh.<artif
 0390 69636961 6c3e005f 6c6f6f70 436f756e  icial>._loopCoun
 03a0 74657200 62797465 00707269 6e744e75  ter.byte.printNu
 03b0 6d626572 0072785f 62756666 65725f69  mber.rx_buffer_i
 03c0 6e646578 5f740062 61756400 756e7369  ndex_t.baud.unsi
 03d0 676e6564 20636861 72005f5a 4e313448  gned char._ZN14H
 03e0 61726477 61726553 65726961 6c31365f  ardwareSerial16_
 03f0 72785f63 6f6d706c 6574655f 69727145  rx_complete_irqE
 0400 762e7061 72742e30 005f5f69 6e697469  v.part.0.__initi
 0410 616c697a 655f7000 474e5520 47494d50  alize_p.GNU GIMP
 0420 4c452035 2e342e30 202d6d6e 2d666c61  LE 5.4.0 -mn-fla
 0430 73683d31 202d6d6d 63753d61 76723520  sh=1 -mmcu=avr5 
 0440 2d6d6e2d 666c6173 683d3120 2d6d6e6f  -mn-flash=1 -mno
 0450 2d736b69 702d6275 67202d6d 6d63753d  -skip-bug -mmcu=
 0460 61767235 202d6720 2d4f7320 2d4f7320  avr5 -g -Os -Os 
 0470 2d666d61 74682d65 72726e6f 202d6673  -fmath-errno -fs
 0480 69676e65 642d7a65 726f7320 2d667472  igned-zeros -ftr
 0490 61707069 6e672d6d 61746820 2d666e6f  apping-math -fno
 04a0 2d747261 7076202d 666e6f2d 6f70656e  -trapv -fno-open
 04b0 6d70202d 666e6f2d 6f70656e 61636320  mp -fno-openacc 
 04c0 2d666e6f 2d657863 65707469 6f6e7320  -fno-exceptions 
 04d0 2d667573 652d6c69 6e6b6572 2d706c75  -fuse-linker-plu
 04e0 67696e20 2d666c74 72616e73 00707269  gin -fltrans.pri
 04f0 6e74005f 5f695265 73746f72 65007569  nt.__iRestore.ui
 0500 6e743136 5f74005f 76707472 2e507269  nt16_t._vptr.Pri
 0510 6e74006c 6f6e6720 756e7369 676e6564  nt.long unsigned
 0520 20696e74 005f7278 5f636f6d 706c6574   int._rx_complet
 0530 655f6972 71007469 6d657230 5f6f7665  e_irq.timer0_ove
 0540 72666c6f 775f636f 756e7400 53747265  rflow_count.Stre
 0550 616d005f 74785f62 75666665 72005f74  am._tx_buffer._t
 0560 785f7564 725f656d 7074795f 69727100  x_udr_empty_irq.
 0570 7072696e 746c6e00 5f5f7374 61746963  println.__static
 0580 5f696e69 7469616c 697a6174 696f6e5f  _initialization_
 0590 616e645f 64657374 72756374 696f6e5f  and_destruction_
 05a0 30005f5f 7072696f 72697479 00746869  0.__priority.thi
 05b0 73005f47 4c4f4241 4c5f5f73 75625f49  s._GLOBAL__sub_I
 05c0 5f5f5f76 6563746f 725f3138 005f5f54  ___vector_18.__T
 05d0 6f446f00 48617264 77617265 53657269  oDo.HardwareSeri
 05e0 616c0062 6175645f 73657474 696e6700  al.baud_setting.
 05f0 5f74785f 62756666 65725f74 61696c00  _tx_buffer_tail.
 0600 5f5a4e31 34486172 64776172 65536572  _ZN14HardwareSer
 0610 69616c35 77726974 6545682e 70617274  ial5writeEh.part
 0620 2e33005f 5f767462 6c5f7074 725f7479  .3.__vtbl_ptr_ty
 0630 7065005f 5f766563 746f725f 3136005f  pe.__vector_16._
 0640 75627272 6c005f74 696d656f 75740073  ubrrl._timeout.s
 0650 697a6500 73726567 5f736176 65005f5f  ize.sreg_save.__
 0660 69436c69 52657456 616c005f 5a4e3134  iCliRetVal._ZN14
 0670 48617264 77617265 53657269 616c3137  HardwareSerial17
 0680 5f74785f 7564725f 656d7074 795f6972  _tx_udr_empty_ir
 0690 7145762e 70617274 2e31005f 75637372  qEv.part.1._ucsr
 06a0 61005f75 63737262 005f7563 73726300  a._ucsrb._ucsrc.
 06b0 74785f62 75666665 725f696e 6465785f  tx_buffer_index_
 06c0 74006c6f 6f70005f 73746172 744d696c  t.loop._startMil
 06d0 6c697300 5f756472 005f7278 5f627566  lis._udr._rx_buf
 06e0 66657200 656e6454 696d655f 6d730062  fer.endTime_ms.b
 06f0 61736500 5f737461 72745469 6d655f6d  ase._startTime_m
 0700 73005f77 72697474 656e0069 6e697400  s._written.init.
Contents of section .debug_loc:
 0000 be000000 c0000000 03009220 02c00000  ........... ....
 0010 00c20000 00030092 2003c200 0000c400  ........ .......
 0020 00000300 922004c4 000000c6 00000003  ..... ..........
 0030 00922005 c6000000 c8000000 03009220  .. ............ 
 0040 06c80000 00ca0000 00030092 2007ca00  ............ ...
 0050 0000cc00 00000300 922008cc 000000ce  ......... ......
 0060 00000003 00922009 ce000000 12010000  ...... .........
 0070 03009220 0a000000 00000000 00be0000  ... ............
 0080 00d80000 00060068 93016993 01d80000  .......h..i.....
 0090 00100100 0006005c 93015d93 01100100  .......\..].....
 00a0 00120100 000400f3 01689f00 00000000  .........h......
 00b0 000000be 000000d8 00000006 00669301  .............f..
 00c0 679301d8 000000de 00000007 00f30166  g..............f
 00d0 8c00229f de000000 fa000000 0900f301  ..".............
 00e0 668c0022 23019ffa 000000fc 00000007  f.."#...........
 00f0 008c00f3 0166229f fc000000 fe000000  .....f".........
 0100 0900f301 668c0022 23019f00 00000000  ....f.."#.......
 0110 000000be 000000d8 00000006 00649301  .............d..
 0120 659301d8 000000fa 00000007 008c0020  e.............. 
 0130 7e00229f fa000000 fc000000 06007e00  ~."...........~.
 0140 8c001c9f fc000000 fe000000 07008c00  ................
 0150 207e0022 9ffe0000 00040100 0008008c   ~."............
 0160 0020f301 64229f00 00000000 000000d2  . ..d"..........
 0170 000000d8 00000002 00309fd8 00000004  .........0......
 0180 01000006 006c9301 6d930100 00000000  .....l..m.......
 0190 00000014 01000018 01000006 00689301  .............h..
 01a0 69930118 0100001a 01000004 00f30168  i..............h
 01b0 9f000000 00000000 001a0100 00260100  .............&..
 01c0 00060068 93016993 01260100 00380100  ...h..i..&...8..
 01d0 0006006e 93016f93 01000000 00000000  ...n..o.........
 01e0 00380100 003e0100 00060068 93016993  .8...>.....h..i.
 01f0 013e0100 00600100 0006006e 93016f93  .>...`.....n..o.
 0200 01000000 00000000 004e0100 005a0100  .........N...Z..
 0210 00010068 00000000 00000000 60010000  ...h........`...
 0220 66010000 06006893 01699301 66010000  f.....h..i..f...
 0230 70010000 06006e93 016f9301 70010000  p.....n..o..p...
 0240 76010000 0400f301 689f7601 00007c01  v.......h.v...|.
 0250 00000600 6e93016f 93010000 00000000  ....n..o........
 0260 00007c01 00008401 00000600 68930169  ..|.........h..i
 0270 93018401 00009401 00000600 6e93016f  ............n..o
 0280 93010000 00000000 0000a801 0000ac01  ................
 0290 00000600 68930169 9301ac01 0000e401  ....h..i........
 02a0 00000600 6e93016f 9301e401 0000ec01  ....n..o........
 02b0 00000400 f301689f 00000000 00000000  ......h.........
 02c0 de010000 e4010000 06006e93 016f9301  ..........n..o..
 02d0 e4010000 ea010000 0400f301 689f0000  ............h...
 02e0 00000000 0000ec01 0000ee01 00000300  ................
 02f0 922002ee 010000f0 01000003 00922003  . ............ .
 0300 f0010000 f2010000 03009220 04f20100  ........... ....
 0310 00f40100 00030092 2005f401 0000f601  ........ .......
 0320 00000300 922006f6 010000f8 01000003  ..... ..........
 0330 00922007 f8010000 86020000 03009220  .. ............ 
 0340 08000000 00000000 00ec0100 00fc0100  ................
 0350 00060068 93016993 01fc0100 007c0200  ...h..i......|..
 0360 0006006c 93016d93 017c0200 00860200  ...l..m..|......
 0370 000400f3 01689f00 00000000 000000ec  .....h..........
 0380 01000020 02000001 00662002 00005c02  ... .....f ...\.
 0390 00000100 5f5c0200 00700200 00010066  ...._\...p.....f
 03a0 70020000 86020000 0400f301 669f0000  p...........f...
 03b0 00000000 00005e02 00007002 00000100  ......^...p.....
 03c0 69000000 00000000 00600200 00700200  i........`...p..
 03d0 00020031 9f720200 00860200 00020030  ...1.r.........0
 03e0 9f000000 00000000 00120200 005c0200  .............\..
 03f0 0001005f 00000000 00000000 12020000  ..._............
 0400 5c020000 06006c93 016d9301 00000000  \.....l..m......
 0410 00000000 20020000 5c020000 01006000  .... ...\.....`.
 0420 00000000 0000004e 0200005c 02000001  .......N...\....
 0430 00690000 00000000 00005002 00005c02  .i........P...\.
 0440 00000200 319f0000 00000000 00008602  ....1...........
 0450 00008802 00000300 92200288 0200008a  ......... ......
 0460 02000003 00922003 8a020000 ca020000  ...... .........
 0470 03009220 04000000 00000000 00860200  ... ............
 0480 008e0200 00060068 93016993 018e0200  .......h..i.....
 0490 00c80200 0006006c 93016d93 01c80200  .......l..m.....
 04a0 00ca0200 000400f3 01689f00 00000000  .........h......
 04b0 000000de 020000f8 02000006 00689301  .............h..
 04c0 699301f8 020000fb 02000006 00669301  i............f..
 04d0 679301fb 020000fc 02000004 00f30168  g..............h
 04e0 9ffc0200 00000300 00060068 93016993  ...........h..i.
 04f0 01000300 00020300 000400f3 01689f00  .............h..
 0500 00000000 00000002 03000004 03000003  ................
 0510 00922002 04030000 06030000 03009220  .. ............ 
 0520 03060300 00080300 00030092 20040803  ............ ...
 0530 00000a03 00000300 9220050a 0300000c  ......... ......
 0540 03000003 00922006 0c030000 0e030000  ...... .........
 0550 03009220 070e0300 00100300 00030092  ... ............
 0560 20081003 00001203 00000300 92200912   ............ ..
 0570 03000016 03000003 0092200a 16030000  .......... .....
 0580 18030000 02008c0a 18030000 84030000  ................
 0590 02008c2b 00000000 00000000 02030000  ...+............
 05a0 38030000 0c006693 01679301 68930169  8.....f..g..h..i
 05b0 93013803 00004003 00000c00 66930167  ..8...@.....f..g
 05c0 93016893 01699301 46030000 65030000  ..h..i..F...e...
 05d0 0c006293 01639301 64930165 93010000  ..b..c..d..e....
 05e0 00000000 00000203 00002a03 00000100  ..........*.....
 05f0 642a0300 00380300 000400f3 01649f00  d*...8.......d..
 0600 00000000 00000022 03000038 03000003  ......."...8....
 0610 0091769f 38030000 7a030000 06006093  ..v.8...z.....`.
 0620 01619301 00000000 00000000 42030000  .a..........B...
 0630 44030000 01006644 03000050 03000001  D.....fD...P....
 0640 006e5003 00005203 00000300 8e509f52  .nP...R......P.R
 0650 03000054 03000001 006e0000 00000000  ...T.....n......
 0660 00008803 00008a03 00000300 9220028a  ............. ..
 0670 0300008c 03000003 00922003 8c030000  .......... .....
 0680 94030000 03009220 04940300 00960300  ....... ........
 0690 00030092 20059603 00009803 00000300  .... ...........
 06a0 92200698 0300009a 03000003 00922007  . ............ .
 06b0 9a030000 9c030000 03009220 089c0300  ........... ....
 06c0 009e0300 00030092 20099e03 00001c04  ........ .......
 06d0 00000300 92200a00 00000000 000000ae  ..... ..........
 06e0 030000b2 0300000c 00689301 6993016a  .........h..i..j
 06f0 93016b93 01b20300 00c00300 00030088  ..k.............
 0700 019fc003 0000c203 00000c00 68930169  ............h..i
 0710 93016a93 016b9301 c2030000 cc030000  ..j..k..........
 0720 03008801 9fcc0300 00f00300 000c0068  ...............h
 0730 93016993 016a9301 6b9301f0 03000006  ..i..j..k.......
 0740 04000005 00033901 80000000 00000000  ......9.........
 0750 0000b203 0000b603 00000100 63b60300  ............c...
 0760 00c40300 00010062 c4030000 c6030000  .......b........
 0770 03008303 9fc60300 00120400 00010062  ...............b
 0780 12040000 16040000 05000338 01800000  ...........8....
 0790 00000000 00000052 050000c6 05000004  .......R........
 07a0 000a00e1 9f000000 00000000 00520500  .............R..
 07b0 00c60500 00020036 9f000000 00000000  .......6........
 07c0 00520500 00680500 00030008 229f6805  .R...h......".h.
 07d0 0000c605 00000200 409f0000 00000000  ........@.......
 07e0 0000da05 0000dc05 00000c00 68930169  ............h..i
 07f0 93016a93 016b9301 00000000 00000000  ..j..k..........
 0800 c8050000 dc050000 01006200 00000000  ..........b.....
 0810 00000034 06000036 0600000c 005c9301  ...4...6.....\..
 0820 5d93015e 93015f93 01000000 00000000  ]..^.._.........
 0830 00220600 00360600 00010068 00000000  ."...6.....h....
 0840 00000000 3e060000 4c060000 02003a9f  ....>...L.....:.
 0850 00000000 00000000 3e060000 4c060000  ........>...L...
 0860 06000cc0 c62d009f 00000000 00000000  .....-..........
 0870 54060000 7a060000 02003a9f 00000000  T...z.....:.....
 0880 00000000 54060000 70060000 0a007c00  ....T...p.....|.
 0890 03300180 00061c9f 70060000 79060000  .0......p...y...
 08a0 0c006293 01639301 64930165 93010000  ..b..c..d..e....
 08b0 00000000 00009006 0000e806 00000200  ................
 08c0 319f0000 00000000 00009006 0000e806  1...............
 08d0 00000300 09ff9f00 00000000 0000001c  ................
 08e0 0400001e 04000003 00922002 1e040000  .......... .....
 08f0 20040000 03009220 03200400 00280400   ...... . ...(..
 0900 00030092 20042804 00002a04 00000300  .... .(...*.....
 0910 9220052a 0400002c 04000003 00922006  . .*...,...... .
 0920 2c040000 2e040000 03009220 072e0400  ,.......... ....
 0930 00300400 00030092 20083004 00003204  .0...... .0...2.
 0940 00000300 92200932 04000034 04000003  ..... .2...4....
 0950 0092200a 34040000 36040000 03009220  .. .4...6...... 
 0960 0b360400 00380400 00030092 200c3804  .6...8...... .8.
 0970 00003a04 00000300 92200d3a 0400003c  ..:...... .:...<
 0980 04000003 0092200e 3c040000 3e040000  ...... .<...>...
 0990 03009220 0f3e0400 00680400 00030092  ... .>...h......
 09a0 20100000 00000000 00006804 00006a04   .........h...j.
 09b0 00000300 9220026a 0400006c 04000003  ..... .j...l....
 09c0 00922003 6c040000 74040000 03009220  .. .l...t...... 
 09d0 04740400 00760400 00030092 20057604  .t...v...... .v.
 09e0 00007804 00000300 92200678 0400007a  ..x...... .x...z
 09f0 04000003 00922007 7a040000 7c040000  ...... .z...|...
 0a00 03009220 087c0400 00cc0400 00030092  ... .|..........
 0a10 20090000 00000000 00009404 0000b604   ...............
 0a20 00000100 69000000 00000000 009c0400  ....i...........
 0a30 00b60400 00010068 00000000 00000000  .......h........
Contents of section .debug_ranges:
 0000 be000000 cc040000 cc040000 90060000  ................
 0010 90060000 ea060000 00000000 00000000  ................

Disassembly of section .data:

00800100 <__data_start>:
  800100:	c0 c6       	rjmp	.+3456   	; 0x800e82 <__bss_end+0xca8>
  800102:	2d 00       	.word	0x002d	; ????

00800104 <_ZTV14HardwareSerial>:
  800104:	00 00       	nop
  800106:	00 00       	nop
  800108:	f6 00       	.word	0x00f6	; ????
  80010a:	5f 00       	.word	0x005f	; ????
  80010c:	8d 00       	.word	0x008d	; ????
  80010e:	43 01       	movw	r8, r6
  800110:	be 00       	.word	0x00be	; ????
  800112:	9c 00       	.word	0x009c	; ????
  800114:	b0 00       	.word	0x00b0	; ????
  800116:	4c 6f       	ori	r20, 0xFC	; 252
  800118:	6f 70       	andi	r22, 0x0F	; 15
  80011a:	73 3a       	cpi	r23, 0xA3	; 163
  80011c:	20 00       	.word	0x0020	; ????
  80011e:	2e 20       	and	r2, r14
  800120:	54 69       	ori	r21, 0x94	; 148
  800122:	6d 65       	ori	r22, 0x5D	; 93
  800124:	3a 20       	and	r3, r10
  800126:	00 20       	and	r0, r0
  800128:	5b 6d       	ori	r21, 0xDB	; 219
  80012a:	73 5d       	subi	r23, 0xD3	; 211
  80012c:	00 0d       	add	r16, r0
  80012e:	0a 00       	.word	0x000a	; ????

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 c4 01 	jmp	0x388	; 0x388 <__vector_16>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 34 02 	jmp	0x468	; 0x468 <__vector_18>
  4c:	0c 94 0e 02 	jmp	0x41c	; 0x41c <__vector_19>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
  68:	48 03       	fmul	r20, r16

0000006a <__ctors_end>:
  6a:	11 24       	eor	r1, r1
  6c:	1f be       	out	0x3f, r1	; 63
  6e:	cf ef       	ldi	r28, 0xFF	; 255
  70:	d8 e0       	ldi	r29, 0x08	; 8
  72:	de bf       	out	0x3e, r29	; 62
  74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	e8 e4       	ldi	r30, 0x48	; 72
  7e:	f7 e0       	ldi	r31, 0x07	; 7
  80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
  82:	05 90       	lpm	r0, Z+
  84:	0d 92       	st	X+, r0
  86:	a0 33       	cpi	r26, 0x30	; 48
  88:	b1 07       	cpc	r27, r17
  8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
  8c:	21 e0       	ldi	r18, 0x01	; 1
  8e:	a0 e3       	ldi	r26, 0x30	; 48
  90:	b1 e0       	ldi	r27, 0x01	; 1
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	aa 3d       	cpi	r26, 0xDA	; 218
  98:	b2 07       	cpc	r27, r18
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	c5 e3       	ldi	r28, 0x35	; 53
  a0:	d0 e0       	ldi	r29, 0x00	; 0
  a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
  a4:	21 97       	sbiw	r28, 0x01	; 1
  a6:	fe 01       	movw	r30, r28
  a8:	0e 94 97 03 	call	0x72e	; 0x72e <__tablejump2__>
  ac:	c4 33       	cpi	r28, 0x34	; 52
  ae:	d1 07       	cpc	r29, r17
  b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
  b2:	0e 94 66 02 	call	0x4cc	; 0x4cc <main>
  b6:	0c 94 a2 03 	jmp	0x744	; 0x744 <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	cf 92       	push	r12
  c0:	df 92       	push	r13
  c2:	ef 92       	push	r14
  c4:	ff 92       	push	r15
  c6:	0f 93       	push	r16
  c8:	1f 93       	push	r17
  ca:	cf 93       	push	r28
  cc:	df 93       	push	r29
  ce:	6c 01       	movw	r12, r24
  d0:	7a 01       	movw	r14, r20
  d2:	8b 01       	movw	r16, r22
  size_t n = 0;
  d4:	c0 e0       	ldi	r28, 0x00	; 0
  d6:	d0 e0       	ldi	r29, 0x00	; 0
  while (size--) {
  d8:	ce 15       	cp	r28, r14
  da:	df 05       	cpc	r29, r15
  dc:	81 f0       	breq	.+32     	; 0xfe <_ZN5Print5writeEPKhj+0x40>
    if (write(*buffer++)) n++;
  de:	d8 01       	movw	r26, r16
  e0:	6d 91       	ld	r22, X+
  e2:	8d 01       	movw	r16, r26
  e4:	d6 01       	movw	r26, r12
  e6:	ed 91       	ld	r30, X+
  e8:	fc 91       	ld	r31, X
  ea:	01 90       	ld	r0, Z+
  ec:	f0 81       	ld	r31, Z
  ee:	e0 2d       	mov	r30, r0
  f0:	c6 01       	movw	r24, r12
  f2:	09 95       	icall
  f4:	89 2b       	or	r24, r25
  f6:	11 f0       	breq	.+4      	; 0xfc <_ZN5Print5writeEPKhj+0x3e>
  f8:	21 96       	adiw	r28, 0x01	; 1
  fa:	ee cf       	rjmp	.-36     	; 0xd8 <_ZN5Print5writeEPKhj+0x1a>
  fc:	7e 01       	movw	r14, r28
    else break;
  }
  return n;
}
  fe:	c7 01       	movw	r24, r14
 100:	df 91       	pop	r29
 102:	cf 91       	pop	r28
 104:	1f 91       	pop	r17
 106:	0f 91       	pop	r16
 108:	ff 90       	pop	r15
 10a:	ef 90       	pop	r14
 10c:	df 90       	pop	r13
 10e:	cf 90       	pop	r12
 110:	08 95       	ret

00000112 <_ZN5Print5flushEv>:
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 112:	08 95       	ret

00000114 <_ZN5Print17availableForWriteEv>:
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 114:	80 e0       	ldi	r24, 0x00	; 0
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	08 95       	ret

0000011a <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 11a:	fc 01       	movw	r30, r24
 11c:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
 11e:	44 8d       	ldd	r20, Z+28	; 0x1c
 120:	25 2f       	mov	r18, r21
 122:	30 e0       	ldi	r19, 0x00	; 0
 124:	84 2f       	mov	r24, r20
 126:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 128:	82 1b       	sub	r24, r18
 12a:	93 0b       	sbc	r25, r19
 12c:	54 17       	cp	r21, r20
 12e:	10 f0       	brcs	.+4      	; 0x134 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
 130:	cf 96       	adiw	r24, 0x3f	; 63
 132:	08 95       	ret
  return tail - head - 1;
 134:	01 97       	sbiw	r24, 0x01	; 1
}
 136:	08 95       	ret

00000138 <_ZN14HardwareSerial4readEv>:
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 138:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 13a:	91 8d       	ldd	r25, Z+25	; 0x19
 13c:	82 8d       	ldd	r24, Z+26	; 0x1a
 13e:	98 17       	cp	r25, r24
 140:	61 f0       	breq	.+24     	; 0x15a <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 142:	82 8d       	ldd	r24, Z+26	; 0x1a
 144:	df 01       	movw	r26, r30
 146:	a8 0f       	add	r26, r24
 148:	b1 1d       	adc	r27, r1
 14a:	5d 96       	adiw	r26, 0x1d	; 29
 14c:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 14e:	92 8d       	ldd	r25, Z+26	; 0x1a
 150:	9f 5f       	subi	r25, 0xFF	; 255
 152:	9f 73       	andi	r25, 0x3F	; 63
 154:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 15a:	8f ef       	ldi	r24, 0xFF	; 255
 15c:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 15e:	08 95       	ret

00000160 <_ZN14HardwareSerial4peekEv>:
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 160:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
 162:	91 8d       	ldd	r25, Z+25	; 0x19
 164:	82 8d       	ldd	r24, Z+26	; 0x1a
 166:	98 17       	cp	r25, r24
 168:	31 f0       	breq	.+12     	; 0x176 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 16a:	82 8d       	ldd	r24, Z+26	; 0x1a
 16c:	e8 0f       	add	r30, r24
 16e:	f1 1d       	adc	r31, r1
 170:	85 8d       	ldd	r24, Z+29	; 0x1d
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 176:	8f ef       	ldi	r24, 0xFF	; 255
 178:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 17a:	08 95       	ret

0000017c <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 17c:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 17e:	91 8d       	ldd	r25, Z+25	; 0x19
 180:	22 8d       	ldd	r18, Z+26	; 0x1a
 182:	89 2f       	mov	r24, r25
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	80 5c       	subi	r24, 0xC0	; 192
 188:	9f 4f       	sbci	r25, 0xFF	; 255
 18a:	82 1b       	sub	r24, r18
 18c:	91 09       	sbc	r25, r1
}
 18e:	8f 73       	andi	r24, 0x3F	; 63
 190:	99 27       	eor	r25, r25
 192:	08 95       	ret

00000194 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 194:	8d e3       	ldi	r24, 0x3D	; 61
 196:	91 e0       	ldi	r25, 0x01	; 1
 198:	0e 94 be 00 	call	0x17c	; 0x17c <_ZN14HardwareSerial9availableEv>
 19c:	21 e0       	ldi	r18, 0x01	; 1
 19e:	89 2b       	or	r24, r25
 1a0:	09 f4       	brne	.+2      	; 0x1a4 <_Z17Serial0_availablev+0x10>
 1a2:	20 e0       	ldi	r18, 0x00	; 0
}
 1a4:	82 2f       	mov	r24, r18
 1a6:	08 95       	ret

000001a8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1a8:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1aa:	84 8d       	ldd	r24, Z+28	; 0x1c
 1ac:	df 01       	movw	r26, r30
 1ae:	a8 0f       	add	r26, r24
 1b0:	b1 1d       	adc	r27, r1
 1b2:	a3 5a       	subi	r26, 0xA3	; 163
 1b4:	bf 4f       	sbci	r27, 0xFF	; 255
 1b6:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1b8:	84 8d       	ldd	r24, Z+28	; 0x1c
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	01 96       	adiw	r24, 0x01	; 1
 1be:	8f 73       	andi	r24, 0x3F	; 63
 1c0:	99 27       	eor	r25, r25
 1c2:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
 1c4:	a6 89       	ldd	r26, Z+22	; 0x16
 1c6:	b7 89       	ldd	r27, Z+23	; 0x17
 1c8:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 1ca:	a0 89       	ldd	r26, Z+16	; 0x10
 1cc:	b1 89       	ldd	r27, Z+17	; 0x11
 1ce:	8c 91       	ld	r24, X
 1d0:	83 70       	andi	r24, 0x03	; 3
 1d2:	80 64       	ori	r24, 0x40	; 64
 1d4:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 1d6:	93 8d       	ldd	r25, Z+27	; 0x1b
 1d8:	84 8d       	ldd	r24, Z+28	; 0x1c
 1da:	98 13       	cpse	r25, r24
 1dc:	06 c0       	rjmp	.+12     	; 0x1ea <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1de:	02 88       	ldd	r0, Z+18	; 0x12
 1e0:	f3 89       	ldd	r31, Z+19	; 0x13
 1e2:	e0 2d       	mov	r30, r0
 1e4:	80 81       	ld	r24, Z
 1e6:	8f 7d       	andi	r24, 0xDF	; 223
 1e8:	80 83       	st	Z, r24
 1ea:	08 95       	ret

000001ec <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 1ec:	ef 92       	push	r14
 1ee:	ff 92       	push	r15
 1f0:	0f 93       	push	r16
 1f2:	1f 93       	push	r17
 1f4:	cf 93       	push	r28
 1f6:	df 93       	push	r29
 1f8:	ec 01       	movw	r28, r24
  _written = true;
 1fa:	81 e0       	ldi	r24, 0x01	; 1
 1fc:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 1fe:	9b 8d       	ldd	r25, Y+27	; 0x1b
 200:	8c 8d       	ldd	r24, Y+28	; 0x1c
 202:	98 13       	cpse	r25, r24
 204:	05 c0       	rjmp	.+10     	; 0x210 <_ZN14HardwareSerial5writeEh+0x24>
 206:	e8 89       	ldd	r30, Y+16	; 0x10
 208:	f9 89       	ldd	r31, Y+17	; 0x11
 20a:	80 81       	ld	r24, Z
 20c:	85 fd       	sbrc	r24, 5
 20e:	26 c0       	rjmp	.+76     	; 0x25c <_ZN14HardwareSerial5writeEh+0x70>
 210:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 212:	0b 8d       	ldd	r16, Y+27	; 0x1b
 214:	10 e0       	ldi	r17, 0x00	; 0
 216:	0f 5f       	subi	r16, 0xFF	; 255
 218:	1f 4f       	sbci	r17, 0xFF	; 255
 21a:	0f 73       	andi	r16, 0x3F	; 63
 21c:	11 27       	eor	r17, r17
 21e:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 220:	8c 8d       	ldd	r24, Y+28	; 0x1c
 222:	e8 12       	cpse	r14, r24
 224:	0c c0       	rjmp	.+24     	; 0x23e <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
 226:	0f b6       	in	r0, 0x3f	; 63
 228:	07 fc       	sbrc	r0, 7
 22a:	fa cf       	rjmp	.-12     	; 0x220 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 22c:	e8 89       	ldd	r30, Y+16	; 0x10
 22e:	f9 89       	ldd	r31, Y+17	; 0x11
 230:	80 81       	ld	r24, Z
 232:	85 ff       	sbrs	r24, 5
 234:	f5 cf       	rjmp	.-22     	; 0x220 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
 236:	ce 01       	movw	r24, r28
 238:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 23c:	f1 cf       	rjmp	.-30     	; 0x220 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 23e:	8b 8d       	ldd	r24, Y+27	; 0x1b
 240:	fe 01       	movw	r30, r28
 242:	e8 0f       	add	r30, r24
 244:	f1 1d       	adc	r31, r1
 246:	e3 5a       	subi	r30, 0xA3	; 163
 248:	ff 4f       	sbci	r31, 0xFF	; 255
 24a:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 24c:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 24e:	f8 94       	cli
    _tx_buffer_head = i;
 250:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
 252:	ea 89       	ldd	r30, Y+18	; 0x12
 254:	fb 89       	ldd	r31, Y+19	; 0x13
 256:	80 81       	ld	r24, Z
 258:	80 62       	ori	r24, 0x20	; 32
 25a:	0a c0       	rjmp	.+20     	; 0x270 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 25c:	9f b7       	in	r25, 0x3f	; 63
 25e:	f8 94       	cli
      *_udr = c;
 260:	ee 89       	ldd	r30, Y+22	; 0x16
 262:	ff 89       	ldd	r31, Y+23	; 0x17
 264:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 266:	e8 89       	ldd	r30, Y+16	; 0x10
 268:	f9 89       	ldd	r31, Y+17	; 0x11
 26a:	80 81       	ld	r24, Z
 26c:	83 70       	andi	r24, 0x03	; 3
 26e:	80 64       	ori	r24, 0x40	; 64
 270:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 272:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
 274:	81 e0       	ldi	r24, 0x01	; 1
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	df 91       	pop	r29
 27a:	cf 91       	pop	r28
 27c:	1f 91       	pop	r17
 27e:	0f 91       	pop	r16
 280:	ff 90       	pop	r15
 282:	ef 90       	pop	r14
 284:	08 95       	ret

00000286 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 286:	cf 93       	push	r28
 288:	df 93       	push	r29
 28a:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 28c:	88 8d       	ldd	r24, Y+24	; 0x18
 28e:	88 23       	and	r24, r24
 290:	c9 f0       	breq	.+50     	; 0x2c4 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 292:	ea 89       	ldd	r30, Y+18	; 0x12
 294:	fb 89       	ldd	r31, Y+19	; 0x13
 296:	80 81       	ld	r24, Z
 298:	85 fd       	sbrc	r24, 5
 29a:	05 c0       	rjmp	.+10     	; 0x2a6 <_ZN14HardwareSerial5flushEv+0x20>
 29c:	a8 89       	ldd	r26, Y+16	; 0x10
 29e:	b9 89       	ldd	r27, Y+17	; 0x11
 2a0:	8c 91       	ld	r24, X
 2a2:	86 fd       	sbrc	r24, 6
 2a4:	0f c0       	rjmp	.+30     	; 0x2c4 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 2a6:	0f b6       	in	r0, 0x3f	; 63
 2a8:	07 fc       	sbrc	r0, 7
 2aa:	f5 cf       	rjmp	.-22     	; 0x296 <_ZN14HardwareSerial5flushEv+0x10>
 2ac:	80 81       	ld	r24, Z
 2ae:	85 ff       	sbrs	r24, 5
 2b0:	f2 cf       	rjmp	.-28     	; 0x296 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 2b2:	a8 89       	ldd	r26, Y+16	; 0x10
 2b4:	b9 89       	ldd	r27, Y+17	; 0x11
 2b6:	8c 91       	ld	r24, X
 2b8:	85 ff       	sbrs	r24, 5
 2ba:	ed cf       	rjmp	.-38     	; 0x296 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
 2bc:	ce 01       	movw	r24, r28
 2be:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 2c2:	e7 cf       	rjmp	.-50     	; 0x292 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 2c4:	df 91       	pop	r29
 2c6:	cf 91       	pop	r28
 2c8:	08 95       	ret

000002ca <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2ca:	80 e0       	ldi	r24, 0x00	; 0
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	89 2b       	or	r24, r25
 2d0:	29 f0       	breq	.+10     	; 0x2dc <_Z14serialEventRunv+0x12>
 2d2:	0e 94 ca 00 	call	0x194	; 0x194 <_Z17Serial0_availablev>
 2d6:	81 11       	cpse	r24, r1
 2d8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
 2dc:	08 95       	ret

000002de <_ZN5Print5writeEPKc.constprop.14>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 2de:	00 97       	sbiw	r24, 0x00	; 0
 2e0:	69 f0       	breq	.+26     	; 0x2fc <_ZN5Print5writeEPKc.constprop.14+0x1e>
      return write((const uint8_t *)str, strlen(str));
 2e2:	fc 01       	movw	r30, r24
 2e4:	01 90       	ld	r0, Z+
 2e6:	00 20       	and	r0, r0
 2e8:	e9 f7       	brne	.-6      	; 0x2e4 <_ZN5Print5writeEPKc.constprop.14+0x6>
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	af 01       	movw	r20, r30
 2ee:	48 1b       	sub	r20, r24
 2f0:	59 0b       	sbc	r21, r25
 2f2:	bc 01       	movw	r22, r24
 2f4:	8d e3       	ldi	r24, 0x3D	; 61
 2f6:	91 e0       	ldi	r25, 0x01	; 1
 2f8:	0c 94 5f 00 	jmp	0xbe	; 0xbe <_ZN5Print5writeEPKhj>
    }
 2fc:	80 e0       	ldi	r24, 0x00	; 0
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	08 95       	ret

00000302 <_ZN5Print11printNumberEmh.constprop.12>:
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 302:	8f 92       	push	r8
 304:	9f 92       	push	r9
 306:	af 92       	push	r10
 308:	bf 92       	push	r11
 30a:	0f 93       	push	r16
 30c:	1f 93       	push	r17
 30e:	cf 93       	push	r28
 310:	df 93       	push	r29
 312:	cd b7       	in	r28, 0x3d	; 61
 314:	de b7       	in	r29, 0x3e	; 62
 316:	a1 97       	sbiw	r28, 0x21	; 33
 318:	0f b6       	in	r0, 0x3f	; 63
 31a:	f8 94       	cli
 31c:	de bf       	out	0x3e, r29	; 62
 31e:	0f be       	out	0x3f, r0	; 63
 320:	cd bf       	out	0x3d, r28	; 61
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 322:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 324:	42 30       	cpi	r20, 0x02	; 2
 326:	08 f4       	brcc	.+2      	; 0x32a <_ZN5Print11printNumberEmh.constprop.12+0x28>
 328:	4a e0       	ldi	r20, 0x0A	; 10
 32a:	8e 01       	movw	r16, r28
 32c:	0f 5d       	subi	r16, 0xDF	; 223
 32e:	1f 4f       	sbci	r17, 0xFF	; 255

  do {
    char c = n % base;
 330:	84 2e       	mov	r8, r20
 332:	91 2c       	mov	r9, r1
 334:	a1 2c       	mov	r10, r1
 336:	b1 2c       	mov	r11, r1
 338:	a5 01       	movw	r20, r10
 33a:	94 01       	movw	r18, r8
 33c:	0e 94 75 03 	call	0x6ea	; 0x6ea <__udivmodsi4>
 340:	e6 2f       	mov	r30, r22
    n /= base;
 342:	b9 01       	movw	r22, r18
 344:	ca 01       	movw	r24, r20

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 346:	01 50       	subi	r16, 0x01	; 1
 348:	11 09       	sbc	r17, r1
 34a:	ea 30       	cpi	r30, 0x0A	; 10
 34c:	14 f4       	brge	.+4      	; 0x352 <_ZN5Print11printNumberEmh.constprop.12+0x50>
 34e:	e0 5d       	subi	r30, 0xD0	; 208
 350:	01 c0       	rjmp	.+2      	; 0x354 <_ZN5Print11printNumberEmh.constprop.12+0x52>
 352:	e9 5c       	subi	r30, 0xC9	; 201
 354:	d8 01       	movw	r26, r16
 356:	ec 93       	st	X, r30
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 358:	23 2b       	or	r18, r19
 35a:	24 2b       	or	r18, r20
 35c:	25 2b       	or	r18, r21
 35e:	61 f7       	brne	.-40     	; 0x338 <_ZN5Print11printNumberEmh.constprop.12+0x36>
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 360:	c8 01       	movw	r24, r16
 362:	0e 94 6f 01 	call	0x2de	; 0x2de <_ZN5Print5writeEPKc.constprop.14>
}
 366:	a1 96       	adiw	r28, 0x21	; 33
 368:	0f b6       	in	r0, 0x3f	; 63
 36a:	f8 94       	cli
 36c:	de bf       	out	0x3e, r29	; 62
 36e:	0f be       	out	0x3f, r0	; 63
 370:	cd bf       	out	0x3d, r28	; 61
 372:	df 91       	pop	r29
 374:	cf 91       	pop	r28
 376:	1f 91       	pop	r17
 378:	0f 91       	pop	r16
 37a:	bf 90       	pop	r11
 37c:	af 90       	pop	r10
 37e:	9f 90       	pop	r9
 380:	8f 90       	pop	r8
 382:	08 95       	ret

00000384 <__cxa_pure_virtual>:
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
  // We might want to write some diagnostics to uart in this case
  //std::terminate();
  abort();
 384:	0e 94 9d 03 	call	0x73a	; 0x73a <abort>

00000388 <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 388:	1f 92       	push	r1
 38a:	0f 92       	push	r0
 38c:	0f b6       	in	r0, 0x3f	; 63
 38e:	0f 92       	push	r0
 390:	11 24       	eor	r1, r1
 392:	2f 93       	push	r18
 394:	3f 93       	push	r19
 396:	8f 93       	push	r24
 398:	9f 93       	push	r25
 39a:	af 93       	push	r26
 39c:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 39e:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <timer0_millis>
 3a2:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <timer0_millis+0x1>
 3a6:	a0 91 3b 01 	lds	r26, 0x013B	; 0x80013b <timer0_millis+0x2>
 3aa:	b0 91 3c 01 	lds	r27, 0x013C	; 0x80013c <timer0_millis+0x3>
	unsigned char f = timer0_fract;
 3ae:	30 91 38 01 	lds	r19, 0x0138	; 0x800138 <timer0_fract>

	m += MILLIS_INC;
	f += FRACT_INC;
 3b2:	23 e0       	ldi	r18, 0x03	; 3
 3b4:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 3b6:	2d 37       	cpi	r18, 0x7D	; 125
 3b8:	20 f4       	brcc	.+8      	; 0x3c2 <__vector_16+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 3ba:	01 96       	adiw	r24, 0x01	; 1
 3bc:	a1 1d       	adc	r26, r1
 3be:	b1 1d       	adc	r27, r1
 3c0:	05 c0       	rjmp	.+10     	; 0x3cc <__vector_16+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 3c2:	26 e8       	ldi	r18, 0x86	; 134
 3c4:	23 0f       	add	r18, r19
		m += 1;
 3c6:	02 96       	adiw	r24, 0x02	; 2
 3c8:	a1 1d       	adc	r26, r1
 3ca:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
 3cc:	20 93 38 01 	sts	0x0138, r18	; 0x800138 <timer0_fract>
	timer0_millis = m;
 3d0:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <timer0_millis>
 3d4:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <timer0_millis+0x1>
 3d8:	a0 93 3b 01 	sts	0x013B, r26	; 0x80013b <timer0_millis+0x2>
 3dc:	b0 93 3c 01 	sts	0x013C, r27	; 0x80013c <timer0_millis+0x3>
	timer0_overflow_count++;
 3e0:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <timer0_overflow_count>
 3e4:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <timer0_overflow_count+0x1>
 3e8:	a0 91 36 01 	lds	r26, 0x0136	; 0x800136 <timer0_overflow_count+0x2>
 3ec:	b0 91 37 01 	lds	r27, 0x0137	; 0x800137 <timer0_overflow_count+0x3>
 3f0:	01 96       	adiw	r24, 0x01	; 1
 3f2:	a1 1d       	adc	r26, r1
 3f4:	b1 1d       	adc	r27, r1
 3f6:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <timer0_overflow_count>
 3fa:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <timer0_overflow_count+0x1>
 3fe:	a0 93 36 01 	sts	0x0136, r26	; 0x800136 <timer0_overflow_count+0x2>
 402:	b0 93 37 01 	sts	0x0137, r27	; 0x800137 <timer0_overflow_count+0x3>
}
 406:	bf 91       	pop	r27
 408:	af 91       	pop	r26
 40a:	9f 91       	pop	r25
 40c:	8f 91       	pop	r24
 40e:	3f 91       	pop	r19
 410:	2f 91       	pop	r18
 412:	0f 90       	pop	r0
 414:	0f be       	out	0x3f, r0	; 63
 416:	0f 90       	pop	r0
 418:	1f 90       	pop	r1
 41a:	18 95       	reti

0000041c <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 41c:	1f 92       	push	r1
 41e:	0f 92       	push	r0
 420:	0f b6       	in	r0, 0x3f	; 63
 422:	0f 92       	push	r0
 424:	11 24       	eor	r1, r1
 426:	2f 93       	push	r18
 428:	3f 93       	push	r19
 42a:	4f 93       	push	r20
 42c:	5f 93       	push	r21
 42e:	6f 93       	push	r22
 430:	7f 93       	push	r23
 432:	8f 93       	push	r24
 434:	9f 93       	push	r25
 436:	af 93       	push	r26
 438:	bf 93       	push	r27
 43a:	ef 93       	push	r30
 43c:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
 43e:	8d e3       	ldi	r24, 0x3D	; 61
 440:	91 e0       	ldi	r25, 0x01	; 1
 442:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
 446:	ff 91       	pop	r31
 448:	ef 91       	pop	r30
 44a:	bf 91       	pop	r27
 44c:	af 91       	pop	r26
 44e:	9f 91       	pop	r25
 450:	8f 91       	pop	r24
 452:	7f 91       	pop	r23
 454:	6f 91       	pop	r22
 456:	5f 91       	pop	r21
 458:	4f 91       	pop	r20
 45a:	3f 91       	pop	r19
 45c:	2f 91       	pop	r18
 45e:	0f 90       	pop	r0
 460:	0f be       	out	0x3f, r0	; 63
 462:	0f 90       	pop	r0
 464:	1f 90       	pop	r1
 466:	18 95       	reti

00000468 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 468:	1f 92       	push	r1
 46a:	0f 92       	push	r0
 46c:	0f b6       	in	r0, 0x3f	; 63
 46e:	0f 92       	push	r0
 470:	11 24       	eor	r1, r1
 472:	2f 93       	push	r18
 474:	8f 93       	push	r24
 476:	9f 93       	push	r25
 478:	ef 93       	push	r30
 47a:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 47c:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <Serial+0x10>
 480:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <Serial+0x11>
 484:	80 81       	ld	r24, Z
 486:	e0 91 53 01 	lds	r30, 0x0153	; 0x800153 <Serial+0x16>
 48a:	f0 91 54 01 	lds	r31, 0x0154	; 0x800154 <Serial+0x17>
 48e:	82 fd       	sbrc	r24, 2
 490:	12 c0       	rjmp	.+36     	; 0x4b6 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 492:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 494:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <Serial+0x19>
 498:	8f 5f       	subi	r24, 0xFF	; 255
 49a:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 49c:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <Serial+0x1a>
 4a0:	82 17       	cp	r24, r18
 4a2:	51 f0       	breq	.+20     	; 0x4b8 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
 4a4:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <Serial+0x19>
 4a8:	f0 e0       	ldi	r31, 0x00	; 0
 4aa:	e3 5c       	subi	r30, 0xC3	; 195
 4ac:	fe 4f       	sbci	r31, 0xFE	; 254
 4ae:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
 4b0:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <Serial+0x19>
 4b4:	01 c0       	rjmp	.+2      	; 0x4b8 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 4b6:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
 4b8:	ff 91       	pop	r31
 4ba:	ef 91       	pop	r30
 4bc:	9f 91       	pop	r25
 4be:	8f 91       	pop	r24
 4c0:	2f 91       	pop	r18
 4c2:	0f 90       	pop	r0
 4c4:	0f be       	out	0x3f, r0	; 63
 4c6:	0f 90       	pop	r0
 4c8:	1f 90       	pop	r1
 4ca:	18 95       	reti

000004cc <main>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 4cc:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 4ce:	84 b5       	in	r24, 0x24	; 36
 4d0:	82 60       	ori	r24, 0x02	; 2
 4d2:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 4d4:	84 b5       	in	r24, 0x24	; 36
 4d6:	81 60       	ori	r24, 0x01	; 1
 4d8:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 4da:	85 b5       	in	r24, 0x25	; 37
 4dc:	82 60       	ori	r24, 0x02	; 2
 4de:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 4e0:	85 b5       	in	r24, 0x25	; 37
 4e2:	81 60       	ori	r24, 0x01	; 1
 4e4:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 4e6:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
 4ea:	81 60       	ori	r24, 0x01	; 1
 4ec:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 4f0:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4f4:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 4f8:	82 60       	ori	r24, 0x02	; 2
 4fa:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 4fe:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 502:	81 60       	ori	r24, 0x01	; 1
 504:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 508:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 50c:	81 60       	ori	r24, 0x01	; 1
 50e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 512:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 516:	84 60       	ori	r24, 0x04	; 4
 518:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 51c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 520:	81 60       	ori	r24, 0x01	; 1
 522:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 526:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 52a:	84 60       	ori	r24, 0x04	; 4
 52c:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS1);
 530:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 534:	82 60       	ori	r24, 0x02	; 2
 536:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS0);
 53a:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 53e:	81 60       	ori	r24, 0x01	; 1
 540:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 544:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 548:	80 68       	ori	r24, 0x80	; 128
 54a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 54e:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 552:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <Serial+0x10>
 556:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <Serial+0x11>
 55a:	82 e0       	ldi	r24, 0x02	; 2
 55c:	80 83       	st	Z, r24
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
 55e:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <Serial+0x10>
 562:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <Serial+0x11>
 566:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 568:	e0 91 49 01 	lds	r30, 0x0149	; 0x800149 <Serial+0xc>
 56c:	f0 91 4a 01 	lds	r31, 0x014A	; 0x80014a <Serial+0xd>
 570:	10 82       	st	Z, r1
  *_ubrrl = baud_setting;
 572:	e0 91 4b 01 	lds	r30, 0x014B	; 0x80014b <Serial+0xe>
 576:	f0 91 4c 01 	lds	r31, 0x014C	; 0x80014c <Serial+0xf>
 57a:	80 e1       	ldi	r24, 0x10	; 16
 57c:	80 83       	st	Z, r24

  _written = false;
 57e:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <Serial+0x18>

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 582:	e0 91 51 01 	lds	r30, 0x0151	; 0x800151 <Serial+0x14>
 586:	f0 91 52 01 	lds	r31, 0x0152	; 0x800152 <Serial+0x15>
 58a:	86 e0       	ldi	r24, 0x06	; 6
 58c:	80 83       	st	Z, r24
  
  sbi(*_ucsrb, RXEN0);
 58e:	e0 91 4f 01 	lds	r30, 0x014F	; 0x80014f <Serial+0x12>
 592:	f0 91 50 01 	lds	r31, 0x0150	; 0x800150 <Serial+0x13>
 596:	80 81       	ld	r24, Z
 598:	80 61       	ori	r24, 0x10	; 16
 59a:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
 59c:	e0 91 4f 01 	lds	r30, 0x014F	; 0x80014f <Serial+0x12>
 5a0:	f0 91 50 01 	lds	r31, 0x0150	; 0x800150 <Serial+0x13>
 5a4:	80 81       	ld	r24, Z
 5a6:	88 60       	ori	r24, 0x08	; 8
 5a8:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
 5aa:	e0 91 4f 01 	lds	r30, 0x014F	; 0x80014f <Serial+0x12>
 5ae:	f0 91 50 01 	lds	r31, 0x0150	; 0x800150 <Serial+0x13>
 5b2:	80 81       	ld	r24, Z
 5b4:	80 68       	ori	r24, 0x80	; 128
 5b6:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
 5b8:	e0 91 4f 01 	lds	r30, 0x014F	; 0x80014f <Serial+0x12>
 5bc:	f0 91 50 01 	lds	r31, 0x0150	; 0x800150 <Serial+0x13>
 5c0:	80 81       	ld	r24, Z
 5c2:	8f 7d       	andi	r24, 0xDF	; 223
 5c4:	80 83       	st	Z, r24
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 5c6:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 5c8:	f8 94       	cli
	m = timer0_millis;
 5ca:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <timer0_millis>
 5ce:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <timer0_millis+0x1>
 5d2:	a0 91 3b 01 	lds	r26, 0x013B	; 0x80013b <timer0_millis+0x2>
 5d6:	b0 91 3c 01 	lds	r27, 0x013C	; 0x80013c <timer0_millis+0x3>
	SREG = oldSREG;
 5da:	2f bf       	out	0x3f, r18	; 63

void setup()
{
  Serial.begin(57600);         // 9600 bps
    
  _startTime_ms = millis();
 5dc:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__data_end>
 5e0:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <__data_end+0x1>
 5e4:	a0 93 32 01 	sts	0x0132, r26	; 0x800132 <__data_end+0x2>
 5e8:	b0 93 33 01 	sts	0x0133, r27	; 0x800133 <__data_end+0x3>
}

void loop() 
{
  if (0 == _loopCounter--) {
 5ec:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 5f0:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 5f4:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <__data_start+0x2>
 5f8:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <__data_start+0x3>
 5fc:	ac 01       	movw	r20, r24
 5fe:	bd 01       	movw	r22, r26
 600:	41 50       	subi	r20, 0x01	; 1
 602:	51 09       	sbc	r21, r1
 604:	61 09       	sbc	r22, r1
 606:	71 09       	sbc	r23, r1
 608:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
 60c:	50 93 01 01 	sts	0x0101, r21	; 0x800101 <__data_start+0x1>
 610:	60 93 02 01 	sts	0x0102, r22	; 0x800102 <__data_start+0x2>
 614:	70 93 03 01 	sts	0x0103, r23	; 0x800103 <__data_start+0x3>
 618:	89 2b       	or	r24, r25
 61a:	8a 2b       	or	r24, r26
 61c:	8b 2b       	or	r24, r27
 61e:	a9 f5       	brne	.+106    	; 0x68a <main+0x1be>
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 620:	8f b7       	in	r24, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 622:	f8 94       	cli
	m = timer0_millis;
 624:	c0 90 39 01 	lds	r12, 0x0139	; 0x800139 <timer0_millis>
 628:	d0 90 3a 01 	lds	r13, 0x013A	; 0x80013a <timer0_millis+0x1>
 62c:	e0 90 3b 01 	lds	r14, 0x013B	; 0x80013b <timer0_millis+0x2>
 630:	f0 90 3c 01 	lds	r15, 0x013C	; 0x80013c <timer0_millis+0x3>
	SREG = oldSREG;
 634:	8f bf       	out	0x3f, r24	; 63
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 636:	86 e1       	ldi	r24, 0x16	; 22
 638:	91 e0       	ldi	r25, 0x01	; 1
 63a:	0e 94 6f 01 	call	0x2de	; 0x2de <_ZN5Print5writeEPKc.constprop.14>
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 63e:	4a e0       	ldi	r20, 0x0A	; 10
 640:	60 ec       	ldi	r22, 0xC0	; 192
 642:	76 ec       	ldi	r23, 0xC6	; 198
 644:	8d e2       	ldi	r24, 0x2D	; 45
 646:	90 e0       	ldi	r25, 0x00	; 0
 648:	0e 94 81 01 	call	0x302	; 0x302 <_ZN5Print11printNumberEmh.constprop.12>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 64c:	8e e1       	ldi	r24, 0x1E	; 30
 64e:	91 e0       	ldi	r25, 0x01	; 1
 650:	0e 94 6f 01 	call	0x2de	; 0x2de <_ZN5Print5writeEPKc.constprop.14>
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 654:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__data_end>
 658:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <__data_end+0x1>
 65c:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <__data_end+0x2>
 660:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <__data_end+0x3>
 664:	a7 01       	movw	r20, r14
 666:	96 01       	movw	r18, r12
 668:	28 1b       	sub	r18, r24
 66a:	39 0b       	sbc	r19, r25
 66c:	4a 0b       	sbc	r20, r26
 66e:	5b 0b       	sbc	r21, r27
 670:	ca 01       	movw	r24, r20
 672:	b9 01       	movw	r22, r18
 674:	4a e0       	ldi	r20, 0x0A	; 10
 676:	0e 94 81 01 	call	0x302	; 0x302 <_ZN5Print11printNumberEmh.constprop.12>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 67a:	87 e2       	ldi	r24, 0x27	; 39
 67c:	91 e0       	ldi	r25, 0x01	; 1
 67e:	0e 94 6f 01 	call	0x2de	; 0x2de <_ZN5Print5writeEPKc.constprop.14>
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
 682:	8d e2       	ldi	r24, 0x2D	; 45
 684:	91 e0       	ldi	r25, 0x01	; 1
 686:	0e 94 6f 01 	call	0x2de	; 0x2de <_ZN5Print5writeEPKc.constprop.14>
	
	setup();
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 68a:	0e 94 65 01 	call	0x2ca	; 0x2ca <_Z14serialEventRunv>
 68e:	ae cf       	rjmp	.-164    	; 0x5ec <main+0x120>

00000690 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 690:	ed e3       	ldi	r30, 0x3D	; 61
 692:	f1 e0       	ldi	r31, 0x01	; 1
 694:	13 82       	std	Z+3, r1	; 0x03
 696:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
 698:	88 ee       	ldi	r24, 0xE8	; 232
 69a:	93 e0       	ldi	r25, 0x03	; 3
 69c:	a0 e0       	ldi	r26, 0x00	; 0
 69e:	b0 e0       	ldi	r27, 0x00	; 0
 6a0:	84 83       	std	Z+4, r24	; 0x04
 6a2:	95 83       	std	Z+5, r25	; 0x05
 6a4:	a6 83       	std	Z+6, r26	; 0x06
 6a6:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 6a8:	88 e0       	ldi	r24, 0x08	; 8
 6aa:	91 e0       	ldi	r25, 0x01	; 1
 6ac:	91 83       	std	Z+1, r25	; 0x01
 6ae:	80 83       	st	Z, r24
 6b0:	85 ec       	ldi	r24, 0xC5	; 197
 6b2:	90 e0       	ldi	r25, 0x00	; 0
 6b4:	95 87       	std	Z+13, r25	; 0x0d
 6b6:	84 87       	std	Z+12, r24	; 0x0c
 6b8:	84 ec       	ldi	r24, 0xC4	; 196
 6ba:	90 e0       	ldi	r25, 0x00	; 0
 6bc:	97 87       	std	Z+15, r25	; 0x0f
 6be:	86 87       	std	Z+14, r24	; 0x0e
 6c0:	80 ec       	ldi	r24, 0xC0	; 192
 6c2:	90 e0       	ldi	r25, 0x00	; 0
 6c4:	91 8b       	std	Z+17, r25	; 0x11
 6c6:	80 8b       	std	Z+16, r24	; 0x10
 6c8:	81 ec       	ldi	r24, 0xC1	; 193
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	93 8b       	std	Z+19, r25	; 0x13
 6ce:	82 8b       	std	Z+18, r24	; 0x12
 6d0:	82 ec       	ldi	r24, 0xC2	; 194
 6d2:	90 e0       	ldi	r25, 0x00	; 0
 6d4:	95 8b       	std	Z+21, r25	; 0x15
 6d6:	84 8b       	std	Z+20, r24	; 0x14
 6d8:	86 ec       	ldi	r24, 0xC6	; 198
 6da:	90 e0       	ldi	r25, 0x00	; 0
 6dc:	97 8b       	std	Z+23, r25	; 0x17
 6de:	86 8b       	std	Z+22, r24	; 0x16
 6e0:	11 8e       	std	Z+25, r1	; 0x19
 6e2:	12 8e       	std	Z+26, r1	; 0x1a
 6e4:	13 8e       	std	Z+27, r1	; 0x1b
 6e6:	14 8e       	std	Z+28, r1	; 0x1c
 6e8:	08 95       	ret

000006ea <__udivmodsi4>:
 6ea:	a1 e2       	ldi	r26, 0x21	; 33
 6ec:	1a 2e       	mov	r1, r26
 6ee:	aa 1b       	sub	r26, r26
 6f0:	bb 1b       	sub	r27, r27
 6f2:	fd 01       	movw	r30, r26
 6f4:	0d c0       	rjmp	.+26     	; 0x710 <__udivmodsi4_ep>

000006f6 <__udivmodsi4_loop>:
 6f6:	aa 1f       	adc	r26, r26
 6f8:	bb 1f       	adc	r27, r27
 6fa:	ee 1f       	adc	r30, r30
 6fc:	ff 1f       	adc	r31, r31
 6fe:	a2 17       	cp	r26, r18
 700:	b3 07       	cpc	r27, r19
 702:	e4 07       	cpc	r30, r20
 704:	f5 07       	cpc	r31, r21
 706:	20 f0       	brcs	.+8      	; 0x710 <__udivmodsi4_ep>
 708:	a2 1b       	sub	r26, r18
 70a:	b3 0b       	sbc	r27, r19
 70c:	e4 0b       	sbc	r30, r20
 70e:	f5 0b       	sbc	r31, r21

00000710 <__udivmodsi4_ep>:
 710:	66 1f       	adc	r22, r22
 712:	77 1f       	adc	r23, r23
 714:	88 1f       	adc	r24, r24
 716:	99 1f       	adc	r25, r25
 718:	1a 94       	dec	r1
 71a:	69 f7       	brne	.-38     	; 0x6f6 <__udivmodsi4_loop>
 71c:	60 95       	com	r22
 71e:	70 95       	com	r23
 720:	80 95       	com	r24
 722:	90 95       	com	r25
 724:	9b 01       	movw	r18, r22
 726:	ac 01       	movw	r20, r24
 728:	bd 01       	movw	r22, r26
 72a:	cf 01       	movw	r24, r30
 72c:	08 95       	ret

0000072e <__tablejump2__>:
 72e:	ee 0f       	add	r30, r30
 730:	ff 1f       	adc	r31, r31
 732:	05 90       	lpm	r0, Z+
 734:	f4 91       	lpm	r31, Z
 736:	e0 2d       	mov	r30, r0
 738:	09 94       	ijmp

0000073a <abort>:
 73a:	81 e0       	ldi	r24, 0x01	; 1
 73c:	90 e0       	ldi	r25, 0x00	; 0
 73e:	f8 94       	cli
 740:	0c 94 a2 03 	jmp	0x744	; 0x744 <_exit>

00000744 <_exit>:
 744:	f8 94       	cli

00000746 <__stop_program>:
 746:	ff cf       	rjmp	.-2      	; 0x746 <__stop_program>

Disassembly of section .bss:

00800130 <__bss_start>:
  800130:	00 00       	nop
	...

00800134 <timer0_overflow_count>:
  800134:	00 00       	nop
	...

00800138 <timer0_fract>:
	...

00800139 <timer0_millis>:
  800139:	00 00       	nop
	...

0080013d <Serial>:
	...

Disassembly of section .comment:

00000000 <_end-0x8001da>:
   0:	47 43       	sbci	r20, 0x37	; 55
   2:	43 3a       	cpi	r20, 0xA3	; 163
   4:	20 28       	or	r2, r0
   6:	47 4e       	sbci	r20, 0xE7	; 231
   8:	55 29       	or	r21, r5
   a:	20 35       	cpi	r18, 0x50	; 80
   c:	2e 34       	cpi	r18, 0x4E	; 78
   e:	2e 30       	cpi	r18, 0x0E	; 14
	...

Disassembly of section .note.gnu.avr.deviceinfo:

00000000 <.note.gnu.avr.deviceinfo>:
   0:	04 00       	.word	0x0004	; ????
   2:	00 00       	nop
   4:	2d 00       	.word	0x002d	; ????
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	00 00       	nop
   c:	41 56       	subi	r20, 0x61	; 97
   e:	52 00       	.word	0x0052	; ????
  10:	00 00       	nop
  12:	00 00       	nop
  14:	00 80       	ld	r0, Z
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	00 00       	nop
  1c:	00 08       	sbc	r0, r0
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 04       	cpc	r0, r0
  26:	00 00       	nop
  28:	08 00       	.word	0x0008	; ????
  2a:	00 00       	nop
  2c:	01 00       	.word	0x0001	; ????
  2e:	00 00       	nop
  30:	00 61       	ori	r16, 0x10	; 16
  32:	74 6d       	ori	r23, 0xD4	; 212
  34:	65 67       	ori	r22, 0x75	; 117
  36:	61 33       	cpi	r22, 0x31	; 49
  38:	32 38       	cpi	r19, 0x82	; 130
  3a:	70 00       	.word	0x0070	; ????
  3c:	00 00       	nop
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	2c 00       	.word	0x002c	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	f4 05       	cpc	r31, r4
   8:	00 00       	nop
   a:	04 00       	.word	0x0004	; ????
   c:	00 00       	nop
   e:	00 00       	nop
  10:	be 00       	.word	0x00be	; ????
  12:	00 00       	nop
  14:	0e 04       	cpc	r0, r14
  16:	00 00       	nop
  18:	cc 04       	cpc	r12, r12
  1a:	00 00       	nop
  1c:	c4 01       	movw	r24, r8
  1e:	00 00       	nop
  20:	90 06       	cpc	r9, r16
  22:	00 00       	nop
  24:	5a 00       	.word	0x005a	; ????
	...
  2e:	00 00       	nop
  30:	1c 00       	.word	0x001c	; ????
  32:	00 00       	nop
  34:	02 00       	.word	0x0002	; ????
  36:	a2 18       	sub	r10, r2
  38:	00 00       	nop
  3a:	04 00       	.word	0x0004	; ????
  3c:	00 00       	nop
  3e:	00 00       	nop
  40:	44 07       	cpc	r20, r20
  42:	00 00       	nop
  44:	04 00       	.word	0x0004	; ????
	...
  4e:	00 00       	nop
  50:	1c 00       	.word	0x001c	; ????
  52:	00 00       	nop
  54:	02 00       	.word	0x0002	; ????
  56:	50 19       	sub	r21, r0
  58:	00 00       	nop
  5a:	04 00       	.word	0x0004	; ????
  5c:	00 00       	nop
  5e:	00 00       	nop
  60:	ea 06       	cpc	r14, r26
  62:	00 00       	nop
  64:	44 00       	.word	0x0044	; ????
	...
  6e:	00 00       	nop
  70:	1c 00       	.word	0x001c	; ????
  72:	00 00       	nop
  74:	02 00       	.word	0x0002	; ????
  76:	fe 19       	sub	r31, r14
  78:	00 00       	nop
  7a:	04 00       	.word	0x0004	; ????
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	76 00       	.word	0x0076	; ????
  82:	00 00       	nop
  84:	16 00       	.word	0x0016	; ????
	...
  8e:	00 00       	nop
  90:	1c 00       	.word	0x001c	; ????
  92:	00 00       	nop
  94:	02 00       	.word	0x0002	; ????
  96:	ac 1a       	sub	r10, r28
  98:	00 00       	nop
  9a:	04 00       	.word	0x0004	; ????
  9c:	00 00       	nop
  9e:	00 00       	nop
  a0:	8c 00       	.word	0x008c	; ????
  a2:	00 00       	nop
  a4:	10 00       	.word	0x0010	; ????
	...
  ae:	00 00       	nop
  b0:	1c 00       	.word	0x001c	; ????
  b2:	00 00       	nop
  b4:	02 00       	.word	0x0002	; ????
  b6:	5a 1b       	sub	r21, r26
  b8:	00 00       	nop
  ba:	04 00       	.word	0x0004	; ????
  bc:	00 00       	nop

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	00 00       	nop
  c0:	9c 00       	.word	0x009c	; ????
  c2:	00 00       	nop
  c4:	16 00       	.word	0x0016	; ????
	...
  ce:	00 00       	nop
  d0:	1c 00       	.word	0x001c	; ????
  d2:	00 00       	nop
  size_t n = 0;
  d4:	02 00       	.word	0x0002	; ????
  d6:	08 1c       	adc	r0, r8
  while (size--) {
  d8:	00 00       	nop
  da:	04 00       	.word	0x0004	; ????
  dc:	00 00       	nop
    if (write(*buffer++)) n++;
  de:	00 00       	nop
  e0:	2e 07       	cpc	r18, r30
  e2:	00 00       	nop
  e4:	0c 00       	.word	0x000c	; ????
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	f0 05       	cpc	r31, r0
       2:	00 00       	nop
       4:	02 00       	.word	0x0002	; ????
       6:	00 00       	nop
       8:	00 00       	nop
       a:	04 01       	movw	r0, r8
	...
      14:	02 0f       	add	r16, r18
      16:	00 00       	nop
      18:	00 01       	movw	r0, r0
      1a:	08 03       	fmul	r16, r16
      1c:	17 00       	.word	0x0017	; ????
      1e:	00 00       	nop
      20:	02 07       	cpc	r16, r18
      22:	04 14       	cp	r0, r4
      24:	00 00       	nop
      26:	00 05       	cpc	r16, r0
      28:	1b 00       	.word	0x001b	; ????
      2a:	00 00       	nop
      2c:	ff 03       	fmulsu	r23, r23
      2e:	00 06       	cpc	r0, r16
      30:	20 00       	.word	0x0020	; ????
      32:	00 00       	nop
      34:	00 00       	nop
      36:	22 00       	.word	0x0022	; ????
      38:	00 00       	nop
      3a:	01 05       	cpc	r16, r1
      3c:	03 00       	.word	0x0003	; ????
      3e:	00 81       	ld	r16, Z
      40:	00 07       	cpc	r16, r16
      42:	29 00       	.word	0x0029	; ????
      44:	00 00       	nop
      46:	00 00       	nop
      48:	14 00       	.word	0x0014	; ????
      4a:	00 00       	nop
      4c:	01 05       	cpc	r16, r1
      4e:	03 c6       	rjmp	.+3078   	; 0xc56 <__stack+0x357>
      50:	00 80       	ld	r0, Z
      52:	00 08       	sbc	r0, r0
      54:	2e 00       	.word	0x002e	; ????
      56:	00 00       	nop
      58:	00 00       	nop
      5a:	14 00       	.word	0x0014	; ????
      5c:	00 00       	nop
      5e:	01 05       	cpc	r16, r1
      60:	03 c0       	rjmp	.+6      	; 0x68 <__ctors_start>
      62:	00 80       	ld	r0, Z
      64:	00 09       	sbc	r16, r0
      66:	35 00       	.word	0x0035	; ????
      68:	00 00       	nop
      6a:	00 00       	nop
      6c:	14 00       	.word	0x0014	; ????
      6e:	00 00       	nop
      70:	01 05       	cpc	r16, r1
      72:	03 c1       	rjmp	.+518    	; 0x27a <_ZN14HardwareSerial5writeEh+0x8e>
      74:	00 80       	ld	r0, Z
      76:	00 0a       	sbc	r0, r16
      78:	3c 00       	.word	0x003c	; ????
      7a:	00 00       	nop
      7c:	00 00       	nop
      7e:	14 00       	.word	0x0014	; ????
      80:	00 00       	nop
      82:	01 05       	cpc	r16, r1
      84:	03 c2       	rjmp	.+1030   	; 0x48c <__vector_18+0x24>
      86:	00 80       	ld	r0, Z
      88:	00 0b       	sbc	r16, r16
      8a:	43 00       	.word	0x0043	; ????
      8c:	00 00       	nop
      8e:	00 00       	nop
      90:	1b 00       	.word	0x001b	; ????
      92:	00 00       	nop
      94:	01 05       	cpc	r16, r1
      96:	03 c4       	rjmp	.+2054   	; 0x89e <__data_load_end+0x126>
      98:	00 80       	ld	r0, Z
      9a:	00 0c       	add	r0, r0
      9c:	49 00       	.word	0x0049	; ????
      9e:	00 00       	nop
      a0:	00 00       	nop
      a2:	14 00       	.word	0x0014	; ????
      a4:	00 00       	nop
      a6:	01 05       	cpc	r16, r1
      a8:	03 bd       	out	0x23, r16	; 35
      aa:	00 80       	ld	r0, Z
      ac:	00 0d       	add	r16, r0
      ae:	4f 00       	.word	0x004f	; ????
      b0:	00 00       	nop
      b2:	00 00       	nop
      b4:	14 00       	.word	0x0014	; ????
      b6:	00 00       	nop
      b8:	01 05       	cpc	r16, r1
      ba:	03 b8       	out	0x03, r0	; 3
      bc:	00 80       	ld	r0, Z

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
      be:	00 0e       	add	r0, r16
      c0:	54 00       	.word	0x0054	; ????
      c2:	00 00       	nop
      c4:	00 00       	nop
      c6:	14 00       	.word	0x0014	; ????
      c8:	00 00       	nop
      ca:	01 05       	cpc	r16, r1
      cc:	03 bc       	out	0x23, r0	; 35
      ce:	00 80       	ld	r0, Z
      d0:	00 0f       	add	r16, r16
      d2:	59 00       	.word	0x0059	; ????
  size_t n = 0;
      d4:	00 00       	nop
      d6:	00 00       	nop
  while (size--) {
      d8:	14 00       	.word	0x0014	; ????
      da:	00 00       	nop
      dc:	01 05       	cpc	r16, r1
    if (write(*buffer++)) n++;
      de:	03 b9       	out	0x03, r16	; 3
      e0:	00 80       	ld	r0, Z
      e2:	00 10       	cpse	r0, r0
      e4:	5e 00       	.word	0x005e	; ????
      e6:	00 00       	nop
      e8:	00 00       	nop
      ea:	14 00       	.word	0x0014	; ????
      ec:	00 00       	nop
      ee:	01 05       	cpc	r16, r1
      f0:	03 bb       	out	0x13, r16	; 19
      f2:	00 80       	ld	r0, Z
      f4:	00 11       	cpse	r16, r0
      f6:	63 00       	.word	0x0063	; ????
      f8:	00 00       	nop
      fa:	00 00       	nop
      fc:	14 00       	.word	0x0014	; ????
    else break;
  }
  return n;
}
      fe:	00 00       	nop
     100:	01 05       	cpc	r16, r1
     102:	03 ba       	out	0x13, r0	; 19
     104:	00 80       	ld	r0, Z
     106:	00 12       	cpse	r0, r16
     108:	68 00       	.word	0x0068	; ????
     10a:	00 00       	nop
     10c:	00 00       	nop
     10e:	14 00       	.word	0x0014	; ????
     110:	00 00       	nop
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     112:	01 05       	cpc	r16, r1
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     114:	03 6f       	ori	r16, 0xF3	; 243
     116:	00 80       	ld	r0, Z
     118:	00 13       	cpse	r16, r16
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     11a:	6f 00       	.word	0x006f	; ????
     11c:	00 00       	nop
    tail = _tx_buffer_tail;
     11e:	00 00       	nop
     120:	14 00       	.word	0x0014	; ????
     122:	00 00       	nop
     124:	01 05       	cpc	r16, r1
     126:	03 36       	cpi	r16, 0x63	; 99
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     128:	00 80       	ld	r0, Z
     12a:	00 14       	cp	r0, r0
     12c:	75 00       	.word	0x0075	; ????
     12e:	00 00       	nop
     130:	00 00       	nop
     132:	14 00       	.word	0x0014	; ????
  return tail - head - 1;
     134:	00 00       	nop
}
     136:	01 05       	cpc	r16, r1
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     138:	03 80       	ldd	r0, Z+3	; 0x03
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     13a:	00 80       	ld	r0, Z
     13c:	00 15       	cp	r16, r0
     13e:	7c 00       	.word	0x007c	; ????
     140:	00 00       	nop
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     142:	00 00       	nop
     144:	14 00       	.word	0x0014	; ????
     146:	00 00       	nop
     148:	01 05       	cpc	r16, r1
     14a:	03 81       	ldd	r16, Z+3	; 0x03
     14c:	00 80       	ld	r0, Z
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     14e:	00 16       	cp	r0, r16
     150:	83 00       	.word	0x0083	; ????
     152:	00 00       	nop
     154:	00 00       	nop
    return c;
     156:	14 00       	.word	0x0014	; ????
     158:	00 00       	nop

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     15a:	01 05       	cpc	r16, r1
     15c:	03 82       	std	Z+3, r0	; 0x03
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     15e:	00 80       	ld	r0, Z
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     160:	00 17       	cp	r16, r16
  if (_rx_buffer_head == _rx_buffer_tail) {
     162:	8a 00       	.word	0x008a	; ????
     164:	00 00       	nop
     166:	00 00       	nop
     168:	1b 00       	.word	0x001b	; ????
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     16a:	00 00       	nop
     16c:	01 05       	cpc	r16, r1
     16e:	03 84       	ldd	r0, Z+11	; 0x0b
     170:	00 80       	ld	r0, Z
     172:	00 18       	sub	r0, r0
     174:	90 00       	.word	0x0090	; ????
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     176:	00 00       	nop
     178:	00 00       	nop
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     17a:	1b 00       	.word	0x001b	; ????
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     17c:	00 00       	nop
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     17e:	01 05       	cpc	r16, r1
     180:	03 88       	ldd	r0, Z+19	; 0x13
     182:	00 80       	ld	r0, Z
     184:	00 19       	sub	r16, r0
     186:	96 00       	.word	0x0096	; ????
     188:	00 00       	nop
     18a:	00 00       	nop
     18c:	1b 00       	.word	0x001b	; ????
}
     18e:	00 00       	nop
     190:	01 05       	cpc	r16, r1
     192:	03 8a       	std	Z+19, r0	; 0x13
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     194:	00 80       	ld	r0, Z
     196:	00 1a       	sub	r0, r16
     198:	9c 00       	.word	0x009c	; ????
     19a:	00 00       	nop
     19c:	00 00       	nop
     19e:	1b 00       	.word	0x001b	; ????
     1a0:	00 00       	nop
     1a2:	01 05       	cpc	r16, r1
}
     1a4:	03 86       	std	Z+11, r0	; 0x0b
     1a6:	00 80       	ld	r0, Z
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     1a8:	00 1b       	sub	r16, r16
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     1aa:	a1 00       	.word	0x00a1	; ????
     1ac:	00 00       	nop
     1ae:	00 00       	nop
     1b0:	14 00       	.word	0x0014	; ????
     1b2:	00 00       	nop
     1b4:	01 05       	cpc	r16, r1
     1b6:	03 43       	sbci	r16, 0x33	; 51
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     1b8:	00 80       	ld	r0, Z
     1ba:	00 1c       	adc	r0, r0
     1bc:	a7 00       	.word	0x00a7	; ????
     1be:	00 00       	nop
     1c0:	00 00       	nop
     1c2:	14 00       	.word	0x0014	; ????

  *_udr = c;
     1c4:	00 00       	nop
     1c6:	01 05       	cpc	r16, r1
     1c8:	03 70       	andi	r16, 0x03	; 3
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     1ca:	00 80       	ld	r0, Z
     1cc:	00 1d       	adc	r16, r0
     1ce:	ae 00       	.word	0x00ae	; ????
     1d0:	00 00       	nop
     1d2:	00 00       	nop
     1d4:	14 00       	.word	0x0014	; ????
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     1d6:	00 00       	nop
     1d8:	01 05       	cpc	r16, r1
     1da:	03 37       	cpi	r16, 0x73	; 115
     1dc:	00 80       	ld	r0, Z
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     1de:	00 1e       	adc	r0, r16
     1e0:	b4 00       	.word	0x00b4	; ????
     1e2:	00 00       	nop
     1e4:	00 00       	nop
     1e6:	14 00       	.word	0x0014	; ????
     1e8:	00 00       	nop
     1ea:	01 05       	cpc	r16, r1
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     1ec:	03 b0       	in	r0, 0x03	; 3
     1ee:	00 80       	ld	r0, Z
     1f0:	00 1f       	adc	r16, r16
     1f2:	bb 00       	.word	0x00bb	; ????
     1f4:	00 00       	nop
     1f6:	00 00       	nop
     1f8:	14 00       	.word	0x0014	; ????
  _written = true;
     1fa:	00 00       	nop
     1fc:	01 05       	cpc	r16, r1
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     1fe:	03 b1       	in	r16, 0x03	; 3
     200:	00 80       	ld	r0, Z
     202:	00 20       	and	r0, r0
     204:	c2 00       	.word	0x00c2	; ????
     206:	00 00       	nop
     208:	00 00       	nop
     20a:	14 00       	.word	0x0014	; ????
     20c:	00 00       	nop
     20e:	01 05       	cpc	r16, r1
     210:	03 b2       	in	r0, 0x13	; 19
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     212:	00 80       	ld	r0, Z
     214:	00 21       	and	r16, r0
     216:	c8 00       	.word	0x00c8	; ????
     218:	00 00       	nop
     21a:	00 00       	nop
     21c:	14 00       	.word	0x0014	; ????
     21e:	00 00       	nop
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     220:	01 05       	cpc	r16, r1
     222:	03 b4       	in	r0, 0x23	; 35
     224:	00 80       	ld	r0, Z
    if (bit_is_clear(SREG, SREG_I)) {
     226:	00 22       	and	r0, r16
     228:	ce 00       	.word	0x00ce	; ????
     22a:	00 00       	nop
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     22c:	00 00       	nop
     22e:	14 00       	.word	0x0014	; ????
     230:	00 00       	nop
     232:	01 05       	cpc	r16, r1
     234:	03 b3       	in	r16, 0x13	; 19
	_tx_udr_empty_irq();
     236:	00 80       	ld	r0, Z
     238:	00 23       	and	r16, r16
     23a:	d4 00       	.word	0x00d4	; ????
     23c:	00 00       	nop
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     23e:	00 00       	nop
     240:	14 00       	.word	0x0014	; ????
     242:	00 00       	nop
     244:	01 05       	cpc	r16, r1
     246:	03 b6       	in	r0, 0x33	; 51
     248:	00 80       	ld	r0, Z
     24a:	00 24       	eor	r0, r0

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     24c:	d9 00       	.word	0x00d9	; ????
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     24e:	00 00       	nop
    _tx_buffer_head = i;
     250:	00 00       	nop
    sbi(*_ucsrb, UDRIE0);
     252:	14 00       	.word	0x0014	; ????
     254:	00 00       	nop
     256:	01 05       	cpc	r16, r1
     258:	03 43       	sbci	r16, 0x33	; 51
     25a:	00 80       	ld	r0, Z
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     25c:	00 25       	eor	r16, r0
     25e:	df 00       	.word	0x00df	; ????
      *_udr = c;
     260:	00 00       	nop
     262:	00 00       	nop
     264:	14 00       	.word	0x0014	; ????
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     266:	00 00       	nop
     268:	01 05       	cpc	r16, r1
     26a:	03 7c       	andi	r16, 0xC3	; 195
     26c:	00 80       	ld	r0, Z
     26e:	00 26       	eor	r0, r16
     270:	e5 00       	.word	0x00e5	; ????
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     272:	00 00       	nop
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
     274:	00 00       	nop
     276:	1b 00       	.word	0x001b	; ????
     278:	00 00       	nop
     27a:	01 05       	cpc	r16, r1
     27c:	03 78       	andi	r16, 0x83	; 131
     27e:	00 80       	ld	r0, Z
     280:	00 27       	eor	r16, r16
     282:	e9 00       	.word	0x00e9	; ????
     284:	00 00       	nop
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     286:	00 00       	nop
     288:	14 00       	.word	0x0014	; ????
     28a:	00 00       	nop
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     28c:	01 05       	cpc	r16, r1
     28e:	03 7a       	andi	r16, 0xA3	; 163
     290:	00 80       	ld	r0, Z
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     292:	00 28       	or	r0, r0
     294:	f0 00       	.word	0x00f0	; ????
     296:	00 00       	nop
     298:	00 00       	nop
     29a:	14 00       	.word	0x0014	; ????
     29c:	00 00       	nop
     29e:	01 05       	cpc	r16, r1
     2a0:	03 7b       	andi	r16, 0xB3	; 179
     2a2:	00 80       	ld	r0, Z
     2a4:	00 29       	or	r16, r0
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     2a6:	f7 00       	.word	0x00f7	; ????
     2a8:	00 00       	nop
     2aa:	00 00       	nop
     2ac:	14 00       	.word	0x0014	; ????
     2ae:	00 00       	nop
     2b0:	01 05       	cpc	r16, r1
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     2b2:	03 7e       	andi	r16, 0xE3	; 227
     2b4:	00 80       	ld	r0, Z
     2b6:	00 2a       	or	r0, r16
     2b8:	fd 00       	.word	0x00fd	; ????
     2ba:	00 00       	nop
	  _tx_udr_empty_irq();
     2bc:	00 00       	nop
     2be:	14 00       	.word	0x0014	; ????
     2c0:	00 00       	nop
     2c2:	01 05       	cpc	r16, r1
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     2c4:	03 50       	subi	r16, 0x03	; 3
     2c6:	00 80       	ld	r0, Z
     2c8:	00 2b       	or	r16, r16
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     2ca:	02 01       	movw	r0, r4
     2cc:	00 00       	nop
     2ce:	00 00       	nop
     2d0:	14 00       	.word	0x0014	; ????
     2d2:	00 00       	nop
     2d4:	01 05       	cpc	r16, r1
     2d6:	03 7f       	andi	r16, 0xF3	; 243
     2d8:	00 80       	ld	r0, Z
     2da:	00 2c       	mov	r0, r0
     2dc:	08 01       	movw	r0, r16
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     2de:	00 00       	nop
     2e0:	00 00       	nop
      return write((const uint8_t *)str, strlen(str));
     2e2:	14 00       	.word	0x0014	; ????
     2e4:	00 00       	nop
     2e6:	01 05       	cpc	r16, r1
     2e8:	03 25       	eor	r16, r3
     2ea:	00 80       	ld	r0, Z
     2ec:	00 2d       	mov	r16, r0
     2ee:	0e 01       	movw	r0, r28
     2f0:	00 00       	nop
     2f2:	00 00       	nop
     2f4:	14 00       	.word	0x0014	; ????
     2f6:	00 00       	nop
     2f8:	01 05       	cpc	r16, r1
     2fa:	03 24       	eor	r0, r3
    }
     2fc:	00 80       	ld	r0, Z
     2fe:	00 2e       	mov	r0, r16
     300:	13 01       	movw	r2, r6
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
     302:	00 00       	nop
     304:	00 00       	nop
     306:	14 00       	.word	0x0014	; ????
     308:	00 00       	nop
     30a:	01 05       	cpc	r16, r1
     30c:	03 23       	and	r16, r19
     30e:	00 80       	ld	r0, Z
     310:	00 2f       	mov	r16, r16
     312:	18 01       	movw	r2, r16
     314:	00 00       	nop
     316:	00 00       	nop
     318:	14 00       	.word	0x0014	; ????
     31a:	00 00       	nop
     31c:	01 05       	cpc	r16, r1
     31e:	03 28       	or	r0, r3
     320:	00 80       	ld	r0, Z
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     322:	00 30       	cpi	r16, 0x00	; 0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     324:	1e 01       	movw	r2, r28
     326:	00 00       	nop
     328:	00 00       	nop
     32a:	14 00       	.word	0x0014	; ????
     32c:	00 00       	nop
     32e:	01 05       	cpc	r16, r1

  do {
    char c = n % base;
     330:	03 27       	eor	r16, r19
     332:	00 80       	ld	r0, Z
     334:	00 31       	cpi	r16, 0x10	; 16
     336:	23 01       	movw	r4, r6
     338:	00 00       	nop
     33a:	00 00       	nop
     33c:	14 00       	.word	0x0014	; ????
     33e:	00 00       	nop
     340:	01 05       	cpc	r16, r1
    n /= base;
     342:	03 26       	eor	r0, r19
     344:	00 80       	ld	r0, Z

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     346:	00 32       	cpi	r16, 0x20	; 32
     348:	28 01       	movw	r4, r16
     34a:	00 00       	nop
     34c:	00 00       	nop
     34e:	14 00       	.word	0x0014	; ????
     350:	00 00       	nop
     352:	01 05       	cpc	r16, r1
     354:	03 2b       	or	r16, r19
     356:	00 80       	ld	r0, Z
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
     358:	00 33       	cpi	r16, 0x30	; 48
     35a:	2e 01       	movw	r4, r28
     35c:	00 00       	nop
     35e:	00 00       	nop
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
     360:	14 00       	.word	0x0014	; ????
     362:	00 00       	nop
     364:	01 05       	cpc	r16, r1
}
     366:	03 2a       	or	r0, r19
     368:	00 80       	ld	r0, Z
     36a:	00 34       	cpi	r16, 0x40	; 64
     36c:	33 01       	movw	r6, r6
     36e:	00 00       	nop
     370:	00 00       	nop
     372:	14 00       	.word	0x0014	; ????
     374:	00 00       	nop
     376:	01 05       	cpc	r16, r1
     378:	03 29       	or	r16, r3
     37a:	00 80       	ld	r0, Z
     37c:	00 35       	cpi	r16, 0x50	; 80
     37e:	38 01       	movw	r6, r16
     380:	00 00       	nop
     382:	00 00       	nop
     384:	14 00       	.word	0x0014	; ????
     386:	00 00       	nop
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     388:	01 05       	cpc	r16, r1
     38a:	03 48       	sbci	r16, 0x83	; 131
     38c:	00 80       	ld	r0, Z
     38e:	00 36       	cpi	r16, 0x60	; 96
     390:	3e 01       	movw	r6, r28
     392:	00 00       	nop
     394:	00 00       	nop
     396:	14 00       	.word	0x0014	; ????
     398:	00 00       	nop
     39a:	01 05       	cpc	r16, r1
     39c:	03 47       	sbci	r16, 0x73	; 115
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     39e:	00 80       	ld	r0, Z
     3a0:	00 37       	cpi	r16, 0x70	; 112
     3a2:	44 01       	movw	r8, r8
     3a4:	00 00       	nop
     3a6:	00 00       	nop
     3a8:	14 00       	.word	0x0014	; ????
     3aa:	00 00       	nop
     3ac:	01 05       	cpc	r16, r1
	unsigned char f = timer0_fract;
     3ae:	03 46       	sbci	r16, 0x63	; 99
     3b0:	00 80       	ld	r0, Z

	m += MILLIS_INC;
	f += FRACT_INC;
     3b2:	00 38       	cpi	r16, 0x80	; 128
     3b4:	4a 01       	movw	r8, r20
	if (f >= FRACT_MAX) {
     3b6:	00 00       	nop
     3b8:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     3ba:	14 00       	.word	0x0014	; ????
     3bc:	00 00       	nop
     3be:	01 05       	cpc	r16, r1
     3c0:	03 45       	sbci	r16, 0x53	; 83
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     3c2:	00 80       	ld	r0, Z
     3c4:	00 39       	cpi	r16, 0x90	; 144
		m += 1;
     3c6:	51 01       	movw	r10, r2
     3c8:	00 00       	nop
     3ca:	00 00       	nop
	}

	timer0_fract = f;
     3cc:	14 00       	.word	0x0014	; ????
     3ce:	00 00       	nop
	timer0_millis = m;
     3d0:	01 05       	cpc	r16, r1
     3d2:	03 44       	sbci	r16, 0x43	; 67
     3d4:	00 80       	ld	r0, Z
     3d6:	00 3a       	cpi	r16, 0xA0	; 160
     3d8:	58 01       	movw	r10, r16
     3da:	00 00       	nop
     3dc:	00 00       	nop
     3de:	14 00       	.word	0x0014	; ????
	timer0_overflow_count++;
     3e0:	00 00       	nop
     3e2:	01 05       	cpc	r16, r1
     3e4:	03 6e       	ori	r16, 0xE3	; 227
     3e6:	00 80       	ld	r0, Z
     3e8:	00 3b       	cpi	r16, 0xB0	; 176
     3ea:	5f 01       	movw	r10, r30
     3ec:	00 00       	nop
     3ee:	00 00       	nop
     3f0:	14 00       	.word	0x0014	; ????
     3f2:	00 00       	nop
     3f4:	01 05       	cpc	r16, r1
     3f6:	03 35       	cpi	r16, 0x53	; 83
     3f8:	00 80       	ld	r0, Z
     3fa:	00 3c       	cpi	r16, 0xC0	; 192
     3fc:	65 01       	movw	r12, r10
     3fe:	00 00       	nop
     400:	00 00       	nop
     402:	14 00       	.word	0x0014	; ????
     404:	00 00       	nop
}
     406:	01 05       	cpc	r16, r1
     408:	03 43       	sbci	r16, 0x33	; 51
     40a:	00 80       	ld	r0, Z
     40c:	00 3d       	cpi	r16, 0xD0	; 208
     40e:	6b 01       	movw	r12, r22
     410:	00 00       	nop
     412:	00 00       	nop
     414:	14 00       	.word	0x0014	; ????
     416:	00 00       	nop
     418:	01 05       	cpc	r16, r1
     41a:	03 69       	ori	r16, 0x93	; 147
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     41c:	00 80       	ld	r0, Z
     41e:	00 3e       	cpi	r16, 0xE0	; 224
     420:	71 01       	movw	r14, r2
     422:	00 00       	nop
     424:	00 00       	nop
     426:	14 00       	.word	0x0014	; ????
     428:	00 00       	nop
     42a:	01 05       	cpc	r16, r1
     42c:	03 3d       	cpi	r16, 0xD3	; 211
     42e:	00 80       	ld	r0, Z
     430:	00 3f       	cpi	r16, 0xF0	; 240
     432:	77 01       	movw	r14, r14
     434:	00 00       	nop
     436:	00 00       	nop
     438:	14 00       	.word	0x0014	; ????
     43a:	00 00       	nop
     43c:	01 05       	cpc	r16, r1
  Serial._tx_udr_empty_irq();
     43e:	03 3c       	cpi	r16, 0xC3	; 195
     440:	00 80       	ld	r0, Z
     442:	00 40       	sbci	r16, 0x00	; 0
     444:	7c 01       	movw	r14, r24
}
     446:	00 00       	nop
     448:	00 00       	nop
     44a:	14 00       	.word	0x0014	; ????
     44c:	00 00       	nop
     44e:	01 05       	cpc	r16, r1
     450:	03 68       	ori	r16, 0x83	; 131
     452:	00 80       	ld	r0, Z
     454:	00 41       	sbci	r16, 0x10	; 16
     456:	82 01       	movw	r16, r4
     458:	00 00       	nop
     45a:	00 00       	nop
     45c:	14 00       	.word	0x0014	; ????
     45e:	00 00       	nop
     460:	01 05       	cpc	r16, r1
     462:	03 6d       	ori	r16, 0xD3	; 211
     464:	00 80       	ld	r0, Z
     466:	00 42       	sbci	r16, 0x20	; 32
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     468:	89 01       	movw	r16, r18
     46a:	00 00       	nop
     46c:	00 00       	nop
     46e:	14 00       	.word	0x0014	; ????
     470:	00 00       	nop
     472:	01 05       	cpc	r16, r1
     474:	03 6c       	ori	r16, 0xC3	; 195
     476:	00 80       	ld	r0, Z
     478:	00 43       	sbci	r16, 0x30	; 48
     47a:	90 01       	movw	r18, r0

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     47c:	00 00       	nop
     47e:	00 00       	nop
     480:	14 00       	.word	0x0014	; ????
     482:	00 00       	nop
     484:	01 05       	cpc	r16, r1
     486:	03 6b       	ori	r16, 0xB3	; 179
     488:	00 80       	ld	r0, Z
     48a:	00 44       	sbci	r16, 0x40	; 64
     48c:	97 01       	movw	r18, r14
     48e:	00 00       	nop
     490:	00 00       	nop
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     492:	14 00       	.word	0x0014	; ????
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     494:	00 00       	nop
     496:	01 05       	cpc	r16, r1
     498:	03 3b       	cpi	r16, 0xB3	; 179
     49a:	00 80       	ld	r0, Z

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     49c:	00 45       	sbci	r16, 0x50	; 80
     49e:	9d 01       	movw	r18, r26
     4a0:	00 00       	nop
     4a2:	00 00       	nop
      _rx_buffer[_rx_buffer_head] = c;
     4a4:	14 00       	.word	0x0014	; ????
     4a6:	00 00       	nop
     4a8:	01 05       	cpc	r16, r1
     4aa:	03 4e       	sbci	r16, 0xE3	; 227
     4ac:	00 80       	ld	r0, Z
     4ae:	00 46       	sbci	r16, 0x60	; 96
      _rx_buffer_head = i;
     4b0:	a2 01       	movw	r20, r4
     4b2:	00 00       	nop
     4b4:	00 00       	nop
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     4b6:	14 00       	.word	0x0014	; ????
    Serial._rx_complete_irq();
  }
     4b8:	00 00       	nop
     4ba:	01 05       	cpc	r16, r1
     4bc:	03 4d       	sbci	r16, 0xD3	; 211
     4be:	00 80       	ld	r0, Z
     4c0:	00 47       	sbci	r16, 0x70	; 112
     4c2:	a7 01       	movw	r20, r14
     4c4:	00 00       	nop
     4c6:	00 00       	nop
     4c8:	14 00       	.word	0x0014	; ????
     4ca:	00 00       	nop

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     4cc:	01 05       	cpc	r16, r1
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     4ce:	03 4c       	sbci	r16, 0xC3	; 195
     4d0:	00 80       	ld	r0, Z
     4d2:	00 48       	sbci	r16, 0x80	; 128
	sbi(TCCR0A, WGM00);
     4d4:	ac 01       	movw	r20, r24
     4d6:	00 00       	nop
     4d8:	00 00       	nop
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     4da:	14 00       	.word	0x0014	; ????
     4dc:	00 00       	nop
     4de:	01 05       	cpc	r16, r1
	sbi(TCCR0B, CS00);
     4e0:	03 60       	ori	r16, 0x03	; 3
     4e2:	00 80       	ld	r0, Z
     4e4:	00 49       	sbci	r16, 0x90	; 144

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     4e6:	b3 01       	movw	r22, r6
     4e8:	00 00       	nop
     4ea:	00 00       	nop
     4ec:	14 00       	.word	0x0014	; ????
     4ee:	00 00       	nop
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     4f0:	01 05       	cpc	r16, r1
     4f2:	03 64       	ori	r16, 0x43	; 67

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     4f4:	00 80       	ld	r0, Z
     4f6:	00 4a       	sbci	r16, 0xA0	; 160
     4f8:	b7 01       	movw	r22, r14
     4fa:	00 00       	nop
     4fc:	00 00       	nop
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     4fe:	14 00       	.word	0x0014	; ????
     500:	00 00       	nop
     502:	01 05       	cpc	r16, r1
     504:	03 66       	ori	r16, 0x63	; 99
     506:	00 80       	ld	r0, Z
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     508:	00 4b       	sbci	r16, 0xB0	; 176
     50a:	be 01       	movw	r22, r28
     50c:	00 00       	nop
     50e:	00 00       	nop
     510:	14 00       	.word	0x0014	; ????

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     512:	00 00       	nop
     514:	01 05       	cpc	r16, r1
     516:	03 61       	ori	r16, 0x13	; 19
     518:	00 80       	ld	r0, Z
     51a:	00 4c       	sbci	r16, 0xC0	; 192

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     51c:	c4 01       	movw	r24, r8
     51e:	00 00       	nop
     520:	00 00       	nop
     522:	14 00       	.word	0x0014	; ????
     524:	00 00       	nop
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     526:	01 05       	cpc	r16, r1
     528:	03 5f       	subi	r16, 0xF3	; 243
     52a:	00 80       	ld	r0, Z
     52c:	00 4d       	sbci	r16, 0xD0	; 208
     52e:	c9 01       	movw	r24, r18
		sbi(ADCSRA, ADPS1);
     530:	00 00       	nop
     532:	00 00       	nop
     534:	1b 00       	.word	0x001b	; ????
     536:	00 00       	nop
     538:	01 05       	cpc	r16, r1
		sbi(ADCSRA, ADPS0);
     53a:	03 5d       	subi	r16, 0xD3	; 211
     53c:	00 80       	ld	r0, Z
     53e:	00 4e       	sbci	r16, 0xE0	; 224
     540:	cc 01       	movw	r24, r24
     542:	00 00       	nop
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     544:	00 00       	nop
     546:	14 00       	.word	0x0014	; ????
     548:	00 00       	nop
     54a:	01 05       	cpc	r16, r1
     54c:	03 57       	subi	r16, 0x73	; 115
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     54e:	00 80       	ld	r0, Z
     550:	00 4f       	sbci	r16, 0xF0	; 240

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     552:	d3 01       	movw	r26, r6
     554:	00 00       	nop
     556:	00 00       	nop
     558:	14 00       	.word	0x0014	; ????
     55a:	00 00       	nop
     55c:	01 05       	cpc	r16, r1
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
     55e:	03 55       	subi	r16, 0x53	; 83
     560:	00 80       	ld	r0, Z
     562:	00 50       	subi	r16, 0x00	; 0
     564:	d9 01       	movw	r26, r18
     566:	00 00       	nop
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     568:	00 00       	nop
     56a:	14 00       	.word	0x0014	; ????
     56c:	00 00       	nop
     56e:	01 05       	cpc	r16, r1
     570:	03 54       	subi	r16, 0x43	; 67
  *_ubrrl = baud_setting;
     572:	00 80       	ld	r0, Z
     574:	00 51       	subi	r16, 0x10	; 16
     576:	df 01       	movw	r26, r30
     578:	00 00       	nop
     57a:	00 00       	nop
     57c:	14 00       	.word	0x0014	; ????

  _written = false;
     57e:	00 00       	nop
     580:	01 05       	cpc	r16, r1

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     582:	03 53       	subi	r16, 0x33	; 51
     584:	00 80       	ld	r0, Z
     586:	00 52       	subi	r16, 0x20	; 32
     588:	e4 01       	movw	r28, r8
     58a:	00 00       	nop
     58c:	00 00       	nop
  
  sbi(*_ucsrb, RXEN0);
     58e:	14 00       	.word	0x0014	; ????
     590:	00 00       	nop
     592:	01 05       	cpc	r16, r1
     594:	03 4b       	sbci	r16, 0xB3	; 179
     596:	00 80       	ld	r0, Z
     598:	00 53       	subi	r16, 0x30	; 48
     59a:	eb 01       	movw	r28, r22
  sbi(*_ucsrb, TXEN0);
     59c:	00 00       	nop
     59e:	00 00       	nop
     5a0:	14 00       	.word	0x0014	; ????
     5a2:	00 00       	nop
     5a4:	01 05       	cpc	r16, r1
     5a6:	03 4a       	sbci	r16, 0xA3	; 163
     5a8:	00 80       	ld	r0, Z
  sbi(*_ucsrb, RXCIE0);
     5aa:	00 54       	subi	r16, 0x40	; 64
     5ac:	f2 01       	movw	r30, r4
     5ae:	00 00       	nop
     5b0:	00 00       	nop
     5b2:	14 00       	.word	0x0014	; ????
     5b4:	00 00       	nop
     5b6:	01 05       	cpc	r16, r1
  cbi(*_ucsrb, UDRIE0);
     5b8:	03 3e       	cpi	r16, 0xE3	; 227
     5ba:	00 80       	ld	r0, Z
     5bc:	00 55       	subi	r16, 0x50	; 80
     5be:	f9 01       	movw	r30, r18
     5c0:	00 00       	nop
     5c2:	00 00       	nop
     5c4:	1b 00       	.word	0x001b	; ????
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     5c6:	00 00       	nop

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     5c8:	01 05       	cpc	r16, r1
	m = timer0_millis;
     5ca:	03 41       	sbci	r16, 0x13	; 19
     5cc:	00 80       	ld	r0, Z
     5ce:	00 56       	subi	r16, 0x60	; 96
     5d0:	fe 01       	movw	r30, r28
     5d2:	00 00       	nop
     5d4:	00 00       	nop
     5d6:	14 00       	.word	0x0014	; ????
     5d8:	00 00       	nop
	SREG = oldSREG;
     5da:	01 05       	cpc	r16, r1

void setup()
{
  Serial.begin(57600);
    
  _startTime_ms = millis();
     5dc:	03 40       	sbci	r16, 0x03	; 3
     5de:	00 80       	ld	r0, Z
     5e0:	00 57       	subi	r16, 0x70	; 112
     5e2:	03 02       	muls	r16, r19
     5e4:	00 00       	nop
     5e6:	00 00       	nop
     5e8:	14 00       	.word	0x0014	; ????
     5ea:	00 00       	nop
}

void loop() 
{
  if (0 == _loopCounter--) {
     5ec:	01 05       	cpc	r16, r1
     5ee:	03 3f       	cpi	r16, 0xF3	; 243
     5f0:	00 80       	ld	r0, Z
     5f2:	00 00       	nop
     5f4:	aa 12       	cpse	r10, r26
     5f6:	00 00       	nop
     5f8:	02 00       	.word	0x0002	; ????
     5fa:	a2 05       	cpc	r26, r2
     5fc:	00 00       	nop
     5fe:	04 01       	movw	r0, r8
     600:	18 04       	cpc	r1, r8
     602:	00 00       	nop
     604:	02 8a       	std	Z+18, r0	; 0x12
     606:	03 00       	.word	0x0003	; ????
	...
     614:	00 1a       	sub	r0, r16
     616:	00 00       	nop
     618:	00 02       	muls	r16, r16
     61a:	02 23       	and	r16, r18
     61c:	06 00       	.word	0x0006	; ????
     61e:	00 2f       	mov	r16, r16
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     620:	00 00       	nop

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     622:	00 03       	mulsu	r16, r16
	m = timer0_millis;
     624:	3a 00       	.word	0x003a	; ????
     626:	00 00       	nop
     628:	3a 00       	.word	0x003a	; ????
     62a:	00 00       	nop
     62c:	04 00       	.word	0x0004	; ????
     62e:	05 02       	muls	r16, r21
     630:	05 69       	ori	r16, 0x95	; 149
     632:	6e 74       	andi	r22, 0x4E	; 78
	SREG = oldSREG;
     634:	00 06       	cpc	r0, r16
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     636:	0d 05       	cpc	r16, r13
     638:	00 00       	nop
     63a:	04 02       	muls	r16, r20
     63c:	25 41       	sbci	r18, 0x15	; 21
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     63e:	00 00       	nop
     640:	00 64       	ori	r16, 0x40	; 64
     642:	01 00       	.word	0x0001	; ????
     644:	00 07       	cpc	r16, r16
     646:	07 05       	cpc	r16, r7
     648:	00 00       	nop
     64a:	64 01       	movw	r12, r8
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     64c:	00 00       	nop
     64e:	02 23       	and	r16, r18
     650:	00 01       	movw	r0, r0
     652:	08 4d       	sbci	r16, 0xD8	; 216
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     654:	02 00       	.word	0x0002	; ????
     656:	00 02       	muls	r16, r16
     658:	28 3a       	cpi	r18, 0xA8	; 168
     65a:	00 00       	nop
     65c:	00 02       	muls	r16, r16
     65e:	23 02       	muls	r18, r19
     660:	03 09       	sbc	r16, r3
     662:	70 05       	cpc	r23, r0
     664:	00 00       	nop
     666:	01 7e       	andi	r16, 0xE1	; 225
     668:	01 6a       	ori	r16, 0xA1	; 161
     66a:	01 00       	.word	0x0001	; ????
     66c:	00 01       	movw	r0, r0
     66e:	82 00       	.word	0x0082	; ????
     670:	00 00       	nop
     672:	89 00       	.word	0x0089	; ????
     674:	00 00       	nop
     676:	0a 4c       	sbci	r16, 0xCA	; 202
     678:	07 00       	.word	0x0007	; ????
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     67a:	00 01       	movw	r0, r0
     67c:	00 09       	sbc	r16, r0
     67e:	70 05       	cpc	r23, r0
     680:	00 00       	nop
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
     682:	01 8a       	std	Z+17, r0	; 0x11
     684:	01 6a       	ori	r16, 0xA1	; 161
     686:	01 00       	.word	0x0001	; ????
     688:	00 01       	movw	r0, r0
     68a:	9e 00       	.word	0x009e	; ????
     68c:	00 00       	nop
     68e:	aa 00       	.word	0x00aa	; ????
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     690:	00 00       	nop
     692:	0a 4c       	sbci	r16, 0xCA	; 202
     694:	07 00       	.word	0x0007	; ????
     696:	00 01       	movw	r0, r0
     698:	0b 3e       	cpi	r16, 0xEB	; 235
     69a:	02 00       	.word	0x0002	; ????
     69c:	00 00       	nop
     69e:	09 ed       	ldi	r16, 0xD9	; 217
     6a0:	04 00       	.word	0x0004	; ????
     6a2:	00 01       	movw	r0, r0
     6a4:	67 01       	movw	r12, r14
     6a6:	6a 01       	movw	r12, r20
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     6a8:	00 00       	nop
     6aa:	01 bf       	out	0x31, r16	; 49
     6ac:	00 00       	nop
     6ae:	00 d0       	rcall	.+0      	; 0x6b0 <_GLOBAL__sub_I___vector_18+0x20>
     6b0:	00 00       	nop
     6b2:	00 0a       	sbc	r0, r16
     6b4:	4c 07       	cpc	r20, r28
     6b6:	00 00       	nop
     6b8:	01 0b       	sbc	r16, r17
     6ba:	37 02       	muls	r19, r23
     6bc:	00 00       	nop
     6be:	0b 3a       	cpi	r16, 0xAB	; 171
     6c0:	00 00       	nop
     6c2:	00 00       	nop
     6c4:	09 ed       	ldi	r16, 0xD9	; 217
     6c6:	04 00       	.word	0x0004	; ????
     6c8:	00 01       	movw	r0, r0
     6ca:	3e 01       	movw	r6, r28
     6cc:	6a 01       	movw	r12, r20
     6ce:	00 00       	nop
     6d0:	01 e5       	ldi	r16, 0x51	; 81
     6d2:	00 00       	nop
     6d4:	00 f1       	brcs	.+64     	; 0x716 <__udivmodsi4_ep+0x6>
     6d6:	00 00       	nop
     6d8:	00 0a       	sbc	r0, r16
     6da:	4c 07       	cpc	r20, r28
     6dc:	00 00       	nop
     6de:	01 0b       	sbc	r16, r17
     6e0:	3e 02       	muls	r19, r30
     6e2:	00 00       	nop
     6e4:	00 0c       	add	r0, r0
     6e6:	a9 03       	fmulsu	r18, r17
     6e8:	00 00       	nop
     6ea:	01 cb       	rjmp	.-2558   	; 0xfffffcee <__eeprom_end+0xff7efcee>
     6ec:	01 6a       	ori	r16, 0xA1	; 161
     6ee:	01 00       	.word	0x0001	; ????
     6f0:	00 03       	mulsu	r16, r16
     6f2:	01 07       	cpc	r16, r17
     6f4:	01 00       	.word	0x0001	; ????
     6f6:	00 18       	sub	r0, r0
     6f8:	01 00       	.word	0x0001	; ????
     6fa:	00 0a       	sbc	r0, r16
     6fc:	4c 07       	cpc	r20, r28
     6fe:	00 00       	nop
     700:	01 0b       	sbc	r16, r17
     702:	37 02       	muls	r19, r23
     704:	00 00       	nop
     706:	0b 87       	std	Y+11, r16	; 0x0b
     708:	02 00       	.word	0x0002	; ????
     70a:	00 00       	nop
     70c:	09 28       	or	r0, r9
     70e:	02 00       	.word	0x0002	; ????
     710:	00 02       	muls	r16, r16
     712:	34 01       	movw	r6, r8
     714:	6a 01       	movw	r12, r20
     716:	00 00       	nop
     718:	01 2d       	mov	r16, r1
     71a:	01 00       	.word	0x0001	; ????
     71c:	00 39       	cpi	r16, 0x90	; 144
     71e:	01 00       	.word	0x0001	; ????
     720:	00 0a       	sbc	r0, r16
     722:	4c 07       	cpc	r20, r28
     724:	00 00       	nop
     726:	01 0b       	sbc	r16, r17
     728:	3e 02       	muls	r19, r30
     72a:	00 00       	nop
     72c:	00 0d       	add	r16, r0
     72e:	28 02       	muls	r18, r24
     730:	00 00       	nop
     732:	01 22       	and	r0, r17
     734:	01 6a       	ori	r16, 0xA1	; 161
     736:	01 00       	.word	0x0001	; ????
     738:	00 01       	movw	r0, r0
     73a:	02 10       	cpse	r0, r2
     73c:	01 41       	sbci	r16, 0x11	; 17
     73e:	00 00       	nop
     740:	00 01       	movw	r0, r0
     742:	52 01       	movw	r10, r4
     744:	00 00       	nop
     746:	0a 4c       	sbci	r16, 0xCA	; 202
     748:	07 00       	.word	0x0007	; ????
     74a:	00 01       	movw	r0, r0
     74c:	0b 74       	andi	r16, 0x4B	; 75
     74e:	08 00       	.word	0x0008	; ????
     750:	00 0b       	sbc	r16, r16
     752:	6a 01       	movw	r12, r20
     754:	00 00       	nop
     756:	00 00       	nop
     758:	0e 02       	muls	r16, r30
     75a:	25 00       	.word	0x0025	; ????
     75c:	00 00       	nop
     75e:	0f 73       	andi	r16, 0x3F	; 63
     760:	02 00       	.word	0x0002	; ????
     762:	00 0c       	add	r0, r0
     764:	d8 75       	andi	r29, 0x58	; 88
     766:	01 00       	.word	0x0001	; ????
     768:	00 10       	cpse	r0, r0
     76a:	02 07       	cpc	r16, r18
     76c:	18 05       	cpc	r17, r8
     76e:	00 00       	nop
     770:	10 01       	movw	r2, r0
     772:	06 d5       	rcall	.+2572   	; 0x1180 <__stack+0x881>
     774:	03 00       	.word	0x0003	; ????
     776:	00 06       	cpc	r0, r16
     778:	4c 05       	cpc	r20, r12
     77a:	00 00       	nop
     77c:	0c 0a       	sbc	r0, r28
     77e:	31 cf       	rjmp	.-414    	; 0x5e2 <main+0x116>
     780:	01 00       	.word	0x0001	; ????
     782:	00 cf       	rjmp	.-512    	; 0x584 <main+0xb8>
     784:	01 00       	.word	0x0001	; ????
     786:	00 11       	cpse	r16, r0
     788:	cf 01       	movw	r24, r30
     78a:	00 00       	nop
     78c:	02 23       	and	r16, r18
     78e:	00 01       	movw	r0, r0
     790:	08 46       	sbci	r16, 0x68	; 104
     792:	06 00       	.word	0x0006	; ????
     794:	00 0a       	sbc	r0, r16
     796:	34 37       	cpi	r19, 0x74	; 116
     798:	02 00       	.word	0x0002	; ????
     79a:	00 02       	muls	r16, r16
     79c:	23 04       	cpc	r2, r3
     79e:	02 08       	sbc	r0, r2
     7a0:	c7 06       	cpc	r12, r23
     7a2:	00 00       	nop
     7a4:	0a 35       	cpi	r16, 0x5A	; 90
     7a6:	37 02       	muls	r19, r23
     7a8:	00 00       	nop
     7aa:	02 23       	and	r16, r18
     7ac:	08 02       	muls	r16, r24
     7ae:	12 51       	subi	r17, 0x12	; 18
     7b0:	03 00       	.word	0x0003	; ????
     7b2:	00 0a       	sbc	r0, r16
     7b4:	3f 01       	movw	r6, r30
     7b6:	01 c7       	rjmp	.+3586   	; 0x15ba <__stack+0xcbb>
     7b8:	01 00       	.word	0x0001	; ????
     7ba:	00 0a       	sbc	r0, r16
     7bc:	78 06       	cpc	r7, r24
     7be:	00 00       	nop
     7c0:	01 00       	.word	0x0001	; ????
     7c2:	00 13       	cpse	r16, r16
     7c4:	0d 05       	cpc	r16, r13
     7c6:	00 00       	nop
     7c8:	01 37       	cpi	r16, 0x71	; 113
     7ca:	02 00       	.word	0x0002	; ????
     7cc:	00 14       	cp	r0, r0
     7ce:	2e 02       	muls	r18, r30
     7d0:	00 00       	nop
     7d2:	02 5a       	subi	r16, 0xA2	; 162
     7d4:	01 01       	movw	r0, r2
     7d6:	02 10       	cpse	r0, r2
     7d8:	03 cf       	rjmp	.-506    	; 0x5e0 <main+0x114>
     7da:	01 00       	.word	0x0001	; ????
     7dc:	00 01       	movw	r0, r0
     7de:	f2 01       	movw	r30, r4
     7e0:	00 00       	nop
     7e2:	f9 01       	movw	r30, r18
     7e4:	00 00       	nop
     7e6:	0a e4       	ldi	r16, 0x4A	; 74
     7e8:	08 00       	.word	0x0008	; ????
     7ea:	00 01       	movw	r0, r0
     7ec:	00 15       	cp	r16, r0
     7ee:	71 03       	mulsu	r23, r17
     7f0:	00 00       	nop
     7f2:	02 3f       	cpi	r16, 0xF2	; 242
     7f4:	01 3a       	cpi	r16, 0xA1	; 161
     7f6:	00 00       	nop
     7f8:	00 01       	movw	r0, r0
     7fa:	02 10       	cpse	r0, r2
     7fc:	02 cf       	rjmp	.-508    	; 0x602 <main+0x136>
     7fe:	01 00       	.word	0x0001	; ????
     800:	00 01       	movw	r0, r0
     802:	16 02       	muls	r17, r22
     804:	00 00       	nop
     806:	1d 02       	muls	r17, r29
     808:	00 00       	nop
     80a:	0a e4       	ldi	r16, 0x4A	; 74
     80c:	08 00       	.word	0x0008	; ????
     80e:	00 01       	movw	r0, r0
     810:	00 16       	cp	r0, r16
     812:	01 51       	subi	r16, 0x11	; 17
     814:	03 00       	.word	0x0003	; ????
     816:	00 02       	muls	r16, r16
     818:	2e 23       	and	r18, r30
     81a:	03 00       	.word	0x0003	; ????
     81c:	00 01       	movw	r0, r0
     81e:	01 2f       	mov	r16, r17
     820:	02 00       	.word	0x0002	; ????
     822:	00 0a       	sbc	r0, r16
     824:	e4 08       	sbc	r14, r4
     826:	00 00       	nop
     828:	01 00       	.word	0x0001	; ????
     82a:	00 10       	cpse	r0, r0
     82c:	04 07       	cpc	r16, r20
     82e:	13 05       	cpc	r17, r3
     830:	00 00       	nop
     832:	0e 02       	muls	r16, r30
     834:	44 02       	muls	r20, r20
     836:	00 00       	nop
     838:	17 7c       	andi	r17, 0xC7	; 199
     83a:	01 00       	.word	0x0001	; ????
     83c:	00 06       	cpc	r0, r16
     83e:	4c 05       	cpc	r20, r12
     840:	00 00       	nop
     842:	0c 0a       	sbc	r0, r28
     844:	31 81       	ldd	r19, Z+1	; 0x01
     846:	02 00       	.word	0x0002	; ????
     848:	00 81       	ld	r16, Z
     84a:	02 00       	.word	0x0002	; ????
     84c:	00 11       	cpse	r16, r0
     84e:	81 02       	muls	r24, r17
     850:	00 00       	nop
     852:	02 23       	and	r16, r18
     854:	00 01       	movw	r0, r0
     856:	08 46       	sbci	r16, 0x68	; 104
     858:	06 00       	.word	0x0006	; ????
     85a:	00 0a       	sbc	r0, r16
     85c:	34 37       	cpi	r19, 0x74	; 116
     85e:	02 00       	.word	0x0002	; ????
     860:	00 02       	muls	r16, r16
     862:	23 04       	cpc	r2, r3
     864:	02 08       	sbc	r0, r2
     866:	c7 06       	cpc	r12, r23
     868:	00 00       	nop
     86a:	0a 35       	cpi	r16, 0x5A	; 90
     86c:	37 02       	muls	r19, r23
     86e:	00 00       	nop
     870:	02 23       	and	r16, r18
     872:	08 02       	muls	r16, r24
     874:	00 18       	sub	r0, r0
     876:	0d 05       	cpc	r16, r13
     878:	00 00       	nop
     87a:	01 0f       	add	r16, r17
     87c:	0c 03       	fmul	r16, r20
     87e:	00 00       	nop
     880:	0d 7e       	andi	r16, 0xED	; 237
     882:	92 02       	muls	r25, r18
     884:	00 00       	nop
     886:	10 01       	movw	r2, r0
     888:	08 cc       	rjmp	.-2032   	; 0x9a <.do_clear_bss_start+0x4>
     88a:	03 00       	.word	0x0003	; ????
     88c:	00 0f       	add	r16, r16
     88e:	b0 06       	cpc	r11, r16
     890:	00 00       	nop
     892:	0e 3b       	cpi	r16, 0xBE	; 190
     894:	87 02       	muls	r24, r23
     896:	00 00       	nop
     898:	0f b5       	in	r16, 0x2f	; 47
     89a:	03 00       	.word	0x0003	; ????
     89c:	00 0e       	add	r0, r16
     89e:	40 87       	std	Z+8, r20	; 0x08
     8a0:	02 00       	.word	0x0002	; ????
     8a2:	00 10       	cpse	r0, r0
     8a4:	01 02       	muls	r16, r17
     8a6:	31 03       	mulsu	r19, r17
     8a8:	00 00       	nop
     8aa:	06 d4       	rcall	.+2060   	; 0x10b8 <__stack+0x7b9>
     8ac:	05 00       	.word	0x0005	; ????
     8ae:	00 9d       	mul	r16, r0
     8b0:	0e 5d       	subi	r16, 0xDE	; 222
     8b2:	81 02       	muls	r24, r17
     8b4:	00 00       	nop
     8b6:	00 05       	cpc	r16, r0
     8b8:	00 00       	nop
     8ba:	11 49       	sbci	r17, 0x91	; 145
     8bc:	02 00       	.word	0x0002	; ????
     8be:	00 02       	muls	r16, r16
     8c0:	23 00       	.word	0x0023	; ????
     8c2:	01 08       	sbc	r0, r1
     8c4:	83 03       	fmuls	r16, r19
     8c6:	00 00       	nop
     8c8:	0e 60       	ori	r16, 0x0E	; 14
     8ca:	0b 05       	cpc	r16, r11
     8cc:	00 00       	nop
     8ce:	02 23       	and	r16, r18
     8d0:	0c 02       	muls	r16, r28
     8d2:	08 3f       	cpi	r16, 0xF8	; 248
     8d4:	06 00       	.word	0x0006	; ????
     8d6:	00 0e       	add	r0, r16
     8d8:	61 0b       	sbc	r22, r17
     8da:	05 00       	.word	0x0005	; ????
     8dc:	00 02       	muls	r16, r16
     8de:	23 0e       	add	r2, r19
     8e0:	02 08       	sbc	r0, r2
     8e2:	9b 06       	cpc	r9, r27
     8e4:	00 00       	nop
     8e6:	0e 62       	ori	r16, 0x2E	; 46
     8e8:	0b 05       	cpc	r16, r11
     8ea:	00 00       	nop
     8ec:	02 23       	and	r16, r18
     8ee:	10 02       	muls	r17, r16
     8f0:	08 a2       	std	Y+32, r0	; 0x20
     8f2:	06 00       	.word	0x0006	; ????
     8f4:	00 0e       	add	r0, r16
     8f6:	63 0b       	sbc	r22, r19
     8f8:	05 00       	.word	0x0005	; ????
     8fa:	00 02       	muls	r16, r16
     8fc:	23 12       	cpse	r2, r19
     8fe:	02 08       	sbc	r0, r2
     900:	a9 06       	cpc	r10, r25
     902:	00 00       	nop
     904:	0e 64       	ori	r16, 0x4E	; 78
     906:	0b 05       	cpc	r16, r11
     908:	00 00       	nop
     90a:	02 23       	and	r16, r18
     90c:	14 02       	muls	r17, r20
     90e:	08 d4       	rcall	.+2064   	; 0x1120 <__stack+0x821>
     910:	06 00       	.word	0x0006	; ????
     912:	00 0e       	add	r0, r16
     914:	65 0b       	sbc	r22, r21
     916:	05 00       	.word	0x0005	; ????
     918:	00 02       	muls	r16, r16
     91a:	23 16       	cp	r2, r19
     91c:	02 08       	sbc	r0, r2
     91e:	02 07       	cpc	r16, r18
     920:	00 00       	nop
     922:	0e 67       	ori	r16, 0x7E	; 126
     924:	af 02       	muls	r26, r31
     926:	00 00       	nop
     928:	02 23       	and	r16, r18
     92a:	18 02       	muls	r17, r24
     92c:	08 36       	cpi	r16, 0x68	; 104
     92e:	03 00       	.word	0x0003	; ????
     930:	00 0e       	add	r0, r16
     932:	69 10       	cpse	r6, r9
     934:	05 00       	.word	0x0005	; ????
     936:	00 02       	muls	r16, r16
     938:	23 19       	sub	r18, r3
     93a:	02 08       	sbc	r0, r2
     93c:	18 02       	muls	r17, r24
     93e:	00 00       	nop
     940:	0e 6a       	ori	r16, 0xAE	; 174
     942:	10 05       	cpc	r17, r0
     944:	00 00       	nop
     946:	02 23       	and	r16, r18
     948:	1a 02       	muls	r17, r26
     94a:	08 08       	sbc	r0, r8
     94c:	02 00       	.word	0x0002	; ????
     94e:	00 0e       	add	r0, r16
     950:	6b 15       	cp	r22, r11
     952:	05 00       	.word	0x0005	; ????
     954:	00 02       	muls	r16, r16
     956:	23 1b       	sub	r18, r19
     958:	02 08       	sbc	r0, r2
     95a:	f0 05       	cpc	r31, r0
     95c:	00 00       	nop
     95e:	0e 6c       	ori	r16, 0xCE	; 206
     960:	15 05       	cpc	r17, r5
     962:	00 00       	nop
     964:	02 23       	and	r16, r18
     966:	1c 02       	muls	r17, r28
     968:	08 d9       	rcall	.-3568   	; 0xfffffb7a <__eeprom_end+0xff7efb7a>
     96a:	06 00       	.word	0x0006	; ????
     96c:	00 0e       	add	r0, r16
     96e:	71 1a       	sub	r7, r17
     970:	05 00       	.word	0x0005	; ????
     972:	00 02       	muls	r16, r16
     974:	23 1d       	adc	r18, r3
     976:	02 08       	sbc	r0, r2
     978:	53 05       	cpc	r21, r3
     97a:	00 00       	nop
     97c:	0e 72       	andi	r16, 0x2E	; 46
     97e:	1a 05       	cpc	r17, r10
     980:	00 00       	nop
     982:	02 23       	and	r16, r18
     984:	5d 02       	muls	r21, r29
     986:	19 a1       	ldd	r17, Y+33	; 0x21
     988:	02 00       	.word	0x0002	; ????
     98a:	00 01       	movw	r0, r0
     98c:	01 02       	muls	r16, r17
     98e:	10 03       	mulsu	r17, r16
     990:	b6 02       	muls	r27, r22
     992:	00 00       	nop
     994:	01 01       	movw	r0, r2
     996:	aa 03       	fmulsu	r18, r18
     998:	00 00       	nop
     99a:	b1 03       	fmuls	r19, r17
     99c:	00 00       	nop
     99e:	0a 47       	sbci	r16, 0x7A	; 122
     9a0:	05 00       	.word	0x0005	; ????
     9a2:	00 01       	movw	r0, r0
     9a4:	00 1a       	sub	r0, r16
     9a6:	00 06       	cpc	r0, r16
     9a8:	00 00       	nop
     9aa:	01 6a       	ori	r16, 0xA1	; 161
     9ac:	01 00       	.word	0x0001	; ????
     9ae:	00 01       	movw	r0, r0
     9b0:	02 10       	cpse	r0, r2
     9b2:	00 b6       	in	r0, 0x30	; 48
     9b4:	02 00       	.word	0x0002	; ????
     9b6:	00 01       	movw	r0, r0
     9b8:	01 cd       	rjmp	.-1534   	; 0x3bc <__vector_16+0x34>
     9ba:	03 00       	.word	0x0003	; ????
     9bc:	00 d9       	rcall	.-3584   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
     9be:	03 00       	.word	0x0003	; ????
     9c0:	00 0a       	sbc	r0, r16
     9c2:	47 05       	cpc	r20, r7
     9c4:	00 00       	nop
     9c6:	01 0b       	sbc	r16, r17
     9c8:	87 02       	muls	r24, r23
     9ca:	00 00       	nop
     9cc:	00 1b       	sub	r16, r16
     9ce:	8f 02       	muls	r24, r31
     9d0:	00 00       	nop
     9d2:	03 75       	andi	r16, 0x53	; 83
     9d4:	01 01       	movw	r0, r2
     9d6:	ea 03       	fmulsu	r22, r18
     9d8:	00 00       	nop
     9da:	fb 03       	fmulsu	r23, r19
     9dc:	00 00       	nop
     9de:	0a 47       	sbci	r16, 0x7A	; 122
     9e0:	05 00       	.word	0x0005	; ????
     9e2:	00 01       	movw	r0, r0
     9e4:	0b 37       	cpi	r16, 0x7B	; 123
     9e6:	02 00       	.word	0x0002	; ????
     9e8:	00 0b       	sbc	r16, r16
     9ea:	31 05       	cpc	r19, r1
     9ec:	00 00       	nop
     9ee:	00 15       	cp	r16, r0
     9f0:	71 03       	mulsu	r23, r17
     9f2:	00 00       	nop
     9f4:	03 c0       	rjmp	.+6      	; 0x9fc <__stack+0xfd>
     9f6:	01 3a       	cpi	r16, 0xA1	; 161
     9f8:	00 00       	nop
     9fa:	00 01       	movw	r0, r0
     9fc:	02 10       	cpse	r0, r2
     9fe:	02 b6       	in	r0, 0x32	; 50
     a00:	02 00       	.word	0x0002	; ????
     a02:	00 01       	movw	r0, r0
     a04:	18 04       	cpc	r1, r8
     a06:	00 00       	nop
     a08:	1f 04       	cpc	r1, r15
     a0a:	00 00       	nop
     a0c:	0a 47       	sbci	r16, 0x7A	; 122
     a0e:	05 00       	.word	0x0005	; ????
     a10:	00 01       	movw	r0, r0
     a12:	00 15       	cp	r16, r0
     a14:	4c 03       	fmul	r20, r20
     a16:	00 00       	nop
     a18:	03 b4       	in	r0, 0x23	; 35
     a1a:	01 3a       	cpi	r16, 0xA1	; 161
     a1c:	00 00       	nop
     a1e:	00 01       	movw	r0, r0
     a20:	02 10       	cpse	r0, r2
     a22:	05 b6       	in	r0, 0x35	; 53
     a24:	02 00       	.word	0x0002	; ????
     a26:	00 01       	movw	r0, r0
     a28:	3c 04       	cpc	r3, r12
     a2a:	00 00       	nop
     a2c:	43 04       	cpc	r4, r3
     a2e:	00 00       	nop
     a30:	0a 47       	sbci	r16, 0x7A	; 122
     a32:	05 00       	.word	0x0005	; ????
     a34:	00 01       	movw	r0, r0
     a36:	00 15       	cp	r16, r0
     a38:	5e 03       	fmul	r21, r22
     a3a:	00 00       	nop
     a3c:	03 ab       	std	Z+51, r16	; 0x33
     a3e:	01 3a       	cpi	r16, 0xA1	; 161
     a40:	00 00       	nop
     a42:	00 01       	movw	r0, r0
     a44:	02 10       	cpse	r0, r2
     a46:	06 b6       	in	r0, 0x36	; 54
     a48:	02 00       	.word	0x0002	; ????
     a4a:	00 01       	movw	r0, r0
     a4c:	60 04       	cpc	r6, r0
     a4e:	00 00       	nop
     a50:	67 04       	cpc	r6, r7
     a52:	00 00       	nop
     a54:	0a 47       	sbci	r16, 0x7A	; 122
     a56:	05 00       	.word	0x0005	; ????
     a58:	00 01       	movw	r0, r0
     a5a:	00 15       	cp	r16, r0
     a5c:	69 02       	muls	r22, r25
     a5e:	00 00       	nop
     a60:	03 a6       	std	Z+43, r0	; 0x2b
     a62:	01 3a       	cpi	r16, 0xA1	; 161
     a64:	00 00       	nop
     a66:	00 01       	movw	r0, r0
     a68:	02 10       	cpse	r0, r2
     a6a:	04 b6       	in	r0, 0x34	; 52
     a6c:	02 00       	.word	0x0002	; ????
     a6e:	00 01       	movw	r0, r0
     a70:	84 04       	cpc	r8, r4
     a72:	00 00       	nop
     a74:	8b 04       	cpc	r8, r11
     a76:	00 00       	nop
     a78:	0a 47       	sbci	r16, 0x7A	; 122
     a7a:	05 00       	.word	0x0005	; ????
     a7c:	00 01       	movw	r0, r0
     a7e:	00 1c       	adc	r0, r0
     a80:	6b 06       	cpc	r6, r27
     a82:	00 00       	nop
     a84:	01 01       	movw	r0, r2
     a86:	01 9b       	sbis	0x00, 1	; 0
     a88:	04 00       	.word	0x0004	; ????
     a8a:	00 a2       	std	Z+32, r0	; 0x20
     a8c:	04 00       	.word	0x0004	; ????
     a8e:	00 0a       	sbc	r0, r16
     a90:	47 05       	cpc	r20, r7
     a92:	00 00       	nop
     a94:	01 00       	.word	0x0001	; ????
     a96:	1b 5e       	subi	r17, 0xEB	; 235
     a98:	05 00       	.word	0x0005	; ????
     a9a:	00 03       	mulsu	r16, r16
     a9c:	59 01       	movw	r10, r18
     a9e:	01 b3       	in	r16, 0x11	; 17
     aa0:	04 00       	.word	0x0004	; ????
     aa2:	00 ba       	out	0x10, r0	; 16
     aa4:	04 00       	.word	0x0004	; ????
     aa6:	00 0a       	sbc	r0, r16
     aa8:	47 05       	cpc	r20, r7
     aaa:	00 00       	nop
     aac:	01 00       	.word	0x0001	; ????
     aae:	15 28       	or	r1, r5
     ab0:	02 00       	.word	0x0002	; ????
     ab2:	00 03       	mulsu	r16, r16
     ab4:	e1 01       	movw	r28, r2
     ab6:	6a 01       	movw	r12, r20
     ab8:	00 00       	nop
     aba:	01 02       	muls	r16, r17
     abc:	10 00       	.word	0x0010	; ????
     abe:	b6 02       	muls	r27, r22
     ac0:	00 00       	nop
     ac2:	01 d7       	rcall	.+3586   	; 0x18c6 <__stack+0xfc7>
     ac4:	04 00       	.word	0x0004	; ????
     ac6:	00 e3       	ldi	r16, 0x30	; 48
     ac8:	04 00       	.word	0x0004	; ????
     aca:	00 0a       	sbc	r0, r16
     acc:	47 05       	cpc	r20, r7
     ace:	00 00       	nop
     ad0:	01 0b       	sbc	r16, r17
     ad2:	87 02       	muls	r24, r23
     ad4:	00 00       	nop
     ad6:	00 1d       	adc	r16, r0
     ad8:	2e 02       	muls	r18, r30
     ada:	00 00       	nop
     adc:	03 cd       	rjmp	.-1530   	; 0x4e4 <main+0x18>
     ade:	01 01       	movw	r0, r2
     ae0:	02 10       	cpse	r0, r2
     ae2:	03 b6       	in	r0, 0x33	; 51
     ae4:	02 00       	.word	0x0002	; ????
     ae6:	00 01       	movw	r0, r0
     ae8:	f8 04       	cpc	r15, r8
     aea:	00 00       	nop
     aec:	0a 47       	sbci	r16, 0x7A	; 122
     aee:	05 00       	.word	0x0005	; ????
     af0:	00 01       	movw	r0, r0
     af2:	00 00       	nop
     af4:	0e 02       	muls	r16, r30
     af6:	06 05       	cpc	r16, r6
     af8:	00 00       	nop
     afa:	1e 87       	std	Y+14, r17	; 0x0e
     afc:	02 00       	.word	0x0002	; ????
     afe:	00 17       	cp	r16, r16
     b00:	00 05       	cpc	r16, r0
     b02:	00 00       	nop
     b04:	1e a4       	ldd	r1, Y+46	; 0x2e
     b06:	02 00       	.word	0x0002	; ????
     b08:	00 1e       	adc	r0, r16
     b0a:	99 02       	muls	r25, r25
     b0c:	00 00       	nop
     b0e:	1f 92       	push	r1
     b10:	02 00       	.word	0x0002	; ????
     b12:	00 2a       	or	r0, r16
     b14:	05 00       	.word	0x0005	; ????
     b16:	00 20       	and	r0, r0
     b18:	2a 05       	cpc	r18, r10
     b1a:	00 00       	nop
     b1c:	3f 00       	.word	0x003f	; ????
     b1e:	10 02       	muls	r17, r16
     b20:	07 86       	std	Z+15, r0	; 0x0f
     b22:	02 00       	.word	0x0002	; ????
     b24:	00 0f       	add	r16, r16
     b26:	a4 03       	fmuls	r18, r20
     b28:	00 00       	nop
     b2a:	0f 7e       	andi	r16, 0xEF	; 239
     b2c:	87 02       	muls	r24, r23
     b2e:	00 00       	nop
     b30:	0f fe       	.word	0xfe0f	; ????
     b32:	04 00       	.word	0x0004	; ????
     b34:	00 0d       	add	r16, r0
     b36:	80 75       	andi	r24, 0x50	; 80
     b38:	01 00       	.word	0x0001	; ????
     b3a:	00 0e       	add	r0, r16
     b3c:	02 b6       	in	r0, 0x32	; 50
     b3e:	02 00       	.word	0x0002	; ????
     b40:	00 21       	and	r16, r0
     b42:	92 03       	fmuls	r17, r18
     b44:	00 00       	nop
     b46:	03 cd       	rjmp	.-1530   	; 0x54e <main+0x82>
     b48:	01 5d       	subi	r16, 0xD1	; 209
     b4a:	05 00       	.word	0x0005	; ????
     b4c:	00 68       	ori	r16, 0x80	; 128
     b4e:	05 00       	.word	0x0005	; ????
     b50:	00 22       	and	r0, r16
     b52:	ad 05       	cpc	r26, r13
     b54:	00 00       	nop
     b56:	68 05       	cpc	r22, r8
     b58:	00 00       	nop
     b5a:	01 00       	.word	0x0001	; ????
     b5c:	17 47       	sbci	r17, 0x77	; 119
     b5e:	05 00       	.word	0x0005	; ????
     b60:	00 21       	and	r16, r0
     b62:	b1 03       	fmuls	r19, r17
     b64:	00 00       	nop
     b66:	03 e1       	ldi	r16, 0x13	; 19
     b68:	01 7d       	andi	r16, 0xD1	; 209
     b6a:	05 00       	.word	0x0005	; ????
     b6c:	00 b4       	in	r0, 0x20	; 32
     b6e:	05 00       	.word	0x0005	; ????
     b70:	00 22       	and	r0, r16
     b72:	ad 05       	cpc	r26, r13
     b74:	00 00       	nop
     b76:	68 05       	cpc	r22, r8
     b78:	00 00       	nop
     b7a:	01 23       	and	r16, r17
     b7c:	63 00       	.word	0x0063	; ????
     b7e:	03 e1       	ldi	r16, 0x13	; 19
     b80:	87 02       	muls	r24, r23
     b82:	00 00       	nop
     b84:	24 69       	ori	r18, 0x94	; 148
     b86:	00 03       	mulsu	r16, r16
     b88:	fb 99       	sbic	0x1f, 3	; 31
     b8a:	02 00       	.word	0x0002	; ????
     b8c:	00 25       	eor	r16, r0
     b8e:	26 54       	subi	r18, 0x46	; 70
     b90:	06 00       	.word	0x0006	; ????
     b92:	00 03       	mulsu	r16, r16
     b94:	11 01       	movw	r2, r2
     b96:	87 02       	muls	r24, r23
     b98:	00 00       	nop
     b9a:	26 cd       	rjmp	.-1460   	; 0x5e8 <main+0x11c>
     b9c:	05 00       	.word	0x0005	; ????
     b9e:	00 03       	mulsu	r16, r16
     ba0:	11 01       	movw	r2, r2
     ba2:	87 02       	muls	r24, r23
     ba4:	00 00       	nop
     ba6:	00 00       	nop
     ba8:	13 d4       	rcall	.+2086   	; 0x13d0 <__stack+0xad1>
     baa:	05 00       	.word	0x0005	; ????
     bac:	00 01       	movw	r0, r0
     bae:	25 06       	cpc	r2, r21
     bb0:	00 00       	nop
     bb2:	1c da       	rcall	.-3016   	; 0xffffffec <__eeprom_end+0xff7effec>
     bb4:	03 00       	.word	0x0003	; ????
     bb6:	00 01       	movw	r0, r0
     bb8:	01 01       	movw	r0, r2
     bba:	ce 05       	cpc	r28, r14
     bbc:	00 00       	nop
     bbe:	d5 05       	cpc	r29, r5
     bc0:	00 00       	nop
     bc2:	0a 25       	eor	r16, r10
     bc4:	06 00       	.word	0x0006	; ????
     bc6:	00 01       	movw	r0, r0
     bc8:	00 1b       	sub	r16, r16
     bca:	25 05       	cpc	r18, r5
     bcc:	00 00       	nop
     bce:	0b 65       	ori	r16, 0x5B	; 91
     bd0:	01 01       	movw	r0, r2
     bd2:	e6 05       	cpc	r30, r6
     bd4:	00 00       	nop
     bd6:	ed 05       	cpc	r30, r13
     bd8:	00 00       	nop
     bda:	0a 25       	eor	r16, r10
     bdc:	06 00       	.word	0x0006	; ????
     bde:	00 01       	movw	r0, r0
     be0:	00 16       	cp	r0, r16
     be2:	01 51       	subi	r16, 0x11	; 17
     be4:	03 00       	.word	0x0003	; ????
     be6:	00 0b       	sbc	r16, r16
     be8:	57 c4       	rjmp	.+2222   	; 0x1498 <__stack+0xb99>
     bea:	02 00       	.word	0x0002	; ????
     bec:	00 01       	movw	r0, r0
     bee:	01 ff       	sbrs	r16, 1
     bf0:	05 00       	.word	0x0005	; ????
     bf2:	00 0a       	sbc	r0, r16
     bf4:	25 06       	cpc	r2, r21
     bf6:	00 00       	nop
     bf8:	01 0b       	sbc	r16, r17
     bfa:	00 05       	cpc	r16, r0
     bfc:	00 00       	nop
     bfe:	0b 00       	.word	0x000b	; ????
     c00:	05 00       	.word	0x0005	; ????
     c02:	00 0b       	sbc	r16, r16
     c04:	00 05       	cpc	r16, r0
     c06:	00 00       	nop
     c08:	0b 00       	.word	0x000b	; ????
     c0a:	05 00       	.word	0x0005	; ????
     c0c:	00 0b       	sbc	r16, r16
     c0e:	00 05       	cpc	r16, r0
     c10:	00 00       	nop
     c12:	0b 00       	.word	0x000b	; ????
     c14:	05 00       	.word	0x0005	; ????
     c16:	00 00       	nop
     c18:	00 0e       	add	r0, r16
     c1a:	02 b4       	in	r0, 0x22	; 34
     c1c:	05 00       	.word	0x0005	; ????
     c1e:	00 21       	and	r16, r0
     c20:	be 05       	cpc	r27, r14
     c22:	00 00       	nop
     c24:	0b 65       	ori	r16, 0x5B	; 91
     c26:	03 3b       	cpi	r16, 0xB3	; 179
     c28:	06 00       	.word	0x0006	; ????
     c2a:	00 5a       	subi	r16, 0xA0	; 160
     c2c:	06 00       	.word	0x0006	; ????
     c2e:	00 22       	and	r0, r16
     c30:	ad 05       	cpc	r26, r13
     c32:	00 00       	nop
     c34:	5a 06       	cpc	r5, r26
     c36:	00 00       	nop
     c38:	01 25       	eor	r16, r1
     c3a:	24 63       	ori	r18, 0x34	; 52
     c3c:	00 0b       	sbc	r16, r16
     c3e:	6a 92       	st	-Y, r6
     c40:	02 00       	.word	0x0002	; ????
     c42:	00 24       	eor	r0, r0
     c44:	69 00       	.word	0x0069	; ????
     c46:	0b 6b       	ori	r16, 0xBB	; 187
     c48:	a4 02       	muls	r26, r20
     c4a:	00 00       	nop
     c4c:	00 00       	nop
     c4e:	17 25       	eor	r17, r7
     c50:	06 00       	.word	0x0006	; ????
     c52:	00 27       	eor	r16, r16
     c54:	d5 05       	cpc	r29, r5
     c56:	00 00       	nop
     c58:	03 6d       	ori	r16, 0xD3	; 211
     c5a:	06 00       	.word	0x0006	; ????
     c5c:	00 78       	andi	r16, 0x80	; 128
     c5e:	06 00       	.word	0x0006	; ????
     c60:	00 22       	and	r0, r16
     c62:	ad 05       	cpc	r26, r13
     c64:	00 00       	nop
     c66:	5a 06       	cpc	r5, r26
     c68:	00 00       	nop
     c6a:	01 00       	.word	0x0001	; ????
     c6c:	0e 02       	muls	r16, r30
     c6e:	83 01       	movw	r16, r6
     c70:	00 00       	nop
     c72:	27 ba       	out	0x17, r2	; 23
     c74:	01 00       	.word	0x0001	; ????
     c76:	00 03       	mulsu	r16, r16
     c78:	8c 06       	cpc	r8, r28
     c7a:	00 00       	nop
     c7c:	97 06       	cpc	r9, r23
     c7e:	00 00       	nop
     c80:	22 ad       	ldd	r18, Z+58	; 0x3a
     c82:	05 00       	.word	0x0005	; ????
     c84:	00 97       	sbiw	r24, 0x00	; 0
     c86:	06 00       	.word	0x0006	; ????
     c88:	00 01       	movw	r0, r0
     c8a:	00 17       	cp	r16, r16
     c8c:	78 06       	cpc	r7, r24
     c8e:	00 00       	nop
     c90:	28 78       	andi	r18, 0x88	; 136
     c92:	05 00       	.word	0x0005	; ????
     c94:	00 01       	movw	r0, r0
     c96:	01 01       	movw	r0, r2
     c98:	bf 06       	cpc	r11, r31
     c9a:	00 00       	nop
     c9c:	29 09       	sbc	r18, r9
     c9e:	04 00       	.word	0x0004	; ????
     ca0:	00 04       	cpc	r0, r0
     ca2:	4d 3a       	cpi	r20, 0xAD	; 173
     ca4:	00 00       	nop
     ca6:	00 29       	or	r16, r0
     ca8:	a2 05       	cpc	r26, r2
     caa:	00 00       	nop
     cac:	04 4d       	sbci	r16, 0xD4	; 212
     cae:	3a 00       	.word	0x003a	; ????
     cb0:	00 00       	nop
     cb2:	00 27       	eor	r16, r16
     cb4:	d9 03       	fmulsu	r21, r17
     cb6:	00 00       	nop
     cb8:	01 cd       	rjmp	.-1534   	; 0x6bc <_GLOBAL__sub_I___vector_18+0x2c>
     cba:	06 00       	.word	0x0006	; ????
     cbc:	00 f9       	bld	r16, 0
     cbe:	06 00       	.word	0x0006	; ????
     cc0:	00 22       	and	r0, r16
     cc2:	ad 05       	cpc	r26, r13
     cc4:	00 00       	nop
     cc6:	68 05       	cpc	r22, r8
     cc8:	00 00       	nop
     cca:	01 29       	or	r16, r1
     ccc:	c7 03       	fmuls	r20, r23
     cce:	00 00       	nop
     cd0:	03 75       	andi	r16, 0x53	; 83
     cd2:	37 02       	muls	r19, r23
     cd4:	00 00       	nop
     cd6:	29 05       	cpc	r18, r9
     cd8:	03 00       	.word	0x0003	; ????
     cda:	00 03       	mulsu	r16, r16
     cdc:	75 31       	cpi	r23, 0x15	; 21
     cde:	05 00       	.word	0x0005	; ????
     ce0:	00 2a       	or	r0, r16
     ce2:	e3 05       	cpc	r30, r3
     ce4:	00 00       	nop
     ce6:	03 78       	andi	r16, 0x83	; 131
     ce8:	3c 05       	cpc	r19, r12
     cea:	00 00       	nop
     cec:	00 13       	cpse	r16, r16
     cee:	d4 05       	cpc	r29, r4
     cf0:	00 00       	nop
     cf2:	01 1d       	adc	r16, r1
     cf4:	07 00       	.word	0x0007	; ????
     cf6:	00 12       	cpse	r0, r16
     cf8:	8f 02       	muls	r24, r31
     cfa:	00 00       	nop
     cfc:	0e 79       	andi	r16, 0x9E	; 158
     cfe:	01 01       	movw	r0, r2
     d00:	10 07       	cpc	r17, r16
     d02:	00 00       	nop
     d04:	0a 1d       	adc	r16, r10
     d06:	07 00       	.word	0x0007	; ????
     d08:	00 01       	movw	r0, r0
     d0a:	0b 37       	cpi	r16, 0x7B	; 123
     d0c:	02 00       	.word	0x0002	; ????
     d0e:	00 00       	nop
     d10:	00 0e       	add	r0, r16
     d12:	02 f9       	bld	r16, 2
     d14:	06 00       	.word	0x0006	; ????
     d16:	00 27       	eor	r16, r16
     d18:	03 07       	cpc	r16, r19
     d1a:	00 00       	nop
     d1c:	03 31       	cpi	r16, 0x13	; 19
     d1e:	07 00       	.word	0x0007	; ????
     d20:	00 47       	sbci	r16, 0x70	; 112
     d22:	07 00       	.word	0x0007	; ????
     d24:	00 22       	and	r0, r16
     d26:	ad 05       	cpc	r26, r13
     d28:	00 00       	nop
     d2a:	47 07       	cpc	r20, r23
     d2c:	00 00       	nop
     d2e:	01 29       	or	r16, r1
     d30:	c7 03       	fmuls	r20, r23
     d32:	00 00       	nop
     d34:	0e 79       	andi	r16, 0x9E	; 158
     d36:	37 02       	muls	r19, r23
     d38:	00 00       	nop
     d3a:	00 17       	cp	r16, r16
     d3c:	1d 07       	cpc	r17, r29
     d3e:	00 00       	nop
     d40:	0e 02       	muls	r16, r30
     d42:	41 00       	.word	0x0041	; ????
     d44:	00 00       	nop
     d46:	27 6d       	ori	r18, 0xD7	; 215
     d48:	00 00       	nop
     d4a:	00 01       	movw	r0, r0
     d4c:	60 07       	cpc	r22, r16
     d4e:	00 00       	nop
     d50:	6b 07       	cpc	r22, r27
     d52:	00 00       	nop
     d54:	22 ad       	ldd	r18, Z+58	; 0x3a
     d56:	05 00       	.word	0x0005	; ????
     d58:	00 6b       	ori	r16, 0xB0	; 176
     d5a:	07 00       	.word	0x0007	; ????
     d5c:	00 01       	movw	r0, r0
     d5e:	00 17       	cp	r16, r16
     d60:	4c 07       	cpc	r20, r28
     d62:	00 00       	nop
     d64:	27 89       	ldd	r18, Z+23	; 0x17
     d66:	00 00       	nop
     d68:	00 01       	movw	r0, r0
     d6a:	7e 07       	cpc	r23, r30
     d6c:	00 00       	nop
     d6e:	9b 07       	cpc	r25, r27
     d70:	00 00       	nop
     d72:	22 ad       	ldd	r18, Z+58	; 0x3a
     d74:	05 00       	.word	0x0005	; ????
     d76:	00 6b       	ori	r16, 0xB0	; 176
     d78:	07 00       	.word	0x0007	; ????
     d7a:	00 01       	movw	r0, r0
     d7c:	23 63       	ori	r18, 0x33	; 51
     d7e:	00 01       	movw	r0, r0
     d80:	8a 3e       	cpi	r24, 0xEA	; 234
     d82:	02 00       	.word	0x0002	; ????
     d84:	00 24       	eor	r0, r0
     d86:	6e 00       	.word	0x006e	; ????
     d88:	01 8c       	ldd	r0, Z+25	; 0x19
     d8a:	6a 01       	movw	r12, r20
     d8c:	00 00       	nop
     d8e:	00 27       	eor	r16, r16
     d90:	aa 00       	.word	0x00aa	; ????
     d92:	00 00       	nop
     d94:	01 a9       	ldd	r16, Z+49	; 0x31
     d96:	07 00       	.word	0x0007	; ????
     d98:	00 c8       	rjmp	.-4096   	; 0xfffffd9a <__eeprom_end+0xff7efd9a>
     d9a:	07 00       	.word	0x0007	; ????
     d9c:	00 22       	and	r0, r16
     d9e:	ad 05       	cpc	r26, r13
     da0:	00 00       	nop
     da2:	6b 07       	cpc	r22, r27
     da4:	00 00       	nop
     da6:	01 23       	and	r16, r17
     da8:	6e 00       	.word	0x006e	; ????
     daa:	01 67       	ori	r16, 0x71	; 113
     dac:	37 02       	muls	r19, r23
     dae:	00 00       	nop
     db0:	29 ef       	ldi	r18, 0xF9	; 249
     db2:	06 00       	.word	0x0006	; ????
     db4:	00 01       	movw	r0, r0
     db6:	67 3a       	cpi	r22, 0xA7	; 167
     db8:	00 00       	nop
     dba:	00 00       	nop
     dbc:	27 d0       	rcall	.+78     	; 0xe0c <__stack+0x50d>
     dbe:	00 00       	nop
     dc0:	00 01       	movw	r0, r0
     dc2:	d6 07       	cpc	r29, r22
     dc4:	00 00       	nop
     dc6:	ec 07       	cpc	r30, r28
     dc8:	00 00       	nop
     dca:	22 ad       	ldd	r18, Z+58	; 0x3a
     dcc:	05 00       	.word	0x0005	; ????
     dce:	00 6b       	ori	r16, 0xB0	; 176
     dd0:	07 00       	.word	0x0007	; ????
     dd2:	00 01       	movw	r0, r0
     dd4:	23 73       	andi	r18, 0x33	; 51
     dd6:	74 72       	andi	r23, 0x24	; 36
     dd8:	00 01       	movw	r0, r0
     dda:	3e 3e       	cpi	r19, 0xEE	; 238
     ddc:	02 00       	.word	0x0002	; ????
     dde:	00 00       	nop
     de0:	27 f1       	brie	.+72     	; 0xe2a <__stack+0x52b>
     de2:	00 00       	nop
     de4:	00 01       	movw	r0, r0
     de6:	fa 07       	cpc	r31, r26
     de8:	00 00       	nop
     dea:	3a 08       	sbc	r3, r10
     dec:	00 00       	nop
     dee:	22 ad       	ldd	r18, Z+58	; 0x3a
     df0:	05 00       	.word	0x0005	; ????
     df2:	00 6b       	ori	r16, 0xB0	; 176
     df4:	07 00       	.word	0x0007	; ????
     df6:	00 01       	movw	r0, r0
     df8:	23 6e       	ori	r18, 0xE3	; 227
     dfa:	00 01       	movw	r0, r0
     dfc:	cb 37       	cpi	r28, 0x7B	; 123
     dfe:	02 00       	.word	0x0002	; ????
     e00:	00 29       	or	r16, r0
     e02:	ef 06       	cpc	r14, r31
     e04:	00 00       	nop
     e06:	01 cb       	rjmp	.-2558   	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     e08:	87 02       	muls	r24, r23
     e0a:	00 00       	nop
     e0c:	24 62       	ori	r18, 0x24	; 36
     e0e:	75 66       	ori	r23, 0x65	; 101
     e10:	00 01       	movw	r0, r0
     e12:	cd 3a       	cpi	r28, 0xAD	; 173
     e14:	08 00       	.word	0x0008	; ????
     e16:	00 24       	eor	r0, r0
     e18:	73 74       	andi	r23, 0x43	; 67
     e1a:	72 00       	.word	0x0072	; ????
     e1c:	01 ce       	rjmp	.-1022   	; 0xa20 <__stack+0x121>
     e1e:	4a 08       	sbc	r4, r10
     e20:	00 00       	nop
     e22:	25 24       	eor	r2, r5
     e24:	63 00       	.word	0x0063	; ????
     e26:	01 d6       	rcall	.+3074   	; 0x1a2a <__stack+0x112b>
     e28:	7c 01       	movw	r14, r24
     e2a:	00 00       	nop
     e2c:	00 00       	nop
     e2e:	1f 7c       	andi	r17, 0xCF	; 207
     e30:	01 00       	.word	0x0001	; ????
     e32:	00 4a       	sbci	r16, 0xA0	; 160
     e34:	08 00       	.word	0x0008	; ????
     e36:	00 20       	and	r0, r0
     e38:	2a 05       	cpc	r18, r10
     e3a:	00 00       	nop
     e3c:	20 00       	.word	0x0020	; ????
     e3e:	0e 02       	muls	r16, r30
     e40:	7c 01       	movw	r14, r24
     e42:	00 00       	nop
     e44:	27 18       	sub	r2, r7
     e46:	01 00       	.word	0x0001	; ????
     e48:	00 03       	mulsu	r16, r16
     e4a:	5e 08       	sbc	r5, r14
     e4c:	00 00       	nop
     e4e:	74 08       	sbc	r7, r4
     e50:	00 00       	nop
     e52:	22 ad       	ldd	r18, Z+58	; 0x3a
     e54:	05 00       	.word	0x0005	; ????
     e56:	00 6b       	ori	r16, 0xB0	; 176
     e58:	07 00       	.word	0x0007	; ????
     e5a:	00 01       	movw	r0, r0
     e5c:	23 73       	andi	r18, 0x33	; 51
     e5e:	74 72       	andi	r23, 0x24	; 36
     e60:	00 02       	muls	r16, r16
     e62:	34 3e       	cpi	r19, 0xE4	; 228
     e64:	02 00       	.word	0x0002	; ????
     e66:	00 00       	nop
     e68:	0e 02       	muls	r16, r30
     e6a:	7a 08       	sbc	r7, r10
     e6c:	00 00       	nop
     e6e:	17 87       	std	Z+15, r17	; 0x0f
     e70:	02 00       	.word	0x0002	; ????
     e72:	00 2b       	or	r16, r16
     e74:	39 01       	movw	r6, r18
     e76:	00 00       	nop
     e78:	be 00       	.word	0x00be	; ????
     e7a:	00 00       	nop
     e7c:	12 01       	movw	r2, r4
     e7e:	00 00       	nop
     e80:	00 00       	nop
     e82:	00 00       	nop
     e84:	99 08       	sbc	r9, r9
     e86:	00 00       	nop
     e88:	01 e4       	ldi	r16, 0x41	; 65
     e8a:	08 00       	.word	0x0008	; ????
     e8c:	00 2c       	mov	r0, r0
     e8e:	ad 05       	cpc	r26, r13
     e90:	00 00       	nop
     e92:	6b 07       	cpc	r22, r27
     e94:	00 00       	nop
     e96:	01 7d       	andi	r16, 0xD1	; 209
     e98:	00 00       	nop
     e9a:	00 2d       	mov	r16, r0
     e9c:	dd 06       	cpc	r13, r29
     e9e:	00 00       	nop
     ea0:	01 22       	and	r0, r17
     ea2:	74 08       	sbc	r7, r4
     ea4:	00 00       	nop
     ea6:	b3 00       	.word	0x00b3	; ????
     ea8:	00 00       	nop
     eaa:	2d 4f       	sbci	r18, 0xFD	; 253
     eac:	06 00       	.word	0x0006	; ????
     eae:	00 01       	movw	r0, r0
     eb0:	22 6a       	ori	r18, 0xA2	; 162
     eb2:	01 00       	.word	0x0001	; ????
     eb4:	00 13       	cpse	r16, r16
     eb6:	01 00       	.word	0x0001	; ????
     eb8:	00 2e       	mov	r0, r16
     eba:	6e 00       	.word	0x006e	; ????
     ebc:	01 24       	eor	r0, r1
     ebe:	6a 01       	movw	r12, r20
     ec0:	00 00       	nop
     ec2:	6f 01       	movw	r12, r30
     ec4:	00 00       	nop
     ec6:	2f f4       	brid	.+10     	; 0xed2 <__stack+0x5d3>
     ec8:	00 00       	nop
     eca:	00 30       	cpi	r16, 0x00	; 0
     ecc:	06 68       	ori	r16, 0x86	; 134
     ece:	93 01       	movw	r18, r6
     ed0:	69 93       	st	Y+, r22
     ed2:	01 02       	muls	r16, r17
     ed4:	7c 00       	.word	0x007c	; ????
     ed6:	00 00       	nop
     ed8:	0e 02       	muls	r16, r30
     eda:	cf 01       	movw	r24, r30
     edc:	00 00       	nop
     ede:	31 d9       	rcall	.-3486   	; 0x142 <_ZN14HardwareSerial4readEv+0xa>
     ee0:	01 00       	.word	0x0001	; ????
     ee2:	00 12       	cpse	r0, r16
     ee4:	01 00       	.word	0x0001	; ????
     ee6:	00 14       	cp	r0, r0
     ee8:	01 00       	.word	0x0001	; ????
     eea:	00 03       	mulsu	r16, r16
     eec:	92 20       	and	r9, r2
     eee:	02 04       	cpc	r0, r2
     ef0:	09 00       	.word	0x0009	; ????
     ef2:	00 01       	movw	r0, r0
     ef4:	16 09       	sbc	r17, r6
     ef6:	00 00       	nop
     ef8:	32 ad       	ldd	r19, Z+58	; 0x3a
     efa:	05 00       	.word	0x0005	; ????
     efc:	00 16       	cp	r0, r16
     efe:	09 00       	.word	0x0009	; ????
     f00:	00 01       	movw	r0, r0
     f02:	06 68       	ori	r16, 0x86	; 134
     f04:	93 01       	movw	r18, r6
     f06:	69 93       	st	Y+, r22
     f08:	01 00       	.word	0x0001	; ????
     f0a:	17 e4       	ldi	r17, 0x47	; 71
     f0c:	08 00       	.word	0x0008	; ????
     f0e:	00 31       	cpi	r16, 0x10	; 16
     f10:	f9 01       	movw	r30, r18
     f12:	00 00       	nop
     f14:	14 01       	movw	r2, r8
     f16:	00 00       	nop
     f18:	1a 01       	movw	r2, r20
     f1a:	00 00       	nop
     f1c:	03 92       	.word	0x9203	; ????
     f1e:	20 02       	muls	r18, r16
     f20:	35 09       	sbc	r19, r5
     f22:	00 00       	nop
     f24:	01 44       	sbci	r16, 0x41	; 65
     f26:	09 00       	.word	0x0009	; ????
     f28:	00 2c       	mov	r0, r0
     f2a:	ad 05       	cpc	r26, r13
     f2c:	00 00       	nop
     f2e:	16 09       	sbc	r17, r6
     f30:	00 00       	nop
     f32:	01 93       	st	Z+, r16
     f34:	01 00       	.word	0x0001	; ????
     f36:	00 00       	nop
     f38:	31 fb       	bst	r19, 1
     f3a:	03 00       	.word	0x0003	; ????
     f3c:	00 1a       	sub	r0, r16
     f3e:	01 00       	.word	0x0001	; ????
     f40:	00 38       	cpi	r16, 0x80	; 128
     f42:	01 00       	.word	0x0001	; ????
     f44:	00 03       	mulsu	r16, r16
     f46:	92 20       	and	r9, r2
     f48:	02 5e       	subi	r16, 0xE2	; 226
     f4a:	09 00       	.word	0x0009	; ????
     f4c:	00 01       	movw	r0, r0
     f4e:	87 09       	sbc	r24, r7
     f50:	00 00       	nop
     f52:	2c ad       	ldd	r18, Y+60	; 0x3c
     f54:	05 00       	.word	0x0005	; ????
     f56:	00 68       	ori	r16, 0x80	; 128
     f58:	05 00       	.word	0x0005	; ????
     f5a:	00 01       	movw	r0, r0
     f5c:	b9 01       	movw	r22, r18
     f5e:	00 00       	nop
     f60:	33 41       	sbci	r19, 0x13	; 19
     f62:	03 00       	.word	0x0003	; ????
     f64:	00 03       	mulsu	r16, r16
     f66:	c2 99       	sbic	0x18, 2	; 24
     f68:	02 00       	.word	0x0002	; ????
     f6a:	00 01       	movw	r0, r0
     f6c:	65 33       	cpi	r22, 0x35	; 53
     f6e:	23 02       	muls	r18, r19
     f70:	00 00       	nop
     f72:	03 c3       	rjmp	.+1542   	; 0x157a <__stack+0xc7b>
     f74:	99 02       	muls	r25, r25
     f76:	00 00       	nop
     f78:	01 64       	ori	r16, 0x41	; 65
     f7a:	00 31       	cpi	r16, 0x10	; 16
     f7c:	1f 04       	cpc	r1, r15
     f7e:	00 00       	nop
     f80:	38 01       	movw	r6, r16
     f82:	00 00       	nop
     f84:	60 01       	movw	r12, r0
     f86:	00 00       	nop
     f88:	03 92       	.word	0x9203	; ????
     f8a:	20 02       	muls	r18, r16
     f8c:	a1 09       	sbc	r26, r1
     f8e:	00 00       	nop
     f90:	01 c7       	rjmp	.+3586   	; 0x1d94 <__stack+0x1495>
     f92:	09 00       	.word	0x0009	; ????
     f94:	00 2c       	mov	r0, r0
     f96:	ad 05       	cpc	r26, r13
     f98:	00 00       	nop
     f9a:	68 05       	cpc	r22, r8
     f9c:	00 00       	nop
     f9e:	01 e1       	ldi	r16, 0x11	; 17
     fa0:	01 00       	.word	0x0001	; ????
     fa2:	00 34       	cpi	r16, 0x40	; 64
     fa4:	42 01       	movw	r8, r4
     fa6:	00 00       	nop
     fa8:	5a 01       	movw	r10, r20
     faa:	00 00       	nop
     fac:	2e 63       	ori	r18, 0x3E	; 62
     fae:	00 03       	mulsu	r16, r16
     fb0:	ba 92       	st	-Y, r11
     fb2:	02 00       	.word	0x0002	; ????
     fb4:	00 09       	sbc	r16, r0
     fb6:	02 00       	.word	0x0002	; ????
     fb8:	00 00       	nop
     fba:	00 31       	cpi	r16, 0x10	; 16
     fbc:	43 04       	cpc	r4, r3
     fbe:	00 00       	nop
     fc0:	60 01       	movw	r12, r0
     fc2:	00 00       	nop
     fc4:	7c 01       	movw	r14, r24
     fc6:	00 00       	nop
     fc8:	03 92       	.word	0x9203	; ????
     fca:	20 02       	muls	r18, r16
     fcc:	e1 09       	sbc	r30, r1
     fce:	00 00       	nop
     fd0:	01 f0       	breq	.+0      	; 0xfd2 <__stack+0x6d3>
     fd2:	09 00       	.word	0x0009	; ????
     fd4:	00 2c       	mov	r0, r0
     fd6:	ad 05       	cpc	r26, r13
     fd8:	00 00       	nop
     fda:	68 05       	cpc	r22, r8
     fdc:	00 00       	nop
     fde:	01 1c       	adc	r0, r1
     fe0:	02 00       	.word	0x0002	; ????
     fe2:	00 00       	nop
     fe4:	31 67       	ori	r19, 0x71	; 113
     fe6:	04 00       	.word	0x0004	; ????
     fe8:	00 7c       	andi	r16, 0xC0	; 192
     fea:	01 00       	.word	0x0001	; ????
     fec:	00 94       	com	r0
     fee:	01 00       	.word	0x0001	; ????
     ff0:	00 03       	mulsu	r16, r16
     ff2:	92 20       	and	r9, r2
     ff4:	02 0a       	sbc	r0, r18
     ff6:	0a 00       	.word	0x000a	; ????
     ff8:	00 01       	movw	r0, r0
     ffa:	19 0a       	sbc	r1, r25
     ffc:	00 00       	nop
     ffe:	2c ad       	ldd	r18, Y+60	; 0x3c
    1000:	05 00       	.word	0x0005	; ????
    1002:	00 68       	ori	r16, 0x80	; 128
    1004:	05 00       	.word	0x0005	; ????
    1006:	00 01       	movw	r0, r0
    1008:	62 02       	muls	r22, r18
    100a:	00 00       	nop
    100c:	00 35       	cpi	r16, 0x50	; 80
    100e:	61 02       	muls	r22, r17
    1010:	00 00       	nop
    1012:	04 4b       	sbci	r16, 0xB4	; 180
    1014:	01 af       	std	Z+57, r16	; 0x39
    1016:	02 00       	.word	0x0002	; ????
    1018:	00 94       	com	r0
    101a:	01 00       	.word	0x0001	; ????
    101c:	00 a8       	ldd	r0, Z+48	; 0x30
    101e:	01 00       	.word	0x0001	; ????
    1020:	00 03       	mulsu	r16, r16
    1022:	92 20       	and	r9, r2
    1024:	02 01       	movw	r0, r4
    1026:	4f 0a       	sbc	r4, r31
    1028:	00 00       	nop
    102a:	36 9c       	mul	r3, r6
    102c:	01 00       	.word	0x0001	; ????
    102e:	00 f0       	brcs	.+0      	; 0x1030 <__stack+0x731>
    1030:	09 00       	.word	0x0009	; ????
    1032:	00 30       	cpi	r16, 0x00	; 0
    1034:	06 68       	ori	r16, 0x86	; 134
    1036:	93 01       	movw	r18, r6
    1038:	69 93       	st	Y+, r22
    103a:	01 05       	cpc	r16, r1
    103c:	03 3d       	cpi	r16, 0xD3	; 211
    103e:	01 80       	ldd	r0, Z+1	; 0x01
    1040:	00 00       	nop
    1042:	00 21       	and	r16, r0
    1044:	8b 04       	cpc	r8, r11
    1046:	00 00       	nop
    1048:	03 59       	subi	r16, 0x93	; 147
    104a:	01 5f       	subi	r16, 0xF1	; 241
    104c:	0a 00       	.word	0x000a	; ????
    104e:	00 73       	andi	r16, 0x30	; 48
    1050:	0a 00       	.word	0x000a	; ????
    1052:	00 22       	and	r0, r16
    1054:	ad 05       	cpc	r26, r13
    1056:	00 00       	nop
    1058:	68 05       	cpc	r22, r8
    105a:	00 00       	nop
    105c:	01 24       	eor	r0, r1
    105e:	63 00       	.word	0x0063	; ????
    1060:	03 5d       	subi	r16, 0xD3	; 211
    1062:	92 02       	muls	r25, r18
    1064:	00 00       	nop
    1066:	00 27       	eor	r16, r16
    1068:	a2 04       	cpc	r10, r2
    106a:	00 00       	nop
    106c:	01 81       	ldd	r16, Z+1	; 0x01
    106e:	0a 00       	.word	0x000a	; ????
    1070:	00 a3       	std	Z+32, r16	; 0x20
    1072:	0a 00       	.word	0x000a	; ????
    1074:	00 22       	and	r0, r16
    1076:	ad 05       	cpc	r26, r13
    1078:	00 00       	nop
    107a:	68 05       	cpc	r22, r8
    107c:	00 00       	nop
    107e:	01 24       	eor	r0, r1
    1080:	63 00       	.word	0x0063	; ????
    1082:	03 5d       	subi	r16, 0xD3	; 211
    1084:	92 02       	muls	r25, r18
    1086:	00 00       	nop
    1088:	25 37       	cpi	r18, 0x75	; 117
    108a:	5f 0a       	sbc	r5, r31
    108c:	00 00       	nop
    108e:	25 38       	cpi	r18, 0x85	; 133
    1090:	69 0a       	sbc	r6, r25
    1092:	00 00       	nop
    1094:	00 00       	nop
    1096:	00 39       	cpi	r16, 0x90	; 144
    1098:	73 0a       	sbc	r7, r19
    109a:	00 00       	nop
    109c:	a8 01       	movw	r20, r16
    109e:	00 00       	nop
    10a0:	ec 01       	movw	r28, r24
    10a2:	00 00       	nop
    10a4:	03 92       	.word	0x9203	; ????
    10a6:	20 02       	muls	r18, r16
    10a8:	bd 0a       	sbc	r11, r29
    10aa:	00 00       	nop
    10ac:	01 f0       	breq	.+0      	; 0x10ae <__stack+0x7af>
    10ae:	0a 00       	.word	0x000a	; ????
    10b0:	00 3a       	cpi	r16, 0xA0	; 160
    10b2:	81 0a       	sbc	r8, r17
    10b4:	00 00       	nop
    10b6:	8a 02       	muls	r24, r26
    10b8:	00 00       	nop
    10ba:	3b 8b       	std	Y+19, r19	; 0x13
    10bc:	0a 00       	.word	0x000a	; ????
    10be:	00 01       	movw	r0, r0
    10c0:	62 34       	cpi	r22, 0x42	; 66
    10c2:	de 01       	movw	r26, r28
    10c4:	00 00       	nop
    10c6:	ec 01       	movw	r28, r24
    10c8:	00 00       	nop
    10ca:	3a 5f       	subi	r19, 0xFA	; 250
    10cc:	0a 00       	.word	0x000a	; ????
    10ce:	00 c0       	rjmp	.+0      	; 0x10d0 <__stack+0x7d1>
    10d0:	02 00       	.word	0x0002	; ????
    10d2:	00 34       	cpi	r16, 0x40	; 64
    10d4:	de 01       	movw	r26, r28
    10d6:	00 00       	nop
    10d8:	ec 01       	movw	r28, r24
    10da:	00 00       	nop
    10dc:	38 69       	ori	r19, 0x98	; 152
    10de:	0a 00       	.word	0x000a	; ????
    10e0:	00 00       	nop
    10e2:	00 00       	nop
    10e4:	27 ba       	out	0x17, r2	; 23
    10e6:	04 00       	.word	0x0004	; ????
    10e8:	00 01       	movw	r0, r0
    10ea:	fe 0a       	sbc	r15, r30
    10ec:	00 00       	nop
    10ee:	56 0b       	sbc	r21, r22
    10f0:	00 00       	nop
    10f2:	22 ad       	ldd	r18, Z+58	; 0x3a
    10f4:	05 00       	.word	0x0005	; ????
    10f6:	00 68       	ori	r16, 0x80	; 128
    10f8:	05 00       	.word	0x0005	; ????
    10fa:	00 01       	movw	r0, r0
    10fc:	23 63       	ori	r18, 0x33	; 51
    10fe:	00 03       	mulsu	r16, r16
    1100:	e1 87       	std	Z+9, r30	; 0x09
    1102:	02 00       	.word	0x0002	; ????
    1104:	00 24       	eor	r0, r0
    1106:	69 00       	.word	0x0069	; ????
    1108:	03 fb       	bst	r16, 3
    110a:	99 02       	muls	r25, r25
    110c:	00 00       	nop
    110e:	3c 3d       	cpi	r19, 0xDC	; 220
    1110:	0b 00       	.word	0x000b	; ????
    1112:	00 37       	cpi	r16, 0x70	; 112
    1114:	87 05       	cpc	r24, r7
    1116:	00 00       	nop
    1118:	37 7d       	andi	r19, 0xD7	; 215
    111a:	05 00       	.word	0x0005	; ????
    111c:	00 25       	eor	r16, r0
    111e:	38 90       	.word	0x9038	; ????
    1120:	05 00       	.word	0x0005	; ????
    1122:	00 25       	eor	r16, r0
    1124:	38 9a       	sbi	0x07, 0	; 7
    1126:	05 00       	.word	0x0005	; ????
    1128:	00 38       	cpi	r16, 0x80	; 128
    112a:	a6 05       	cpc	r26, r6
    112c:	00 00       	nop
    112e:	00 00       	nop
    1130:	00 25       	eor	r16, r0
    1132:	2a 54       	subi	r18, 0x4A	; 74
    1134:	06 00       	.word	0x0006	; ????
    1136:	00 03       	mulsu	r16, r16
    1138:	f1 87       	std	Z+9, r31	; 0x09
    113a:	02 00       	.word	0x0002	; ????
    113c:	00 2a       	or	r0, r16
    113e:	cd 05       	cpc	r28, r13
    1140:	00 00       	nop
    1142:	03 f1       	brvs	.+64     	; 0x1184 <__stack+0x885>
    1144:	87 02       	muls	r24, r23
    1146:	00 00       	nop
    1148:	00 00       	nop
    114a:	3d f0       	brhs	.+14     	; 0x115a <__stack+0x85b>
    114c:	0a 00       	.word	0x000a	; ????
    114e:	00 ec       	ldi	r16, 0xC0	; 192
    1150:	01 00       	.word	0x0001	; ????
    1152:	00 86       	std	Z+8, r0	; 0x08
    1154:	02 00       	.word	0x0002	; ????
    1156:	00 e6       	ldi	r16, 0x60	; 96
    1158:	02 00       	.word	0x0002	; ????
    115a:	00 70       	andi	r16, 0x00	; 0
    115c:	0b 00       	.word	0x000b	; ????
    115e:	00 01       	movw	r0, r0
    1160:	4d 0c       	add	r4, r13
    1162:	00 00       	nop
    1164:	3a fe       	.word	0xfe3a	; ????
    1166:	0a 00       	.word	0x000a	; ????
    1168:	00 49       	sbci	r16, 0x90	; 144
    116a:	03 00       	.word	0x0003	; ????
    116c:	00 3a       	cpi	r16, 0xA0	; 160
    116e:	08 0b       	sbc	r16, r24
    1170:	00 00       	nop
    1172:	7f 03       	fmul	r23, r23
    1174:	00 00       	nop
    1176:	38 11       	cpse	r19, r8
    1178:	0b 00       	.word	0x000b	; ????
    117a:	00 3e       	cpi	r16, 0xE0	; 224
    117c:	5c 02       	muls	r21, r28
    117e:	00 00       	nop
    1180:	74 02       	muls	r23, r20
    1182:	00 00       	nop
    1184:	d8 0b       	sbc	r29, r24
    1186:	00 00       	nop
    1188:	3f 3e       	cpi	r19, 0xEF	; 239
    118a:	0b 00       	.word	0x000b	; ????
    118c:	00 b6       	in	r0, 0x30	; 48
    118e:	03 00       	.word	0x0003	; ????
    1190:	00 3f       	cpi	r16, 0xF0	; 240
    1192:	49 0b       	sbc	r20, r25
    1194:	00 00       	nop
    1196:	c9 03       	fmulsu	r20, r17
    1198:	00 00       	nop
    119a:	40 4d       	sbci	r20, 0xD0	; 208
    119c:	0c 00       	.word	0x000c	; ????
    119e:	00 5e       	subi	r16, 0xE0	; 224
    11a0:	02 00       	.word	0x0002	; ????
    11a2:	00 60       	ori	r16, 0x00	; 0
    11a4:	02 00       	.word	0x0002	; ????
    11a6:	00 03       	mulsu	r16, r16
    11a8:	f1 41       	sbci	r31, 0x11	; 17
    11aa:	5a 0c       	add	r5, r10
    11ac:	00 00       	nop
    11ae:	72 02       	muls	r23, r18
    11b0:	00 00       	nop
    11b2:	74 02       	muls	r23, r20
    11b4:	00 00       	nop
    11b6:	03 f1       	brvs	.+64     	; 0x11f8 <__stack+0x8f9>
    11b8:	42 5f       	subi	r20, 0xF2	; 242
    11ba:	5f 73       	andi	r21, 0x3F	; 63
    11bc:	00 05       	cpc	r16, r0
    11be:	44 74       	andi	r20, 0x44	; 68
    11c0:	08 00       	.word	0x0008	; ????
    11c2:	00 06       	cpc	r0, r16
    11c4:	f2 32       	cpi	r31, 0x22	; 34
    11c6:	11 00       	.word	0x0011	; ????
    11c8:	00 00       	nop
    11ca:	00 00       	nop
    11cc:	34 12       	cpse	r3, r20
    11ce:	02 00       	.word	0x0002	; ????
    11d0:	00 5c       	subi	r16, 0xC0	; 192
    11d2:	02 00       	.word	0x0002	; ????
    11d4:	00 3a       	cpi	r16, 0xA0	; 160
    11d6:	87 05       	cpc	r24, r7
    11d8:	00 00       	nop
    11da:	e9 03       	fmulsu	r22, r17
    11dc:	00 00       	nop
    11de:	3a 7d       	andi	r19, 0xDA	; 218
    11e0:	05 00       	.word	0x0005	; ????
    11e2:	00 fc       	sbrc	r0, 0
    11e4:	03 00       	.word	0x0003	; ????
    11e6:	00 34       	cpi	r16, 0x40	; 64
    11e8:	12 02       	muls	r17, r18
    11ea:	00 00       	nop
    11ec:	5c 02       	muls	r21, r28
    11ee:	00 00       	nop
    11f0:	3f 90       	pop	r3
    11f2:	05 00       	.word	0x0005	; ????
    11f4:	00 14       	cp	r0, r0
    11f6:	04 00       	.word	0x0004	; ????
    11f8:	00 3e       	cpi	r16, 0xE0	; 224
    11fa:	4c 02       	muls	r20, r28
    11fc:	00 00       	nop
    11fe:	5c 02       	muls	r21, r28
    1200:	00 00       	nop
    1202:	35 0c       	add	r3, r5
    1204:	00 00       	nop
    1206:	3f 9a       	sbi	0x07, 7	; 7
    1208:	05 00       	.word	0x0005	; ????
    120a:	00 27       	eor	r16, r16
    120c:	04 00       	.word	0x0004	; ????
    120e:	00 3f       	cpi	r16, 0xF0	; 240
    1210:	a6 05       	cpc	r26, r6
    1212:	00 00       	nop
    1214:	3a 04       	cpc	r3, r10
    1216:	00 00       	nop
    1218:	43 4d       	sbci	r20, 0xD3	; 211
    121a:	0c 00       	.word	0x000c	; ????
    121c:	00 4e       	sbci	r16, 0xE0	; 224
    121e:	02 00       	.word	0x0002	; ????
    1220:	00 50       	subi	r16, 0x00	; 0
    1222:	02 00       	.word	0x0002	; ????
    1224:	00 03       	mulsu	r16, r16
    1226:	11 01       	movw	r2, r2
    1228:	00 36       	cpi	r16, 0x60	; 96
    122a:	3c 02       	muls	r19, r28
    122c:	00 00       	nop
    122e:	73 0a       	sbc	r7, r19
    1230:	00 00       	nop
    1232:	30 06       	cpc	r3, r16
    1234:	68 93       	.word	0x9368	; ????
    1236:	01 69       	ori	r16, 0x91	; 145
    1238:	93 01       	movw	r18, r6
    123a:	02 8c       	ldd	r0, Z+26	; 0x1a
    123c:	00 00       	nop
    123e:	00 00       	nop
    1240:	00 44       	sbci	r16, 0x40	; 64
    1242:	5e 06       	cpc	r5, r30
    1244:	00 00       	nop
    1246:	05 30       	cpi	r16, 0x05	; 5
    1248:	01 87       	std	Z+9, r16	; 0x09
    124a:	02 00       	.word	0x0002	; ????
    124c:	00 03       	mulsu	r16, r16
    124e:	45 f3       	brhs	.-48     	; 0x1220 <__stack+0x921>
    1250:	04 00       	.word	0x0004	; ????
    1252:	00 05       	cpc	r16, r0
    1254:	44 01       	movw	r8, r8
    1256:	03 27       	eor	r16, r19
    1258:	e3 04       	cpc	r14, r3
    125a:	00 00       	nop
    125c:	01 71       	andi	r16, 0x11	; 17
    125e:	0c 00       	.word	0x000c	; ????
    1260:	00 83       	st	Z, r16
    1262:	0c 00       	.word	0x000c	; ????
    1264:	00 22       	and	r0, r16
    1266:	ad 05       	cpc	r26, r13
    1268:	00 00       	nop
    126a:	68 05       	cpc	r22, r8
    126c:	00 00       	nop
    126e:	01 25       	eor	r16, r1
    1270:	37 5d       	subi	r19, 0xD7	; 215
    1272:	05 00       	.word	0x0005	; ????
    1274:	00 00       	nop
    1276:	00 3d       	cpi	r16, 0xD0	; 208
    1278:	63 0c       	add	r6, r3
    127a:	00 00       	nop
    127c:	86 02       	muls	r24, r22
    127e:	00 00       	nop
    1280:	ca 02       	muls	r28, r26
    1282:	00 00       	nop
    1284:	4e 04       	cpc	r4, r14
    1286:	00 00       	nop
    1288:	9d 0c       	add	r9, r13
    128a:	00 00       	nop
    128c:	01 cb       	rjmp	.-2558   	; 0x890 <__data_load_end+0x118>
    128e:	0c 00       	.word	0x000c	; ????
    1290:	00 3a       	cpi	r16, 0xA0	; 160
    1292:	71 0c       	add	r7, r1
    1294:	00 00       	nop
    1296:	7d 04       	cpc	r7, r13
    1298:	00 00       	nop
    129a:	34 92       	xch	Z, r3
    129c:	02 00       	.word	0x0002	; ????
    129e:	00 c4       	rjmp	.+2048   	; 0x1aa0 <__stack+0x11a1>
    12a0:	02 00       	.word	0x0002	; ????
    12a2:	00 37       	cpi	r16, 0x70	; 112
    12a4:	5d 05       	cpc	r21, r13
    12a6:	00 00       	nop
    12a8:	36 c2       	rjmp	.+1132   	; 0x1716 <__stack+0xe17>
    12aa:	02 00       	.word	0x0002	; ????
    12ac:	00 73       	andi	r16, 0x30	; 48
    12ae:	0a 00       	.word	0x000a	; ????
    12b0:	00 30       	cpi	r16, 0x00	; 0
    12b2:	06 68       	ori	r16, 0x86	; 134
    12b4:	93 01       	movw	r18, r6
    12b6:	69 93       	st	Y+, r22
    12b8:	01 02       	muls	r16, r17
    12ba:	8c 00       	.word	0x008c	; ????
    12bc:	00 00       	nop
    12be:	00 46       	sbci	r16, 0x60	; 96
    12c0:	14 03       	mulsu	r17, r20
    12c2:	00 00       	nop
    12c4:	03 40       	sbci	r16, 0x03	; 3
    12c6:	01 ca       	rjmp	.-3070   	; 0x6ca <_GLOBAL__sub_I___vector_18+0x3a>
    12c8:	02 00       	.word	0x0002	; ????
    12ca:	00 de       	rcall	.-1024   	; 0xecc <__stack+0x5cd>
    12cc:	02 00       	.word	0x0002	; ????
    12ce:	00 03       	mulsu	r16, r16
    12d0:	92 20       	and	r9, r2
    12d2:	02 01       	movw	r0, r4
    12d4:	f4 0c       	add	r15, r4
    12d6:	00 00       	nop
    12d8:	47 d6       	rcall	.+3214   	; 0x1f68 <__stack+0x1669>
    12da:	02 00       	.word	0x0002	; ????
    12dc:	00 19       	sub	r16, r0
    12de:	0a 00       	.word	0x000a	; ????
    12e0:	00 48       	sbci	r16, 0x80	; 128
    12e2:	dc 02       	muls	r29, r28
    12e4:	00 00       	nop
    12e6:	01 00       	.word	0x0001	; ????
    12e8:	49 50       	subi	r20, 0x09	; 9
    12ea:	08 00       	.word	0x0008	; ????
    12ec:	00 de       	rcall	.-1024   	; 0xeee <__stack+0x5ef>
    12ee:	02 00       	.word	0x0002	; ????
    12f0:	00 02       	muls	r16, r16
    12f2:	03 00       	.word	0x0003	; ????
    12f4:	00 03       	mulsu	r16, r16
    12f6:	92 20       	and	r9, r2
    12f8:	02 01       	movw	r0, r4
    12fa:	45 0d       	add	r20, r5
    12fc:	00 00       	nop
    12fe:	3a 68       	ori	r19, 0x8A	; 138
    1300:	08 00       	.word	0x0008	; ????
    1302:	00 b3       	in	r16, 0x10	; 16
    1304:	04 00       	.word	0x0004	; ????
    1306:	00 4a       	sbci	r16, 0xA0	; 160
    1308:	5e 08       	sbc	r5, r14
    130a:	00 00       	nop
    130c:	06 03       	mulsu	r16, r22
    130e:	3d 01       	movw	r6, r26
    1310:	80 00       	.word	0x0080	; ????
    1312:	9f 4b       	sbci	r25, 0xBF	; 191
    1314:	fc 02       	muls	r31, r28
    1316:	00 00       	nop
    1318:	01 7f       	andi	r16, 0xF1	; 241
    131a:	08 00       	.word	0x0008	; ????
    131c:	00 30       	cpi	r16, 0x00	; 0
    131e:	06 68       	ori	r16, 0x86	; 134
    1320:	93 01       	movw	r18, r6
    1322:	69 93       	st	Y+, r22
    1324:	01 05       	cpc	r16, r1
    1326:	03 3d       	cpi	r16, 0xD3	; 211
    1328:	01 80       	ldd	r0, Z+1	; 0x01
    132a:	00 30       	cpi	r16, 0x00	; 0
    132c:	06 66       	ori	r16, 0x66	; 102
    132e:	93 01       	movw	r18, r6
    1330:	67 93       	lat	Z, r22
    1332:	01 03       	mulsu	r16, r17
    1334:	f3 01       	movw	r30, r6
    1336:	68 00       	.word	0x0068	; ????
    1338:	00 4c       	sbci	r16, 0xC0	; 192
    133a:	ec 07       	cpc	r30, r28
    133c:	00 00       	nop
    133e:	02 03       	mulsu	r16, r18
    1340:	00 00       	nop
    1342:	84 03       	fmuls	r16, r20
    1344:	00 00       	nop
    1346:	07 05       	cpc	r16, r7
    1348:	00 00       	nop
    134a:	01 b7       	in	r16, 0x31	; 49
    134c:	0d 00       	.word	0x000d	; ????
    134e:	00 3a       	cpi	r16, 0xA0	; 160
    1350:	04 08       	sbc	r0, r4
    1352:	00 00       	nop
    1354:	9c 05       	cpc	r25, r12
    1356:	00 00       	nop
    1358:	3a 0d       	add	r19, r10
    135a:	08 00       	.word	0x0008	; ????
    135c:	00 e6       	ldi	r16, 0x60	; 96
    135e:	05 00       	.word	0x0005	; ????
    1360:	00 3b       	cpi	r16, 0xB0	; 176
    1362:	18 08       	sbc	r1, r8
    1364:	00 00       	nop
    1366:	02 8c       	ldd	r0, Z+26	; 0x1a
    1368:	01 3f       	cpi	r16, 0xF1	; 241
    136a:	23 08       	sbc	r2, r3
    136c:	00 00       	nop
    136e:	07 06       	cpc	r0, r23
    1370:	00 00       	nop
    1372:	4a fa       	.word	0xfa4a	; ????
    1374:	07 00       	.word	0x0007	; ????
    1376:	00 06       	cpc	r0, r16
    1378:	03 3d       	cpi	r16, 0xD3	; 211
    137a:	01 80       	ldd	r0, Z+1	; 0x01
    137c:	00 9f       	mul	r16, r16
    137e:	3e 30       	cpi	r19, 0x0E	; 14
    1380:	03 00       	.word	0x0003	; ????
    1382:	00 58       	subi	r16, 0x80	; 128
    1384:	03 00       	.word	0x0003	; ????
    1386:	00 a1       	ldd	r16, Z+32	; 0x20
    1388:	0d 00       	.word	0x000d	; ????
    138a:	00 3f       	cpi	r16, 0xF0	; 240
    138c:	2f 08       	sbc	r2, r15
    138e:	00 00       	nop
    1390:	2c 06       	cpc	r2, r28
    1392:	00 00       	nop
    1394:	00 36       	cpi	r16, 0x60	; 96
    1396:	66 03       	mulsu	r22, r22
    1398:	00 00       	nop
    139a:	f4 0c       	add	r15, r4
    139c:	00 00       	nop
    139e:	30 06       	cpc	r3, r16
    13a0:	68 93       	.word	0x9368	; ????
    13a2:	01 69       	ori	r16, 0x91	; 145
    13a4:	93 01       	movw	r18, r6
    13a6:	02 80       	ldd	r0, Z+2	; 0x02
    13a8:	00 00       	nop
    13aa:	00 4d       	sbci	r16, 0xD0	; 208
    13ac:	f2 02       	muls	r31, r18
    13ae:	00 00       	nop
    13b0:	06 18       	sub	r0, r6
    13b2:	01 01       	movw	r0, r2
    13b4:	84 03       	fmuls	r16, r20
    13b6:	00 00       	nop
    13b8:	88 03       	fmulsu	r16, r16
    13ba:	00 00       	nop
    13bc:	03 92       	.word	0x9203	; ????
    13be:	20 02       	muls	r18, r16
    13c0:	01 d7       	rcall	.+3586   	; 0x21c4 <__stack+0x18c5>
    13c2:	0d 00       	.word	0x000d	; ????
    13c4:	00 4e       	sbci	r16, 0xE0	; 224
    13c6:	88 03       	fmulsu	r16, r16
    13c8:	00 00       	nop
    13ca:	00 4f       	sbci	r16, 0xF0	; 240
    13cc:	01 33       	cpi	r16, 0x31	; 49
    13ce:	06 00       	.word	0x0006	; ????
    13d0:	00 07       	cpc	r16, r16
    13d2:	2d 01       	movw	r4, r26
    13d4:	88 03       	fmulsu	r16, r16
    13d6:	00 00       	nop
    13d8:	1c 04       	cpc	r1, r12
    13da:	00 00       	nop
    13dc:	62 06       	cpc	r6, r18
    13de:	00 00       	nop
    13e0:	01 0c       	add	r0, r1
    13e2:	0e 00       	.word	0x000e	; ????
    13e4:	00 2e       	mov	r0, r16
    13e6:	6d 00       	.word	0x006d	; ????
    13e8:	07 32       	cpi	r16, 0x27	; 39
    13ea:	37 02       	muls	r19, r23
    13ec:	00 00       	nop
    13ee:	df 06       	cpc	r13, r31
    13f0:	00 00       	nop
    13f2:	2e 66       	ori	r18, 0x6E	; 110
    13f4:	00 07       	cpc	r16, r16
    13f6:	33 92       	.word	0x9233	; ????
    13f8:	02 00       	.word	0x0002	; ????
    13fa:	00 52       	subi	r16, 0x20	; 32
    13fc:	07 00       	.word	0x0007	; ????
    13fe:	00 00       	nop
    1400:	45 46       	sbci	r20, 0x65	; 101
    1402:	03 00       	.word	0x0003	; ????
    1404:	00 09       	sbc	r16, r0
    1406:	0c 01       	movw	r0, r24
    1408:	01 45       	sbci	r16, 0x51	; 81
    140a:	95 02       	muls	r25, r21
    140c:	00 00       	nop
    140e:	08 1c       	adc	r0, r8
    1410:	01 01       	movw	r0, r2
    1412:	45 0b       	sbc	r20, r21
    1414:	07 00       	.word	0x0007	; ????
    1416:	00 07       	cpc	r16, r16
    1418:	f1 01       	movw	r30, r2
    141a:	01 50       	subi	r16, 0x01	; 1
    141c:	6a 03       	fmul	r22, r18
    141e:	00 00       	nop
    1420:	07 41       	sbci	r16, 0x17	; 23
    1422:	01 37       	cpi	r16, 0x71	; 113
    1424:	02 00       	.word	0x0002	; ????
    1426:	00 01       	movw	r0, r0
    1428:	4d 0e       	add	r4, r29
    142a:	00 00       	nop
    142c:	24 6d       	ori	r18, 0xD4	; 212
    142e:	00 07       	cpc	r16, r16
    1430:	43 37       	cpi	r20, 0x73	; 115
    1432:	02 00       	.word	0x0002	; ????
    1434:	00 2a       	or	r0, r16
    1436:	59 02       	muls	r21, r25
    1438:	00 00       	nop
    143a:	07 44       	sbci	r16, 0x47	; 71
    143c:	87 02       	muls	r24, r23
    143e:	00 00       	nop
    1440:	00 45       	sbci	r16, 0x50	; 80
    1442:	c2 06       	cpc	r12, r18
    1444:	00 00       	nop
    1446:	09 13       	cpse	r16, r25
    1448:	01 01       	movw	r0, r2
    144a:	28 41       	sbci	r18, 0x18	; 24
    144c:	02 00       	.word	0x0002	; ????
    144e:	00 01       	movw	r0, r0
    1450:	01 01       	movw	r0, r2
    1452:	70 0e       	add	r7, r16
    1454:	00 00       	nop
    1456:	25 2a       	or	r2, r21
    1458:	e4 06       	cpc	r14, r20
    145a:	00 00       	nop
    145c:	09 17       	cp	r16, r25
    145e:	37 02       	muls	r19, r23
    1460:	00 00       	nop
    1462:	00 00       	nop
    1464:	51 01       	movw	r10, r2
    1466:	ed 02       	muls	r30, r29
    1468:	00 00       	nop
    146a:	08 21       	and	r16, r8
    146c:	01 3a       	cpi	r16, 0xA1	; 161
    146e:	00 00       	nop
    1470:	00 01       	movw	r0, r0
    1472:	cc 04       	cpc	r12, r12
    1474:	00 00       	nop
    1476:	90 06       	cpc	r9, r16
    1478:	00 00       	nop
    147a:	03 92       	.word	0x9203	; ????
    147c:	20 02       	muls	r18, r16
    147e:	01 1c       	adc	r0, r1
    1480:	11 00       	.word	0x0011	; ????
    1482:	00 40       	sbci	r16, 0x00	; 0
    1484:	1e 0e       	add	r1, r30
    1486:	00 00       	nop
    1488:	cc 04       	cpc	r12, r12
    148a:	00 00       	nop
    148c:	52 05       	cpc	r21, r2
    148e:	00 00       	nop
    1490:	08 23       	and	r16, r24
    1492:	52 0c       	add	r5, r2
    1494:	0e 00       	.word	0x000e	; ????
    1496:	00 52       	subi	r16, 0x20	; 32
    1498:	05 00       	.word	0x0005	; ????
    149a:	00 ec       	ldi	r16, 0xC0	; 192
    149c:	05 00       	.word	0x0005	; ????
    149e:	00 08       	sbc	r0, r0
    14a0:	2b 3a       	cpi	r18, 0xAB	; 171
    14a2:	0f 00       	.word	0x000f	; ????
    14a4:	00 52       	subi	r16, 0x20	; 32
    14a6:	23 07       	cpc	r18, r19
    14a8:	00 00       	nop
    14aa:	52 05       	cpc	r21, r2
    14ac:	00 00       	nop
    14ae:	c6 05       	cpc	r28, r6
    14b0:	00 00       	nop
    14b2:	09 0e       	add	r0, r25
    14b4:	0d 0f       	add	r16, r29
    14b6:	00 00       	nop
    14b8:	37 31       	cpi	r19, 0x17	; 23
    14ba:	07 00       	.word	0x0007	; ????
    14bc:	00 3a       	cpi	r16, 0xA0	; 160
    14be:	3b 07       	cpc	r19, r27
    14c0:	00 00       	nop
    14c2:	97 07       	cpc	r25, r23
    14c4:	00 00       	nop
    14c6:	41 bf       	out	0x31, r20	; 49
    14c8:	06 00       	.word	0x0006	; ????
    14ca:	00 52       	subi	r16, 0x20	; 32
    14cc:	05 00       	.word	0x0005	; ????
    14ce:	00 c6       	rjmp	.+3072   	; 0x20d0 <__stack+0x17d1>
    14d0:	05 00       	.word	0x0005	; ????
    14d2:	00 0e       	add	r0, r16
    14d4:	79 37       	cpi	r23, 0x79	; 121
    14d6:	cd 06       	cpc	r12, r29
    14d8:	00 00       	nop
    14da:	3a d7       	rcall	.+3700   	; 0x2350 <__stack+0x1a51>
    14dc:	06 00       	.word	0x0006	; ????
    14de:	00 97       	sbiw	r24, 0x00	; 0
    14e0:	07 00       	.word	0x0007	; ????
    14e2:	00 3a       	cpi	r16, 0xA0	; 160
    14e4:	e2 06       	cpc	r14, r18
    14e6:	00 00       	nop
    14e8:	ad 07       	cpc	r26, r29
    14ea:	00 00       	nop
    14ec:	34 52       	subi	r19, 0x24	; 36
    14ee:	05 00       	.word	0x0005	; ????
    14f0:	00 c6       	rjmp	.+3072   	; 0x20f2 <__stack+0x17f3>
    14f2:	05 00       	.word	0x0005	; ????
    14f4:	00 3f       	cpi	r16, 0xF0	; 240
    14f6:	ed 06       	cpc	r14, r29
    14f8:	00 00       	nop
    14fa:	c1 07       	cpc	r28, r17
    14fc:	00 00       	nop
    14fe:	00 00       	nop
    1500:	00 41       	sbci	r16, 0x10	; 16
    1502:	27 0e       	add	r2, r23
    1504:	00 00       	nop
    1506:	c6 05       	cpc	r28, r6
    1508:	00 00       	nop
    150a:	dc 05       	cpc	r29, r12
    150c:	00 00       	nop
    150e:	09 10       	cpse	r0, r9
    1510:	34 c6       	rjmp	.+3176   	; 0x217a <__stack+0x187b>
    1512:	05 00       	.word	0x0005	; ????
    1514:	00 dc       	rcall	.-2048   	; 0xd16 <__stack+0x417>
    1516:	05 00       	.word	0x0005	; ????
    1518:	00 3f       	cpi	r16, 0xF0	; 240
    151a:	38 0e       	add	r3, r24
    151c:	00 00       	nop
    151e:	e2 07       	cpc	r30, r18
    1520:	00 00       	nop
    1522:	3f 41       	sbci	r19, 0x1F	; 31
    1524:	0e 00       	.word	0x000e	; ????
    1526:	00 00       	nop
    1528:	08 00       	.word	0x0008	; ????
    152a:	00 00       	nop
    152c:	00 00       	nop
    152e:	52 4d       	sbci	r21, 0xD2	; 210
    1530:	0e 00       	.word	0x000e	; ????
    1532:	00 ec       	ldi	r16, 0xC0	; 192
    1534:	05 00       	.word	0x0005	; ????
    1536:	00 8a       	std	Z+16, r0	; 0x10
    1538:	06 00       	.word	0x0006	; ????
    153a:	00 08       	sbc	r0, r0
    153c:	2e 12       	cpse	r2, r30
    153e:	11 00       	.word	0x0011	; ????
    1540:	00 34       	cpi	r16, 0x40	; 64
    1542:	20 06       	cpc	r2, r16
    1544:	00 00       	nop
    1546:	8a 06       	cpc	r8, r26
    1548:	00 00       	nop
    154a:	3b 63       	ori	r19, 0x3B	; 59
    154c:	0e 00       	.word	0x000e	; ????
    154e:	00 0c       	add	r0, r0
    1550:	5c 93       	st	X, r21
    1552:	01 5d       	subi	r16, 0xD1	; 209
    1554:	93 01       	movw	r18, r6
    1556:	5e 93       	st	-X, r21
    1558:	01 5f       	subi	r16, 0xF1	; 241
    155a:	93 01       	movw	r18, r6
    155c:	52 27       	eor	r21, r18
    155e:	0e 00       	.word	0x000e	; ????
    1560:	00 20       	and	r0, r0
    1562:	06 00       	.word	0x0006	; ????
    1564:	00 36       	cpi	r16, 0x60	; 96
    1566:	06 00       	.word	0x0006	; ????
    1568:	00 09       	sbc	r16, r0
    156a:	17 98       	cbi	0x02, 7	; 2
    156c:	0f 00       	.word	0x000f	; ????
    156e:	00 34       	cpi	r16, 0x40	; 64
    1570:	20 06       	cpc	r2, r16
    1572:	00 00       	nop
    1574:	36 06       	cpc	r3, r22
    1576:	00 00       	nop
    1578:	3f 38       	cpi	r19, 0x8F	; 143
    157a:	0e 00       	.word	0x000e	; ????
    157c:	00 13       	cpse	r16, r16
    157e:	08 00       	.word	0x0008	; ????
    1580:	00 3f       	cpi	r16, 0xF0	; 240
    1582:	41 0e       	add	r4, r17
    1584:	00 00       	nop
    1586:	31 08       	sbc	r3, r1
    1588:	00 00       	nop
    158a:	00 00       	nop
    158c:	52 c8       	rjmp	.-3932   	; 0x632 <main+0x166>
    158e:	07 00       	.word	0x0007	; ????
    1590:	00 36       	cpi	r16, 0x60	; 96
    1592:	06 00       	.word	0x0006	; ????
    1594:	00 3e       	cpi	r16, 0xE0	; 224
    1596:	06 00       	.word	0x0006	; ????
    1598:	00 09       	sbc	r16, r0
    159a:	19 ce       	rjmp	.-974    	; 0x11ce <__stack+0x8cf>
    159c:	0f 00       	.word	0x000f	; ????
    159e:	00 37       	cpi	r16, 0x70	; 112
    15a0:	d6 07       	cpc	r29, r22
    15a2:	00 00       	nop
    15a4:	37 e0       	ldi	r19, 0x07	; 7
    15a6:	07 00       	.word	0x0007	; ????
    15a8:	00 36       	cpi	r16, 0x60	; 96
    15aa:	3e 06       	cpc	r3, r30
    15ac:	00 00       	nop
    15ae:	f4 0c       	add	r15, r4
    15b0:	00 00       	nop
    15b2:	30 06       	cpc	r3, r16
    15b4:	68 93       	.word	0x9368	; ????
    15b6:	01 69       	ori	r16, 0x91	; 145
    15b8:	93 01       	movw	r18, r6
    15ba:	05 03       	mulsu	r16, r21
    15bc:	16 01       	movw	r2, r12
    15be:	80 00       	.word	0x0080	; ????
    15c0:	00 00       	nop
    15c2:	52 9b       	sbis	0x0a, 2	; 10
    15c4:	07 00       	.word	0x0007	; ????
    15c6:	00 3e       	cpi	r16, 0xE0	; 224
    15c8:	06 00       	.word	0x0006	; ????
    15ca:	00 4c       	sbci	r16, 0xC0	; 192
    15cc:	06 00       	.word	0x0006	; ????
    15ce:	00 09       	sbc	r16, r0
    15d0:	1a 1c       	adc	r1, r10
    15d2:	10 00       	.word	0x0010	; ????
    15d4:	00 37       	cpi	r16, 0x70	; 112
    15d6:	a9 07       	cpc	r26, r25
    15d8:	00 00       	nop
    15da:	3a bc       	out	0x2a, r3	; 42
    15dc:	07 00       	.word	0x0007	; ????
    15de:	00 44       	sbci	r16, 0x40	; 64
    15e0:	08 00       	.word	0x0008	; ????
    15e2:	00 3a       	cpi	r16, 0xA0	; 160
    15e4:	b3 07       	cpc	r27, r19
    15e6:	00 00       	nop
    15e8:	58 08       	sbc	r5, r8
    15ea:	00 00       	nop
    15ec:	36 4c       	sbci	r19, 0xC6	; 198
    15ee:	06 00       	.word	0x0006	; ????
    15f0:	00 45       	sbci	r16, 0x50	; 80
    15f2:	0d 00       	.word	0x000d	; ????
    15f4:	00 30       	cpi	r16, 0x00	; 0
    15f6:	0c 66       	ori	r16, 0x6C	; 108
    15f8:	93 01       	movw	r18, r6
    15fa:	67 93       	lat	Z, r22
    15fc:	01 68       	ori	r16, 0x81	; 129
    15fe:	93 01       	movw	r18, r6
    1600:	69 93       	st	Y+, r22
    1602:	01 05       	cpc	r16, r1
    1604:	0c c0       	rjmp	.+24     	; 0x161e <__stack+0xd1f>
    1606:	c6 2d       	mov	r28, r6
    1608:	00 30       	cpi	r16, 0x00	; 0
    160a:	01 64       	ori	r16, 0x41	; 65
    160c:	01 3a       	cpi	r16, 0xA1	; 161
    160e:	00 00       	nop
    1610:	52 c8       	rjmp	.-3932   	; 0x6b6 <_GLOBAL__sub_I___vector_18+0x26>
    1612:	07 00       	.word	0x0007	; ????
    1614:	00 4c       	sbci	r16, 0xC0	; 192
    1616:	06 00       	.word	0x0006	; ????
    1618:	00 54       	subi	r16, 0x40	; 64
    161a:	06 00       	.word	0x0006	; ????
    161c:	00 09       	sbc	r16, r0
    161e:	1c 52       	subi	r17, 0x2C	; 44
    1620:	10 00       	.word	0x0010	; ????
    1622:	00 37       	cpi	r16, 0x70	; 112
    1624:	d6 07       	cpc	r29, r22
    1626:	00 00       	nop
    1628:	37 e0       	ldi	r19, 0x07	; 7
    162a:	07 00       	.word	0x0007	; ????
    162c:	00 36       	cpi	r16, 0x60	; 96
    162e:	54 06       	cpc	r5, r20
    1630:	00 00       	nop
    1632:	f4 0c       	add	r15, r4
    1634:	00 00       	nop
    1636:	30 06       	cpc	r3, r16
    1638:	68 93       	.word	0x9368	; ????
    163a:	01 69       	ori	r16, 0x91	; 145
    163c:	93 01       	movw	r18, r6
    163e:	05 03       	mulsu	r16, r21
    1640:	1e 01       	movw	r2, r28
    1642:	80 00       	.word	0x0080	; ????
    1644:	00 00       	nop
    1646:	52 9b       	sbis	0x0a, 2	; 10
    1648:	07 00       	.word	0x0007	; ????
    164a:	00 54       	subi	r16, 0x40	; 64
    164c:	06 00       	.word	0x0006	; ????
    164e:	00 7a       	andi	r16, 0xA0	; 160
    1650:	06 00       	.word	0x0006	; ????
    1652:	00 09       	sbc	r16, r0
    1654:	1d 8c       	ldd	r1, Y+29	; 0x1d
    1656:	10 00       	.word	0x0010	; ????
    1658:	00 37       	cpi	r16, 0x70	; 112
    165a:	a9 07       	cpc	r26, r25
    165c:	00 00       	nop
    165e:	3a bc       	out	0x2a, r3	; 42
    1660:	07 00       	.word	0x0007	; ????
    1662:	00 70       	andi	r16, 0x00	; 0
    1664:	08 00       	.word	0x0008	; ????
    1666:	00 3a       	cpi	r16, 0xA0	; 160
    1668:	b3 07       	cpc	r27, r19
    166a:	00 00       	nop
    166c:	84 08       	sbc	r8, r4
    166e:	00 00       	nop
    1670:	36 7a       	andi	r19, 0xA6	; 166
    1672:	06 00       	.word	0x0006	; ????
    1674:	00 45       	sbci	r16, 0x50	; 80
    1676:	0d 00       	.word	0x000d	; ????
    1678:	00 30       	cpi	r16, 0x00	; 0
    167a:	01 64       	ori	r16, 0x41	; 65
    167c:	01 3a       	cpi	r16, 0xA1	; 161
    167e:	00 00       	nop
    1680:	41 70       	andi	r20, 0x01	; 1
    1682:	07 00       	.word	0x0007	; ????
    1684:	00 7a       	andi	r16, 0xA0	; 160
    1686:	06 00       	.word	0x0006	; ????
    1688:	00 8a       	std	Z+16, r0	; 0x10
    168a:	06 00       	.word	0x0006	; ????
    168c:	00 09       	sbc	r16, r0
    168e:	1e 37       	cpi	r17, 0x7E	; 126
    1690:	7e 07       	cpc	r23, r30
    1692:	00 00       	nop
    1694:	37 88       	ldd	r3, Z+23	; 0x17
    1696:	07 00       	.word	0x0007	; ????
    1698:	00 34       	cpi	r16, 0x40	; 64
    169a:	7a 06       	cpc	r7, r26
    169c:	00 00       	nop
    169e:	8a 06       	cpc	r8, r26
    16a0:	00 00       	nop
    16a2:	38 91       	.word	0x9138	; ????
    16a4:	07 00       	.word	0x0007	; ????
    16a6:	00 52       	subi	r16, 0x20	; 32
    16a8:	c8 07       	cpc	r28, r24
    16aa:	00 00       	nop
    16ac:	7a 06       	cpc	r7, r26
    16ae:	00 00       	nop
    16b0:	82 06       	cpc	r8, r18
    16b2:	00 00       	nop
    16b4:	01 8c       	ldd	r0, Z+25	; 0x19
    16b6:	e1 10       	cpse	r14, r1
    16b8:	00 00       	nop
    16ba:	53 53       	subi	r21, 0x33	; 51
    16bc:	36 82       	std	Z+6, r3	; 0x06
    16be:	06 00       	.word	0x0006	; ????
    16c0:	00 f4       	brcc	.+0      	; 0x16c2 <__stack+0xdc3>
    16c2:	0c 00       	.word	0x000c	; ????
    16c4:	00 30       	cpi	r16, 0x00	; 0
    16c6:	06 68       	ori	r16, 0x86	; 134
    16c8:	93 01       	movw	r18, r6
    16ca:	69 93       	st	Y+, r22
    16cc:	01 05       	cpc	r16, r1
    16ce:	03 27       	eor	r16, r19
    16d0:	01 80       	ldd	r0, Z+1	; 0x01
    16d2:	00 00       	nop
    16d4:	00 41       	sbci	r16, 0x10	; 16
    16d6:	52 07       	cpc	r21, r18
    16d8:	00 00       	nop
    16da:	82 06       	cpc	r8, r18
    16dc:	00 00       	nop
    16de:	8a 06       	cpc	r8, r26
    16e0:	00 00       	nop
    16e2:	01 8d       	ldd	r16, Z+25	; 0x19
    16e4:	37 60       	ori	r19, 0x07	; 7
    16e6:	07 00       	.word	0x0007	; ????
    16e8:	00 36       	cpi	r16, 0x60	; 96
    16ea:	8a 06       	cpc	r8, r26
    16ec:	00 00       	nop
    16ee:	f4 0c       	add	r15, r4
    16f0:	00 00       	nop
    16f2:	30 06       	cpc	r3, r16
    16f4:	68 93       	.word	0x9368	; ????
    16f6:	01 69       	ori	r16, 0x91	; 145
    16f8:	93 01       	movw	r18, r6
    16fa:	05 03       	mulsu	r16, r21
    16fc:	2d 01       	movw	r4, r26
    16fe:	80 00       	.word	0x0080	; ????
    1700:	00 00       	nop
    1702:	00 00       	nop
    1704:	00 00       	nop
    1706:	47 8e       	std	Z+31, r4	; 0x1f
    1708:	06 00       	.word	0x0006	; ????
    170a:	00 cb       	rjmp	.-2560   	; 0xd0c <__stack+0x40d>
    170c:	0c 00       	.word	0x000c	; ????
    170e:	00 00       	nop
    1710:	54 b2       	in	r5, 0x14	; 20
    1712:	05 00       	.word	0x0005	; ????
    1714:	00 01       	movw	r0, r0
    1716:	01 90       	ld	r0, Z+
    1718:	06 00       	.word	0x0006	; ????
    171a:	00 ea       	ldi	r16, 0xA0	; 160
    171c:	06 00       	.word	0x0006	; ????
    171e:	00 03       	mulsu	r16, r16
    1720:	92 20       	and	r9, r2
    1722:	02 01       	movw	r0, r4
    1724:	a1 11       	cpse	r26, r1
    1726:	00 00       	nop
    1728:	41 9c       	mul	r4, r1
    172a:	06 00       	.word	0x0006	; ????
    172c:	00 90 06 00 	lds	r0, 0x0006	; 0x800006 <__TEXT_REGION_LENGTH__+0x7e0006>
    1730:	00 ea       	ldi	r16, 0xA0	; 160
    1732:	06 00       	.word	0x0006	; ????
    1734:	00 04       	cpc	r0, r0
    1736:	4d 3a       	cpi	r20, 0xAD	; 173
    1738:	a8 06       	cpc	r10, r24
    173a:	00 00       	nop
    173c:	b6 08       	sbc	r11, r6
    173e:	00 00       	nop
    1740:	3a b3       	in	r19, 0x1a	; 26
    1742:	06 00       	.word	0x0006	; ????
    1744:	00 ca       	rjmp	.-3072   	; 0xb46 <__stack+0x247>
    1746:	08 00       	.word	0x0008	; ????
    1748:	00 41       	sbci	r16, 0x10	; 16
    174a:	a1 11       	cpse	r26, r1
    174c:	00 00       	nop
    174e:	90 06       	cpc	r9, r16
    1750:	00 00       	nop
    1752:	ea 06       	cpc	r14, r26
    1754:	00 00       	nop
    1756:	04 46       	sbci	r16, 0x64	; 100
    1758:	55 c6       	rjmp	.+3242   	; 0x2404 <__stack+0x1b05>
    175a:	55 c2       	rjmp	.+1194   	; 0x1c06 <__stack+0x1307>
    175c:	55 c1       	rjmp	.+682    	; 0x1a08 <__stack+0x1109>
    175e:	55 c0       	rjmp	.+170    	; 0x180a <__stack+0xf0b>
    1760:	55 c4       	rjmp	.+2218   	; 0x200c <__stack+0x170d>
    1762:	55 c5       	rjmp	.+2730   	; 0x220e <__stack+0x190f>
    1764:	56 06       	cpc	r5, r22
    1766:	03 3d       	cpi	r16, 0xD3	; 211
    1768:	01 80       	ldd	r0, Z+1	; 0x01
    176a:	00 9f       	mul	r16, r16
    176c:	41 7e       	andi	r20, 0xE1	; 225
    176e:	06 00       	.word	0x0006	; ????
    1770:	00 90 06 00 	lds	r0, 0x0006	; 0x800006 <__TEXT_REGION_LENGTH__+0x7e0006>
    1774:	00 a8       	ldd	r0, Z+48	; 0x30
    1776:	06 00       	.word	0x0006	; ????
    1778:	00 0b       	sbc	r16, r16
    177a:	5f 37       	cpi	r21, 0x7F	; 127
    177c:	8c 06       	cpc	r8, r28
    177e:	00 00       	nop
    1780:	41 a7       	std	Z+41, r20	; 0x29
    1782:	11 00       	.word	0x0011	; ????
    1784:	00 90 06 00 	lds	r0, 0x0006	; 0x800006 <__TEXT_REGION_LENGTH__+0x7e0006>
    1788:	00 98       	cbi	0x00, 0	; 0
    178a:	06 00       	.word	0x0006	; ????
    178c:	00 0a       	sbc	r0, r16
    178e:	3f 53       	subi	r19, 0x3F	; 63
    1790:	00 00       	nop
    1792:	00 00       	nop
    1794:	00 57       	subi	r16, 0x70	; 112
    1796:	ed 05       	cpc	r30, r13
    1798:	00 00       	nop
    179a:	03 57       	subi	r16, 0x73	; 115
    179c:	1d 02       	muls	r17, r29
    179e:	00 00       	nop
    17a0:	03 4f       	sbci	r16, 0xF3	; 243
    17a2:	01 7a       	andi	r16, 0xA1	; 161
    17a4:	02 00       	.word	0x0002	; ????
    17a6:	00 04       	cpc	r0, r0
    17a8:	3b 01       	movw	r6, r22
    17aa:	1c 04       	cpc	r1, r12
    17ac:	00 00       	nop
    17ae:	68 04       	cpc	r6, r8
    17b0:	00 00       	nop
    17b2:	df 08       	sbc	r13, r15
    17b4:	00 00       	nop
    17b6:	01 e0       	ldi	r16, 0x01	; 1
    17b8:	11 00       	.word	0x0011	; ????
    17ba:	00 36       	cpi	r16, 0x60	; 96
    17bc:	46 04       	cpc	r4, r6
    17be:	00 00       	nop
    17c0:	73 0a       	sbc	r7, r19
    17c2:	00 00       	nop
    17c4:	30 06       	cpc	r3, r16
    17c6:	68 93       	.word	0x9368	; ????
    17c8:	01 69       	ori	r16, 0x91	; 145
    17ca:	93 01       	movw	r18, r6
    17cc:	05 03       	mulsu	r16, r21
    17ce:	3d 01       	movw	r6, r26
    17d0:	80 00       	.word	0x0080	; ????
    17d2:	00 00       	nop
    17d4:	4f 01       	movw	r8, r30
    17d6:	c1 05       	cpc	r28, r1
    17d8:	00 00       	nop
    17da:	04 28       	or	r0, r4
    17dc:	01 68       	ori	r16, 0x81	; 129
    17de:	04 00       	.word	0x0004	; ????
    17e0:	00 cc       	rjmp	.-2048   	; 0xfe2 <__stack+0x6e3>
    17e2:	04 00       	.word	0x0004	; ????
    17e4:	00 aa       	std	Z+48, r0	; 0x30
    17e6:	09 00       	.word	0x0009	; ????
    17e8:	00 01       	movw	r0, r0
    17ea:	3b 12       	cpse	r3, r27
    17ec:	00 00       	nop
    17ee:	41 5f       	subi	r20, 0xF1	; 241
    17f0:	06 00       	.word	0x0006	; ????
    17f2:	00 7c       	andi	r16, 0xC0	; 192
    17f4:	04 00       	.word	0x0004	; ????
    17f6:	00 b8       	out	0x00, r0	; 0
    17f8:	04 00       	.word	0x0004	; ????
    17fa:	00 04       	cpc	r0, r0
    17fc:	31 37       	cpi	r19, 0x71	; 113
    17fe:	6d 06       	cpc	r6, r29
    1800:	00 00       	nop
    1802:	34 92       	xch	Z, r3
    1804:	04 00       	.word	0x0004	; ????
    1806:	00 b6       	in	r0, 0x30	; 48
    1808:	04 00       	.word	0x0004	; ????
    180a:	00 37       	cpi	r16, 0x70	; 112
    180c:	3b 06       	cpc	r3, r27
    180e:	00 00       	nop
    1810:	34 92       	xch	Z, r3
    1812:	04 00       	.word	0x0004	; ????
    1814:	00 b6       	in	r0, 0x30	; 48
    1816:	04 00       	.word	0x0004	; ????
    1818:	00 3f       	cpi	r16, 0xF0	; 240
    181a:	46 06       	cpc	r4, r22
    181c:	00 00       	nop
    181e:	1a 0a       	sbc	r1, r26
    1820:	00 00       	nop
    1822:	3f 4f       	sbci	r19, 0xFF	; 255
    1824:	06 00       	.word	0x0006	; ????
    1826:	00 2d       	mov	r16, r0
    1828:	0a 00       	.word	0x000a	; ????
    182a:	00 00       	nop
    182c:	00 00       	nop
    182e:	00 33       	cpi	r16, 0x30	; 48
    1830:	f4 06       	cpc	r15, r20
    1832:	00 00       	nop
    1834:	09 08       	sbc	r0, r9
    1836:	37 02       	muls	r19, r23
    1838:	00 00       	nop
    183a:	05 03       	mulsu	r16, r21
    183c:	30 01       	movw	r6, r0
    183e:	80 00       	.word	0x0080	; ????
    1840:	33 97       	sbiw	r30, 0x03	; 3
    1842:	03 00       	.word	0x0003	; ????
    1844:	00 09       	sbc	r16, r0
    1846:	07 37       	cpi	r16, 0x77	; 119
    1848:	02 00       	.word	0x0002	; ????
    184a:	00 05       	cpc	r16, r0
    184c:	03 00       	.word	0x0003	; ????
    184e:	01 80       	ldd	r0, Z+1	; 0x01
    1850:	00 33       	cpi	r16, 0x30	; 48
    1852:	36 05       	cpc	r19, r6
    1854:	00 00       	nop
    1856:	07 26       	eor	r0, r23
    1858:	75 12       	cpse	r7, r21
    185a:	00 00       	nop
    185c:	05 03       	mulsu	r16, r21
    185e:	34 01       	movw	r6, r8
    1860:	80 00       	.word	0x0080	; ????
    1862:	10 04       	cpc	r1, r0
    1864:	07 13       	cpse	r16, r23
    1866:	05 00       	.word	0x0005	; ????
    1868:	00 1e       	adc	r0, r16
    186a:	6e 12       	cpse	r6, r30
    186c:	00 00       	nop
    186e:	33 34       	cpi	r19, 0x43	; 67
    1870:	02 00       	.word	0x0002	; ????
    1872:	00 07       	cpc	r16, r16
    1874:	28 92       	.word	0x9228	; ????
    1876:	02 00       	.word	0x0002	; ????
    1878:	00 05       	cpc	r16, r0
    187a:	03 38       	cpi	r16, 0x83	; 131
    187c:	01 80       	ldd	r0, Z+1	; 0x01
    187e:	00 33       	cpi	r16, 0x30	; 48
    1880:	63 03       	mulsu	r22, r19
    1882:	00 00       	nop
    1884:	07 27       	eor	r16, r23
    1886:	75 12       	cpse	r7, r21
    1888:	00 00       	nop
    188a:	05 03       	mulsu	r16, r21
    188c:	39 01       	movw	r6, r18
    188e:	80 00       	.word	0x0080	; ????
    1890:	33 dc       	rcall	.-1946   	; 0x10f8 <__stack+0x7f9>
    1892:	05 00       	.word	0x0005	; ????
    1894:	00 04       	cpc	r0, r0
    1896:	46 b4       	in	r4, 0x26	; 38
    1898:	05 00       	.word	0x0005	; ????
    189a:	00 05       	cpc	r16, r0
    189c:	03 3d       	cpi	r16, 0xD3	; 211
    189e:	01 80       	ldd	r0, Z+1	; 0x01
    18a0:	00 00       	nop
    18a2:	aa 00       	.word	0x00aa	; ????
    18a4:	00 00       	nop
    18a6:	02 00       	.word	0x0002	; ????
    18a8:	90 0a       	sbc	r9, r16
    18aa:	00 00       	nop
    18ac:	04 01       	movw	r0, r8
    18ae:	6d 08       	sbc	r6, r13
    18b0:	00 00       	nop
    18b2:	44 07       	cpc	r20, r20
    18b4:	00 00       	nop
    18b6:	48 07       	cpc	r20, r24
    18b8:	00 00       	nop
    18ba:	2e 2e       	mov	r2, r30
    18bc:	2f 2e       	mov	r2, r31
    18be:	2e 2f       	mov	r18, r30
    18c0:	2e 2e       	mov	r2, r30
    18c2:	2f 2e       	mov	r2, r31
    18c4:	2e 2f       	mov	r18, r30
    18c6:	67 63       	ori	r22, 0x37	; 55
    18c8:	63 2f       	mov	r22, r19
    18ca:	6c 69       	ori	r22, 0x9C	; 156
    18cc:	62 67       	ori	r22, 0x72	; 114
    18ce:	63 63       	ori	r22, 0x33	; 51
    18d0:	2f 63       	ori	r18, 0x3F	; 63
    18d2:	6f 6e       	ori	r22, 0xEF	; 239
    18d4:	66 69       	ori	r22, 0x96	; 150
    18d6:	67 2f       	mov	r22, r23
    18d8:	61 76       	andi	r22, 0x61	; 97
    18da:	72 2f       	mov	r23, r18
    18dc:	6c 69       	ori	r22, 0x9C	; 156
    18de:	62 31       	cpi	r22, 0x12	; 18
    18e0:	66 75       	andi	r22, 0x56	; 86
    18e2:	6e 63       	ori	r22, 0x3E	; 62
    18e4:	73 2e       	mov	r7, r19
    18e6:	53 00       	.word	0x0053	; ????
    18e8:	2f 55       	subi	r18, 0x5F	; 95
    18ea:	73 65       	ori	r23, 0x53	; 83
    18ec:	72 73       	andi	r23, 0x32	; 50
    18ee:	2f 6a       	ori	r18, 0xAF	; 175
    18f0:	65 6e       	ori	r22, 0xE5	; 229
    18f2:	6b 69       	ori	r22, 0x9B	; 155
    18f4:	6e 73       	andi	r22, 0x3E	; 62
    18f6:	2f 6a       	ori	r18, 0xAF	; 175
    18f8:	65 6e       	ori	r22, 0xE5	; 229
    18fa:	6b 69       	ori	r22, 0x9B	; 155
    18fc:	6e 73       	andi	r22, 0x3E	; 62
    18fe:	2f 77       	andi	r18, 0x7F	; 127
    1900:	6f 72       	andi	r22, 0x2F	; 47
    1902:	6b 73       	andi	r22, 0x3B	; 59
    1904:	70 61       	ori	r23, 0x10	; 16
    1906:	63 65       	ori	r22, 0x53	; 83
    1908:	2f 61       	ori	r18, 0x1F	; 31
    190a:	76 72       	andi	r23, 0x26	; 38
    190c:	2d 67       	ori	r18, 0x7D	; 125
    190e:	63 63       	ori	r22, 0x33	; 51
    1910:	2d 73       	andi	r18, 0x3D	; 61
    1912:	74 61       	ori	r23, 0x14	; 20
    1914:	67 69       	ori	r22, 0x97	; 151
    1916:	6e 67       	ori	r22, 0x7E	; 126
    1918:	2f 6c       	ori	r18, 0xCF	; 207
    191a:	61 62       	ori	r22, 0x21	; 33
    191c:	65 6c       	ori	r22, 0xC5	; 197
    191e:	2f 6d       	ori	r18, 0xDF	; 223
    1920:	61 63       	ori	r22, 0x31	; 49
    1922:	2d 6d       	ori	r18, 0xDD	; 221
    1924:	69 6e       	ori	r22, 0xE9	; 233
    1926:	69 2f       	mov	r22, r25
    1928:	67 63       	ori	r22, 0x37	; 55
    192a:	63 2d       	mov	r22, r3
    192c:	62 75       	andi	r22, 0x52	; 82
    192e:	69 6c       	ori	r22, 0xC9	; 201
    1930:	64 2f       	mov	r22, r20
    1932:	61 76       	andi	r22, 0x61	; 97
    1934:	72 2f       	mov	r23, r18
    1936:	61 76       	andi	r22, 0x61	; 97
    1938:	72 35       	cpi	r23, 0x52	; 82
    193a:	2f 6c       	ori	r18, 0xCF	; 207
    193c:	69 62       	ori	r22, 0x29	; 41
    193e:	67 63       	ori	r22, 0x37	; 55
    1940:	63 00       	.word	0x0063	; ????
    1942:	47 4e       	sbci	r20, 0xE7	; 231
    1944:	55 20       	and	r5, r5
    1946:	41 53       	subi	r20, 0x31	; 49
    1948:	20 32       	cpi	r18, 0x20	; 32
    194a:	2e 32       	cpi	r18, 0x2E	; 46
    194c:	36 00       	.word	0x0036	; ????
    194e:	01 80       	ldd	r0, Z+1	; 0x01
    1950:	aa 00       	.word	0x00aa	; ????
    1952:	00 00       	nop
    1954:	02 00       	.word	0x0002	; ????
    1956:	a4 0a       	sbc	r10, r20
    1958:	00 00       	nop
    195a:	04 01       	movw	r0, r8
    195c:	cf 08       	sbc	r12, r15
    195e:	00 00       	nop
    1960:	ea 06       	cpc	r14, r26
    1962:	00 00       	nop
    1964:	2e 07       	cpc	r18, r30
    1966:	00 00       	nop
    1968:	2e 2e       	mov	r2, r30
    196a:	2f 2e       	mov	r2, r31
    196c:	2e 2f       	mov	r18, r30
    196e:	2e 2e       	mov	r2, r30
    1970:	2f 2e       	mov	r2, r31
    1972:	2e 2f       	mov	r18, r30
    1974:	67 63       	ori	r22, 0x37	; 55
    1976:	63 2f       	mov	r22, r19
    1978:	6c 69       	ori	r22, 0x9C	; 156
    197a:	62 67       	ori	r22, 0x72	; 114
    197c:	63 63       	ori	r22, 0x33	; 51
    197e:	2f 63       	ori	r18, 0x3F	; 63
    1980:	6f 6e       	ori	r22, 0xEF	; 239
    1982:	66 69       	ori	r22, 0x96	; 150
    1984:	67 2f       	mov	r22, r23
    1986:	61 76       	andi	r22, 0x61	; 97
    1988:	72 2f       	mov	r23, r18
    198a:	6c 69       	ori	r22, 0x9C	; 156
    198c:	62 31       	cpi	r22, 0x12	; 18
    198e:	66 75       	andi	r22, 0x56	; 86
    1990:	6e 63       	ori	r22, 0x3E	; 62
    1992:	73 2e       	mov	r7, r19
    1994:	53 00       	.word	0x0053	; ????
    1996:	2f 55       	subi	r18, 0x5F	; 95
    1998:	73 65       	ori	r23, 0x53	; 83
    199a:	72 73       	andi	r23, 0x32	; 50
    199c:	2f 6a       	ori	r18, 0xAF	; 175
    199e:	65 6e       	ori	r22, 0xE5	; 229
    19a0:	6b 69       	ori	r22, 0x9B	; 155
    19a2:	6e 73       	andi	r22, 0x3E	; 62
    19a4:	2f 6a       	ori	r18, 0xAF	; 175
    19a6:	65 6e       	ori	r22, 0xE5	; 229
    19a8:	6b 69       	ori	r22, 0x9B	; 155
    19aa:	6e 73       	andi	r22, 0x3E	; 62
    19ac:	2f 77       	andi	r18, 0x7F	; 127
    19ae:	6f 72       	andi	r22, 0x2F	; 47
    19b0:	6b 73       	andi	r22, 0x3B	; 59
    19b2:	70 61       	ori	r23, 0x10	; 16
    19b4:	63 65       	ori	r22, 0x53	; 83
    19b6:	2f 61       	ori	r18, 0x1F	; 31
    19b8:	76 72       	andi	r23, 0x26	; 38
    19ba:	2d 67       	ori	r18, 0x7D	; 125
    19bc:	63 63       	ori	r22, 0x33	; 51
    19be:	2d 73       	andi	r18, 0x3D	; 61
    19c0:	74 61       	ori	r23, 0x14	; 20
    19c2:	67 69       	ori	r22, 0x97	; 151
    19c4:	6e 67       	ori	r22, 0x7E	; 126
    19c6:	2f 6c       	ori	r18, 0xCF	; 207
    19c8:	61 62       	ori	r22, 0x21	; 33
    19ca:	65 6c       	ori	r22, 0xC5	; 197
    19cc:	2f 6d       	ori	r18, 0xDF	; 223
    19ce:	61 63       	ori	r22, 0x31	; 49
    19d0:	2d 6d       	ori	r18, 0xDD	; 221
    19d2:	69 6e       	ori	r22, 0xE9	; 233
    19d4:	69 2f       	mov	r22, r25
    19d6:	67 63       	ori	r22, 0x37	; 55
    19d8:	63 2d       	mov	r22, r3
    19da:	62 75       	andi	r22, 0x52	; 82
    19dc:	69 6c       	ori	r22, 0xC9	; 201
    19de:	64 2f       	mov	r22, r20
    19e0:	61 76       	andi	r22, 0x61	; 97
    19e2:	72 2f       	mov	r23, r18
    19e4:	61 76       	andi	r22, 0x61	; 97
    19e6:	72 35       	cpi	r23, 0x52	; 82
    19e8:	2f 6c       	ori	r18, 0xCF	; 207
    19ea:	69 62       	ori	r22, 0x29	; 41
    19ec:	67 63       	ori	r22, 0x37	; 55
    19ee:	63 00       	.word	0x0063	; ????
    19f0:	47 4e       	sbci	r20, 0xE7	; 231
    19f2:	55 20       	and	r5, r5
    19f4:	41 53       	subi	r20, 0x31	; 49
    19f6:	20 32       	cpi	r18, 0x20	; 32
    19f8:	2e 32       	cpi	r18, 0x2E	; 46
    19fa:	36 00       	.word	0x0036	; ????
    19fc:	01 80       	ldd	r0, Z+1	; 0x01
    19fe:	aa 00       	.word	0x00aa	; ????
    1a00:	00 00       	nop
    1a02:	02 00       	.word	0x0002	; ????
    1a04:	b8 0a       	sbc	r11, r24
    1a06:	00 00       	nop
    1a08:	04 01       	movw	r0, r8
    1a0a:	f1 09       	sbc	r31, r1
    1a0c:	00 00       	nop
    1a0e:	76 00       	.word	0x0076	; ????
    1a10:	00 00       	nop
    1a12:	8c 00       	.word	0x008c	; ????
    1a14:	00 00       	nop
    1a16:	2e 2e       	mov	r2, r30
    1a18:	2f 2e       	mov	r2, r31
    1a1a:	2e 2f       	mov	r18, r30
    1a1c:	2e 2e       	mov	r2, r30
    1a1e:	2f 2e       	mov	r2, r31
    1a20:	2e 2f       	mov	r18, r30
    1a22:	67 63       	ori	r22, 0x37	; 55
    1a24:	63 2f       	mov	r22, r19
    1a26:	6c 69       	ori	r22, 0x9C	; 156
    1a28:	62 67       	ori	r22, 0x72	; 114
    1a2a:	63 63       	ori	r22, 0x33	; 51
    1a2c:	2f 63       	ori	r18, 0x3F	; 63
    1a2e:	6f 6e       	ori	r22, 0xEF	; 239
    1a30:	66 69       	ori	r22, 0x96	; 150
    1a32:	67 2f       	mov	r22, r23
    1a34:	61 76       	andi	r22, 0x61	; 97
    1a36:	72 2f       	mov	r23, r18
    1a38:	6c 69       	ori	r22, 0x9C	; 156
    1a3a:	62 31       	cpi	r22, 0x12	; 18
    1a3c:	66 75       	andi	r22, 0x56	; 86
    1a3e:	6e 63       	ori	r22, 0x3E	; 62
    1a40:	73 2e       	mov	r7, r19
    1a42:	53 00       	.word	0x0053	; ????
    1a44:	2f 55       	subi	r18, 0x5F	; 95
    1a46:	73 65       	ori	r23, 0x53	; 83
    1a48:	72 73       	andi	r23, 0x32	; 50
    1a4a:	2f 6a       	ori	r18, 0xAF	; 175
    1a4c:	65 6e       	ori	r22, 0xE5	; 229
    1a4e:	6b 69       	ori	r22, 0x9B	; 155
    1a50:	6e 73       	andi	r22, 0x3E	; 62
    1a52:	2f 6a       	ori	r18, 0xAF	; 175
    1a54:	65 6e       	ori	r22, 0xE5	; 229
    1a56:	6b 69       	ori	r22, 0x9B	; 155
    1a58:	6e 73       	andi	r22, 0x3E	; 62
    1a5a:	2f 77       	andi	r18, 0x7F	; 127
    1a5c:	6f 72       	andi	r22, 0x2F	; 47
    1a5e:	6b 73       	andi	r22, 0x3B	; 59
    1a60:	70 61       	ori	r23, 0x10	; 16
    1a62:	63 65       	ori	r22, 0x53	; 83
    1a64:	2f 61       	ori	r18, 0x1F	; 31
    1a66:	76 72       	andi	r23, 0x26	; 38
    1a68:	2d 67       	ori	r18, 0x7D	; 125
    1a6a:	63 63       	ori	r22, 0x33	; 51
    1a6c:	2d 73       	andi	r18, 0x3D	; 61
    1a6e:	74 61       	ori	r23, 0x14	; 20
    1a70:	67 69       	ori	r22, 0x97	; 151
    1a72:	6e 67       	ori	r22, 0x7E	; 126
    1a74:	2f 6c       	ori	r18, 0xCF	; 207
    1a76:	61 62       	ori	r22, 0x21	; 33
    1a78:	65 6c       	ori	r22, 0xC5	; 197
    1a7a:	2f 6d       	ori	r18, 0xDF	; 223
    1a7c:	61 63       	ori	r22, 0x31	; 49
    1a7e:	2d 6d       	ori	r18, 0xDD	; 221
    1a80:	69 6e       	ori	r22, 0xE9	; 233
    1a82:	69 2f       	mov	r22, r25
    1a84:	67 63       	ori	r22, 0x37	; 55
    1a86:	63 2d       	mov	r22, r3
    1a88:	62 75       	andi	r22, 0x52	; 82
    1a8a:	69 6c       	ori	r22, 0xC9	; 201
    1a8c:	64 2f       	mov	r22, r20
    1a8e:	61 76       	andi	r22, 0x61	; 97
    1a90:	72 2f       	mov	r23, r18
    1a92:	61 76       	andi	r22, 0x61	; 97
    1a94:	72 35       	cpi	r23, 0x52	; 82
    1a96:	2f 6c       	ori	r18, 0xCF	; 207
    1a98:	69 62       	ori	r22, 0x29	; 41
    1a9a:	67 63       	ori	r22, 0x37	; 55
    1a9c:	63 00       	.word	0x0063	; ????
    1a9e:	47 4e       	sbci	r20, 0xE7	; 231
    1aa0:	55 20       	and	r5, r5
    1aa2:	41 53       	subi	r20, 0x31	; 49
    1aa4:	20 32       	cpi	r18, 0x20	; 32
    1aa6:	2e 32       	cpi	r18, 0x2E	; 46
    1aa8:	36 00       	.word	0x0036	; ????
    1aaa:	01 80       	ldd	r0, Z+1	; 0x01
    1aac:	aa 00       	.word	0x00aa	; ????
    1aae:	00 00       	nop
    1ab0:	02 00       	.word	0x0002	; ????
    1ab2:	cc 0a       	sbc	r12, r28
    1ab4:	00 00       	nop
    1ab6:	04 01       	movw	r0, r8
    1ab8:	89 0a       	sbc	r8, r25
    1aba:	00 00       	nop
    1abc:	8c 00       	.word	0x008c	; ????
    1abe:	00 00       	nop
    1ac0:	9c 00       	.word	0x009c	; ????
    1ac2:	00 00       	nop
    1ac4:	2e 2e       	mov	r2, r30
    1ac6:	2f 2e       	mov	r2, r31
    1ac8:	2e 2f       	mov	r18, r30
    1aca:	2e 2e       	mov	r2, r30
    1acc:	2f 2e       	mov	r2, r31
    1ace:	2e 2f       	mov	r18, r30
    1ad0:	67 63       	ori	r22, 0x37	; 55
    1ad2:	63 2f       	mov	r22, r19
    1ad4:	6c 69       	ori	r22, 0x9C	; 156
    1ad6:	62 67       	ori	r22, 0x72	; 114
    1ad8:	63 63       	ori	r22, 0x33	; 51
    1ada:	2f 63       	ori	r18, 0x3F	; 63
    1adc:	6f 6e       	ori	r22, 0xEF	; 239
    1ade:	66 69       	ori	r22, 0x96	; 150
    1ae0:	67 2f       	mov	r22, r23
    1ae2:	61 76       	andi	r22, 0x61	; 97
    1ae4:	72 2f       	mov	r23, r18
    1ae6:	6c 69       	ori	r22, 0x9C	; 156
    1ae8:	62 31       	cpi	r22, 0x12	; 18
    1aea:	66 75       	andi	r22, 0x56	; 86
    1aec:	6e 63       	ori	r22, 0x3E	; 62
    1aee:	73 2e       	mov	r7, r19
    1af0:	53 00       	.word	0x0053	; ????
    1af2:	2f 55       	subi	r18, 0x5F	; 95
    1af4:	73 65       	ori	r23, 0x53	; 83
    1af6:	72 73       	andi	r23, 0x32	; 50
    1af8:	2f 6a       	ori	r18, 0xAF	; 175
    1afa:	65 6e       	ori	r22, 0xE5	; 229
    1afc:	6b 69       	ori	r22, 0x9B	; 155
    1afe:	6e 73       	andi	r22, 0x3E	; 62
    1b00:	2f 6a       	ori	r18, 0xAF	; 175
    1b02:	65 6e       	ori	r22, 0xE5	; 229
    1b04:	6b 69       	ori	r22, 0x9B	; 155
    1b06:	6e 73       	andi	r22, 0x3E	; 62
    1b08:	2f 77       	andi	r18, 0x7F	; 127
    1b0a:	6f 72       	andi	r22, 0x2F	; 47
    1b0c:	6b 73       	andi	r22, 0x3B	; 59
    1b0e:	70 61       	ori	r23, 0x10	; 16
    1b10:	63 65       	ori	r22, 0x53	; 83
    1b12:	2f 61       	ori	r18, 0x1F	; 31
    1b14:	76 72       	andi	r23, 0x26	; 38
    1b16:	2d 67       	ori	r18, 0x7D	; 125
    1b18:	63 63       	ori	r22, 0x33	; 51
    1b1a:	2d 73       	andi	r18, 0x3D	; 61
    1b1c:	74 61       	ori	r23, 0x14	; 20
    1b1e:	67 69       	ori	r22, 0x97	; 151
    1b20:	6e 67       	ori	r22, 0x7E	; 126
    1b22:	2f 6c       	ori	r18, 0xCF	; 207
    1b24:	61 62       	ori	r22, 0x21	; 33
    1b26:	65 6c       	ori	r22, 0xC5	; 197
    1b28:	2f 6d       	ori	r18, 0xDF	; 223
    1b2a:	61 63       	ori	r22, 0x31	; 49
    1b2c:	2d 6d       	ori	r18, 0xDD	; 221
    1b2e:	69 6e       	ori	r22, 0xE9	; 233
    1b30:	69 2f       	mov	r22, r25
    1b32:	67 63       	ori	r22, 0x37	; 55
    1b34:	63 2d       	mov	r22, r3
    1b36:	62 75       	andi	r22, 0x52	; 82
    1b38:	69 6c       	ori	r22, 0xC9	; 201
    1b3a:	64 2f       	mov	r22, r20
    1b3c:	61 76       	andi	r22, 0x61	; 97
    1b3e:	72 2f       	mov	r23, r18
    1b40:	61 76       	andi	r22, 0x61	; 97
    1b42:	72 35       	cpi	r23, 0x52	; 82
    1b44:	2f 6c       	ori	r18, 0xCF	; 207
    1b46:	69 62       	ori	r22, 0x29	; 41
    1b48:	67 63       	ori	r22, 0x37	; 55
    1b4a:	63 00       	.word	0x0063	; ????
    1b4c:	47 4e       	sbci	r20, 0xE7	; 231
    1b4e:	55 20       	and	r5, r5
    1b50:	41 53       	subi	r20, 0x31	; 49
    1b52:	20 32       	cpi	r18, 0x20	; 32
    1b54:	2e 32       	cpi	r18, 0x2E	; 46
    1b56:	36 00       	.word	0x0036	; ????
    1b58:	01 80       	ldd	r0, Z+1	; 0x01
    1b5a:	aa 00       	.word	0x00aa	; ????
    1b5c:	00 00       	nop
    1b5e:	02 00       	.word	0x0002	; ????
    1b60:	e0 0a       	sbc	r14, r16
    1b62:	00 00       	nop
    1b64:	04 01       	movw	r0, r8
    1b66:	0f 0b       	sbc	r16, r31
    1b68:	00 00       	nop
    1b6a:	9c 00       	.word	0x009c	; ????
    1b6c:	00 00       	nop
    1b6e:	b2 00       	.word	0x00b2	; ????
    1b70:	00 00       	nop
    1b72:	2e 2e       	mov	r2, r30
    1b74:	2f 2e       	mov	r2, r31
    1b76:	2e 2f       	mov	r18, r30
    1b78:	2e 2e       	mov	r2, r30
    1b7a:	2f 2e       	mov	r2, r31
    1b7c:	2e 2f       	mov	r18, r30
    1b7e:	67 63       	ori	r22, 0x37	; 55
    1b80:	63 2f       	mov	r22, r19
    1b82:	6c 69       	ori	r22, 0x9C	; 156
    1b84:	62 67       	ori	r22, 0x72	; 114
    1b86:	63 63       	ori	r22, 0x33	; 51
    1b88:	2f 63       	ori	r18, 0x3F	; 63
    1b8a:	6f 6e       	ori	r22, 0xEF	; 239
    1b8c:	66 69       	ori	r22, 0x96	; 150
    1b8e:	67 2f       	mov	r22, r23
    1b90:	61 76       	andi	r22, 0x61	; 97
    1b92:	72 2f       	mov	r23, r18
    1b94:	6c 69       	ori	r22, 0x9C	; 156
    1b96:	62 31       	cpi	r22, 0x12	; 18
    1b98:	66 75       	andi	r22, 0x56	; 86
    1b9a:	6e 63       	ori	r22, 0x3E	; 62
    1b9c:	73 2e       	mov	r7, r19
    1b9e:	53 00       	.word	0x0053	; ????
    1ba0:	2f 55       	subi	r18, 0x5F	; 95
    1ba2:	73 65       	ori	r23, 0x53	; 83
    1ba4:	72 73       	andi	r23, 0x32	; 50
    1ba6:	2f 6a       	ori	r18, 0xAF	; 175
    1ba8:	65 6e       	ori	r22, 0xE5	; 229
    1baa:	6b 69       	ori	r22, 0x9B	; 155
    1bac:	6e 73       	andi	r22, 0x3E	; 62
    1bae:	2f 6a       	ori	r18, 0xAF	; 175
    1bb0:	65 6e       	ori	r22, 0xE5	; 229
    1bb2:	6b 69       	ori	r22, 0x9B	; 155
    1bb4:	6e 73       	andi	r22, 0x3E	; 62
    1bb6:	2f 77       	andi	r18, 0x7F	; 127
    1bb8:	6f 72       	andi	r22, 0x2F	; 47
    1bba:	6b 73       	andi	r22, 0x3B	; 59
    1bbc:	70 61       	ori	r23, 0x10	; 16
    1bbe:	63 65       	ori	r22, 0x53	; 83
    1bc0:	2f 61       	ori	r18, 0x1F	; 31
    1bc2:	76 72       	andi	r23, 0x26	; 38
    1bc4:	2d 67       	ori	r18, 0x7D	; 125
    1bc6:	63 63       	ori	r22, 0x33	; 51
    1bc8:	2d 73       	andi	r18, 0x3D	; 61
    1bca:	74 61       	ori	r23, 0x14	; 20
    1bcc:	67 69       	ori	r22, 0x97	; 151
    1bce:	6e 67       	ori	r22, 0x7E	; 126
    1bd0:	2f 6c       	ori	r18, 0xCF	; 207
    1bd2:	61 62       	ori	r22, 0x21	; 33
    1bd4:	65 6c       	ori	r22, 0xC5	; 197
    1bd6:	2f 6d       	ori	r18, 0xDF	; 223
    1bd8:	61 63       	ori	r22, 0x31	; 49
    1bda:	2d 6d       	ori	r18, 0xDD	; 221
    1bdc:	69 6e       	ori	r22, 0xE9	; 233
    1bde:	69 2f       	mov	r22, r25
    1be0:	67 63       	ori	r22, 0x37	; 55
    1be2:	63 2d       	mov	r22, r3
    1be4:	62 75       	andi	r22, 0x52	; 82
    1be6:	69 6c       	ori	r22, 0xC9	; 201
    1be8:	64 2f       	mov	r22, r20
    1bea:	61 76       	andi	r22, 0x61	; 97
    1bec:	72 2f       	mov	r23, r18
    1bee:	61 76       	andi	r22, 0x61	; 97
    1bf0:	72 35       	cpi	r23, 0x52	; 82
    1bf2:	2f 6c       	ori	r18, 0xCF	; 207
    1bf4:	69 62       	ori	r22, 0x29	; 41
    1bf6:	67 63       	ori	r22, 0x37	; 55
    1bf8:	63 00       	.word	0x0063	; ????
    1bfa:	47 4e       	sbci	r20, 0xE7	; 231
    1bfc:	55 20       	and	r5, r5
    1bfe:	41 53       	subi	r20, 0x31	; 49
    1c00:	20 32       	cpi	r18, 0x20	; 32
    1c02:	2e 32       	cpi	r18, 0x2E	; 46
    1c04:	36 00       	.word	0x0036	; ????
    1c06:	01 80       	ldd	r0, Z+1	; 0x01
    1c08:	aa 00       	.word	0x00aa	; ????
    1c0a:	00 00       	nop
    1c0c:	02 00       	.word	0x0002	; ????
    1c0e:	f4 0a       	sbc	r15, r20
    1c10:	00 00       	nop
    1c12:	04 01       	movw	r0, r8
    1c14:	a1 0b       	sbc	r26, r17
    1c16:	00 00       	nop
    1c18:	2e 07       	cpc	r18, r30
    1c1a:	00 00       	nop
    1c1c:	3a 07       	cpc	r19, r26
    1c1e:	00 00       	nop
    1c20:	2e 2e       	mov	r2, r30
    1c22:	2f 2e       	mov	r2, r31
    1c24:	2e 2f       	mov	r18, r30
    1c26:	2e 2e       	mov	r2, r30
    1c28:	2f 2e       	mov	r2, r31
    1c2a:	2e 2f       	mov	r18, r30
    1c2c:	67 63       	ori	r22, 0x37	; 55
    1c2e:	63 2f       	mov	r22, r19
    1c30:	6c 69       	ori	r22, 0x9C	; 156
    1c32:	62 67       	ori	r22, 0x72	; 114
    1c34:	63 63       	ori	r22, 0x33	; 51
    1c36:	2f 63       	ori	r18, 0x3F	; 63
    1c38:	6f 6e       	ori	r22, 0xEF	; 239
    1c3a:	66 69       	ori	r22, 0x96	; 150
    1c3c:	67 2f       	mov	r22, r23
    1c3e:	61 76       	andi	r22, 0x61	; 97
    1c40:	72 2f       	mov	r23, r18
    1c42:	6c 69       	ori	r22, 0x9C	; 156
    1c44:	62 31       	cpi	r22, 0x12	; 18
    1c46:	66 75       	andi	r22, 0x56	; 86
    1c48:	6e 63       	ori	r22, 0x3E	; 62
    1c4a:	73 2e       	mov	r7, r19
    1c4c:	53 00       	.word	0x0053	; ????
    1c4e:	2f 55       	subi	r18, 0x5F	; 95
    1c50:	73 65       	ori	r23, 0x53	; 83
    1c52:	72 73       	andi	r23, 0x32	; 50
    1c54:	2f 6a       	ori	r18, 0xAF	; 175
    1c56:	65 6e       	ori	r22, 0xE5	; 229
    1c58:	6b 69       	ori	r22, 0x9B	; 155
    1c5a:	6e 73       	andi	r22, 0x3E	; 62
    1c5c:	2f 6a       	ori	r18, 0xAF	; 175
    1c5e:	65 6e       	ori	r22, 0xE5	; 229
    1c60:	6b 69       	ori	r22, 0x9B	; 155
    1c62:	6e 73       	andi	r22, 0x3E	; 62
    1c64:	2f 77       	andi	r18, 0x7F	; 127
    1c66:	6f 72       	andi	r22, 0x2F	; 47
    1c68:	6b 73       	andi	r22, 0x3B	; 59
    1c6a:	70 61       	ori	r23, 0x10	; 16
    1c6c:	63 65       	ori	r22, 0x53	; 83
    1c6e:	2f 61       	ori	r18, 0x1F	; 31
    1c70:	76 72       	andi	r23, 0x26	; 38
    1c72:	2d 67       	ori	r18, 0x7D	; 125
    1c74:	63 63       	ori	r22, 0x33	; 51
    1c76:	2d 73       	andi	r18, 0x3D	; 61
    1c78:	74 61       	ori	r23, 0x14	; 20
    1c7a:	67 69       	ori	r22, 0x97	; 151
    1c7c:	6e 67       	ori	r22, 0x7E	; 126
    1c7e:	2f 6c       	ori	r18, 0xCF	; 207
    1c80:	61 62       	ori	r22, 0x21	; 33
    1c82:	65 6c       	ori	r22, 0xC5	; 197
    1c84:	2f 6d       	ori	r18, 0xDF	; 223
    1c86:	61 63       	ori	r22, 0x31	; 49
    1c88:	2d 6d       	ori	r18, 0xDD	; 221
    1c8a:	69 6e       	ori	r22, 0xE9	; 233
    1c8c:	69 2f       	mov	r22, r25
    1c8e:	67 63       	ori	r22, 0x37	; 55
    1c90:	63 2d       	mov	r22, r3
    1c92:	62 75       	andi	r22, 0x52	; 82
    1c94:	69 6c       	ori	r22, 0xC9	; 201
    1c96:	64 2f       	mov	r22, r20
    1c98:	61 76       	andi	r22, 0x61	; 97
    1c9a:	72 2f       	mov	r23, r18
    1c9c:	61 76       	andi	r22, 0x61	; 97
    1c9e:	72 35       	cpi	r23, 0x52	; 82
    1ca0:	2f 6c       	ori	r18, 0xCF	; 207
    1ca2:	69 62       	ori	r22, 0x29	; 41
    1ca4:	67 63       	ori	r22, 0x37	; 55
    1ca6:	63 00       	.word	0x0063	; ????
    1ca8:	47 4e       	sbci	r20, 0xE7	; 231
    1caa:	55 20       	and	r5, r5
    1cac:	41 53       	subi	r20, 0x31	; 49
    1cae:	20 32       	cpi	r18, 0x20	; 32
    1cb0:	2e 32       	cpi	r18, 0x2E	; 46
    1cb2:	36 00       	.word	0x0036	; ????
    1cb4:	01 80       	ldd	r0, Z+1	; 0x01

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	01 11       	cpse	r16, r1
   2:	01 25       	eor	r16, r1
   4:	0e 10       	cpse	r0, r14
   6:	06 00       	.word	0x0006	; ????
   8:	00 02       	muls	r16, r16
   a:	24 00       	.word	0x0024	; ????
   c:	03 0e       	add	r0, r19
   e:	0b 0b       	sbc	r16, r27
  10:	3e 0b       	sbc	r19, r30
  12:	00 00       	nop
  14:	03 24       	eor	r0, r3
  16:	00 03       	mulsu	r16, r16
  18:	0e 0b       	sbc	r16, r30
  1a:	0b 3e       	cpi	r16, 0xEB	; 235
  1c:	0b 00       	.word	0x000b	; ????
  1e:	00 04       	cpc	r0, r0
  20:	01 01       	movw	r0, r2
  22:	49 13       	cpse	r20, r25
  24:	00 00       	nop
  26:	05 21       	and	r16, r5
  28:	00 49       	sbci	r16, 0x90	; 144
  2a:	13 2f       	mov	r17, r19
  2c:	05 00       	.word	0x0005	; ????
  2e:	00 06       	cpc	r0, r16
  30:	34 00       	.word	0x0034	; ????
  32:	03 0e       	add	r0, r19
  34:	3a 0b       	sbc	r19, r26
  36:	3b 0b       	sbc	r19, r27
  38:	49 13       	cpse	r20, r25
  3a:	3f 0c       	add	r3, r15
  3c:	02 0a       	sbc	r0, r18
  3e:	00 00       	nop
  40:	07 34       	cpi	r16, 0x47	; 71
  42:	00 03       	mulsu	r16, r16
  44:	0e 3a       	cpi	r16, 0xAE	; 174
  46:	0b 3b       	cpi	r16, 0xBB	; 187
  48:	0b 49       	sbci	r16, 0x9B	; 155
  4a:	13 3f       	cpi	r17, 0xF3	; 243
  4c:	0c 02       	muls	r16, r28
  4e:	0a 00       	.word	0x000a	; ????
  50:	00 08       	sbc	r0, r0
  52:	34 00       	.word	0x0034	; ????
  54:	03 0e       	add	r0, r19
  56:	3a 0b       	sbc	r19, r26
  58:	3b 0b       	sbc	r19, r27
  5a:	49 13       	cpse	r20, r25
  5c:	3f 0c       	add	r3, r15
  5e:	02 0a       	sbc	r0, r18
  60:	00 00       	nop
  62:	09 34       	cpi	r16, 0x49	; 73
  64:	00 03       	mulsu	r16, r16
  66:	0e 3a       	cpi	r16, 0xAE	; 174
  68:	0b 3b       	cpi	r16, 0xBB	; 187
  6a:	0b 49       	sbci	r16, 0x9B	; 155
  6c:	13 3f       	cpi	r17, 0xF3	; 243
  6e:	0c 02       	muls	r16, r28
  70:	0a 00       	.word	0x000a	; ????
  72:	00 0a       	sbc	r0, r16
  74:	34 00       	.word	0x0034	; ????
  76:	03 0e       	add	r0, r19
  78:	3a 0b       	sbc	r19, r26
  7a:	3b 0b       	sbc	r19, r27
  7c:	49 13       	cpse	r20, r25
  7e:	3f 0c       	add	r3, r15
  80:	02 0a       	sbc	r0, r18
  82:	00 00       	nop
  84:	0b 34       	cpi	r16, 0x4B	; 75
  86:	00 03       	mulsu	r16, r16
  88:	0e 3a       	cpi	r16, 0xAE	; 174
  8a:	0b 3b       	cpi	r16, 0xBB	; 187
  8c:	0b 49       	sbci	r16, 0x9B	; 155
  8e:	13 3f       	cpi	r17, 0xF3	; 243
  90:	0c 02       	muls	r16, r28
  92:	0a 00       	.word	0x000a	; ????
  94:	00 0c       	add	r0, r0
  96:	34 00       	.word	0x0034	; ????
  98:	03 0e       	add	r0, r19
  9a:	3a 0b       	sbc	r19, r26
  9c:	3b 0b       	sbc	r19, r27
  9e:	49 13       	cpse	r20, r25
  a0:	3f 0c       	add	r3, r15
  a2:	02 0a       	sbc	r0, r18
  a4:	00 00       	nop
  a6:	0d 34       	cpi	r16, 0x4D	; 77
  a8:	00 03       	mulsu	r16, r16
  aa:	0e 3a       	cpi	r16, 0xAE	; 174
  ac:	0b 3b       	cpi	r16, 0xBB	; 187
  ae:	0b 49       	sbci	r16, 0x9B	; 155
  b0:	13 3f       	cpi	r17, 0xF3	; 243
  b2:	0c 02       	muls	r16, r28
  b4:	0a 00       	.word	0x000a	; ????
  b6:	00 0e       	add	r0, r16
  b8:	34 00       	.word	0x0034	; ????
  ba:	03 0e       	add	r0, r19
  bc:	3a 0b       	sbc	r19, r26

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	3b 0b       	sbc	r19, r27
  c0:	49 13       	cpse	r20, r25
  c2:	3f 0c       	add	r3, r15
  c4:	02 0a       	sbc	r0, r18
  c6:	00 00       	nop
  c8:	0f 34       	cpi	r16, 0x4F	; 79
  ca:	00 03       	mulsu	r16, r16
  cc:	0e 3a       	cpi	r16, 0xAE	; 174
  ce:	0b 3b       	cpi	r16, 0xBB	; 187
  d0:	0b 49       	sbci	r16, 0x9B	; 155
  d2:	13 3f       	cpi	r17, 0xF3	; 243
  size_t n = 0;
  d4:	0c 02       	muls	r16, r28
  d6:	0a 00       	.word	0x000a	; ????
  while (size--) {
  d8:	00 10       	cpse	r0, r0
  da:	34 00       	.word	0x0034	; ????
  dc:	03 0e       	add	r0, r19
    if (write(*buffer++)) n++;
  de:	3a 0b       	sbc	r19, r26
  e0:	3b 0b       	sbc	r19, r27
  e2:	49 13       	cpse	r20, r25
  e4:	3f 0c       	add	r3, r15
  e6:	02 0a       	sbc	r0, r18
  e8:	00 00       	nop
  ea:	11 34       	cpi	r17, 0x41	; 65
  ec:	00 03       	mulsu	r16, r16
  ee:	0e 3a       	cpi	r16, 0xAE	; 174
  f0:	0b 3b       	cpi	r16, 0xBB	; 187
  f2:	0b 49       	sbci	r16, 0x9B	; 155
  f4:	13 3f       	cpi	r17, 0xF3	; 243
  f6:	0c 02       	muls	r16, r28
  f8:	0a 00       	.word	0x000a	; ????
  fa:	00 12       	cpse	r0, r16
  fc:	34 00       	.word	0x0034	; ????
    else break;
  }
  return n;
}
  fe:	03 0e       	add	r0, r19
 100:	3a 0b       	sbc	r19, r26
 102:	3b 0b       	sbc	r19, r27
 104:	49 13       	cpse	r20, r25
 106:	3f 0c       	add	r3, r15
 108:	02 0a       	sbc	r0, r18
 10a:	00 00       	nop
 10c:	13 34       	cpi	r17, 0x43	; 67
 10e:	00 03       	mulsu	r16, r16
 110:	0e 3a       	cpi	r16, 0xAE	; 174
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 112:	0b 3b       	cpi	r16, 0xBB	; 187
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 114:	0b 49       	sbci	r16, 0x9B	; 155
 116:	13 3f       	cpi	r17, 0xF3	; 243
 118:	0c 02       	muls	r16, r28
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 11a:	0a 00       	.word	0x000a	; ????
 11c:	00 14       	cp	r0, r0
    tail = _tx_buffer_tail;
 11e:	34 00       	.word	0x0034	; ????
 120:	03 0e       	add	r0, r19
 122:	3a 0b       	sbc	r19, r26
 124:	3b 0b       	sbc	r19, r27
 126:	49 13       	cpse	r20, r25
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 128:	3f 0c       	add	r3, r15
 12a:	02 0a       	sbc	r0, r18
 12c:	00 00       	nop
 12e:	15 34       	cpi	r17, 0x45	; 69
 130:	00 03       	mulsu	r16, r16
 132:	0e 3a       	cpi	r16, 0xAE	; 174
  return tail - head - 1;
 134:	0b 3b       	cpi	r16, 0xBB	; 187
}
 136:	0b 49       	sbci	r16, 0x9B	; 155
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 138:	13 3f       	cpi	r17, 0xF3	; 243
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 13a:	0c 02       	muls	r16, r28
 13c:	0a 00       	.word	0x000a	; ????
 13e:	00 16       	cp	r0, r16
 140:	34 00       	.word	0x0034	; ????
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 142:	03 0e       	add	r0, r19
 144:	3a 0b       	sbc	r19, r26
 146:	3b 0b       	sbc	r19, r27
 148:	49 13       	cpse	r20, r25
 14a:	3f 0c       	add	r3, r15
 14c:	02 0a       	sbc	r0, r18
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 14e:	00 00       	nop
 150:	17 34       	cpi	r17, 0x47	; 71
 152:	00 03       	mulsu	r16, r16
 154:	0e 3a       	cpi	r16, 0xAE	; 174
    return c;
 156:	0b 3b       	cpi	r16, 0xBB	; 187
 158:	0b 49       	sbci	r16, 0x9B	; 155

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 15a:	13 3f       	cpi	r17, 0xF3	; 243
 15c:	0c 02       	muls	r16, r28
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 15e:	0a 00       	.word	0x000a	; ????
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 160:	00 18       	sub	r0, r0
  if (_rx_buffer_head == _rx_buffer_tail) {
 162:	34 00       	.word	0x0034	; ????
 164:	03 0e       	add	r0, r19
 166:	3a 0b       	sbc	r19, r26
 168:	3b 0b       	sbc	r19, r27
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 16a:	49 13       	cpse	r20, r25
 16c:	3f 0c       	add	r3, r15
 16e:	02 0a       	sbc	r0, r18
 170:	00 00       	nop
 172:	19 34       	cpi	r17, 0x49	; 73
 174:	00 03       	mulsu	r16, r16
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 176:	0e 3a       	cpi	r16, 0xAE	; 174
 178:	0b 3b       	cpi	r16, 0xBB	; 187
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 17a:	0b 49       	sbci	r16, 0x9B	; 155
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 17c:	13 3f       	cpi	r17, 0xF3	; 243
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 17e:	0c 02       	muls	r16, r28
 180:	0a 00       	.word	0x000a	; ????
 182:	00 1a       	sub	r0, r16
 184:	34 00       	.word	0x0034	; ????
 186:	03 0e       	add	r0, r19
 188:	3a 0b       	sbc	r19, r26
 18a:	3b 0b       	sbc	r19, r27
 18c:	49 13       	cpse	r20, r25
}
 18e:	3f 0c       	add	r3, r15
 190:	02 0a       	sbc	r0, r18
 192:	00 00       	nop
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 194:	1b 34       	cpi	r17, 0x4B	; 75
 196:	00 03       	mulsu	r16, r16
 198:	0e 3a       	cpi	r16, 0xAE	; 174
 19a:	0b 3b       	cpi	r16, 0xBB	; 187
 19c:	0b 49       	sbci	r16, 0x9B	; 155
 19e:	13 3f       	cpi	r17, 0xF3	; 243
 1a0:	0c 02       	muls	r16, r28
 1a2:	0a 00       	.word	0x000a	; ????
}
 1a4:	00 1c       	adc	r0, r0
 1a6:	34 00       	.word	0x0034	; ????
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1a8:	03 0e       	add	r0, r19
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1aa:	3a 0b       	sbc	r19, r26
 1ac:	3b 0b       	sbc	r19, r27
 1ae:	49 13       	cpse	r20, r25
 1b0:	3f 0c       	add	r3, r15
 1b2:	02 0a       	sbc	r0, r18
 1b4:	00 00       	nop
 1b6:	1d 34       	cpi	r17, 0x4D	; 77
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1b8:	00 03       	mulsu	r16, r16
 1ba:	0e 3a       	cpi	r16, 0xAE	; 174
 1bc:	0b 3b       	cpi	r16, 0xBB	; 187
 1be:	0b 49       	sbci	r16, 0x9B	; 155
 1c0:	13 3f       	cpi	r17, 0xF3	; 243
 1c2:	0c 02       	muls	r16, r28

  *_udr = c;
 1c4:	0a 00       	.word	0x000a	; ????
 1c6:	00 1e       	adc	r0, r16
 1c8:	34 00       	.word	0x0034	; ????
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 1ca:	03 0e       	add	r0, r19
 1cc:	3a 0b       	sbc	r19, r26
 1ce:	3b 0b       	sbc	r19, r27
 1d0:	49 13       	cpse	r20, r25
 1d2:	3f 0c       	add	r3, r15
 1d4:	02 0a       	sbc	r0, r18
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 1d6:	00 00       	nop
 1d8:	1f 34       	cpi	r17, 0x4F	; 79
 1da:	00 03       	mulsu	r16, r16
 1dc:	0e 3a       	cpi	r16, 0xAE	; 174
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1de:	0b 3b       	cpi	r16, 0xBB	; 187
 1e0:	0b 49       	sbci	r16, 0x9B	; 155
 1e2:	13 3f       	cpi	r17, 0xF3	; 243
 1e4:	0c 02       	muls	r16, r28
 1e6:	0a 00       	.word	0x000a	; ????
 1e8:	00 20       	and	r0, r0
 1ea:	34 00       	.word	0x0034	; ????
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 1ec:	03 0e       	add	r0, r19
 1ee:	3a 0b       	sbc	r19, r26
 1f0:	3b 0b       	sbc	r19, r27
 1f2:	49 13       	cpse	r20, r25
 1f4:	3f 0c       	add	r3, r15
 1f6:	02 0a       	sbc	r0, r18
 1f8:	00 00       	nop
  _written = true;
 1fa:	21 34       	cpi	r18, 0x41	; 65
 1fc:	00 03       	mulsu	r16, r16
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 1fe:	0e 3a       	cpi	r16, 0xAE	; 174
 200:	0b 3b       	cpi	r16, 0xBB	; 187
 202:	0b 49       	sbci	r16, 0x9B	; 155
 204:	13 3f       	cpi	r17, 0xF3	; 243
 206:	0c 02       	muls	r16, r28
 208:	0a 00       	.word	0x000a	; ????
 20a:	00 22       	and	r0, r16
 20c:	34 00       	.word	0x0034	; ????
 20e:	03 0e       	add	r0, r19
 210:	3a 0b       	sbc	r19, r26
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 212:	3b 0b       	sbc	r19, r27
 214:	49 13       	cpse	r20, r25
 216:	3f 0c       	add	r3, r15
 218:	02 0a       	sbc	r0, r18
 21a:	00 00       	nop
 21c:	23 34       	cpi	r18, 0x43	; 67
 21e:	00 03       	mulsu	r16, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 220:	0e 3a       	cpi	r16, 0xAE	; 174
 222:	0b 3b       	cpi	r16, 0xBB	; 187
 224:	0b 49       	sbci	r16, 0x9B	; 155
    if (bit_is_clear(SREG, SREG_I)) {
 226:	13 3f       	cpi	r17, 0xF3	; 243
 228:	0c 02       	muls	r16, r28
 22a:	0a 00       	.word	0x000a	; ????
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 22c:	00 24       	eor	r0, r0
 22e:	34 00       	.word	0x0034	; ????
 230:	03 0e       	add	r0, r19
 232:	3a 0b       	sbc	r19, r26
 234:	3b 0b       	sbc	r19, r27
	_tx_udr_empty_irq();
 236:	49 13       	cpse	r20, r25
 238:	3f 0c       	add	r3, r15
 23a:	02 0a       	sbc	r0, r18
 23c:	00 00       	nop
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 23e:	25 34       	cpi	r18, 0x45	; 69
 240:	00 03       	mulsu	r16, r16
 242:	0e 3a       	cpi	r16, 0xAE	; 174
 244:	0b 3b       	cpi	r16, 0xBB	; 187
 246:	0b 49       	sbci	r16, 0x9B	; 155
 248:	13 3f       	cpi	r17, 0xF3	; 243
 24a:	0c 02       	muls	r16, r28

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 24c:	0a 00       	.word	0x000a	; ????
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 24e:	00 26       	eor	r0, r16
    _tx_buffer_head = i;
 250:	34 00       	.word	0x0034	; ????
    sbi(*_ucsrb, UDRIE0);
 252:	03 0e       	add	r0, r19
 254:	3a 0b       	sbc	r19, r26
 256:	3b 0b       	sbc	r19, r27
 258:	49 13       	cpse	r20, r25
 25a:	3f 0c       	add	r3, r15
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 25c:	02 0a       	sbc	r0, r18
 25e:	00 00       	nop
      *_udr = c;
 260:	27 34       	cpi	r18, 0x47	; 71
 262:	00 03       	mulsu	r16, r16
 264:	0e 3a       	cpi	r16, 0xAE	; 174
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 266:	0b 3b       	cpi	r16, 0xBB	; 187
 268:	0b 49       	sbci	r16, 0x9B	; 155
 26a:	13 3f       	cpi	r17, 0xF3	; 243
 26c:	0c 02       	muls	r16, r28
 26e:	0a 00       	.word	0x000a	; ????
 270:	00 28       	or	r0, r0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 272:	34 00       	.word	0x0034	; ????
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
 274:	03 0e       	add	r0, r19
 276:	3a 0b       	sbc	r19, r26
 278:	3b 0b       	sbc	r19, r27
 27a:	49 13       	cpse	r20, r25
 27c:	3f 0c       	add	r3, r15
 27e:	02 0a       	sbc	r0, r18
 280:	00 00       	nop
 282:	29 34       	cpi	r18, 0x49	; 73
 284:	00 03       	mulsu	r16, r16
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 286:	0e 3a       	cpi	r16, 0xAE	; 174
 288:	0b 3b       	cpi	r16, 0xBB	; 187
 28a:	0b 49       	sbci	r16, 0x9B	; 155
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 28c:	13 3f       	cpi	r17, 0xF3	; 243
 28e:	0c 02       	muls	r16, r28
 290:	0a 00       	.word	0x000a	; ????
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 292:	00 2a       	or	r0, r16
 294:	34 00       	.word	0x0034	; ????
 296:	03 0e       	add	r0, r19
 298:	3a 0b       	sbc	r19, r26
 29a:	3b 0b       	sbc	r19, r27
 29c:	49 13       	cpse	r20, r25
 29e:	3f 0c       	add	r3, r15
 2a0:	02 0a       	sbc	r0, r18
 2a2:	00 00       	nop
 2a4:	2b 34       	cpi	r18, 0x4B	; 75
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 2a6:	00 03       	mulsu	r16, r16
 2a8:	0e 3a       	cpi	r16, 0xAE	; 174
 2aa:	0b 3b       	cpi	r16, 0xBB	; 187
 2ac:	0b 49       	sbci	r16, 0x9B	; 155
 2ae:	13 3f       	cpi	r17, 0xF3	; 243
 2b0:	0c 02       	muls	r16, r28
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 2b2:	0a 00       	.word	0x000a	; ????
 2b4:	00 2c       	mov	r0, r0
 2b6:	34 00       	.word	0x0034	; ????
 2b8:	03 0e       	add	r0, r19
 2ba:	3a 0b       	sbc	r19, r26
	  _tx_udr_empty_irq();
 2bc:	3b 0b       	sbc	r19, r27
 2be:	49 13       	cpse	r20, r25
 2c0:	3f 0c       	add	r3, r15
 2c2:	02 0a       	sbc	r0, r18
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 2c4:	00 00       	nop
 2c6:	2d 34       	cpi	r18, 0x4D	; 77
 2c8:	00 03       	mulsu	r16, r16
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2ca:	0e 3a       	cpi	r16, 0xAE	; 174
 2cc:	0b 3b       	cpi	r16, 0xBB	; 187
 2ce:	0b 49       	sbci	r16, 0x9B	; 155
 2d0:	13 3f       	cpi	r17, 0xF3	; 243
 2d2:	0c 02       	muls	r16, r28
 2d4:	0a 00       	.word	0x000a	; ????
 2d6:	00 2e       	mov	r0, r16
 2d8:	34 00       	.word	0x0034	; ????
 2da:	03 0e       	add	r0, r19
 2dc:	3a 0b       	sbc	r19, r26
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 2de:	3b 0b       	sbc	r19, r27
 2e0:	49 13       	cpse	r20, r25
      return write((const uint8_t *)str, strlen(str));
 2e2:	3f 0c       	add	r3, r15
 2e4:	02 0a       	sbc	r0, r18
 2e6:	00 00       	nop
 2e8:	2f 34       	cpi	r18, 0x4F	; 79
 2ea:	00 03       	mulsu	r16, r16
 2ec:	0e 3a       	cpi	r16, 0xAE	; 174
 2ee:	0b 3b       	cpi	r16, 0xBB	; 187
 2f0:	0b 49       	sbci	r16, 0x9B	; 155
 2f2:	13 3f       	cpi	r17, 0xF3	; 243
 2f4:	0c 02       	muls	r16, r28
 2f6:	0a 00       	.word	0x000a	; ????
 2f8:	00 30       	cpi	r16, 0x00	; 0
 2fa:	34 00       	.word	0x0034	; ????
    }
 2fc:	03 0e       	add	r0, r19
 2fe:	3a 0b       	sbc	r19, r26
 300:	3b 0b       	sbc	r19, r27
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 302:	49 13       	cpse	r20, r25
 304:	3f 0c       	add	r3, r15
 306:	02 0a       	sbc	r0, r18
 308:	00 00       	nop
 30a:	31 34       	cpi	r19, 0x41	; 65
 30c:	00 03       	mulsu	r16, r16
 30e:	0e 3a       	cpi	r16, 0xAE	; 174
 310:	0b 3b       	cpi	r16, 0xBB	; 187
 312:	0b 49       	sbci	r16, 0x9B	; 155
 314:	13 3f       	cpi	r17, 0xF3	; 243
 316:	0c 02       	muls	r16, r28
 318:	0a 00       	.word	0x000a	; ????
 31a:	00 32       	cpi	r16, 0x20	; 32
 31c:	34 00       	.word	0x0034	; ????
 31e:	03 0e       	add	r0, r19
 320:	3a 0b       	sbc	r19, r26
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 322:	3b 0b       	sbc	r19, r27

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 324:	49 13       	cpse	r20, r25
 326:	3f 0c       	add	r3, r15
 328:	02 0a       	sbc	r0, r18
 32a:	00 00       	nop
 32c:	33 34       	cpi	r19, 0x43	; 67
 32e:	00 03       	mulsu	r16, r16

  do {
    char c = n % base;
 330:	0e 3a       	cpi	r16, 0xAE	; 174
 332:	0b 3b       	cpi	r16, 0xBB	; 187
 334:	0b 49       	sbci	r16, 0x9B	; 155
 336:	13 3f       	cpi	r17, 0xF3	; 243
 338:	0c 02       	muls	r16, r28
 33a:	0a 00       	.word	0x000a	; ????
 33c:	00 34       	cpi	r16, 0x40	; 64
 33e:	34 00       	.word	0x0034	; ????
 340:	03 0e       	add	r0, r19
    n /= base;
 342:	3a 0b       	sbc	r19, r26
 344:	3b 0b       	sbc	r19, r27

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 346:	49 13       	cpse	r20, r25
 348:	3f 0c       	add	r3, r15
 34a:	02 0a       	sbc	r0, r18
 34c:	00 00       	nop
 34e:	35 34       	cpi	r19, 0x45	; 69
 350:	00 03       	mulsu	r16, r16
 352:	0e 3a       	cpi	r16, 0xAE	; 174
 354:	0b 3b       	cpi	r16, 0xBB	; 187
 356:	0b 49       	sbci	r16, 0x9B	; 155
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 358:	13 3f       	cpi	r17, 0xF3	; 243
 35a:	0c 02       	muls	r16, r28
 35c:	0a 00       	.word	0x000a	; ????
 35e:	00 36       	cpi	r16, 0x60	; 96
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 360:	34 00       	.word	0x0034	; ????
 362:	03 0e       	add	r0, r19
 364:	3a 0b       	sbc	r19, r26
}
 366:	3b 0b       	sbc	r19, r27
 368:	49 13       	cpse	r20, r25
 36a:	3f 0c       	add	r3, r15
 36c:	02 0a       	sbc	r0, r18
 36e:	00 00       	nop
 370:	37 34       	cpi	r19, 0x47	; 71
 372:	00 03       	mulsu	r16, r16
 374:	0e 3a       	cpi	r16, 0xAE	; 174
 376:	0b 3b       	cpi	r16, 0xBB	; 187
 378:	0b 49       	sbci	r16, 0x9B	; 155
 37a:	13 3f       	cpi	r17, 0xF3	; 243
 37c:	0c 02       	muls	r16, r28
 37e:	0a 00       	.word	0x000a	; ????
 380:	00 38       	cpi	r16, 0x80	; 128
 382:	34 00       	.word	0x0034	; ????
 384:	03 0e       	add	r0, r19
 386:	3a 0b       	sbc	r19, r26
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 388:	3b 0b       	sbc	r19, r27
 38a:	49 13       	cpse	r20, r25
 38c:	3f 0c       	add	r3, r15
 38e:	02 0a       	sbc	r0, r18
 390:	00 00       	nop
 392:	39 34       	cpi	r19, 0x49	; 73
 394:	00 03       	mulsu	r16, r16
 396:	0e 3a       	cpi	r16, 0xAE	; 174
 398:	0b 3b       	cpi	r16, 0xBB	; 187
 39a:	0b 49       	sbci	r16, 0x9B	; 155
 39c:	13 3f       	cpi	r17, 0xF3	; 243
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 39e:	0c 02       	muls	r16, r28
 3a0:	0a 00       	.word	0x000a	; ????
 3a2:	00 3a       	cpi	r16, 0xA0	; 160
 3a4:	34 00       	.word	0x0034	; ????
 3a6:	03 0e       	add	r0, r19
 3a8:	3a 0b       	sbc	r19, r26
 3aa:	3b 0b       	sbc	r19, r27
 3ac:	49 13       	cpse	r20, r25
	unsigned char f = timer0_fract;
 3ae:	3f 0c       	add	r3, r15
 3b0:	02 0a       	sbc	r0, r18

	m += MILLIS_INC;
	f += FRACT_INC;
 3b2:	00 00       	nop
 3b4:	3b 34       	cpi	r19, 0x4B	; 75
	if (f >= FRACT_MAX) {
 3b6:	00 03       	mulsu	r16, r16
 3b8:	0e 3a       	cpi	r16, 0xAE	; 174
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 3ba:	0b 3b       	cpi	r16, 0xBB	; 187
 3bc:	0b 49       	sbci	r16, 0x9B	; 155
 3be:	13 3f       	cpi	r17, 0xF3	; 243
 3c0:	0c 02       	muls	r16, r28
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 3c2:	0a 00       	.word	0x000a	; ????
 3c4:	00 3c       	cpi	r16, 0xC0	; 192
		m += 1;
 3c6:	34 00       	.word	0x0034	; ????
 3c8:	03 0e       	add	r0, r19
 3ca:	3a 0b       	sbc	r19, r26
	}

	timer0_fract = f;
 3cc:	3b 0b       	sbc	r19, r27
 3ce:	49 13       	cpse	r20, r25
	timer0_millis = m;
 3d0:	3f 0c       	add	r3, r15
 3d2:	02 0a       	sbc	r0, r18
 3d4:	00 00       	nop
 3d6:	3d 34       	cpi	r19, 0x4D	; 77
 3d8:	00 03       	mulsu	r16, r16
 3da:	0e 3a       	cpi	r16, 0xAE	; 174
 3dc:	0b 3b       	cpi	r16, 0xBB	; 187
 3de:	0b 49       	sbci	r16, 0x9B	; 155
	timer0_overflow_count++;
 3e0:	13 3f       	cpi	r17, 0xF3	; 243
 3e2:	0c 02       	muls	r16, r28
 3e4:	0a 00       	.word	0x000a	; ????
 3e6:	00 3e       	cpi	r16, 0xE0	; 224
 3e8:	34 00       	.word	0x0034	; ????
 3ea:	03 0e       	add	r0, r19
 3ec:	3a 0b       	sbc	r19, r26
 3ee:	3b 0b       	sbc	r19, r27
 3f0:	49 13       	cpse	r20, r25
 3f2:	3f 0c       	add	r3, r15
 3f4:	02 0a       	sbc	r0, r18
 3f6:	00 00       	nop
 3f8:	3f 34       	cpi	r19, 0x4F	; 79
 3fa:	00 03       	mulsu	r16, r16
 3fc:	0e 3a       	cpi	r16, 0xAE	; 174
 3fe:	0b 3b       	cpi	r16, 0xBB	; 187
 400:	0b 49       	sbci	r16, 0x9B	; 155
 402:	13 3f       	cpi	r17, 0xF3	; 243
 404:	0c 02       	muls	r16, r28
}
 406:	0a 00       	.word	0x000a	; ????
 408:	00 40       	sbci	r16, 0x00	; 0
 40a:	34 00       	.word	0x0034	; ????
 40c:	03 0e       	add	r0, r19
 40e:	3a 0b       	sbc	r19, r26
 410:	3b 0b       	sbc	r19, r27
 412:	49 13       	cpse	r20, r25
 414:	3f 0c       	add	r3, r15
 416:	02 0a       	sbc	r0, r18
 418:	00 00       	nop
 41a:	41 34       	cpi	r20, 0x41	; 65
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 41c:	00 03       	mulsu	r16, r16
 41e:	0e 3a       	cpi	r16, 0xAE	; 174
 420:	0b 3b       	cpi	r16, 0xBB	; 187
 422:	0b 49       	sbci	r16, 0x9B	; 155
 424:	13 3f       	cpi	r17, 0xF3	; 243
 426:	0c 02       	muls	r16, r28
 428:	0a 00       	.word	0x000a	; ????
 42a:	00 42       	sbci	r16, 0x20	; 32
 42c:	34 00       	.word	0x0034	; ????
 42e:	03 0e       	add	r0, r19
 430:	3a 0b       	sbc	r19, r26
 432:	3b 0b       	sbc	r19, r27
 434:	49 13       	cpse	r20, r25
 436:	3f 0c       	add	r3, r15
 438:	02 0a       	sbc	r0, r18
 43a:	00 00       	nop
 43c:	43 34       	cpi	r20, 0x43	; 67
  Serial._tx_udr_empty_irq();
 43e:	00 03       	mulsu	r16, r16
 440:	0e 3a       	cpi	r16, 0xAE	; 174
 442:	0b 3b       	cpi	r16, 0xBB	; 187
 444:	0b 49       	sbci	r16, 0x9B	; 155
}
 446:	13 3f       	cpi	r17, 0xF3	; 243
 448:	0c 02       	muls	r16, r28
 44a:	0a 00       	.word	0x000a	; ????
 44c:	00 44       	sbci	r16, 0x40	; 64
 44e:	34 00       	.word	0x0034	; ????
 450:	03 0e       	add	r0, r19
 452:	3a 0b       	sbc	r19, r26
 454:	3b 0b       	sbc	r19, r27
 456:	49 13       	cpse	r20, r25
 458:	3f 0c       	add	r3, r15
 45a:	02 0a       	sbc	r0, r18
 45c:	00 00       	nop
 45e:	45 34       	cpi	r20, 0x45	; 69
 460:	00 03       	mulsu	r16, r16
 462:	0e 3a       	cpi	r16, 0xAE	; 174
 464:	0b 3b       	cpi	r16, 0xBB	; 187
 466:	0b 49       	sbci	r16, 0x9B	; 155
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 468:	13 3f       	cpi	r17, 0xF3	; 243
 46a:	0c 02       	muls	r16, r28
 46c:	0a 00       	.word	0x000a	; ????
 46e:	00 46       	sbci	r16, 0x60	; 96
 470:	34 00       	.word	0x0034	; ????
 472:	03 0e       	add	r0, r19
 474:	3a 0b       	sbc	r19, r26
 476:	3b 0b       	sbc	r19, r27
 478:	49 13       	cpse	r20, r25
 47a:	3f 0c       	add	r3, r15

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 47c:	02 0a       	sbc	r0, r18
 47e:	00 00       	nop
 480:	47 34       	cpi	r20, 0x47	; 71
 482:	00 03       	mulsu	r16, r16
 484:	0e 3a       	cpi	r16, 0xAE	; 174
 486:	0b 3b       	cpi	r16, 0xBB	; 187
 488:	0b 49       	sbci	r16, 0x9B	; 155
 48a:	13 3f       	cpi	r17, 0xF3	; 243
 48c:	0c 02       	muls	r16, r28
 48e:	0a 00       	.word	0x000a	; ????
 490:	00 48       	sbci	r16, 0x80	; 128
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 492:	34 00       	.word	0x0034	; ????
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 494:	03 0e       	add	r0, r19
 496:	3a 0b       	sbc	r19, r26
 498:	3b 0b       	sbc	r19, r27
 49a:	49 13       	cpse	r20, r25

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 49c:	3f 0c       	add	r3, r15
 49e:	02 0a       	sbc	r0, r18
 4a0:	00 00       	nop
 4a2:	49 34       	cpi	r20, 0x49	; 73
      _rx_buffer[_rx_buffer_head] = c;
 4a4:	00 03       	mulsu	r16, r16
 4a6:	0e 3a       	cpi	r16, 0xAE	; 174
 4a8:	0b 3b       	cpi	r16, 0xBB	; 187
 4aa:	0b 49       	sbci	r16, 0x9B	; 155
 4ac:	13 3f       	cpi	r17, 0xF3	; 243
 4ae:	0c 02       	muls	r16, r28
      _rx_buffer_head = i;
 4b0:	0a 00       	.word	0x000a	; ????
 4b2:	00 4a       	sbci	r16, 0xA0	; 160
 4b4:	34 00       	.word	0x0034	; ????
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 4b6:	03 0e       	add	r0, r19
    Serial._rx_complete_irq();
  }
 4b8:	3a 0b       	sbc	r19, r26
 4ba:	3b 0b       	sbc	r19, r27
 4bc:	49 13       	cpse	r20, r25
 4be:	3f 0c       	add	r3, r15
 4c0:	02 0a       	sbc	r0, r18
 4c2:	00 00       	nop
 4c4:	4b 34       	cpi	r20, 0x4B	; 75
 4c6:	00 03       	mulsu	r16, r16
 4c8:	0e 3a       	cpi	r16, 0xAE	; 174
 4ca:	0b 3b       	cpi	r16, 0xBB	; 187

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 4cc:	0b 49       	sbci	r16, 0x9B	; 155
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 4ce:	13 3f       	cpi	r17, 0xF3	; 243
 4d0:	0c 02       	muls	r16, r28
 4d2:	0a 00       	.word	0x000a	; ????
	sbi(TCCR0A, WGM00);
 4d4:	00 4c       	sbci	r16, 0xC0	; 192
 4d6:	34 00       	.word	0x0034	; ????
 4d8:	03 0e       	add	r0, r19
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 4da:	3a 0b       	sbc	r19, r26
 4dc:	3b 0b       	sbc	r19, r27
 4de:	49 13       	cpse	r20, r25
	sbi(TCCR0B, CS00);
 4e0:	3f 0c       	add	r3, r15
 4e2:	02 0a       	sbc	r0, r18
 4e4:	00 00       	nop

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 4e6:	4d 34       	cpi	r20, 0x4D	; 77
 4e8:	00 03       	mulsu	r16, r16
 4ea:	0e 3a       	cpi	r16, 0xAE	; 174
 4ec:	0b 3b       	cpi	r16, 0xBB	; 187
 4ee:	0b 49       	sbci	r16, 0x9B	; 155
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 4f0:	13 3f       	cpi	r17, 0xF3	; 243
 4f2:	0c 02       	muls	r16, r28

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4f4:	0a 00       	.word	0x000a	; ????
 4f6:	00 4e       	sbci	r16, 0xE0	; 224
 4f8:	34 00       	.word	0x0034	; ????
 4fa:	03 0e       	add	r0, r19
 4fc:	3a 0b       	sbc	r19, r26
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 4fe:	3b 0b       	sbc	r19, r27
 500:	49 13       	cpse	r20, r25
 502:	3f 0c       	add	r3, r15
 504:	02 0a       	sbc	r0, r18
 506:	00 00       	nop
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 508:	4f 34       	cpi	r20, 0x4F	; 79
 50a:	00 03       	mulsu	r16, r16
 50c:	0e 3a       	cpi	r16, 0xAE	; 174
 50e:	0b 3b       	cpi	r16, 0xBB	; 187
 510:	0b 49       	sbci	r16, 0x9B	; 155

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 512:	13 3f       	cpi	r17, 0xF3	; 243
 514:	0c 02       	muls	r16, r28
 516:	0a 00       	.word	0x000a	; ????
 518:	00 50       	subi	r16, 0x00	; 0
 51a:	34 00       	.word	0x0034	; ????

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 51c:	03 0e       	add	r0, r19
 51e:	3a 0b       	sbc	r19, r26
 520:	3b 0b       	sbc	r19, r27
 522:	49 13       	cpse	r20, r25
 524:	3f 0c       	add	r3, r15
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 526:	02 0a       	sbc	r0, r18
 528:	00 00       	nop
 52a:	51 34       	cpi	r21, 0x41	; 65
 52c:	00 03       	mulsu	r16, r16
 52e:	0e 3a       	cpi	r16, 0xAE	; 174
		sbi(ADCSRA, ADPS1);
 530:	0b 3b       	cpi	r16, 0xBB	; 187
 532:	0b 49       	sbci	r16, 0x9B	; 155
 534:	13 3f       	cpi	r17, 0xF3	; 243
 536:	0c 02       	muls	r16, r28
 538:	0a 00       	.word	0x000a	; ????
		sbi(ADCSRA, ADPS0);
 53a:	00 52       	subi	r16, 0x20	; 32
 53c:	34 00       	.word	0x0034	; ????
 53e:	03 0e       	add	r0, r19
 540:	3a 0b       	sbc	r19, r26
 542:	3b 0b       	sbc	r19, r27
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 544:	49 13       	cpse	r20, r25
 546:	3f 0c       	add	r3, r15
 548:	02 0a       	sbc	r0, r18
 54a:	00 00       	nop
 54c:	53 34       	cpi	r21, 0x43	; 67
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 54e:	00 03       	mulsu	r16, r16
 550:	0e 3a       	cpi	r16, 0xAE	; 174

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 552:	0b 3b       	cpi	r16, 0xBB	; 187
 554:	0b 49       	sbci	r16, 0x9B	; 155
 556:	13 3f       	cpi	r17, 0xF3	; 243
 558:	0c 02       	muls	r16, r28
 55a:	0a 00       	.word	0x000a	; ????
 55c:	00 54       	subi	r16, 0x40	; 64
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
 55e:	34 00       	.word	0x0034	; ????
 560:	03 0e       	add	r0, r19
 562:	3a 0b       	sbc	r19, r26
 564:	3b 0b       	sbc	r19, r27
 566:	49 13       	cpse	r20, r25
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 568:	3f 0c       	add	r3, r15
 56a:	02 0a       	sbc	r0, r18
 56c:	00 00       	nop
 56e:	55 34       	cpi	r21, 0x45	; 69
 570:	00 03       	mulsu	r16, r16
  *_ubrrl = baud_setting;
 572:	0e 3a       	cpi	r16, 0xAE	; 174
 574:	0b 3b       	cpi	r16, 0xBB	; 187
 576:	0b 49       	sbci	r16, 0x9B	; 155
 578:	13 3f       	cpi	r17, 0xF3	; 243
 57a:	0c 02       	muls	r16, r28
 57c:	0a 00       	.word	0x000a	; ????

  _written = false;
 57e:	00 56       	subi	r16, 0x60	; 96
 580:	34 00       	.word	0x0034	; ????

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 582:	03 0e       	add	r0, r19
 584:	3a 0b       	sbc	r19, r26
 586:	3b 0b       	sbc	r19, r27
 588:	49 13       	cpse	r20, r25
 58a:	3f 0c       	add	r3, r15
 58c:	02 0a       	sbc	r0, r18
  
  sbi(*_ucsrb, RXEN0);
 58e:	00 00       	nop
 590:	57 34       	cpi	r21, 0x47	; 71
 592:	00 03       	mulsu	r16, r16
 594:	0e 3a       	cpi	r16, 0xAE	; 174
 596:	0b 3b       	cpi	r16, 0xBB	; 187
 598:	0b 49       	sbci	r16, 0x9B	; 155
 59a:	13 3f       	cpi	r17, 0xF3	; 243
  sbi(*_ucsrb, TXEN0);
 59c:	0c 02       	muls	r16, r28
 59e:	0a 00       	.word	0x000a	; ????
 5a0:	00 00       	nop
 5a2:	01 11       	cpse	r16, r1
 5a4:	01 25       	eor	r16, r1
 5a6:	0e 13       	cpse	r16, r30
 5a8:	0b 03       	fmul	r16, r19
  sbi(*_ucsrb, RXCIE0);
 5aa:	0e 55       	subi	r16, 0x5E	; 94
 5ac:	06 11       	cpse	r16, r6
 5ae:	01 52       	subi	r16, 0x21	; 33
 5b0:	01 10       	cpse	r0, r1
 5b2:	06 00       	.word	0x0006	; ????
 5b4:	00 02       	muls	r16, r16
 5b6:	0f 00       	.word	0x000f	; ????
  cbi(*_ucsrb, UDRIE0);
 5b8:	0b 0b       	sbc	r16, r27
 5ba:	03 0e       	add	r0, r19
 5bc:	49 13       	cpse	r20, r25
 5be:	00 00       	nop
 5c0:	03 15       	cp	r16, r3
 5c2:	01 49       	sbci	r16, 0x91	; 145
 5c4:	13 01       	movw	r2, r6
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 5c6:	13 00       	.word	0x0013	; ????

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 5c8:	00 04       	cpc	r0, r0
	m = timer0_millis;
 5ca:	18 00       	.word	0x0018	; ????
 5cc:	00 00       	nop
 5ce:	05 24       	eor	r0, r5
 5d0:	00 0b       	sbc	r16, r16
 5d2:	0b 3e       	cpi	r16, 0xEB	; 235
 5d4:	0b 03       	fmul	r16, r19
 5d6:	08 00       	.word	0x0008	; ????
 5d8:	00 06       	cpc	r0, r16
	SREG = oldSREG;
 5da:	13 01       	movw	r2, r6

void setup()
{
  Serial.begin(57600);         // 9600 bps
    
  _startTime_ms = millis();
 5dc:	03 0e       	add	r0, r19
 5de:	0b 0b       	sbc	r16, r27
 5e0:	3a 0b       	sbc	r19, r26
 5e2:	3b 0b       	sbc	r19, r27
 5e4:	1d 13       	cpse	r17, r29
 5e6:	01 13       	cpse	r16, r17
 5e8:	00 00       	nop
 5ea:	07 0d       	add	r16, r7
}

void loop() 
{
  if (0 == _loopCounter--) {
 5ec:	00 03       	mulsu	r16, r16
 5ee:	0e 49       	sbci	r16, 0x9E	; 158
 5f0:	13 38       	cpi	r17, 0x83	; 131
 5f2:	0a 34       	cpi	r16, 0x4A	; 74
 5f4:	0c 00       	.word	0x000c	; ????
 5f6:	00 08       	sbc	r0, r0
 5f8:	0d 00       	.word	0x000d	; ????
 5fa:	03 0e       	add	r0, r19
 5fc:	3a 0b       	sbc	r19, r26
 5fe:	3b 0b       	sbc	r19, r27
 600:	49 13       	cpse	r20, r25
 602:	38 0a       	sbc	r3, r24
 604:	32 0b       	sbc	r19, r18
 606:	00 00       	nop
 608:	09 2e       	mov	r0, r25
 60a:	01 03       	mulsu	r16, r17
 60c:	0e 3a       	cpi	r16, 0xAE	; 174
 60e:	0b 3b       	cpi	r16, 0xBB	; 187
 610:	0b 27       	eor	r16, r27
 612:	0c 49       	sbci	r16, 0x9C	; 156
 614:	13 3c       	cpi	r17, 0xC3	; 195
 616:	0c 64       	ori	r16, 0x4C	; 76
 618:	13 01       	movw	r2, r6
 61a:	13 00       	.word	0x0013	; ????
 61c:	00 0a       	sbc	r0, r16
 61e:	05 00       	.word	0x0005	; ????
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 620:	49 13       	cpse	r20, r25

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 622:	34 0c       	add	r3, r4
	m = timer0_millis;
 624:	00 00       	nop
 626:	0b 05       	cpc	r16, r11
 628:	00 49       	sbci	r16, 0x90	; 144
 62a:	13 00       	.word	0x0013	; ????
 62c:	00 0c       	add	r0, r0
 62e:	2e 01       	movw	r4, r28
 630:	03 0e       	add	r0, r19
 632:	3a 0b       	sbc	r19, r26
	SREG = oldSREG;
 634:	3b 0b       	sbc	r19, r27
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 636:	27 0c       	add	r2, r7
 638:	49 13       	cpse	r20, r25
 63a:	32 0b       	sbc	r19, r18
 63c:	3c 0c       	add	r3, r12
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 63e:	64 13       	cpse	r22, r20
 640:	01 13       	cpse	r16, r17
 642:	00 00       	nop
 644:	0d 2e       	mov	r0, r29
 646:	01 03       	mulsu	r16, r17
 648:	0e 3a       	cpi	r16, 0xAE	; 174
 64a:	0b 3b       	cpi	r16, 0xBB	; 187
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 64c:	0b 27       	eor	r16, r27
 64e:	0c 49       	sbci	r16, 0x9C	; 156
 650:	13 4c       	sbci	r17, 0xC3	; 195
 652:	0b 4d       	sbci	r16, 0xDB	; 219
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 654:	0a 1d       	adc	r16, r10
 656:	13 3c       	cpi	r17, 0xC3	; 195
 658:	0c 64       	ori	r16, 0x4C	; 76
 65a:	13 00       	.word	0x0013	; ????
 65c:	00 0e       	add	r0, r16
 65e:	0f 00       	.word	0x000f	; ????
 660:	0b 0b       	sbc	r16, r27
 662:	49 13       	cpse	r20, r25
 664:	00 00       	nop
 666:	0f 16       	cp	r0, r31
 668:	00 03       	mulsu	r16, r16
 66a:	0e 3a       	cpi	r16, 0xAE	; 174
 66c:	0b 3b       	cpi	r16, 0xBB	; 187
 66e:	0b 49       	sbci	r16, 0x9B	; 155
 670:	13 00       	.word	0x0013	; ????
 672:	00 10       	cpse	r0, r0
 674:	24 00       	.word	0x0024	; ????
 676:	0b 0b       	sbc	r16, r27
 678:	3e 0b       	sbc	r19, r30
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 67a:	03 0e       	add	r0, r19
 67c:	00 00       	nop
 67e:	11 1c       	adc	r1, r1
 680:	00 49       	sbci	r16, 0x90	; 144
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
 682:	13 38       	cpi	r17, 0x83	; 131
 684:	0a 32       	cpi	r16, 0x2A	; 42
 686:	0b 00       	.word	0x000b	; ????
 688:	00 12       	cpse	r0, r16
 68a:	2e 01       	movw	r4, r28
 68c:	03 0e       	add	r0, r19
 68e:	3a 0b       	sbc	r19, r26
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 690:	3b 0b       	sbc	r19, r27
 692:	27 0c       	add	r2, r7
 694:	3c 0c       	add	r3, r12
 696:	64 13       	cpse	r22, r20
 698:	00 00       	nop
 69a:	13 13       	cpse	r17, r19
 69c:	01 03       	mulsu	r16, r17
 69e:	0e 3c       	cpi	r16, 0xCE	; 206
 6a0:	0c 01       	movw	r0, r24
 6a2:	13 00       	.word	0x0013	; ????
 6a4:	00 14       	cp	r0, r0
 6a6:	2e 01       	movw	r4, r28
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 6a8:	03 0e       	add	r0, r19
 6aa:	3a 0b       	sbc	r19, r26
 6ac:	3b 0b       	sbc	r19, r27
 6ae:	27 0c       	add	r2, r7
 6b0:	4c 0b       	sbc	r20, r28
 6b2:	4d 0a       	sbc	r4, r29
 6b4:	1d 13       	cpse	r17, r29
 6b6:	3c 0c       	add	r3, r12
 6b8:	64 13       	cpse	r22, r20
 6ba:	01 13       	cpse	r16, r17
 6bc:	00 00       	nop
 6be:	15 2e       	mov	r1, r21
 6c0:	01 03       	mulsu	r16, r17
 6c2:	0e 3a       	cpi	r16, 0xAE	; 174
 6c4:	0b 3b       	cpi	r16, 0xBB	; 187
 6c6:	0b 27       	eor	r16, r27
 6c8:	0c 49       	sbci	r16, 0x9C	; 156
 6ca:	13 4c       	sbci	r17, 0xC3	; 195
 6cc:	0b 4d       	sbci	r16, 0xDB	; 219
 6ce:	0a 1d       	adc	r16, r10
 6d0:	13 3c       	cpi	r17, 0xC3	; 195
 6d2:	0c 64       	ori	r16, 0x4C	; 76
 6d4:	13 01       	movw	r2, r6
 6d6:	13 00       	.word	0x0013	; ????
 6d8:	00 16       	cp	r0, r16
 6da:	2e 01       	movw	r4, r28
 6dc:	3f 0c       	add	r3, r15
 6de:	03 0e       	add	r0, r19
 6e0:	3a 0b       	sbc	r19, r26
 6e2:	3b 0b       	sbc	r19, r27
 6e4:	87 40       	sbci	r24, 0x07	; 7
 6e6:	0e 27       	eor	r16, r30
 6e8:	0c 3c       	cpi	r16, 0xCC	; 204
 6ea:	0c 64       	ori	r16, 0x4C	; 76
 6ec:	13 00       	.word	0x0013	; ????
 6ee:	00 17       	cp	r16, r16
 6f0:	26 00       	.word	0x0026	; ????
 6f2:	49 13       	cpse	r20, r25
 6f4:	00 00       	nop
 6f6:	18 13       	cpse	r17, r24
 6f8:	00 03       	mulsu	r16, r16
 6fa:	0e 3c       	cpi	r16, 0xCE	; 206
 6fc:	0c 00       	.word	0x000c	; ????
 6fe:	00 19       	sub	r16, r0
 700:	2e 01       	movw	r4, r28
 702:	03 0e       	add	r0, r19
 704:	27 0c       	add	r2, r7
 706:	4c 0b       	sbc	r20, r28
 708:	4d 0a       	sbc	r4, r29
 70a:	1d 13       	cpse	r17, r29
 70c:	34 0c       	add	r3, r4
 70e:	3c 0c       	add	r3, r12
 710:	64 13       	cpse	r22, r20
 712:	01 13       	cpse	r16, r17
 714:	00 00       	nop
 716:	1a 2e       	mov	r1, r26
 718:	01 03       	mulsu	r16, r17
 71a:	0e 27       	eor	r16, r30
 71c:	0c 49       	sbci	r16, 0x9C	; 156
 71e:	13 4c       	sbci	r17, 0xC3	; 195
 720:	0b 4d       	sbci	r16, 0xDB	; 219
 722:	0a 1d       	adc	r16, r10
 724:	13 34       	cpi	r17, 0x43	; 67
 726:	0c 3c       	cpi	r16, 0xCC	; 204
 728:	0c 64       	ori	r16, 0x4C	; 76
 72a:	13 01       	movw	r2, r6
 72c:	13 00       	.word	0x0013	; ????
 72e:	00 1b       	sub	r16, r16
 730:	2e 01       	movw	r4, r28
 732:	03 0e       	add	r0, r19
 734:	3a 0b       	sbc	r19, r26
 736:	3b 0b       	sbc	r19, r27
 738:	27 0c       	add	r2, r7
 73a:	3c 0c       	add	r3, r12
 73c:	64 13       	cpse	r22, r20
 73e:	01 13       	cpse	r16, r17
 740:	00 00       	nop
 742:	1c 2e       	mov	r1, r28
 744:	01 03       	mulsu	r16, r17
 746:	0e 27       	eor	r16, r30
 748:	0c 34       	cpi	r16, 0x4C	; 76
 74a:	0c 3c       	cpi	r16, 0xCC	; 204
 74c:	0c 64       	ori	r16, 0x4C	; 76
 74e:	13 01       	movw	r2, r6
 750:	13 00       	.word	0x0013	; ????
 752:	00 1d       	adc	r16, r0
 754:	2e 01       	movw	r4, r28
 756:	03 0e       	add	r0, r19
 758:	3a 0b       	sbc	r19, r26
 75a:	3b 0b       	sbc	r19, r27
 75c:	27 0c       	add	r2, r7
 75e:	4c 0b       	sbc	r20, r28
 760:	4d 0a       	sbc	r4, r29
 762:	1d 13       	cpse	r17, r29
 764:	3c 0c       	add	r3, r12
 766:	64 13       	cpse	r22, r20
 768:	00 00       	nop
 76a:	1e 35       	cpi	r17, 0x5E	; 94
 76c:	00 49       	sbci	r16, 0x90	; 144
 76e:	13 00       	.word	0x0013	; ????
 770:	00 1f       	adc	r16, r16
 772:	01 01       	movw	r0, r2
 774:	49 13       	cpse	r20, r25
 776:	01 13       	cpse	r16, r17
 778:	00 00       	nop
 77a:	20 21       	and	r18, r0
 77c:	00 49       	sbci	r16, 0x90	; 144
 77e:	13 2f       	mov	r17, r19
 780:	0b 00       	.word	0x000b	; ????
 782:	00 21       	and	r16, r0
 784:	2e 01       	movw	r4, r28
 786:	47 13       	cpse	r20, r23
 788:	3a 0b       	sbc	r19, r26
 78a:	3b 0b       	sbc	r19, r27
 78c:	20 0b       	sbc	r18, r16
 78e:	64 13       	cpse	r22, r20
 790:	01 13       	cpse	r16, r17
 792:	00 00       	nop
 794:	22 05       	cpc	r18, r2
 796:	00 03       	mulsu	r16, r16
 798:	0e 49       	sbci	r16, 0x9E	; 158
 79a:	13 34       	cpi	r17, 0x43	; 67
 79c:	0c 00       	.word	0x000c	; ????
 79e:	00 23       	and	r16, r16
 7a0:	05 00       	.word	0x0005	; ????
 7a2:	03 08       	sbc	r0, r3
 7a4:	3a 0b       	sbc	r19, r26
 7a6:	3b 0b       	sbc	r19, r27
 7a8:	49 13       	cpse	r20, r25
 7aa:	00 00       	nop
 7ac:	24 34       	cpi	r18, 0x44	; 68
 7ae:	00 03       	mulsu	r16, r16
 7b0:	08 3a       	cpi	r16, 0xA8	; 168
 7b2:	0b 3b       	cpi	r16, 0xBB	; 187
 7b4:	0b 49       	sbci	r16, 0x9B	; 155
 7b6:	13 00       	.word	0x0013	; ????
 7b8:	00 25       	eor	r16, r0
 7ba:	0b 01       	movw	r0, r22
 7bc:	00 00       	nop
 7be:	26 34       	cpi	r18, 0x46	; 70
 7c0:	00 03       	mulsu	r16, r16
 7c2:	0e 3a       	cpi	r16, 0xAE	; 174
 7c4:	0b 3b       	cpi	r16, 0xBB	; 187
 7c6:	05 49       	sbci	r16, 0x95	; 149
 7c8:	13 00       	.word	0x0013	; ????
 7ca:	00 27       	eor	r16, r16
 7cc:	2e 01       	movw	r4, r28
 7ce:	47 13       	cpse	r20, r23
 7d0:	20 0b       	sbc	r18, r16
 7d2:	64 13       	cpse	r22, r20
 7d4:	01 13       	cpse	r16, r17
 7d6:	00 00       	nop
 7d8:	28 2e       	mov	r2, r24
 7da:	01 03       	mulsu	r16, r17
 7dc:	0e 27       	eor	r16, r30
 7de:	0c 34       	cpi	r16, 0x4C	; 76
 7e0:	0c 20       	and	r0, r12
 7e2:	0b 01       	movw	r0, r22
 7e4:	13 00       	.word	0x0013	; ????
 7e6:	00 29       	or	r16, r0
 7e8:	05 00       	.word	0x0005	; ????
 7ea:	03 0e       	add	r0, r19
 7ec:	3a 0b       	sbc	r19, r26
 7ee:	3b 0b       	sbc	r19, r27
 7f0:	49 13       	cpse	r20, r25
 7f2:	00 00       	nop
 7f4:	2a 34       	cpi	r18, 0x4A	; 74
 7f6:	00 03       	mulsu	r16, r16
 7f8:	0e 3a       	cpi	r16, 0xAE	; 174
 7fa:	0b 3b       	cpi	r16, 0xBB	; 187
 7fc:	0b 49       	sbci	r16, 0x9B	; 155
 7fe:	13 00       	.word	0x0013	; ????
 800:	00 2b       	or	r16, r16
 802:	2e 01       	movw	r4, r28
 804:	47 13       	cpse	r20, r23
 806:	11 01       	movw	r2, r2
 808:	12 01       	movw	r2, r4
 80a:	40 06       	cpc	r4, r16
 80c:	64 13       	cpse	r22, r20
 80e:	97 42       	sbci	r25, 0x27	; 39
 810:	0c 01       	movw	r0, r24
 812:	13 00       	.word	0x0013	; ????
 814:	00 2c       	mov	r0, r0
 816:	05 00       	.word	0x0005	; ????
 818:	03 0e       	add	r0, r19
 81a:	49 13       	cpse	r20, r25
 81c:	34 0c       	add	r3, r4
 81e:	02 06       	cpc	r0, r18
 820:	00 00       	nop
 822:	2d 05       	cpc	r18, r13
 824:	00 03       	mulsu	r16, r16
 826:	0e 3a       	cpi	r16, 0xAE	; 174
 828:	0b 3b       	cpi	r16, 0xBB	; 187
 82a:	0b 49       	sbci	r16, 0x9B	; 155
 82c:	13 02       	muls	r17, r19
 82e:	06 00       	.word	0x0006	; ????
 830:	00 2e       	mov	r0, r16
 832:	34 00       	.word	0x0034	; ????
 834:	03 08       	sbc	r0, r3
 836:	3a 0b       	sbc	r19, r26
 838:	3b 0b       	sbc	r19, r27
 83a:	49 13       	cpse	r20, r25
 83c:	02 06       	cpc	r0, r18
 83e:	00 00       	nop
 840:	2f 89       	ldd	r18, Y+23	; 0x17
 842:	82 01       	movw	r16, r4
 844:	01 11       	cpse	r16, r1
 846:	01 00       	.word	0x0001	; ????
 848:	00 30       	cpi	r16, 0x00	; 0
 84a:	8a 82       	std	Y+2, r8	; 0x02
 84c:	01 00       	.word	0x0001	; ????
 84e:	02 0a       	sbc	r0, r18
 850:	91 42       	sbci	r25, 0x21	; 33
 852:	0a 00       	.word	0x000a	; ????
 854:	00 31       	cpi	r16, 0x10	; 16
 856:	2e 01       	movw	r4, r28
 858:	47 13       	cpse	r20, r23
 85a:	11 01       	movw	r2, r2
 85c:	12 01       	movw	r2, r4
 85e:	40 0a       	sbc	r4, r16
 860:	64 13       	cpse	r22, r20
 862:	97 42       	sbci	r25, 0x27	; 39
 864:	0c 01       	movw	r0, r24
 866:	13 00       	.word	0x0013	; ????
 868:	00 32       	cpi	r16, 0x20	; 32
 86a:	05 00       	.word	0x0005	; ????
 86c:	03 0e       	add	r0, r19
 86e:	49 13       	cpse	r20, r25
 870:	34 0c       	add	r3, r4
 872:	02 0a       	sbc	r0, r18
 874:	00 00       	nop
 876:	33 34       	cpi	r19, 0x43	; 67
 878:	00 03       	mulsu	r16, r16
 87a:	0e 3a       	cpi	r16, 0xAE	; 174
 87c:	0b 3b       	cpi	r16, 0xBB	; 187
 87e:	0b 49       	sbci	r16, 0x9B	; 155
 880:	13 02       	muls	r17, r19
 882:	0a 00       	.word	0x000a	; ????
 884:	00 34       	cpi	r16, 0x40	; 64
 886:	0b 01       	movw	r0, r22
 888:	11 01       	movw	r2, r2
 88a:	12 01       	movw	r2, r4
 88c:	00 00       	nop
 88e:	35 2e       	mov	r3, r21
 890:	01 03       	mulsu	r16, r17
 892:	0e 3a       	cpi	r16, 0xAE	; 174
 894:	0b 3b       	cpi	r16, 0xBB	; 187
 896:	0b 27       	eor	r16, r27
 898:	0c 49       	sbci	r16, 0x9C	; 156
 89a:	13 11       	cpse	r17, r3
 89c:	01 12       	cpse	r0, r17
 89e:	01 40       	sbci	r16, 0x01	; 1
 8a0:	0a 97       	sbiw	r24, 0x0a	; 10
 8a2:	42 0c       	add	r4, r2
 8a4:	01 13       	cpse	r16, r17
 8a6:	00 00       	nop
 8a8:	36 89       	ldd	r19, Z+22	; 0x16
 8aa:	82 01       	movw	r16, r4
 8ac:	01 11       	cpse	r16, r1
 8ae:	01 31       	cpi	r16, 0x11	; 17
 8b0:	13 00       	.word	0x0013	; ????
 8b2:	00 37       	cpi	r16, 0x70	; 112
 8b4:	05 00       	.word	0x0005	; ????
 8b6:	31 13       	cpse	r19, r17
 8b8:	00 00       	nop
 8ba:	38 34       	cpi	r19, 0x48	; 72
 8bc:	00 31       	cpi	r16, 0x10	; 16
 8be:	13 00       	.word	0x0013	; ????
 8c0:	00 39       	cpi	r16, 0x90	; 144
 8c2:	2e 01       	movw	r4, r28
 8c4:	31 13       	cpse	r19, r17
 8c6:	11 01       	movw	r2, r2
 8c8:	12 01       	movw	r2, r4
 8ca:	40 0a       	sbc	r4, r16
 8cc:	64 13       	cpse	r22, r20
 8ce:	97 42       	sbci	r25, 0x27	; 39
 8d0:	0c 01       	movw	r0, r24
 8d2:	13 00       	.word	0x0013	; ????
 8d4:	00 3a       	cpi	r16, 0xA0	; 160
 8d6:	05 00       	.word	0x0005	; ????
 8d8:	31 13       	cpse	r19, r17
 8da:	02 06       	cpc	r0, r18
 8dc:	00 00       	nop
 8de:	3b 34       	cpi	r19, 0x4B	; 75
 8e0:	00 31       	cpi	r16, 0x10	; 16
 8e2:	13 02       	muls	r17, r19
 8e4:	0a 00       	.word	0x000a	; ????
 8e6:	00 3c       	cpi	r16, 0xC0	; 192
 8e8:	0b 01       	movw	r0, r22
 8ea:	01 13       	cpse	r16, r17
 8ec:	00 00       	nop
 8ee:	3d 2e       	mov	r3, r29
 8f0:	01 31       	cpi	r16, 0x11	; 17
 8f2:	13 11       	cpse	r17, r3
 8f4:	01 12       	cpse	r0, r17
 8f6:	01 40       	sbci	r16, 0x01	; 1
 8f8:	06 64       	ori	r16, 0x46	; 70
 8fa:	13 97       	sbiw	r26, 0x03	; 3
 8fc:	42 0c       	add	r4, r2
 8fe:	01 13       	cpse	r16, r17
 900:	00 00       	nop
 902:	3e 0b       	sbc	r19, r30
 904:	01 11       	cpse	r16, r1
 906:	01 12       	cpse	r0, r17
 908:	01 01       	movw	r0, r2
 90a:	13 00       	.word	0x0013	; ????
 90c:	00 3f       	cpi	r16, 0xF0	; 240
 90e:	34 00       	.word	0x0034	; ????
 910:	31 13       	cpse	r19, r17
 912:	02 06       	cpc	r0, r18
 914:	00 00       	nop
 916:	40 1d       	adc	r20, r0
 918:	00 31       	cpi	r16, 0x10	; 16
 91a:	13 11       	cpse	r17, r3
 91c:	01 12       	cpse	r0, r17
 91e:	01 58       	subi	r16, 0x81	; 129
 920:	0b 59       	subi	r16, 0x9B	; 155
 922:	0b 00       	.word	0x000b	; ????
 924:	00 41       	sbci	r16, 0x10	; 16
 926:	1d 01       	movw	r2, r26
 928:	31 13       	cpse	r19, r17
 92a:	11 01       	movw	r2, r2
 92c:	12 01       	movw	r2, r4
 92e:	58 0b       	sbc	r21, r24
 930:	59 0b       	sbc	r21, r25
 932:	00 00       	nop
 934:	42 34       	cpi	r20, 0x42	; 66
 936:	00 03       	mulsu	r16, r16
 938:	08 3a       	cpi	r16, 0xA8	; 168
 93a:	0b 3b       	cpi	r16, 0xBB	; 187
 93c:	0b 49       	sbci	r16, 0x9B	; 155
 93e:	13 02       	muls	r17, r19
 940:	0a 00       	.word	0x000a	; ????
 942:	00 43       	sbci	r16, 0x30	; 48
 944:	1d 00       	.word	0x001d	; ????
 946:	31 13       	cpse	r19, r17
 948:	11 01       	movw	r2, r2
 94a:	12 01       	movw	r2, r4
 94c:	58 0b       	sbc	r21, r24
 94e:	59 05       	cpc	r21, r9
 950:	00 00       	nop
 952:	44 2e       	mov	r4, r20
 954:	00 03       	mulsu	r16, r16
 956:	0e 3a       	cpi	r16, 0xAE	; 174
 958:	0b 3b       	cpi	r16, 0xBB	; 187
 95a:	0b 27       	eor	r16, r27
 95c:	0c 49       	sbci	r16, 0x9C	; 156
 95e:	13 20       	and	r1, r3
 960:	0b 00       	.word	0x000b	; ????
 962:	00 45       	sbci	r16, 0x50	; 80
 964:	2e 00       	.word	0x002e	; ????
 966:	03 0e       	add	r0, r19
 968:	3a 0b       	sbc	r19, r26
 96a:	3b 0b       	sbc	r19, r27
 96c:	27 0c       	add	r2, r7
 96e:	20 0b       	sbc	r18, r16
 970:	00 00       	nop
 972:	46 2e       	mov	r4, r22
 974:	01 03       	mulsu	r16, r17
 976:	0e 3a       	cpi	r16, 0xAE	; 174
 978:	0b 3b       	cpi	r16, 0xBB	; 187
 97a:	0b 27       	eor	r16, r27
 97c:	0c 11       	cpse	r16, r12
 97e:	01 12       	cpse	r0, r17
 980:	01 40       	sbci	r16, 0x01	; 1
 982:	0a 97       	sbiw	r24, 0x0a	; 10
 984:	42 0c       	add	r4, r2
 986:	01 13       	cpse	r16, r17
 988:	00 00       	nop
 98a:	47 89       	ldd	r20, Z+23	; 0x17
 98c:	82 01       	movw	r16, r4
 98e:	00 11       	cpse	r16, r0
 990:	01 31       	cpi	r16, 0x11	; 17
 992:	13 00       	.word	0x0013	; ????
 994:	00 48       	sbci	r16, 0x80	; 128
 996:	89 82       	std	Y+1, r8	; 0x01
 998:	01 00       	.word	0x0001	; ????
 99a:	11 01       	movw	r2, r2
 99c:	95 42       	sbci	r25, 0x25	; 37
 99e:	0c 00       	.word	0x000c	; ????
 9a0:	00 49       	sbci	r16, 0x90	; 144
 9a2:	2e 01       	movw	r4, r28
 9a4:	31 13       	cpse	r19, r17
 9a6:	11 01       	movw	r2, r2
 9a8:	12 01       	movw	r2, r4
 9aa:	40 0a       	sbc	r4, r16
 9ac:	97 42       	sbci	r25, 0x27	; 39
 9ae:	0c 01       	movw	r0, r24
 9b0:	13 00       	.word	0x0013	; ????
 9b2:	00 4a       	sbci	r16, 0xA0	; 160
 9b4:	05 00       	.word	0x0005	; ????
 9b6:	31 13       	cpse	r19, r17
 9b8:	02 0a       	sbc	r0, r18
 9ba:	00 00       	nop
 9bc:	4b 89       	ldd	r20, Y+19	; 0x13
 9be:	82 01       	movw	r16, r4
 9c0:	01 11       	cpse	r16, r1
 9c2:	01 95       	neg	r16
 9c4:	42 0c       	add	r4, r2
 9c6:	31 13       	cpse	r19, r17
 9c8:	00 00       	nop
 9ca:	4c 2e       	mov	r4, r28
 9cc:	01 31       	cpi	r16, 0x11	; 17
 9ce:	13 11       	cpse	r17, r3
 9d0:	01 12       	cpse	r0, r17
 9d2:	01 40       	sbci	r16, 0x01	; 1
 9d4:	06 97       	sbiw	r24, 0x06	; 6
 9d6:	42 0c       	add	r4, r2
 9d8:	01 13       	cpse	r16, r17
 9da:	00 00       	nop
 9dc:	4d 2e       	mov	r4, r29
 9de:	01 03       	mulsu	r16, r17
 9e0:	0e 3a       	cpi	r16, 0xAE	; 174
 9e2:	0b 3b       	cpi	r16, 0xBB	; 187
 9e4:	0b 27       	eor	r16, r27
 9e6:	0c 87       	std	Y+12, r16	; 0x0c
 9e8:	01 0c       	add	r0, r1
 9ea:	11 01       	movw	r2, r2
 9ec:	12 01       	movw	r2, r4
 9ee:	40 0a       	sbc	r4, r16
 9f0:	97 42       	sbci	r25, 0x27	; 39
 9f2:	0c 01       	movw	r0, r24
 9f4:	13 00       	.word	0x0013	; ????
 9f6:	00 4e       	sbci	r16, 0xE0	; 224
 9f8:	89 82       	std	Y+1, r8	; 0x01
 9fa:	01 00       	.word	0x0001	; ????
 9fc:	11 01       	movw	r2, r2
 9fe:	00 00       	nop
 a00:	4f 2e       	mov	r4, r31
 a02:	01 3f       	cpi	r16, 0xF1	; 241
 a04:	0c 03       	fmul	r16, r20
 a06:	0e 3a       	cpi	r16, 0xAE	; 174
 a08:	0b 3b       	cpi	r16, 0xBB	; 187
 a0a:	0b 27       	eor	r16, r27
 a0c:	0c 11       	cpse	r16, r12
 a0e:	01 12       	cpse	r0, r17
 a10:	01 40       	sbci	r16, 0x01	; 1
 a12:	06 97       	sbiw	r24, 0x06	; 6
 a14:	42 0c       	add	r4, r2
 a16:	01 13       	cpse	r16, r17
 a18:	00 00       	nop
 a1a:	50 2e       	mov	r5, r16
 a1c:	01 03       	mulsu	r16, r17
 a1e:	0e 3a       	cpi	r16, 0xAE	; 174
 a20:	0b 3b       	cpi	r16, 0xBB	; 187
 a22:	0b 27       	eor	r16, r27
 a24:	0c 49       	sbci	r16, 0x9C	; 156
 a26:	13 20       	and	r1, r3
 a28:	0b 01       	movw	r0, r22
 a2a:	13 00       	.word	0x0013	; ????
 a2c:	00 51       	subi	r16, 0x10	; 16
 a2e:	2e 01       	movw	r4, r28
 a30:	3f 0c       	add	r3, r15
 a32:	03 0e       	add	r0, r19
 a34:	3a 0b       	sbc	r19, r26
 a36:	3b 0b       	sbc	r19, r27
 a38:	27 0c       	add	r2, r7
 a3a:	49 13       	cpse	r20, r25
 a3c:	87 01       	movw	r16, r14
 a3e:	0c 11       	cpse	r16, r12
 a40:	01 12       	cpse	r0, r17
 a42:	01 40       	sbci	r16, 0x01	; 1
 a44:	0a 97       	sbiw	r24, 0x0a	; 10
 a46:	42 0c       	add	r4, r2
 a48:	01 13       	cpse	r16, r17
 a4a:	00 00       	nop
 a4c:	52 1d       	adc	r21, r2
 a4e:	01 31       	cpi	r16, 0x11	; 17
 a50:	13 11       	cpse	r17, r3
 a52:	01 12       	cpse	r0, r17
 a54:	01 58       	subi	r16, 0x81	; 129
 a56:	0b 59       	subi	r16, 0x9B	; 155
 a58:	0b 01       	movw	r0, r22
 a5a:	13 00       	.word	0x0013	; ????
 a5c:	00 53       	subi	r16, 0x30	; 48
 a5e:	34 00       	.word	0x0034	; ????
 a60:	00 00       	nop
 a62:	54 2e       	mov	r5, r20
 a64:	01 03       	mulsu	r16, r17
 a66:	0e 27       	eor	r16, r30
 a68:	0c 34       	cpi	r16, 0x4C	; 76
 a6a:	0c 11       	cpse	r16, r12
 a6c:	01 12       	cpse	r0, r17
 a6e:	01 40       	sbci	r16, 0x01	; 1
 a70:	0a 97       	sbiw	r24, 0x0a	; 10
 a72:	42 0c       	add	r4, r2
 a74:	01 13       	cpse	r16, r17
 a76:	00 00       	nop
 a78:	55 34       	cpi	r21, 0x45	; 69
 a7a:	00 1c       	adc	r0, r0
 a7c:	0b 00       	.word	0x000b	; ????
 a7e:	00 56       	subi	r16, 0x60	; 96
 a80:	34 00       	.word	0x0034	; ????
 a82:	02 0a       	sbc	r0, r18
 a84:	00 00       	nop
 a86:	57 2e       	mov	r5, r23
 a88:	00 47       	sbci	r16, 0x70	; 112
 a8a:	13 20       	and	r1, r3
 a8c:	0b 00       	.word	0x000b	; ????
 a8e:	00 00       	nop
 a90:	01 11       	cpse	r16, r1
 a92:	00 10       	cpse	r0, r0
 a94:	06 11       	cpse	r16, r6
 a96:	01 12       	cpse	r0, r17
 a98:	01 03       	mulsu	r16, r17
 a9a:	08 1b       	sub	r16, r24
 a9c:	08 25       	eor	r16, r8
 a9e:	08 13       	cpse	r16, r24
 aa0:	05 00       	.word	0x0005	; ????
 aa2:	00 00       	nop
 aa4:	01 11       	cpse	r16, r1
 aa6:	00 10       	cpse	r0, r0
 aa8:	06 11       	cpse	r16, r6
 aaa:	01 12       	cpse	r0, r17
 aac:	01 03       	mulsu	r16, r17
 aae:	08 1b       	sub	r16, r24
 ab0:	08 25       	eor	r16, r8
 ab2:	08 13       	cpse	r16, r24
 ab4:	05 00       	.word	0x0005	; ????
 ab6:	00 00       	nop
 ab8:	01 11       	cpse	r16, r1
 aba:	00 10       	cpse	r0, r0
 abc:	06 11       	cpse	r16, r6
 abe:	01 12       	cpse	r0, r17
 ac0:	01 03       	mulsu	r16, r17
 ac2:	08 1b       	sub	r16, r24
 ac4:	08 25       	eor	r16, r8
 ac6:	08 13       	cpse	r16, r24
 ac8:	05 00       	.word	0x0005	; ????
 aca:	00 00       	nop
 acc:	01 11       	cpse	r16, r1
 ace:	00 10       	cpse	r0, r0
 ad0:	06 11       	cpse	r16, r6
 ad2:	01 12       	cpse	r0, r17
 ad4:	01 03       	mulsu	r16, r17
 ad6:	08 1b       	sub	r16, r24
 ad8:	08 25       	eor	r16, r8
 ada:	08 13       	cpse	r16, r24
 adc:	05 00       	.word	0x0005	; ????
 ade:	00 00       	nop
 ae0:	01 11       	cpse	r16, r1
 ae2:	00 10       	cpse	r0, r0
 ae4:	06 11       	cpse	r16, r6
 ae6:	01 12       	cpse	r0, r17
 ae8:	01 03       	mulsu	r16, r17
 aea:	08 1b       	sub	r16, r24
 aec:	08 25       	eor	r16, r8
 aee:	08 13       	cpse	r16, r24
 af0:	05 00       	.word	0x0005	; ????
 af2:	00 00       	nop
 af4:	01 11       	cpse	r16, r1
 af6:	00 10       	cpse	r0, r0
 af8:	06 11       	cpse	r16, r6
 afa:	01 12       	cpse	r0, r17
 afc:	01 03       	mulsu	r16, r17
 afe:	08 1b       	sub	r16, r24
 b00:	08 25       	eor	r16, r8
 b02:	08 13       	cpse	r16, r24
 b04:	05 00       	.word	0x0005	; ????
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
   0:	16 00       	.word	0x0016	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	10 00       	.word	0x0010	; ????
   8:	00 00       	nop
   a:	02 01       	movw	r0, r4
   c:	fb 0e       	add	r15, r27
   e:	0a 00       	.word	0x000a	; ????
  10:	01 01       	movw	r0, r2
  12:	01 01       	movw	r0, r2
  14:	00 00       	nop
  16:	00 01       	movw	r0, r0
  18:	00 00       	nop
  1a:	4f 08       	sbc	r4, r15
  1c:	00 00       	nop
  1e:	02 00       	.word	0x0002	; ????
  20:	40 04       	cpc	r4, r0
  22:	00 00       	nop
  24:	02 01       	movw	r0, r4
  26:	fb 0e       	add	r15, r27
  28:	0a 00       	.word	0x000a	; ????
  2a:	01 01       	movw	r0, r2
  2c:	01 01       	movw	r0, r2
  2e:	00 00       	nop
  30:	00 01       	movw	r0, r0
  32:	2f 70       	andi	r18, 0x0F	; 15
  34:	72 69       	ori	r23, 0x92	; 146
  36:	76 61       	ori	r23, 0x16	; 22
  38:	74 65       	ori	r23, 0x54	; 84
  3a:	2f 76       	andi	r18, 0x6F	; 111
  3c:	61 72       	andi	r22, 0x21	; 33
  3e:	2f 66       	ori	r18, 0x6F	; 111
  40:	6f 6c       	ori	r22, 0xCF	; 207
  42:	64 65       	ori	r22, 0x54	; 84
  44:	72 73       	andi	r23, 0x32	; 50
  46:	2f 76       	andi	r18, 0x6F	; 111
  48:	39 2f       	mov	r19, r25
  4a:	66 5f       	subi	r22, 0xF6	; 246
  4c:	5f 70       	andi	r21, 0x0F	; 15
  4e:	39 66       	ori	r19, 0x69	; 105
  50:	74 73       	andi	r23, 0x34	; 52
  52:	33 6d       	ori	r19, 0xD3	; 211
  54:	39 37       	cpi	r19, 0x79	; 121
  56:	7a 30       	cpi	r23, 0x0A	; 10
  58:	38 30       	cpi	r19, 0x08	; 8
  5a:	72 33       	cpi	r23, 0x32	; 50
  5c:	71 71       	andi	r23, 0x11	; 17
  5e:	76 5f       	subi	r23, 0xF6	; 246
  60:	71 30       	cpi	r23, 0x01	; 1
  62:	30 30       	cpi	r19, 0x00	; 0
  64:	30 30       	cpi	r19, 0x00	; 0
  66:	67 6e       	ori	r22, 0xE7	; 231
  68:	2f 54       	subi	r18, 0x4F	; 79
  6a:	2f 41       	sbci	r18, 0x1F	; 31
  6c:	70 70       	andi	r23, 0x00	; 0
  6e:	54 72       	andi	r21, 0x24	; 36
  70:	61 6e       	ori	r22, 0xE1	; 225
  72:	73 6c       	ori	r23, 0xC3	; 195
  74:	6f 63       	ori	r22, 0x3F	; 63
  76:	61 74       	andi	r22, 0x41	; 65
  78:	69 6f       	ori	r22, 0xF9	; 249
  7a:	6e 2f       	mov	r22, r30
  7c:	34 46       	sbci	r19, 0x64	; 100
  7e:	34 35       	cpi	r19, 0x54	; 84
  80:	46 31       	cpi	r20, 0x16	; 22
  82:	35 36       	cpi	r19, 0x65	; 101
  84:	2d 33       	cpi	r18, 0x3D	; 61
  86:	37 45       	sbci	r19, 0x57	; 87
  88:	42 2d       	mov	r20, r2
  8a:	34 38       	cpi	r19, 0x84	; 132
  8c:	34 30       	cpi	r19, 0x04	; 4
  8e:	2d 38       	cpi	r18, 0x8D	; 141
  90:	33 43       	sbci	r19, 0x33	; 51
  92:	43 2d       	mov	r20, r3
  94:	42 41       	sbci	r20, 0x12	; 18
  96:	39 43       	sbci	r19, 0x39	; 57
  98:	46 45       	sbci	r20, 0x56	; 86
  9a:	30 31       	cpi	r19, 0x10	; 16
  9c:	39 43       	sbci	r19, 0x39	; 57
  9e:	35 33       	cpi	r19, 0x35	; 53
  a0:	2f 64       	ori	r18, 0x4F	; 79
  a2:	2f 41       	sbci	r18, 0x1F	; 31
  a4:	72 64       	ori	r23, 0x42	; 66
  a6:	75 69       	ori	r23, 0x95	; 149
  a8:	6e 6f       	ori	r22, 0xFE	; 254
  aa:	20 31       	cpi	r18, 0x10	; 16
  ac:	2e 38       	cpi	r18, 0x8E	; 142
  ae:	2e 39       	cpi	r18, 0x9E	; 158
  b0:	2e 61       	ori	r18, 0x1E	; 30
  b2:	70 70       	andi	r23, 0x00	; 0
  b4:	2f 43       	sbci	r18, 0x3F	; 63
  b6:	6f 6e       	ori	r22, 0xEF	; 239
  b8:	74 65       	ori	r23, 0x54	; 84
  ba:	6e 74       	andi	r22, 0x4E	; 78
  bc:	73 2f       	mov	r23, r19

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	4a 61       	ori	r20, 0x1A	; 26
  c0:	76 61       	ori	r23, 0x16	; 22
  c2:	2f 68       	ori	r18, 0x8F	; 143
  c4:	61 72       	andi	r22, 0x21	; 33
  c6:	64 77       	andi	r22, 0x74	; 116
  c8:	61 72       	andi	r22, 0x21	; 33
  ca:	65 2f       	mov	r22, r21
  cc:	61 72       	andi	r22, 0x21	; 33
  ce:	64 75       	andi	r22, 0x54	; 84
  d0:	69 6e       	ori	r22, 0xE9	; 233
  d2:	6f 2f       	mov	r22, r31
  size_t n = 0;
  d4:	61 76       	andi	r22, 0x61	; 97
  d6:	72 2f       	mov	r23, r18
  while (size--) {
  d8:	63 6f       	ori	r22, 0xF3	; 243
  da:	72 65       	ori	r23, 0x52	; 82
  dc:	73 2f       	mov	r23, r19
    if (write(*buffer++)) n++;
  de:	61 72       	andi	r22, 0x21	; 33
  e0:	64 75       	andi	r22, 0x54	; 84
  e2:	69 6e       	ori	r22, 0xE9	; 233
  e4:	6f 00       	.word	0x006f	; ????
  e6:	2f 70       	andi	r18, 0x0F	; 15
  e8:	72 69       	ori	r23, 0x92	; 146
  ea:	76 61       	ori	r23, 0x16	; 22
  ec:	74 65       	ori	r23, 0x54	; 84
  ee:	2f 76       	andi	r18, 0x6F	; 111
  f0:	61 72       	andi	r22, 0x21	; 33
  f2:	2f 66       	ori	r18, 0x6F	; 111
  f4:	6f 6c       	ori	r22, 0xCF	; 207
  f6:	64 65       	ori	r22, 0x54	; 84
  f8:	72 73       	andi	r23, 0x32	; 50
  fa:	2f 76       	andi	r18, 0x6F	; 111
  fc:	39 2f       	mov	r19, r25
    else break;
  }
  return n;
}
  fe:	66 5f       	subi	r22, 0xF6	; 246
 100:	5f 70       	andi	r21, 0x0F	; 15
 102:	39 66       	ori	r19, 0x69	; 105
 104:	74 73       	andi	r23, 0x34	; 52
 106:	33 6d       	ori	r19, 0xD3	; 211
 108:	39 37       	cpi	r19, 0x79	; 121
 10a:	7a 30       	cpi	r23, 0x0A	; 10
 10c:	38 30       	cpi	r19, 0x08	; 8
 10e:	72 33       	cpi	r23, 0x32	; 50
 110:	71 71       	andi	r23, 0x11	; 17
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 112:	76 5f       	subi	r23, 0xF6	; 246
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 114:	71 30       	cpi	r23, 0x01	; 1
 116:	30 30       	cpi	r19, 0x00	; 0
 118:	30 30       	cpi	r19, 0x00	; 0
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 11a:	67 6e       	ori	r22, 0xE7	; 231
 11c:	2f 54       	subi	r18, 0x4F	; 79
    tail = _tx_buffer_tail;
 11e:	2f 41       	sbci	r18, 0x1F	; 31
 120:	70 70       	andi	r23, 0x00	; 0
 122:	54 72       	andi	r21, 0x24	; 36
 124:	61 6e       	ori	r22, 0xE1	; 225
 126:	73 6c       	ori	r23, 0xC3	; 195
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 128:	6f 63       	ori	r22, 0x3F	; 63
 12a:	61 74       	andi	r22, 0x41	; 65
 12c:	69 6f       	ori	r22, 0xF9	; 249
 12e:	6e 2f       	mov	r22, r30
 130:	34 46       	sbci	r19, 0x64	; 100
 132:	34 35       	cpi	r19, 0x54	; 84
  return tail - head - 1;
 134:	46 31       	cpi	r20, 0x16	; 22
}
 136:	35 36       	cpi	r19, 0x65	; 101
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 138:	2d 33       	cpi	r18, 0x3D	; 61
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 13a:	37 45       	sbci	r19, 0x57	; 87
 13c:	42 2d       	mov	r20, r2
 13e:	34 38       	cpi	r19, 0x84	; 132
 140:	34 30       	cpi	r19, 0x04	; 4
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 142:	2d 38       	cpi	r18, 0x8D	; 141
 144:	33 43       	sbci	r19, 0x33	; 51
 146:	43 2d       	mov	r20, r3
 148:	42 41       	sbci	r20, 0x12	; 18
 14a:	39 43       	sbci	r19, 0x39	; 57
 14c:	46 45       	sbci	r20, 0x56	; 86
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 14e:	30 31       	cpi	r19, 0x10	; 16
 150:	39 43       	sbci	r19, 0x39	; 57
 152:	35 33       	cpi	r19, 0x35	; 53
 154:	2f 64       	ori	r18, 0x4F	; 79
    return c;
 156:	2f 41       	sbci	r18, 0x1F	; 31
 158:	72 64       	ori	r23, 0x42	; 66

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 15a:	75 69       	ori	r23, 0x95	; 149
 15c:	6e 6f       	ori	r22, 0xFE	; 254
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 15e:	20 31       	cpi	r18, 0x10	; 16
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 160:	2e 38       	cpi	r18, 0x8E	; 142
  if (_rx_buffer_head == _rx_buffer_tail) {
 162:	2e 39       	cpi	r18, 0x9E	; 158
 164:	2e 61       	ori	r18, 0x1E	; 30
 166:	70 70       	andi	r23, 0x00	; 0
 168:	2f 43       	sbci	r18, 0x3F	; 63
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 16a:	6f 6e       	ori	r22, 0xEF	; 239
 16c:	74 65       	ori	r23, 0x54	; 84
 16e:	6e 74       	andi	r22, 0x4E	; 78
 170:	73 2f       	mov	r23, r19
 172:	4a 61       	ori	r20, 0x1A	; 26
 174:	76 61       	ori	r23, 0x16	; 22
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 176:	2f 68       	ori	r18, 0x8F	; 143
 178:	61 72       	andi	r22, 0x21	; 33
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 17a:	64 77       	andi	r22, 0x74	; 116
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 17c:	61 72       	andi	r22, 0x21	; 33
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 17e:	65 2f       	mov	r22, r21
 180:	74 6f       	ori	r23, 0xF4	; 244
 182:	6f 6c       	ori	r22, 0xCF	; 207
 184:	73 2f       	mov	r23, r19
 186:	61 76       	andi	r22, 0x61	; 97
 188:	72 2f       	mov	r23, r18
 18a:	61 76       	andi	r22, 0x61	; 97
 18c:	72 2f       	mov	r23, r18
}
 18e:	69 6e       	ori	r22, 0xE9	; 233
 190:	63 6c       	ori	r22, 0xC3	; 195
 192:	75 64       	ori	r23, 0x45	; 69
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 194:	65 2f       	mov	r22, r21
 196:	75 74       	andi	r23, 0x45	; 69
 198:	69 6c       	ori	r22, 0xC9	; 201
 19a:	00 2f       	mov	r16, r16
 19c:	5f 73       	andi	r21, 0x3F	; 63
 19e:	68 61       	ori	r22, 0x18	; 24
 1a0:	72 65       	ori	r23, 0x52	; 82
 1a2:	64 5f       	subi	r22, 0xF4	; 244
}
 1a4:	2f 64       	ori	r18, 0x4F	; 79
 1a6:	65 76       	andi	r22, 0x65	; 101
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1a8:	2f 64       	ori	r18, 0x4F	; 79
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1aa:	65 76       	andi	r22, 0x65	; 101
 1ac:	2e 70       	andi	r18, 0x0E	; 14
 1ae:	72 6f       	ori	r23, 0xF2	; 242
 1b0:	6a 65       	ori	r22, 0x5A	; 90
 1b2:	63 74       	andi	r22, 0x43	; 67
 1b4:	73 2f       	mov	r23, r19
 1b6:	54 4f       	sbci	r21, 0xF4	; 244
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1b8:	43 2f       	mov	r20, r19
 1ba:	4d 49       	sbci	r20, 0x9D	; 157
 1bc:	44 49       	sbci	r20, 0x94	; 148
 1be:	2d 46       	sbci	r18, 0x6D	; 109
 1c0:	4f 4f       	sbci	r20, 0xFF	; 255
 1c2:	54 2d       	mov	r21, r4

  *_udr = c;
 1c4:	43 4f       	sbci	r20, 0xF3	; 243
 1c6:	4e 54       	subi	r20, 0x4E	; 78
 1c8:	52 4f       	sbci	r21, 0xF2	; 242
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 1ca:	4c 4c       	sbci	r20, 0xCC	; 204
 1cc:	45 52       	subi	r20, 0x25	; 37
 1ce:	2e 50       	subi	r18, 0x0E	; 14
 1d0:	55 42       	sbci	r21, 0x25	; 37
 1d2:	4c 49       	sbci	r20, 0x9C	; 156
 1d4:	43 2e       	mov	r4, r19
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 1d6:	47 49       	sbci	r20, 0x97	; 151
 1d8:	54 2f       	mov	r21, r20
 1da:	61 72       	andi	r22, 0x21	; 33
 1dc:	64 75       	andi	r22, 0x54	; 84
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1de:	69 6e       	ori	r22, 0xE9	; 233
 1e0:	6f 2f       	mov	r22, r31
 1e2:	4a 42       	sbci	r20, 0x2A	; 42
 1e4:	5f 43       	sbci	r21, 0x3F	; 63
 1e6:	50 55       	subi	r21, 0x50	; 80
 1e8:	5f 55       	subi	r21, 0x5F	; 95
 1ea:	73 61       	ori	r23, 0x13	; 19
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 1ec:	67 65       	ori	r22, 0x57	; 87
 1ee:	5f 42       	sbci	r21, 0x2F	; 47
 1f0:	61 73       	andi	r22, 0x31	; 49
 1f2:	69 63       	ori	r22, 0x39	; 57
 1f4:	31 5f       	subi	r19, 0xF1	; 241
 1f6:	53 65       	ori	r21, 0x53	; 83
 1f8:	72 69       	ori	r23, 0x92	; 146
  _written = true;
 1fa:	61 6c       	ori	r22, 0xC1	; 193
 1fc:	00 2f       	mov	r16, r16
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 1fe:	70 72       	andi	r23, 0x20	; 32
 200:	69 76       	andi	r22, 0x69	; 105
 202:	61 74       	andi	r22, 0x41	; 65
 204:	65 2f       	mov	r22, r21
 206:	76 61       	ori	r23, 0x16	; 22
 208:	72 2f       	mov	r23, r18
 20a:	66 6f       	ori	r22, 0xF6	; 246
 20c:	6c 64       	ori	r22, 0x4C	; 76
 20e:	65 72       	andi	r22, 0x25	; 37
 210:	73 2f       	mov	r23, r19
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 212:	76 39       	cpi	r23, 0x96	; 150
 214:	2f 66       	ori	r18, 0x6F	; 111
 216:	5f 5f       	subi	r21, 0xFF	; 255
 218:	70 39       	cpi	r23, 0x90	; 144
 21a:	66 74       	andi	r22, 0x46	; 70
 21c:	73 33       	cpi	r23, 0x33	; 51
 21e:	6d 39       	cpi	r22, 0x9D	; 157
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 220:	37 7a       	andi	r19, 0xA7	; 167
 222:	30 38       	cpi	r19, 0x80	; 128
 224:	30 72       	andi	r19, 0x20	; 32
    if (bit_is_clear(SREG, SREG_I)) {
 226:	33 71       	andi	r19, 0x13	; 19
 228:	71 76       	andi	r23, 0x61	; 97
 22a:	5f 71       	andi	r21, 0x1F	; 31
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 22c:	30 30       	cpi	r19, 0x00	; 0
 22e:	30 30       	cpi	r19, 0x00	; 0
 230:	30 67       	ori	r19, 0x70	; 112
 232:	6e 2f       	mov	r22, r30
 234:	54 2f       	mov	r21, r20
	_tx_udr_empty_irq();
 236:	41 70       	andi	r20, 0x01	; 1
 238:	70 54       	subi	r23, 0x40	; 64
 23a:	72 61       	ori	r23, 0x12	; 18
 23c:	6e 73       	andi	r22, 0x3E	; 62
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 23e:	6c 6f       	ori	r22, 0xFC	; 252
 240:	63 61       	ori	r22, 0x13	; 19
 242:	74 69       	ori	r23, 0x94	; 148
 244:	6f 6e       	ori	r22, 0xEF	; 239
 246:	2f 34       	cpi	r18, 0x4F	; 79
 248:	46 34       	cpi	r20, 0x46	; 70
 24a:	35 46       	sbci	r19, 0x65	; 101

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 24c:	31 35       	cpi	r19, 0x51	; 81
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 24e:	36 2d       	mov	r19, r6
    _tx_buffer_head = i;
 250:	33 37       	cpi	r19, 0x73	; 115
    sbi(*_ucsrb, UDRIE0);
 252:	45 42       	sbci	r20, 0x25	; 37
 254:	2d 34       	cpi	r18, 0x4D	; 77
 256:	38 34       	cpi	r19, 0x48	; 72
 258:	30 2d       	mov	r19, r0
 25a:	38 33       	cpi	r19, 0x38	; 56
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 25c:	43 43       	sbci	r20, 0x33	; 51
 25e:	2d 42       	sbci	r18, 0x2D	; 45
      *_udr = c;
 260:	41 39       	cpi	r20, 0x91	; 145
 262:	43 46       	sbci	r20, 0x63	; 99
 264:	45 30       	cpi	r20, 0x05	; 5
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 266:	31 39       	cpi	r19, 0x91	; 145
 268:	43 35       	cpi	r20, 0x53	; 83
 26a:	33 2f       	mov	r19, r19
 26c:	64 2f       	mov	r22, r20
 26e:	41 72       	andi	r20, 0x21	; 33
 270:	64 75       	andi	r22, 0x54	; 84
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 272:	69 6e       	ori	r22, 0xE9	; 233
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
 274:	6f 20       	and	r6, r15
 276:	31 2e       	mov	r3, r17
 278:	38 2e       	mov	r3, r24
 27a:	39 2e       	mov	r3, r25
 27c:	61 70       	andi	r22, 0x01	; 1
 27e:	70 2f       	mov	r23, r16
 280:	43 6f       	ori	r20, 0xF3	; 243
 282:	6e 74       	andi	r22, 0x4E	; 78
 284:	65 6e       	ori	r22, 0xE5	; 229
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 286:	74 73       	andi	r23, 0x34	; 52
 288:	2f 4a       	sbci	r18, 0xAF	; 175
 28a:	61 76       	andi	r22, 0x61	; 97
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 28c:	61 2f       	mov	r22, r17
 28e:	68 61       	ori	r22, 0x18	; 24
 290:	72 64       	ori	r23, 0x42	; 66
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 292:	77 61       	ori	r23, 0x17	; 23
 294:	72 65       	ori	r23, 0x52	; 82
 296:	2f 74       	andi	r18, 0x4F	; 79
 298:	6f 6f       	ori	r22, 0xFF	; 255
 29a:	6c 73       	andi	r22, 0x3C	; 60
 29c:	2f 61       	ori	r18, 0x1F	; 31
 29e:	76 72       	andi	r23, 0x26	; 38
 2a0:	2f 6c       	ori	r18, 0xCF	; 207
 2a2:	69 62       	ori	r22, 0x29	; 41
 2a4:	2f 67       	ori	r18, 0x7F	; 127
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 2a6:	63 63       	ori	r22, 0x33	; 51
 2a8:	2f 61       	ori	r18, 0x1F	; 31
 2aa:	76 72       	andi	r23, 0x26	; 38
 2ac:	2f 35       	cpi	r18, 0x5F	; 95
 2ae:	2e 34       	cpi	r18, 0x4E	; 78
 2b0:	2e 30       	cpi	r18, 0x0E	; 14
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 2b2:	2f 69       	ori	r18, 0x9F	; 159
 2b4:	6e 63       	ori	r22, 0x3E	; 62
 2b6:	6c 75       	andi	r22, 0x5C	; 92
 2b8:	64 65       	ori	r22, 0x54	; 84
 2ba:	00 2f       	mov	r16, r16
	  _tx_udr_empty_irq();
 2bc:	70 72       	andi	r23, 0x20	; 32
 2be:	69 76       	andi	r22, 0x69	; 105
 2c0:	61 74       	andi	r22, 0x41	; 65
 2c2:	65 2f       	mov	r22, r21
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 2c4:	76 61       	ori	r23, 0x16	; 22
 2c6:	72 2f       	mov	r23, r18
 2c8:	66 6f       	ori	r22, 0xF6	; 246
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2ca:	6c 64       	ori	r22, 0x4C	; 76
 2cc:	65 72       	andi	r22, 0x25	; 37
 2ce:	73 2f       	mov	r23, r19
 2d0:	76 39       	cpi	r23, 0x96	; 150
 2d2:	2f 66       	ori	r18, 0x6F	; 111
 2d4:	5f 5f       	subi	r21, 0xFF	; 255
 2d6:	70 39       	cpi	r23, 0x90	; 144
 2d8:	66 74       	andi	r22, 0x46	; 70
 2da:	73 33       	cpi	r23, 0x33	; 51
 2dc:	6d 39       	cpi	r22, 0x9D	; 157
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 2de:	37 7a       	andi	r19, 0xA7	; 167
 2e0:	30 38       	cpi	r19, 0x80	; 128
      return write((const uint8_t *)str, strlen(str));
 2e2:	30 72       	andi	r19, 0x20	; 32
 2e4:	33 71       	andi	r19, 0x13	; 19
 2e6:	71 76       	andi	r23, 0x61	; 97
 2e8:	5f 71       	andi	r21, 0x1F	; 31
 2ea:	30 30       	cpi	r19, 0x00	; 0
 2ec:	30 30       	cpi	r19, 0x00	; 0
 2ee:	30 67       	ori	r19, 0x70	; 112
 2f0:	6e 2f       	mov	r22, r30
 2f2:	54 2f       	mov	r21, r20
 2f4:	41 70       	andi	r20, 0x01	; 1
 2f6:	70 54       	subi	r23, 0x40	; 64
 2f8:	72 61       	ori	r23, 0x12	; 18
 2fa:	6e 73       	andi	r22, 0x3E	; 62
    }
 2fc:	6c 6f       	ori	r22, 0xFC	; 252
 2fe:	63 61       	ori	r22, 0x13	; 19
 300:	74 69       	ori	r23, 0x94	; 148
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 302:	6f 6e       	ori	r22, 0xEF	; 239
 304:	2f 34       	cpi	r18, 0x4F	; 79
 306:	46 34       	cpi	r20, 0x46	; 70
 308:	35 46       	sbci	r19, 0x65	; 101
 30a:	31 35       	cpi	r19, 0x51	; 81
 30c:	36 2d       	mov	r19, r6
 30e:	33 37       	cpi	r19, 0x73	; 115
 310:	45 42       	sbci	r20, 0x25	; 37
 312:	2d 34       	cpi	r18, 0x4D	; 77
 314:	38 34       	cpi	r19, 0x48	; 72
 316:	30 2d       	mov	r19, r0
 318:	38 33       	cpi	r19, 0x38	; 56
 31a:	43 43       	sbci	r20, 0x33	; 51
 31c:	2d 42       	sbci	r18, 0x2D	; 45
 31e:	41 39       	cpi	r20, 0x91	; 145
 320:	43 46       	sbci	r20, 0x63	; 99
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 322:	45 30       	cpi	r20, 0x05	; 5

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 324:	31 39       	cpi	r19, 0x91	; 145
 326:	43 35       	cpi	r20, 0x53	; 83
 328:	33 2f       	mov	r19, r19
 32a:	64 2f       	mov	r22, r20
 32c:	41 72       	andi	r20, 0x21	; 33
 32e:	64 75       	andi	r22, 0x54	; 84

  do {
    char c = n % base;
 330:	69 6e       	ori	r22, 0xE9	; 233
 332:	6f 20       	and	r6, r15
 334:	31 2e       	mov	r3, r17
 336:	38 2e       	mov	r3, r24
 338:	39 2e       	mov	r3, r25
 33a:	61 70       	andi	r22, 0x01	; 1
 33c:	70 2f       	mov	r23, r16
 33e:	43 6f       	ori	r20, 0xF3	; 243
 340:	6e 74       	andi	r22, 0x4E	; 78
    n /= base;
 342:	65 6e       	ori	r22, 0xE5	; 229
 344:	74 73       	andi	r23, 0x34	; 52

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 346:	2f 4a       	sbci	r18, 0xAF	; 175
 348:	61 76       	andi	r22, 0x61	; 97
 34a:	61 2f       	mov	r22, r17
 34c:	68 61       	ori	r22, 0x18	; 24
 34e:	72 64       	ori	r23, 0x42	; 66
 350:	77 61       	ori	r23, 0x17	; 23
 352:	72 65       	ori	r23, 0x52	; 82
 354:	2f 74       	andi	r18, 0x4F	; 79
 356:	6f 6f       	ori	r22, 0xFF	; 255
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 358:	6c 73       	andi	r22, 0x3C	; 60
 35a:	2f 61       	ori	r18, 0x1F	; 31
 35c:	76 72       	andi	r23, 0x26	; 38
 35e:	2f 61       	ori	r18, 0x1F	; 31
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 360:	76 72       	andi	r23, 0x26	; 38
 362:	2f 69       	ori	r18, 0x9F	; 159
 364:	6e 63       	ori	r22, 0x3E	; 62
}
 366:	6c 75       	andi	r22, 0x5C	; 92
 368:	64 65       	ori	r22, 0x54	; 84
 36a:	00 00       	nop
 36c:	50 72       	andi	r21, 0x20	; 32
 36e:	69 6e       	ori	r22, 0xE9	; 233
 370:	74 2e       	mov	r7, r20
 372:	63 70       	andi	r22, 0x03	; 3
 374:	70 00       	.word	0x0070	; ????
 376:	01 00       	.word	0x0001	; ????
 378:	00 50       	subi	r16, 0x00	; 0
 37a:	72 69       	ori	r23, 0x92	; 146
 37c:	6e 74       	andi	r22, 0x4E	; 78
 37e:	2e 68       	ori	r18, 0x8E	; 142
 380:	00 01       	movw	r0, r0
 382:	00 00       	nop
 384:	48 61       	ori	r20, 0x18	; 24
 386:	72 64       	ori	r23, 0x42	; 66
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 388:	77 61       	ori	r23, 0x17	; 23
 38a:	72 65       	ori	r23, 0x52	; 82
 38c:	53 65       	ori	r21, 0x53	; 83
 38e:	72 69       	ori	r23, 0x92	; 146
 390:	61 6c       	ori	r22, 0xC1	; 193
 392:	2e 63       	ori	r18, 0x3E	; 62
 394:	70 70       	andi	r23, 0x00	; 0
 396:	00 01       	movw	r0, r0
 398:	00 00       	nop
 39a:	48 61       	ori	r20, 0x18	; 24
 39c:	72 64       	ori	r23, 0x42	; 66
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 39e:	77 61       	ori	r23, 0x17	; 23
 3a0:	72 65       	ori	r23, 0x52	; 82
 3a2:	53 65       	ori	r21, 0x53	; 83
 3a4:	72 69       	ori	r23, 0x92	; 146
 3a6:	61 6c       	ori	r22, 0xC1	; 193
 3a8:	30 2e       	mov	r3, r16
 3aa:	63 70       	andi	r22, 0x03	; 3
 3ac:	70 00       	.word	0x0070	; ????
	unsigned char f = timer0_fract;
 3ae:	01 00       	.word	0x0001	; ????
 3b0:	00 61       	ori	r16, 0x10	; 16

	m += MILLIS_INC;
	f += FRACT_INC;
 3b2:	74 6f       	ori	r23, 0xF4	; 244
 3b4:	6d 69       	ori	r22, 0x9D	; 157
	if (f >= FRACT_MAX) {
 3b6:	63 2e       	mov	r6, r19
 3b8:	68 00       	.word	0x0068	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 3ba:	02 00       	.word	0x0002	; ????
 3bc:	00 61       	ori	r16, 0x10	; 16
 3be:	62 69       	ori	r22, 0x92	; 146
 3c0:	2e 63       	ori	r18, 0x3E	; 62
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 3c2:	70 70       	andi	r23, 0x00	; 0
 3c4:	00 01       	movw	r0, r0
		m += 1;
 3c6:	00 00       	nop
 3c8:	77 69       	ori	r23, 0x97	; 151
 3ca:	72 69       	ori	r23, 0x92	; 146
	}

	timer0_fract = f;
 3cc:	6e 67       	ori	r22, 0x7E	; 126
 3ce:	2e 63       	ori	r18, 0x3E	; 62
	timer0_millis = m;
 3d0:	00 01       	movw	r0, r0
 3d2:	00 00       	nop
 3d4:	6d 61       	ori	r22, 0x1D	; 29
 3d6:	69 6e       	ori	r22, 0xE9	; 233
 3d8:	2e 63       	ori	r18, 0x3E	; 62
 3da:	70 70       	andi	r23, 0x00	; 0
 3dc:	00 01       	movw	r0, r0
 3de:	00 00       	nop
	timer0_overflow_count++;
 3e0:	4a 42       	sbci	r20, 0x2A	; 42
 3e2:	5f 43       	sbci	r21, 0x3F	; 63
 3e4:	50 55       	subi	r21, 0x50	; 80
 3e6:	5f 55       	subi	r21, 0x5F	; 95
 3e8:	73 61       	ori	r23, 0x13	; 19
 3ea:	67 65       	ori	r22, 0x57	; 87
 3ec:	5f 42       	sbci	r21, 0x2F	; 47
 3ee:	61 73       	andi	r22, 0x31	; 49
 3f0:	69 63       	ori	r22, 0x39	; 57
 3f2:	31 5f       	subi	r19, 0xF1	; 241
 3f4:	53 65       	ori	r21, 0x53	; 83
 3f6:	72 69       	ori	r23, 0x92	; 146
 3f8:	61 6c       	ori	r22, 0xC1	; 193
 3fa:	2e 69       	ori	r18, 0x9E	; 158
 3fc:	6e 6f       	ori	r22, 0xFE	; 254
 3fe:	00 03       	mulsu	r16, r16
 400:	00 00       	nop
 402:	53 74       	andi	r21, 0x43	; 67
 404:	72 65       	ori	r23, 0x52	; 82
}
 406:	61 6d       	ori	r22, 0xD1	; 209
 408:	2e 68       	ori	r18, 0x8E	; 142
 40a:	00 01       	movw	r0, r0
 40c:	00 00       	nop
 40e:	48 61       	ori	r20, 0x18	; 24
 410:	72 64       	ori	r23, 0x42	; 66
 412:	77 61       	ori	r23, 0x17	; 23
 414:	72 65       	ori	r23, 0x52	; 82
 416:	53 65       	ori	r21, 0x53	; 83
 418:	72 69       	ori	r23, 0x92	; 146
 41a:	61 6c       	ori	r22, 0xC1	; 193
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 41c:	5f 70       	andi	r21, 0x0F	; 15
 41e:	72 69       	ori	r23, 0x92	; 146
 420:	76 61       	ori	r23, 0x16	; 22
 422:	74 65       	ori	r23, 0x54	; 84
 424:	2e 68       	ori	r18, 0x8E	; 142
 426:	00 01       	movw	r0, r0
 428:	00 00       	nop
 42a:	73 74       	andi	r23, 0x43	; 67
 42c:	64 64       	ori	r22, 0x44	; 68
 42e:	65 66       	ori	r22, 0x65	; 101
 430:	2e 68       	ori	r18, 0x8E	; 142
 432:	00 04       	cpc	r0, r0
 434:	00 00       	nop
 436:	73 74       	andi	r23, 0x43	; 67
 438:	64 69       	ori	r22, 0x94	; 148
 43a:	6e 74       	andi	r22, 0x4E	; 78
 43c:	2e 68       	ori	r18, 0x8E	; 142
  Serial._tx_udr_empty_irq();
 43e:	00 05       	cpc	r16, r0
 440:	00 00       	nop
 442:	48 61       	ori	r20, 0x18	; 24
 444:	72 64       	ori	r23, 0x42	; 66
}
 446:	77 61       	ori	r23, 0x17	; 23
 448:	72 65       	ori	r23, 0x52	; 82
 44a:	53 65       	ori	r21, 0x53	; 83
 44c:	72 69       	ori	r23, 0x92	; 146
 44e:	61 6c       	ori	r22, 0xC1	; 193
 450:	2e 68       	ori	r18, 0x8E	; 142
 452:	00 01       	movw	r0, r0
 454:	00 00       	nop
 456:	41 72       	andi	r20, 0x21	; 33
 458:	64 75       	andi	r22, 0x54	; 84
 45a:	69 6e       	ori	r22, 0xE9	; 233
 45c:	6f 2e       	mov	r6, r31
 45e:	68 00       	.word	0x0068	; ????
 460:	01 00       	.word	0x0001	; ????
 462:	00 00       	nop
 464:	00 05       	cpc	r16, r0
 466:	02 be       	out	0x32, r0	; 50
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 468:	00 00       	nop
 46a:	00 03       	mulsu	r16, r16
 46c:	22 01       	movw	r4, r4
 46e:	03 01       	movw	r0, r6
 470:	09 16       	cp	r0, r25
 472:	00 01       	movw	r0, r0
 474:	03 01       	movw	r0, r6
 476:	09 04       	cpc	r0, r9
 478:	00 01       	movw	r0, r0
 47a:	03 01       	movw	r0, r6

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 47c:	09 06       	cpc	r0, r25
 47e:	00 01       	movw	r0, r0
 480:	03 04       	cpc	r0, r3
 482:	09 20       	and	r0, r9
 484:	00 01       	movw	r0, r0
 486:	04 02       	muls	r16, r20
 488:	03 30       	cpi	r16, 0x03	; 3
 48a:	09 14       	cp	r0, r9
 48c:	00 01       	movw	r0, r0
 48e:	03 65       	ori	r16, 0x53	; 83
 490:	09 02       	muls	r16, r25
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 492:	00 01       	movw	r0, r0
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 494:	03 00       	.word	0x0003	; ????
 496:	09 00       	.word	0x0009	; ????
 498:	00 01       	movw	r0, r0
 49a:	04 03       	mulsu	r16, r20

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 49c:	03 82       	std	Z+3, r0	; 0x03
 49e:	01 09       	sbc	r16, r1
 4a0:	06 00       	.word	0x0006	; ????
 4a2:	01 03       	mulsu	r16, r17
      _rx_buffer[_rx_buffer_head] = c;
 4a4:	05 09       	sbc	r16, r5
 4a6:	00 00       	nop
 4a8:	01 03       	mulsu	r16, r17
 4aa:	01 09       	sbc	r16, r1
 4ac:	04 00       	.word	0x0004	; ????
 4ae:	01 03       	mulsu	r16, r17
      _rx_buffer_head = i;
 4b0:	02 09       	sbc	r16, r2
 4b2:	0a 00       	.word	0x000a	; ????
 4b4:	01 03       	mulsu	r16, r17
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 4b6:	01 09       	sbc	r16, r1
    Serial._rx_complete_irq();
  }
 4b8:	0c 00       	.word	0x000c	; ????
 4ba:	01 03       	mulsu	r16, r17
 4bc:	01 09       	sbc	r16, r1
 4be:	02 00       	.word	0x0002	; ????
 4c0:	01 03       	mulsu	r16, r17
 4c2:	6a 09       	sbc	r22, r10
 4c4:	02 00       	.word	0x0002	; ????
 4c6:	01 03       	mulsu	r16, r17
 4c8:	02 09       	sbc	r16, r2
 4ca:	02 00       	.word	0x0002	; ????

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 4cc:	01 03       	mulsu	r16, r17
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 4ce:	03 09       	sbc	r16, r3
 4d0:	08 00       	.word	0x0008	; ????
 4d2:	01 03       	mulsu	r16, r17
	sbi(TCCR0A, WGM00);
 4d4:	01 09       	sbc	r16, r1
 4d6:	0c 00       	.word	0x000c	; ????
 4d8:	01 03       	mulsu	r16, r17
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 4da:	01 09       	sbc	r16, r1
 4dc:	08 00       	.word	0x0008	; ????
 4de:	01 03       	mulsu	r16, r17
	sbi(TCCR0B, CS00);
 4e0:	7c 09       	sbc	r23, r12
 4e2:	04 00       	.word	0x0004	; ????
 4e4:	01 03       	mulsu	r16, r17

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 4e6:	06 09       	sbc	r16, r6
 4e8:	04 00       	.word	0x0004	; ????
 4ea:	01 03       	mulsu	r16, r17
 4ec:	6e 09       	sbc	r22, r14
 4ee:	02 00       	.word	0x0002	; ????
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 4f0:	01 03       	mulsu	r16, r17
 4f2:	01 09       	sbc	r16, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4f4:	02 00       	.word	0x0002	; ????
 4f6:	01 03       	mulsu	r16, r17
 4f8:	03 09       	sbc	r16, r3
 4fa:	08 00       	.word	0x0008	; ????
 4fc:	01 03       	mulsu	r16, r17
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 4fe:	7e 09       	sbc	r23, r14
 500:	0c 00       	.word	0x000c	; ????
 502:	01 03       	mulsu	r16, r17
 504:	04 09       	sbc	r16, r4
 506:	04 00       	.word	0x0004	; ????
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 508:	01 03       	mulsu	r16, r17
 50a:	75 09       	sbc	r23, r5
 50c:	02 00       	.word	0x0002	; ????
 50e:	01 03       	mulsu	r16, r17
 510:	01 09       	sbc	r16, r1

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 512:	02 00       	.word	0x0002	; ????
 514:	01 03       	mulsu	r16, r17
 516:	01 09       	sbc	r16, r1
 518:	10 00       	.word	0x0010	; ????
 51a:	01 04       	cpc	r0, r1

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 51c:	04 03       	mulsu	r16, r20
 51e:	a2 7f       	andi	r26, 0xF2	; 242
 520:	09 06       	cpc	r0, r25
 522:	00 01       	movw	r0, r0
 524:	03 01       	movw	r0, r6
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 526:	09 00       	.word	0x0009	; ????
 528:	00 01       	movw	r0, r0
 52a:	03 01       	movw	r0, r6
 52c:	09 10       	cpse	r0, r9
 52e:	00 01       	movw	r0, r0
		sbi(ADCSRA, ADPS1);
 530:	04 03       	mulsu	r16, r20
 532:	03 0d       	add	r16, r3
 534:	09 04       	cpc	r0, r9
 536:	00 01       	movw	r0, r0
 538:	03 03       	mulsu	r16, r19
		sbi(ADCSRA, ADPS0);
 53a:	09 02       	muls	r16, r25
 53c:	00 01       	movw	r0, r0
 53e:	03 01       	movw	r0, r6
 540:	09 0e       	add	r0, r25
 542:	00 01       	movw	r0, r0
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 544:	03 02       	muls	r16, r19
 546:	09 0c       	add	r0, r9
 548:	00 01       	movw	r0, r0
 54a:	03 08       	sbc	r0, r3
 54c:	09 06       	cpc	r0, r25
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 54e:	00 01       	movw	r0, r0
 550:	03 05       	cpc	r16, r3

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 552:	09 0c       	add	r0, r9
 554:	00 01       	movw	r0, r0
 556:	03 02       	muls	r16, r19
 558:	09 08       	sbc	r0, r9
 55a:	00 01       	movw	r0, r0
 55c:	03 f3       	brvs	.-64     	; 0x51e <main+0x52>
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
 55e:	00 09       	sbc	r16, r0
 560:	0e 00       	.word	0x000e	; ????
 562:	01 03       	mulsu	r16, r17
 564:	01 09       	sbc	r16, r1
 566:	0e 00       	.word	0x000e	; ????
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 568:	01 03       	mulsu	r16, r17
 56a:	05 09       	sbc	r16, r5
 56c:	04 00       	.word	0x0004	; ????
 56e:	01 03       	mulsu	r16, r17
 570:	13 09       	sbc	r17, r3
  *_ubrrl = baud_setting;
 572:	14 00       	.word	0x0014	; ????
 574:	01 03       	mulsu	r16, r17
 576:	04 09       	sbc	r16, r4
 578:	0e 00       	.word	0x000e	; ????
 57a:	01 03       	mulsu	r16, r17
 57c:	01 09       	sbc	r16, r1

  _written = false;
 57e:	06 00       	.word	0x0006	; ????
 580:	01 03       	mulsu	r16, r17

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 582:	05 09       	sbc	r16, r5
 584:	06 00       	.word	0x0006	; ????
 586:	01 03       	mulsu	r16, r17
 588:	01 09       	sbc	r16, r1
 58a:	0a 00       	.word	0x000a	; ????
 58c:	01 03       	mulsu	r16, r17
  
  sbi(*_ucsrb, RXEN0);
 58e:	06 09       	sbc	r16, r6
 590:	08 00       	.word	0x0008	; ????
 592:	01 03       	mulsu	r16, r17
 594:	05 09       	sbc	r16, r5
 596:	0e 00       	.word	0x000e	; ????
 598:	01 04       	cpc	r0, r1
 59a:	05 03       	mulsu	r16, r21
  sbi(*_ucsrb, TXEN0);
 59c:	a1 7e       	andi	r26, 0xE1	; 225
 59e:	09 02       	muls	r16, r25
 5a0:	00 01       	movw	r0, r0
 5a2:	04 03       	mulsu	r16, r20
 5a4:	03 e0       	ldi	r16, 0x03	; 3
 5a6:	01 09       	sbc	r16, r1
 5a8:	02 00       	.word	0x0002	; ????
  sbi(*_ucsrb, RXCIE0);
 5aa:	01 03       	mulsu	r16, r17
 5ac:	01 09       	sbc	r16, r1
 5ae:	02 00       	.word	0x0002	; ????
 5b0:	01 03       	mulsu	r16, r17
 5b2:	5e 09       	sbc	r21, r14
 5b4:	0a 00       	.word	0x000a	; ????
 5b6:	01 04       	cpc	r0, r1
  cbi(*_ucsrb, UDRIE0);
 5b8:	05 03       	mulsu	r16, r21
 5ba:	c1 7e       	andi	r28, 0xE1	; 225
 5bc:	09 02       	muls	r16, r25
 5be:	00 01       	movw	r0, r0
 5c0:	04 03       	mulsu	r16, r20
 5c2:	03 c0       	rjmp	.+6      	; 0x5ca <main+0xfe>
 5c4:	01 09       	sbc	r16, r1
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 5c6:	02 00       	.word	0x0002	; ????

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 5c8:	01 03       	mulsu	r16, r17
	m = timer0_millis;
 5ca:	02 09       	sbc	r16, r2
 5cc:	06 00       	.word	0x0006	; ????
 5ce:	01 04       	cpc	r0, r1
 5d0:	05 03       	mulsu	r16, r21
 5d2:	d2 7e       	andi	r29, 0xE2	; 226
 5d4:	09 0c       	add	r0, r9
 5d6:	00 01       	movw	r0, r0
 5d8:	03 01       	movw	r0, r6
	SREG = oldSREG;
 5da:	09 02       	muls	r16, r25

void setup()
{
  Serial.begin(57600);         // 9600 bps
    
  _startTime_ms = millis();
 5dc:	00 01       	movw	r0, r0
 5de:	04 03       	mulsu	r16, r20
 5e0:	03 d0       	rcall	.+6      	; 0x5e8 <main+0x11c>
 5e2:	01 09       	sbc	r16, r1
 5e4:	00 00       	nop
 5e6:	01 03       	mulsu	r16, r17
 5e8:	b7 7f       	andi	r27, 0xF7	; 247
 5ea:	09 12       	cpse	r0, r25
}

void loop() 
{
  if (0 == _loopCounter--) {
 5ec:	00 01       	movw	r0, r0
 5ee:	03 04       	cpc	r0, r3
 5f0:	09 06       	cpc	r0, r25
 5f2:	00 01       	movw	r0, r0
 5f4:	03 03       	mulsu	r16, r19
 5f6:	09 06       	cpc	r0, r25
 5f8:	00 01       	movw	r0, r0
 5fa:	03 01       	movw	r0, r6
 5fc:	09 14       	cp	r0, r9
 5fe:	00 01       	movw	r0, r0
 600:	03 04       	cpc	r0, r3
 602:	09 0c       	add	r0, r9
 604:	00 01       	movw	r0, r0
 606:	03 01       	movw	r0, r6
 608:	09 0a       	sbc	r0, r25
 60a:	00 01       	movw	r0, r0
 60c:	03 04       	cpc	r0, r3
 60e:	09 08       	sbc	r0, r9
 610:	00 01       	movw	r0, r0
 612:	03 e2       	ldi	r16, 0x23	; 35
 614:	7e 09       	sbc	r23, r14
 616:	06 00       	.word	0x0006	; ????
 618:	01 03       	mulsu	r16, r17
 61a:	02 09       	sbc	r16, r2
 61c:	00 00       	nop
 61e:	01 04       	cpc	r0, r1
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 620:	02 03       	mulsu	r16, r18

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 622:	71 09       	sbc	r23, r1
	m = timer0_millis;
 624:	14 00       	.word	0x0014	; ????
 626:	01 03       	mulsu	r16, r17
 628:	01 09       	sbc	r16, r1
 62a:	00 00       	nop
 62c:	01 03       	mulsu	r16, r17
 62e:	01 09       	sbc	r16, r1
 630:	04 00       	.word	0x0004	; ????
 632:	01 03       	mulsu	r16, r17
	SREG = oldSREG;
 634:	01 09       	sbc	r16, r1
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 636:	1a 00       	.word	0x001a	; ????
 638:	01 04       	cpc	r0, r1
 63a:	01 03       	mulsu	r16, r17
 63c:	94 01       	movw	r18, r8
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 63e:	09 06       	cpc	r0, r25
 640:	00 01       	movw	r0, r0
 642:	03 05       	cpc	r16, r3
 644:	09 20       	and	r0, r9
 646:	00 01       	movw	r0, r0
 648:	03 03       	mulsu	r16, r19
 64a:	09 02       	muls	r16, r25
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 64c:	00 01       	movw	r0, r0
 64e:	03 03       	mulsu	r16, r19
 650:	09 0c       	add	r0, r9
 652:	00 01       	movw	r0, r0
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 654:	03 01       	movw	r0, r6
 656:	09 12       	cpse	r0, r25
 658:	00 01       	movw	r0, r0
 65a:	03 02       	muls	r16, r19
 65c:	09 04       	cpc	r0, r9
 65e:	00 01       	movw	r0, r0
 660:	03 7c       	andi	r16, 0xC3	; 195
 662:	09 12       	cpse	r0, r25
 664:	00 01       	movw	r0, r0
 666:	03 07       	cpc	r16, r19
 668:	09 08       	sbc	r0, r9
 66a:	00 01       	movw	r0, r0
 66c:	03 01       	movw	r0, r6
 66e:	09 06       	cpc	r0, r25
 670:	00 01       	movw	r0, r0
 672:	04 06       	cpc	r0, r20
 674:	03 bb       	out	0x13, r16	; 19
 676:	7e 09       	sbc	r23, r14
 678:	1e 00       	.word	0x001e	; ????
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 67a:	01 03       	mulsu	r16, r17
 67c:	03 09       	sbc	r16, r3
 67e:	00 00       	nop
 680:	01 04       	cpc	r0, r1
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
 682:	07 03       	mulsu	r16, r23
 684:	14 09       	sbc	r17, r4
 686:	04 00       	.word	0x0004	; ????
 688:	01 03       	mulsu	r16, r17
 68a:	03 09       	sbc	r16, r3
 68c:	16 00       	.word	0x0016	; ????
 68e:	01 03       	mulsu	r16, r17
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 690:	01 09       	sbc	r16, r1
 692:	10 00       	.word	0x0010	; ????
 694:	01 03       	mulsu	r16, r17
 696:	03 09       	sbc	r16, r3
 698:	04 00       	.word	0x0004	; ????
 69a:	01 03       	mulsu	r16, r17
 69c:	01 09       	sbc	r16, r1
 69e:	04 00       	.word	0x0004	; ????
 6a0:	01 03       	mulsu	r16, r17
 6a2:	7e 09       	sbc	r23, r14
 6a4:	04 00       	.word	0x0004	; ????
 6a6:	01 03       	mulsu	r16, r17
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 6a8:	03 09       	sbc	r16, r3
 6aa:	08 00       	.word	0x0008	; ????
 6ac:	01 03       	mulsu	r16, r17
 6ae:	01 09       	sbc	r16, r1
 6b0:	04 00       	.word	0x0004	; ????
 6b2:	01 03       	mulsu	r16, r17
 6b4:	03 09       	sbc	r16, r3
 6b6:	06 00       	.word	0x0006	; ????
 6b8:	01 03       	mulsu	r16, r17
 6ba:	01 09       	sbc	r16, r1
 6bc:	04 00       	.word	0x0004	; ????
 6be:	01 03       	mulsu	r16, r17
 6c0:	01 09       	sbc	r16, r1
 6c2:	10 00       	.word	0x0010	; ????
 6c4:	01 03       	mulsu	r16, r17
 6c6:	01 09       	sbc	r16, r1
 6c8:	26 00       	.word	0x0026	; ????
 6ca:	01 04       	cpc	r0, r1
 6cc:	04 03       	mulsu	r16, r20
 6ce:	00 09       	sbc	r16, r0
 6d0:	16 00       	.word	0x0016	; ????
 6d2:	01 03       	mulsu	r16, r17
 6d4:	01 09       	sbc	r16, r1
 6d6:	22 00       	.word	0x0022	; ????
 6d8:	01 03       	mulsu	r16, r17
 6da:	01 09       	sbc	r16, r1
 6dc:	08 00       	.word	0x0008	; ????
 6de:	01 03       	mulsu	r16, r17
 6e0:	6f 09       	sbc	r22, r15
 6e2:	22 00       	.word	0x0022	; ????
 6e4:	01 04       	cpc	r0, r1
 6e6:	0b 03       	fmul	r16, r19
 6e8:	37 09       	sbc	r19, r7
 6ea:	14 00       	.word	0x0014	; ????
 6ec:	01 03       	mulsu	r16, r17
 6ee:	03 09       	sbc	r16, r3
 6f0:	16 00       	.word	0x0016	; ????
 6f2:	01 03       	mulsu	r16, r17
 6f4:	01 09       	sbc	r16, r1
 6f6:	02 00       	.word	0x0002	; ????
 6f8:	01 03       	mulsu	r16, r17
 6fa:	06 09       	sbc	r16, r6
 6fc:	08 00       	.word	0x0008	; ????
 6fe:	01 03       	mulsu	r16, r17
 700:	01 09       	sbc	r16, r1
 702:	08 00       	.word	0x0008	; ????
 704:	01 03       	mulsu	r16, r17
 706:	01 09       	sbc	r16, r1
 708:	0c 00       	.word	0x000c	; ????
 70a:	01 03       	mulsu	r16, r17
 70c:	04 09       	sbc	r16, r4
 70e:	06 00       	.word	0x0006	; ????
 710:	01 04       	cpc	r0, r1
 712:	04 03       	mulsu	r16, r20
 714:	bb 7f       	andi	r27, 0xFB	; 251
 716:	09 02       	muls	r16, r25
 718:	00 01       	movw	r0, r0
 71a:	09 14       	cp	r0, r9
 71c:	00 00       	nop
 71e:	01 01       	movw	r0, r2
 720:	04 08       	sbc	r0, r4
 722:	00 05       	cpc	r16, r0
 724:	02 cc       	rjmp	.-2044   	; 0xffffff2a <__eeprom_end+0xff7eff2a>
 726:	04 00       	.word	0x0004	; ????
 728:	00 03       	mulsu	r16, r16
 72a:	21 01       	movw	r4, r2
 72c:	04 07       	cpc	r16, r20
 72e:	03 d3       	rcall	.+1542   	; 0xd36 <__stack+0x437>
 730:	01 09       	sbc	r16, r1
 732:	00 00       	nop
 734:	01 03       	mulsu	r16, r17
 736:	06 09       	sbc	r16, r6
 738:	02 00       	.word	0x0002	; ????
 73a:	01 03       	mulsu	r16, r17
 73c:	01 09       	sbc	r16, r1
 73e:	06 00       	.word	0x0006	; ????
 740:	01 03       	mulsu	r16, r17
 742:	0d 09       	sbc	r16, r13
 744:	06 00       	.word	0x0006	; ????
 746:	01 03       	mulsu	r16, r17
 748:	01 09       	sbc	r16, r1
 74a:	06 00       	.word	0x0006	; ????
 74c:	01 03       	mulsu	r16, r17
 74e:	0d 09       	sbc	r16, r13
 750:	06 00       	.word	0x0006	; ????
 752:	01 03       	mulsu	r16, r17
 754:	0b 09       	sbc	r16, r11
 756:	0a 00       	.word	0x000a	; ????
 758:	01 03       	mulsu	r16, r17
 75a:	03 09       	sbc	r16, r3
 75c:	04 00       	.word	0x0004	; ????
 75e:	01 03       	mulsu	r16, r17
 760:	02 09       	sbc	r16, r2
 762:	0a 00       	.word	0x000a	; ????
 764:	01 03       	mulsu	r16, r17
 766:	0a 09       	sbc	r16, r10
 768:	0a 00       	.word	0x000a	; ????
 76a:	01 03       	mulsu	r16, r17
 76c:	07 09       	sbc	r16, r7
 76e:	0a 00       	.word	0x000a	; ????
 770:	01 03       	mulsu	r16, r17
 772:	09 09       	sbc	r16, r9
 774:	0a 00       	.word	0x000a	; ????
 776:	01 03       	mulsu	r16, r17
 778:	23 09       	sbc	r18, r3
 77a:	0a 00       	.word	0x000a	; ????
 77c:	01 03       	mulsu	r16, r17
 77e:	01 09       	sbc	r16, r1
 780:	0a 00       	.word	0x000a	; ????
 782:	01 03       	mulsu	r16, r17
 784:	01 09       	sbc	r16, r1
 786:	0a 00       	.word	0x000a	; ????
 788:	01 03       	mulsu	r16, r17
 78a:	17 09       	sbc	r17, r7
 78c:	0a 00       	.word	0x000a	; ????
 78e:	01 03       	mulsu	r16, r17
 790:	09 09       	sbc	r16, r9
 792:	0a 00       	.word	0x000a	; ????
 794:	01 04       	cpc	r0, r1
 796:	03 03       	mulsu	r16, r19
 798:	f3 7d       	andi	r31, 0xD3	; 211
 79a:	09 04       	cpc	r0, r9
 79c:	00 01       	movw	r0, r0
 79e:	03 09       	sbc	r16, r3
 7a0:	09 0c       	add	r0, r9
 7a2:	00 01       	movw	r0, r0
 7a4:	03 05       	cpc	r16, r3
 7a6:	09 0a       	sbc	r0, r25
 7a8:	00 01       	movw	r0, r0
 7aa:	03 01       	movw	r0, r6
 7ac:	09 0a       	sbc	r0, r25
 7ae:	00 01       	movw	r0, r0
 7b0:	03 02       	muls	r16, r19
 7b2:	09 0c       	add	r0, r9
 7b4:	00 01       	movw	r0, r0
 7b6:	03 06       	cpc	r0, r19
 7b8:	09 04       	cpc	r0, r9
 7ba:	00 01       	movw	r0, r0
 7bc:	03 02       	muls	r16, r19
 7be:	09 0c       	add	r0, r9
 7c0:	00 01       	movw	r0, r0
 7c2:	03 01       	movw	r0, r6
 7c4:	09 0e       	add	r0, r25
 7c6:	00 01       	movw	r0, r0
 7c8:	03 01       	movw	r0, r6
 7ca:	09 0e       	add	r0, r25
 7cc:	00 01       	movw	r0, r0
 7ce:	03 01       	movw	r0, r6
 7d0:	09 0e       	add	r0, r25
 7d2:	00 01       	movw	r0, r0
 7d4:	04 07       	cpc	r16, r20
 7d6:	03 af       	std	Z+59, r16	; 0x3b
 7d8:	7f 09       	sbc	r23, r15
 7da:	0e 00       	.word	0x000e	; ????
 7dc:	01 03       	mulsu	r16, r17
 7de:	04 09       	sbc	r16, r4
 7e0:	02 00       	.word	0x0002	; ????
 7e2:	01 03       	mulsu	r16, r17
 7e4:	01 09       	sbc	r16, r1
 7e6:	02 00       	.word	0x0002	; ????
 7e8:	01 03       	mulsu	r16, r17
 7ea:	01 09       	sbc	r16, r1
 7ec:	10 00       	.word	0x0010	; ????
 7ee:	01 04       	cpc	r0, r1
 7f0:	09 03       	fmul	r16, r17
 7f2:	46 09       	sbc	r20, r6
 7f4:	02 00       	.word	0x0002	; ????
 7f6:	01 03       	mulsu	r16, r17
 7f8:	05 09       	sbc	r16, r5
 7fa:	10 00       	.word	0x0010	; ????
 7fc:	01 04       	cpc	r0, r1
 7fe:	07 03       	mulsu	r16, r23
 800:	2f 09       	sbc	r18, r15
 802:	34 00       	.word	0x0034	; ????
 804:	01 03       	mulsu	r16, r17
 806:	04 09       	sbc	r16, r4
 808:	02 00       	.word	0x0002	; ????
 80a:	01 03       	mulsu	r16, r17
 80c:	01 09       	sbc	r16, r1
 80e:	02 00       	.word	0x0002	; ????
 810:	01 03       	mulsu	r16, r17
 812:	01 09       	sbc	r16, r1
 814:	10 00       	.word	0x0010	; ????
 816:	01 04       	cpc	r0, r1
 818:	01 03       	mulsu	r16, r17
 81a:	76 09       	sbc	r23, r6
 81c:	02 00       	.word	0x0002	; ????
 81e:	01 03       	mulsu	r16, r17
 820:	2a 09       	sbc	r18, r10
 822:	08 00       	.word	0x0008	; ????
 824:	01 03       	mulsu	r16, r17
 826:	56 09       	sbc	r21, r6
 828:	0e 00       	.word	0x000e	; ????
 82a:	01 03       	mulsu	r16, r17
 82c:	2a 09       	sbc	r18, r10
 82e:	08 00       	.word	0x0008	; ????
 830:	01 03       	mulsu	r16, r17
 832:	56 09       	sbc	r21, r6
 834:	26 00       	.word	0x0026	; ????
 836:	01 03       	mulsu	r16, r17
 838:	c0 00       	.word	0x00c0	; ????
 83a:	09 08       	sbc	r0, r9
 83c:	00 01       	movw	r0, r0
 83e:	04 08       	sbc	r0, r4
 840:	03 af       	std	Z+59, r16	; 0x3b
 842:	7f 09       	sbc	r23, r15
 844:	08 00       	.word	0x0008	; ????
 846:	01 04       	cpc	r0, r1
 848:	04 03       	mulsu	r16, r20
 84a:	1e 09       	sbc	r17, r14
 84c:	06 00       	.word	0x0006	; ????
 84e:	01 04       	cpc	r0, r1
 850:	02 03       	mulsu	r16, r18
 852:	61 09       	sbc	r22, r1
 854:	00 00       	nop
 856:	01 04       	cpc	r0, r1
 858:	0a 03       	fmul	r16, r18
 85a:	11 09       	sbc	r17, r1
 85c:	08 00       	.word	0x0008	; ????
 85e:	01 04       	cpc	r0, r1
 860:	0b 03       	fmul	r16, r19
 862:	20 09       	sbc	r18, r0
 864:	10 00       	.word	0x0010	; ????
 866:	01 09       	sbc	r16, r1
 868:	42 00       	.word	0x0042	; ????
 86a:	00 01       	movw	r0, r0
 86c:	01 5e       	subi	r16, 0xE1	; 225
 86e:	00 00       	nop
 870:	00 02       	muls	r16, r16
 872:	00 41       	sbci	r16, 0x10	; 16
 874:	00 00       	nop
 876:	00 02       	muls	r16, r16
 878:	01 fb       	bst	r16, 1
 87a:	0e 0a       	sbc	r0, r30
 87c:	00 01       	movw	r0, r0
 87e:	01 01       	movw	r0, r2
 880:	01 00       	.word	0x0001	; ????
 882:	00 00       	nop
 884:	01 2e       	mov	r0, r17
 886:	2e 2f       	mov	r18, r30
 888:	2e 2e       	mov	r2, r30
 88a:	2f 2e       	mov	r2, r31
 88c:	2e 2f       	mov	r18, r30
 88e:	2e 2e       	mov	r2, r30
 890:	2f 67       	ori	r18, 0x7F	; 127
 892:	63 63       	ori	r22, 0x33	; 51
 894:	2f 6c       	ori	r18, 0xCF	; 207
 896:	69 62       	ori	r22, 0x29	; 41
 898:	67 63       	ori	r22, 0x37	; 55
 89a:	63 2f       	mov	r22, r19
 89c:	63 6f       	ori	r22, 0xF3	; 243
 89e:	6e 66       	ori	r22, 0x6E	; 110
 8a0:	69 67       	ori	r22, 0x79	; 121
 8a2:	2f 61       	ori	r18, 0x1F	; 31
 8a4:	76 72       	andi	r23, 0x26	; 38
 8a6:	00 00       	nop
 8a8:	6c 69       	ori	r22, 0x9C	; 156
 8aa:	62 31       	cpi	r22, 0x12	; 18
 8ac:	66 75       	andi	r22, 0x56	; 86
 8ae:	6e 63       	ori	r22, 0x3E	; 62
 8b0:	73 2e       	mov	r7, r19
 8b2:	53 00       	.word	0x0053	; ????
 8b4:	01 00       	.word	0x0001	; ????
 8b6:	00 00       	nop
 8b8:	00 05       	cpc	r16, r0
 8ba:	02 44       	sbci	r16, 0x42	; 66
 8bc:	07 00       	.word	0x0007	; ????
 8be:	00 03       	mulsu	r16, r16
 8c0:	e6 11       	cpse	r30, r6
 8c2:	01 03       	mulsu	r16, r17
 8c4:	02 09       	sbc	r16, r2
 8c6:	02 00       	.word	0x0002	; ????
 8c8:	01 09       	sbc	r16, r1
 8ca:	02 00       	.word	0x0002	; ????
 8cc:	00 01       	movw	r0, r0
 8ce:	01 1e       	adc	r0, r17
 8d0:	01 00       	.word	0x0001	; ????
 8d2:	00 02       	muls	r16, r16
 8d4:	00 41       	sbci	r16, 0x10	; 16
 8d6:	00 00       	nop
 8d8:	00 02       	muls	r16, r16
 8da:	01 fb       	bst	r16, 1
 8dc:	0e 0a       	sbc	r0, r30
 8de:	00 01       	movw	r0, r0
 8e0:	01 01       	movw	r0, r2
 8e2:	01 00       	.word	0x0001	; ????
 8e4:	00 00       	nop
 8e6:	01 2e       	mov	r0, r17
 8e8:	2e 2f       	mov	r18, r30
 8ea:	2e 2e       	mov	r2, r30
 8ec:	2f 2e       	mov	r2, r31
 8ee:	2e 2f       	mov	r18, r30
 8f0:	2e 2e       	mov	r2, r30
 8f2:	2f 67       	ori	r18, 0x7F	; 127
 8f4:	63 63       	ori	r22, 0x33	; 51
 8f6:	2f 6c       	ori	r18, 0xCF	; 207
 8f8:	69 62       	ori	r22, 0x29	; 41
 8fa:	67 63       	ori	r22, 0x37	; 55
 8fc:	63 2f       	mov	r22, r19
 8fe:	63 6f       	ori	r22, 0xF3	; 243
 900:	6e 66       	ori	r22, 0x6E	; 110
 902:	69 67       	ori	r22, 0x79	; 121
 904:	2f 61       	ori	r18, 0x1F	; 31
 906:	76 72       	andi	r23, 0x26	; 38
 908:	00 00       	nop
 90a:	6c 69       	ori	r22, 0x9C	; 156
 90c:	62 31       	cpi	r22, 0x12	; 18
 90e:	66 75       	andi	r22, 0x56	; 86
 910:	6e 63       	ori	r22, 0x3E	; 62
 912:	73 2e       	mov	r7, r19
 914:	53 00       	.word	0x0053	; ????
 916:	01 00       	.word	0x0001	; ????
 918:	00 00       	nop
 91a:	00 05       	cpc	r16, r0
 91c:	02 ea       	ldi	r16, 0xA2	; 162
 91e:	06 00       	.word	0x0006	; ????
 920:	00 03       	mulsu	r16, r16
 922:	e6 0c       	add	r14, r6
 924:	01 03       	mulsu	r16, r17
 926:	01 09       	sbc	r16, r1
 928:	02 00       	.word	0x0002	; ????
 92a:	01 03       	mulsu	r16, r17
 92c:	01 09       	sbc	r16, r1
 92e:	02 00       	.word	0x0002	; ????
 930:	01 03       	mulsu	r16, r17
 932:	01 09       	sbc	r16, r1
 934:	02 00       	.word	0x0002	; ????
 936:	01 03       	mulsu	r16, r17
 938:	01 09       	sbc	r16, r1
 93a:	02 00       	.word	0x0002	; ????
 93c:	01 03       	mulsu	r16, r17
 93e:	02 09       	sbc	r16, r2
 940:	02 00       	.word	0x0002	; ????
 942:	01 03       	mulsu	r16, r17
 944:	02 09       	sbc	r16, r2
 946:	02 00       	.word	0x0002	; ????
 948:	01 03       	mulsu	r16, r17
 94a:	01 09       	sbc	r16, r1
 94c:	02 00       	.word	0x0002	; ????
 94e:	01 03       	mulsu	r16, r17
 950:	01 09       	sbc	r16, r1
 952:	02 00       	.word	0x0002	; ????
 954:	01 03       	mulsu	r16, r17
 956:	01 09       	sbc	r16, r1
 958:	02 00       	.word	0x0002	; ????
 95a:	01 03       	mulsu	r16, r17
 95c:	01 09       	sbc	r16, r1
 95e:	02 00       	.word	0x0002	; ????
 960:	01 03       	mulsu	r16, r17
 962:	01 09       	sbc	r16, r1
 964:	02 00       	.word	0x0002	; ????
 966:	01 03       	mulsu	r16, r17
 968:	01 09       	sbc	r16, r1
 96a:	02 00       	.word	0x0002	; ????
 96c:	01 03       	mulsu	r16, r17
 96e:	01 09       	sbc	r16, r1
 970:	02 00       	.word	0x0002	; ????
 972:	01 03       	mulsu	r16, r17
 974:	01 09       	sbc	r16, r1
 976:	02 00       	.word	0x0002	; ????
 978:	01 03       	mulsu	r16, r17
 97a:	01 09       	sbc	r16, r1
 97c:	02 00       	.word	0x0002	; ????
 97e:	01 03       	mulsu	r16, r17
 980:	01 09       	sbc	r16, r1
 982:	02 00       	.word	0x0002	; ????
 984:	01 03       	mulsu	r16, r17
 986:	01 09       	sbc	r16, r1
 988:	02 00       	.word	0x0002	; ????
 98a:	01 03       	mulsu	r16, r17
 98c:	01 09       	sbc	r16, r1
 98e:	02 00       	.word	0x0002	; ????
 990:	01 03       	mulsu	r16, r17
 992:	02 09       	sbc	r16, r2
 994:	02 00       	.word	0x0002	; ????
 996:	01 03       	mulsu	r16, r17
 998:	01 09       	sbc	r16, r1
 99a:	02 00       	.word	0x0002	; ????
 99c:	01 03       	mulsu	r16, r17
 99e:	01 09       	sbc	r16, r1
 9a0:	02 00       	.word	0x0002	; ????
 9a2:	01 03       	mulsu	r16, r17
 9a4:	01 09       	sbc	r16, r1
 9a6:	02 00       	.word	0x0002	; ????
 9a8:	01 03       	mulsu	r16, r17
 9aa:	01 09       	sbc	r16, r1
 9ac:	02 00       	.word	0x0002	; ????
 9ae:	01 03       	mulsu	r16, r17
 9b0:	01 09       	sbc	r16, r1
 9b2:	02 00       	.word	0x0002	; ????
 9b4:	01 03       	mulsu	r16, r17
 9b6:	02 09       	sbc	r16, r2
 9b8:	02 00       	.word	0x0002	; ????
 9ba:	01 03       	mulsu	r16, r17
 9bc:	01 09       	sbc	r16, r1
 9be:	02 00       	.word	0x0002	; ????
 9c0:	01 03       	mulsu	r16, r17
 9c2:	01 09       	sbc	r16, r1
 9c4:	02 00       	.word	0x0002	; ????
 9c6:	01 03       	mulsu	r16, r17
 9c8:	01 09       	sbc	r16, r1
 9ca:	02 00       	.word	0x0002	; ????
 9cc:	01 03       	mulsu	r16, r17
 9ce:	02 09       	sbc	r16, r2
 9d0:	02 00       	.word	0x0002	; ????
 9d2:	01 03       	mulsu	r16, r17
 9d4:	02 09       	sbc	r16, r2
 9d6:	02 00       	.word	0x0002	; ????
 9d8:	01 03       	mulsu	r16, r17
 9da:	02 09       	sbc	r16, r2
 9dc:	02 00       	.word	0x0002	; ????
 9de:	01 03       	mulsu	r16, r17
 9e0:	02 09       	sbc	r16, r2
 9e2:	02 00       	.word	0x0002	; ????
 9e4:	01 03       	mulsu	r16, r17
 9e6:	02 09       	sbc	r16, r2
 9e8:	02 00       	.word	0x0002	; ????
 9ea:	01 09       	sbc	r16, r1
 9ec:	02 00       	.word	0x0002	; ????
 9ee:	00 01       	movw	r0, r0
 9f0:	01 94       	neg	r0
 9f2:	00 00       	nop
 9f4:	00 02       	muls	r16, r16
 9f6:	00 41       	sbci	r16, 0x10	; 16
 9f8:	00 00       	nop
 9fa:	00 02       	muls	r16, r16
 9fc:	01 fb       	bst	r16, 1
 9fe:	0e 0a       	sbc	r0, r30
 a00:	00 01       	movw	r0, r0
 a02:	01 01       	movw	r0, r2
 a04:	01 00       	.word	0x0001	; ????
 a06:	00 00       	nop
 a08:	01 2e       	mov	r0, r17
 a0a:	2e 2f       	mov	r18, r30
 a0c:	2e 2e       	mov	r2, r30
 a0e:	2f 2e       	mov	r2, r31
 a10:	2e 2f       	mov	r18, r30
 a12:	2e 2e       	mov	r2, r30
 a14:	2f 67       	ori	r18, 0x7F	; 127
 a16:	63 63       	ori	r22, 0x33	; 51
 a18:	2f 6c       	ori	r18, 0xCF	; 207
 a1a:	69 62       	ori	r22, 0x29	; 41
 a1c:	67 63       	ori	r22, 0x37	; 55
 a1e:	63 2f       	mov	r22, r19
 a20:	63 6f       	ori	r22, 0xF3	; 243
 a22:	6e 66       	ori	r22, 0x6E	; 110
 a24:	69 67       	ori	r22, 0x79	; 121
 a26:	2f 61       	ori	r18, 0x1F	; 31
 a28:	76 72       	andi	r23, 0x26	; 38
 a2a:	00 00       	nop
 a2c:	6c 69       	ori	r22, 0x9C	; 156
 a2e:	62 31       	cpi	r22, 0x12	; 18
 a30:	66 75       	andi	r22, 0x56	; 86
 a32:	6e 63       	ori	r22, 0x3E	; 62
 a34:	73 2e       	mov	r7, r19
 a36:	53 00       	.word	0x0053	; ????
 a38:	01 00       	.word	0x0001	; ????
 a3a:	00 00       	nop
 a3c:	00 05       	cpc	r16, r0
 a3e:	02 76       	andi	r16, 0x62	; 98
 a40:	00 00       	nop
 a42:	00 03       	mulsu	r16, r16
 a44:	e9 12       	cpse	r14, r25
 a46:	01 03       	mulsu	r16, r17
 a48:	01 09       	sbc	r16, r1
 a4a:	02 00       	.word	0x0002	; ????
 a4c:	01 03       	mulsu	r16, r17
 a4e:	01 09       	sbc	r16, r1
 a50:	02 00       	.word	0x0002	; ????
 a52:	01 03       	mulsu	r16, r17
 a54:	01 09       	sbc	r16, r1
 a56:	02 00       	.word	0x0002	; ????
 a58:	01 03       	mulsu	r16, r17
 a5a:	01 09       	sbc	r16, r1
 a5c:	02 00       	.word	0x0002	; ????
 a5e:	01 03       	mulsu	r16, r17
 a60:	01 09       	sbc	r16, r1
 a62:	02 00       	.word	0x0002	; ????
 a64:	01 03       	mulsu	r16, r17
 a66:	03 09       	sbc	r16, r3
 a68:	02 00       	.word	0x0002	; ????
 a6a:	01 03       	mulsu	r16, r17
 a6c:	05 09       	sbc	r16, r5
 a6e:	02 00       	.word	0x0002	; ????
 a70:	01 03       	mulsu	r16, r17
 a72:	02 09       	sbc	r16, r2
 a74:	02 00       	.word	0x0002	; ????
 a76:	01 03       	mulsu	r16, r17
 a78:	01 09       	sbc	r16, r1
 a7a:	02 00       	.word	0x0002	; ????
 a7c:	01 03       	mulsu	r16, r17
 a7e:	01 09       	sbc	r16, r1
 a80:	02 00       	.word	0x0002	; ????
 a82:	01 09       	sbc	r16, r1
 a84:	02 00       	.word	0x0002	; ????
 a86:	00 01       	movw	r0, r0
 a88:	01 82       	std	Z+1, r0	; 0x01
 a8a:	00 00       	nop
 a8c:	00 02       	muls	r16, r16
 a8e:	00 41       	sbci	r16, 0x10	; 16
 a90:	00 00       	nop
 a92:	00 02       	muls	r16, r16
 a94:	01 fb       	bst	r16, 1
 a96:	0e 0a       	sbc	r0, r30
 a98:	00 01       	movw	r0, r0
 a9a:	01 01       	movw	r0, r2
 a9c:	01 00       	.word	0x0001	; ????
 a9e:	00 00       	nop
 aa0:	01 2e       	mov	r0, r17
 aa2:	2e 2f       	mov	r18, r30
 aa4:	2e 2e       	mov	r2, r30
 aa6:	2f 2e       	mov	r2, r31
 aa8:	2e 2f       	mov	r18, r30
 aaa:	2e 2e       	mov	r2, r30
 aac:	2f 67       	ori	r18, 0x7F	; 127
 aae:	63 63       	ori	r22, 0x33	; 51
 ab0:	2f 6c       	ori	r18, 0xCF	; 207
 ab2:	69 62       	ori	r22, 0x29	; 41
 ab4:	67 63       	ori	r22, 0x37	; 55
 ab6:	63 2f       	mov	r22, r19
 ab8:	63 6f       	ori	r22, 0xF3	; 243
 aba:	6e 66       	ori	r22, 0x6E	; 110
 abc:	69 67       	ori	r22, 0x79	; 121
 abe:	2f 61       	ori	r18, 0x1F	; 31
 ac0:	76 72       	andi	r23, 0x26	; 38
 ac2:	00 00       	nop
 ac4:	6c 69       	ori	r22, 0x9C	; 156
 ac6:	62 31       	cpi	r22, 0x12	; 18
 ac8:	66 75       	andi	r22, 0x56	; 86
 aca:	6e 63       	ori	r22, 0x3E	; 62
 acc:	73 2e       	mov	r7, r19
 ace:	53 00       	.word	0x0053	; ????
 ad0:	01 00       	.word	0x0001	; ????
 ad2:	00 00       	nop
 ad4:	00 05       	cpc	r16, r0
 ad6:	02 8c       	ldd	r0, Z+26	; 0x1a
 ad8:	00 00       	nop
 ada:	00 03       	mulsu	r16, r16
 adc:	89 13       	cpse	r24, r25
 ade:	01 03       	mulsu	r16, r17
 ae0:	01 09       	sbc	r16, r1
 ae2:	02 00       	.word	0x0002	; ????
 ae4:	01 03       	mulsu	r16, r17
 ae6:	01 09       	sbc	r16, r1
 ae8:	02 00       	.word	0x0002	; ????
 aea:	01 03       	mulsu	r16, r17
 aec:	01 09       	sbc	r16, r1
 aee:	02 00       	.word	0x0002	; ????
 af0:	01 03       	mulsu	r16, r17
 af2:	02 09       	sbc	r16, r2
 af4:	02 00       	.word	0x0002	; ????
 af6:	01 03       	mulsu	r16, r17
 af8:	02 09       	sbc	r16, r2
 afa:	02 00       	.word	0x0002	; ????
 afc:	01 03       	mulsu	r16, r17
 afe:	01 09       	sbc	r16, r1
 b00:	02 00       	.word	0x0002	; ????
 b02:	01 03       	mulsu	r16, r17
 b04:	01 09       	sbc	r16, r1
 b06:	02 00       	.word	0x0002	; ????
 b08:	01 09       	sbc	r16, r1
 b0a:	02 00       	.word	0x0002	; ????
 b0c:	00 01       	movw	r0, r0
 b0e:	01 8e       	std	Z+25, r0	; 0x19
 b10:	00 00       	nop
 b12:	00 02       	muls	r16, r16
 b14:	00 41       	sbci	r16, 0x10	; 16
 b16:	00 00       	nop
 b18:	00 02       	muls	r16, r16
 b1a:	01 fb       	bst	r16, 1
 b1c:	0e 0a       	sbc	r0, r30
 b1e:	00 01       	movw	r0, r0
 b20:	01 01       	movw	r0, r2
 b22:	01 00       	.word	0x0001	; ????
 b24:	00 00       	nop
 b26:	01 2e       	mov	r0, r17
 b28:	2e 2f       	mov	r18, r30
 b2a:	2e 2e       	mov	r2, r30
 b2c:	2f 2e       	mov	r2, r31
 b2e:	2e 2f       	mov	r18, r30
 b30:	2e 2e       	mov	r2, r30
 b32:	2f 67       	ori	r18, 0x7F	; 127
 b34:	63 63       	ori	r22, 0x33	; 51
 b36:	2f 6c       	ori	r18, 0xCF	; 207
 b38:	69 62       	ori	r22, 0x29	; 41
 b3a:	67 63       	ori	r22, 0x37	; 55
 b3c:	63 2f       	mov	r22, r19
 b3e:	63 6f       	ori	r22, 0xF3	; 243
 b40:	6e 66       	ori	r22, 0x6E	; 110
 b42:	69 67       	ori	r22, 0x79	; 121
 b44:	2f 61       	ori	r18, 0x1F	; 31
 b46:	76 72       	andi	r23, 0x26	; 38
 b48:	00 00       	nop
 b4a:	6c 69       	ori	r22, 0x9C	; 156
 b4c:	62 31       	cpi	r22, 0x12	; 18
 b4e:	66 75       	andi	r22, 0x56	; 86
 b50:	6e 63       	ori	r22, 0x3E	; 62
 b52:	73 2e       	mov	r7, r19
 b54:	53 00       	.word	0x0053	; ????
 b56:	01 00       	.word	0x0001	; ????
 b58:	00 00       	nop
 b5a:	00 05       	cpc	r16, r0
 b5c:	02 9c       	mul	r0, r2
 b5e:	00 00       	nop
 b60:	00 03       	mulsu	r16, r16
 b62:	a2 13       	cpse	r26, r18
 b64:	01 03       	mulsu	r16, r17
 b66:	01 09       	sbc	r16, r1
 b68:	02 00       	.word	0x0002	; ????
 b6a:	01 03       	mulsu	r16, r17
 b6c:	01 09       	sbc	r16, r1
 b6e:	02 00       	.word	0x0002	; ????
 b70:	01 03       	mulsu	r16, r17
 b72:	04 09       	sbc	r16, r4
 b74:	02 00       	.word	0x0002	; ????
 b76:	01 03       	mulsu	r16, r17
 b78:	02 09       	sbc	r16, r2
 b7a:	02 00       	.word	0x0002	; ????
 b7c:	01 03       	mulsu	r16, r17
 b7e:	06 09       	sbc	r16, r6
 b80:	02 00       	.word	0x0002	; ????
 b82:	01 03       	mulsu	r16, r17
 b84:	01 09       	sbc	r16, r1
 b86:	02 00       	.word	0x0002	; ????
 b88:	01 03       	mulsu	r16, r17
 b8a:	02 09       	sbc	r16, r2
 b8c:	04 00       	.word	0x0004	; ????
 b8e:	01 03       	mulsu	r16, r17
 b90:	01 09       	sbc	r16, r1
 b92:	02 00       	.word	0x0002	; ????
 b94:	01 03       	mulsu	r16, r17
 b96:	05 09       	sbc	r16, r5
 b98:	02 00       	.word	0x0002	; ????
 b9a:	01 09       	sbc	r16, r1
 b9c:	02 00       	.word	0x0002	; ????
 b9e:	00 01       	movw	r0, r0
 ba0:	01 76       	andi	r16, 0x61	; 97
 ba2:	00 00       	nop
 ba4:	00 02       	muls	r16, r16
 ba6:	00 41       	sbci	r16, 0x10	; 16
 ba8:	00 00       	nop
 baa:	00 02       	muls	r16, r16
 bac:	01 fb       	bst	r16, 1
 bae:	0e 0a       	sbc	r0, r30
 bb0:	00 01       	movw	r0, r0
 bb2:	01 01       	movw	r0, r2
 bb4:	01 00       	.word	0x0001	; ????
 bb6:	00 00       	nop
 bb8:	01 2e       	mov	r0, r17
 bba:	2e 2f       	mov	r18, r30
 bbc:	2e 2e       	mov	r2, r30
 bbe:	2f 2e       	mov	r2, r31
 bc0:	2e 2f       	mov	r18, r30
 bc2:	2e 2e       	mov	r2, r30
 bc4:	2f 67       	ori	r18, 0x7F	; 127
 bc6:	63 63       	ori	r22, 0x33	; 51
 bc8:	2f 6c       	ori	r18, 0xCF	; 207
 bca:	69 62       	ori	r22, 0x29	; 41
 bcc:	67 63       	ori	r22, 0x37	; 55
 bce:	63 2f       	mov	r22, r19
 bd0:	63 6f       	ori	r22, 0xF3	; 243
 bd2:	6e 66       	ori	r22, 0x6E	; 110
 bd4:	69 67       	ori	r22, 0x79	; 121
 bd6:	2f 61       	ori	r18, 0x1F	; 31
 bd8:	76 72       	andi	r23, 0x26	; 38
 bda:	00 00       	nop
 bdc:	6c 69       	ori	r22, 0x9C	; 156
 bde:	62 31       	cpi	r22, 0x12	; 18
 be0:	66 75       	andi	r22, 0x56	; 86
 be2:	6e 63       	ori	r22, 0x3E	; 62
 be4:	73 2e       	mov	r7, r19
 be6:	53 00       	.word	0x0053	; ????
 be8:	01 00       	.word	0x0001	; ????
 bea:	00 00       	nop
 bec:	00 05       	cpc	r16, r0
 bee:	02 2e       	mov	r0, r18
 bf0:	07 00       	.word	0x0007	; ????
 bf2:	00 03       	mulsu	r16, r16
 bf4:	f8 11       	cpse	r31, r8
 bf6:	01 03       	mulsu	r16, r17
 bf8:	01 09       	sbc	r16, r1
 bfa:	02 00       	.word	0x0002	; ????
 bfc:	01 03       	mulsu	r16, r17
 bfe:	1f 09       	sbc	r17, r15
 c00:	02 00       	.word	0x0002	; ????
 c02:	01 03       	mulsu	r16, r17
 c04:	01 09       	sbc	r16, r1
 c06:	02 00       	.word	0x0002	; ????
 c08:	01 03       	mulsu	r16, r17
 c0a:	01 09       	sbc	r16, r1
 c0c:	02 00       	.word	0x0002	; ????
 c0e:	01 03       	mulsu	r16, r17
 c10:	01 09       	sbc	r16, r1
 c12:	02 00       	.word	0x0002	; ????
 c14:	01 09       	sbc	r16, r1
 c16:	02 00       	.word	0x0002	; ????
 c18:	00 01       	movw	r0, r0
 c1a:	01 00       	Address 0x00000c1a is out of bounds.
.word	0xffff	; ????

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	10 00       	.word	0x0010	; ????
   2:	00 00       	nop
   4:	ff ff       	.word	0xffff	; ????
   6:	ff ff       	.word	0xffff	; ????
   8:	01 00       	.word	0x0001	; ????
   a:	02 7f       	andi	r16, 0xF2	; 242
   c:	24 0c       	add	r2, r4
   e:	20 02       	muls	r18, r16
  10:	a4 01       	movw	r20, r8
  12:	00 00       	nop
  14:	34 00       	.word	0x0034	; ????
  16:	00 00       	nop
  18:	00 00       	nop
  1a:	00 00       	nop
  1c:	be 00       	.word	0x00be	; ????
  1e:	00 00       	nop
  20:	54 00       	.word	0x0054	; ????
  22:	00 00       	nop
  24:	41 0e       	add	r4, r17
  26:	03 8c       	ldd	r0, Z+27	; 0x1b
  28:	02 41       	sbci	r16, 0x12	; 18
  2a:	0e 04       	cpc	r0, r14
  2c:	8d 03       	fmulsu	r16, r21
  2e:	41 0e       	add	r4, r17
  30:	05 8e       	std	Z+29, r0	; 0x1d
  32:	04 41       	sbci	r16, 0x14	; 20
  34:	0e 06       	cpc	r0, r30
  36:	8f 05       	cpc	r24, r15
  38:	41 0e       	add	r4, r17
  3a:	07 90       	elpm	r0, Z+
  3c:	06 41       	sbci	r16, 0x16	; 22
  3e:	0e 08       	sbc	r0, r14
  40:	91 07       	cpc	r25, r17
  42:	41 0e       	add	r4, r17
  44:	09 9c       	mul	r0, r9
  46:	08 41       	sbci	r16, 0x18	; 24
  48:	0e 0a       	sbc	r0, r30
  4a:	9d 09       	sbc	r25, r13
  4c:	0c 00       	.word	0x000c	; ????
  4e:	00 00       	nop
  50:	00 00       	nop
  52:	00 00       	nop
  54:	12 01       	movw	r2, r4
  56:	00 00       	nop
  58:	02 00       	.word	0x0002	; ????
  5a:	00 00       	nop
  5c:	0c 00       	.word	0x000c	; ????
  5e:	00 00       	nop
  60:	00 00       	nop
  62:	00 00       	nop
  64:	14 01       	movw	r2, r8
  66:	00 00       	nop
  68:	06 00       	.word	0x0006	; ????
  6a:	00 00       	nop
  6c:	0c 00       	.word	0x000c	; ????
  6e:	00 00       	nop
  70:	00 00       	nop
  72:	00 00       	nop
  74:	1a 01       	movw	r2, r20
  76:	00 00       	nop
  78:	1e 00       	.word	0x001e	; ????
  7a:	00 00       	nop
  7c:	0c 00       	.word	0x000c	; ????
  7e:	00 00       	nop
  80:	00 00       	nop
  82:	00 00       	nop
  84:	38 01       	movw	r6, r16
  86:	00 00       	nop
  88:	28 00       	.word	0x0028	; ????
  8a:	00 00       	nop
  8c:	0c 00       	.word	0x000c	; ????
  8e:	00 00       	nop
  90:	00 00       	nop
  92:	00 00       	nop
  94:	60 01       	movw	r12, r0
  96:	00 00       	nop
  98:	1c 00       	.word	0x001c	; ????
  9a:	00 00       	nop
  9c:	0c 00       	.word	0x000c	; ????
  9e:	00 00       	nop
  a0:	00 00       	nop
  a2:	00 00       	nop
  a4:	7c 01       	movw	r14, r24
  a6:	00 00       	nop
  a8:	18 00       	.word	0x0018	; ????
  aa:	00 00       	nop
  ac:	0c 00       	.word	0x000c	; ????
  ae:	00 00       	nop
  b0:	00 00       	nop
  b2:	00 00       	nop
  b4:	94 01       	movw	r18, r8
  b6:	00 00       	nop
  b8:	14 00       	.word	0x0014	; ????
  ba:	00 00       	nop
  bc:	0c 00       	.word	0x000c	; ????

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	00 00       	nop
  c0:	00 00       	nop
  c2:	00 00       	nop
  c4:	a8 01       	movw	r20, r16
  c6:	00 00       	nop
  c8:	44 00       	.word	0x0044	; ????
  ca:	00 00       	nop
  cc:	2c 00       	.word	0x002c	; ????
  ce:	00 00       	nop
  d0:	00 00       	nop
  d2:	00 00       	nop
  size_t n = 0;
  d4:	ec 01       	movw	r28, r24
  d6:	00 00       	nop
  while (size--) {
  d8:	9a 00       	.word	0x009a	; ????
  da:	00 00       	nop
  dc:	41 0e       	add	r4, r17
    if (write(*buffer++)) n++;
  de:	03 8e       	std	Z+27, r0	; 0x1b
  e0:	02 41       	sbci	r16, 0x12	; 18
  e2:	0e 04       	cpc	r0, r14
  e4:	8f 03       	fmulsu	r16, r23
  e6:	41 0e       	add	r4, r17
  e8:	05 90       	lpm	r0, Z+
  ea:	04 41       	sbci	r16, 0x14	; 20
  ec:	0e 06       	cpc	r0, r30
  ee:	91 05       	cpc	r25, r1
  f0:	41 0e       	add	r4, r17
  f2:	07 9c       	mul	r0, r7
  f4:	06 41       	sbci	r16, 0x16	; 22
  f6:	0e 08       	sbc	r0, r14
  f8:	9d 07       	cpc	r25, r29
  fa:	00 00       	nop
  fc:	18 00       	.word	0x0018	; ????
    else break;
  }
  return n;
}
  fe:	00 00       	nop
 100:	00 00       	nop
 102:	00 00       	nop
 104:	86 02       	muls	r24, r22
 106:	00 00       	nop
 108:	44 00       	.word	0x0044	; ????
 10a:	00 00       	nop
 10c:	41 0e       	add	r4, r17
 10e:	03 9c       	mul	r0, r3
 110:	02 41       	sbci	r16, 0x12	; 18
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 112:	0e 04       	cpc	r0, r14
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 114:	9d 03       	fmulsu	r17, r21
 116:	00 00       	nop
 118:	0c 00       	.word	0x000c	; ????
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 11a:	00 00       	nop
 11c:	00 00       	nop
    tail = _tx_buffer_tail;
 11e:	00 00       	nop
 120:	ca 02       	muls	r28, r26
 122:	00 00       	nop
 124:	14 00       	.word	0x0014	; ????
 126:	00 00       	nop
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 128:	0c 00       	.word	0x000c	; ????
 12a:	00 00       	nop
 12c:	00 00       	nop
 12e:	00 00       	nop
 130:	de 02       	muls	r29, r30
 132:	00 00       	nop
  return tail - head - 1;
 134:	24 00       	.word	0x0024	; ????
}
 136:	00 00       	nop
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 138:	3c 00       	.word	0x003c	; ????
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 13a:	00 00       	nop
 13c:	00 00       	nop
 13e:	00 00       	nop
 140:	02 03       	mulsu	r16, r18
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 142:	00 00       	nop
 144:	82 00       	.word	0x0082	; ????
 146:	00 00       	nop
 148:	41 0e       	add	r4, r17
 14a:	03 88       	ldd	r0, Z+19	; 0x13
 14c:	02 41       	sbci	r16, 0x12	; 18
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 14e:	0e 04       	cpc	r0, r14
 150:	89 03       	fmulsu	r16, r17
 152:	41 0e       	add	r4, r17
 154:	05 8a       	std	Z+21, r0	; 0x15
    return c;
 156:	04 41       	sbci	r16, 0x14	; 20
 158:	0e 06       	cpc	r0, r30

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 15a:	8b 05       	cpc	r24, r11
 15c:	41 0e       	add	r4, r17
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 15e:	07 90       	elpm	r0, Z+
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 160:	06 41       	sbci	r16, 0x16	; 22
  if (_rx_buffer_head == _rx_buffer_tail) {
 162:	0e 08       	sbc	r0, r14
 164:	91 07       	cpc	r25, r17
 166:	41 0e       	add	r4, r17
 168:	09 9c       	mul	r0, r9
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 16a:	08 41       	sbci	r16, 0x18	; 24
 16c:	0e 0a       	sbc	r0, r30
 16e:	9d 09       	sbc	r25, r13
 170:	42 0d       	add	r20, r2
 172:	1c 41       	sbci	r17, 0x1C	; 28
 174:	0e 2b       	or	r16, r30
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 176:	00 00       	nop
 178:	0c 00       	.word	0x000c	; ????
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 17a:	00 00       	nop
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 17c:	00 00       	nop
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 17e:	00 00       	nop
 180:	84 03       	fmuls	r16, r20
 182:	00 00       	nop
 184:	04 00       	.word	0x0004	; ????
 186:	00 00       	nop
 188:	34 00       	.word	0x0034	; ????
 18a:	00 00       	nop
 18c:	00 00       	nop
}
 18e:	00 00       	nop
 190:	88 03       	fmulsu	r16, r16
 192:	00 00       	nop
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 194:	94 00       	.word	0x0094	; ????
 196:	00 00       	nop
 198:	41 0e       	add	r4, r17
 19a:	03 81       	ldd	r16, Z+3	; 0x03
 19c:	02 41       	sbci	r16, 0x12	; 18
 19e:	0e 04       	cpc	r0, r14
 1a0:	80 03       	fmuls	r16, r16
 1a2:	44 0e       	add	r4, r20
}
 1a4:	05 92       	las	Z, r0
 1a6:	04 41       	sbci	r16, 0x14	; 20
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1a8:	0e 06       	cpc	r0, r30
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1aa:	93 05       	cpc	r25, r3
 1ac:	41 0e       	add	r4, r17
 1ae:	07 98       	cbi	0x00, 7	; 0
 1b0:	06 41       	sbci	r16, 0x16	; 22
 1b2:	0e 08       	sbc	r0, r14
 1b4:	99 07       	cpc	r25, r25
 1b6:	41 0e       	add	r4, r17
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1b8:	09 9a       	sbi	0x01, 1	; 1
 1ba:	08 41       	sbci	r16, 0x18	; 24
 1bc:	0e 0a       	sbc	r0, r30
 1be:	9b 09       	sbc	r25, r11
 1c0:	0c 00       	.word	0x000c	; ????
 1c2:	00 00       	nop

  *_udr = c;
 1c4:	00 00       	nop
 1c6:	00 00       	nop
 1c8:	cc 04       	cpc	r12, r12
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 1ca:	00 00       	nop
 1cc:	c4 01       	movw	r24, r8
 1ce:	00 00       	nop
 1d0:	0c 00       	.word	0x000c	; ????
 1d2:	00 00       	nop
 1d4:	00 00       	nop
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 1d6:	00 00       	nop
 1d8:	90 06       	cpc	r9, r16
 1da:	00 00       	nop
 1dc:	5a 00       	.word	0x005a	; ????
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1de:	00 00       	nop
 1e0:	54 00       	.word	0x0054	; ????
 1e2:	00 00       	nop
 1e4:	00 00       	nop
 1e6:	00 00       	nop
 1e8:	1c 04       	cpc	r1, r12
 1ea:	00 00       	nop
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 1ec:	4c 00       	.word	0x004c	; ????
 1ee:	00 00       	nop
 1f0:	41 0e       	add	r4, r17
 1f2:	03 81       	ldd	r16, Z+3	; 0x03
 1f4:	02 41       	sbci	r16, 0x12	; 18
 1f6:	0e 04       	cpc	r0, r14
 1f8:	80 03       	fmuls	r16, r16
  _written = true;
 1fa:	44 0e       	add	r4, r20
 1fc:	05 92       	las	Z, r0
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 1fe:	04 41       	sbci	r16, 0x14	; 20
 200:	0e 06       	cpc	r0, r30
 202:	93 05       	cpc	r25, r3
 204:	41 0e       	add	r4, r17
 206:	07 94       	ror	r0
 208:	06 41       	sbci	r16, 0x16	; 22
 20a:	0e 08       	sbc	r0, r14
 20c:	95 07       	cpc	r25, r21
 20e:	41 0e       	add	r4, r17
 210:	09 96       	adiw	r24, 0x09	; 9
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 212:	08 41       	sbci	r16, 0x18	; 24
 214:	0e 0a       	sbc	r0, r30
 216:	97 09       	sbc	r25, r7
 218:	41 0e       	add	r4, r17
 21a:	0b 98       	cbi	0x01, 3	; 1
 21c:	0a 41       	sbci	r16, 0x1A	; 26
 21e:	0e 0c       	add	r0, r14
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 220:	99 0b       	sbc	r25, r25
 222:	41 0e       	add	r4, r17
 224:	0d 9a       	sbi	0x01, 5	; 1
    if (bit_is_clear(SREG, SREG_I)) {
 226:	0c 41       	sbci	r16, 0x1C	; 28
 228:	0e 0e       	add	r0, r30
 22a:	9b 0d       	add	r25, r11
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 22c:	41 0e       	add	r4, r17
 22e:	0f 9e       	mul	r0, r31
 230:	0e 41       	sbci	r16, 0x1E	; 30
 232:	0e 10       	cpse	r0, r14
 234:	9f 0f       	add	r25, r31
	_tx_udr_empty_irq();
 236:	00 00       	nop
 238:	30 00       	.word	0x0030	; ????
 23a:	00 00       	nop
 23c:	00 00       	nop
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 23e:	00 00       	nop
 240:	68 04       	cpc	r6, r8
 242:	00 00       	nop
 244:	64 00       	.word	0x0064	; ????
 246:	00 00       	nop
 248:	41 0e       	add	r4, r17
 24a:	03 81       	ldd	r16, Z+3	; 0x03

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 24c:	02 41       	sbci	r16, 0x12	; 18
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 24e:	0e 04       	cpc	r0, r14
    _tx_buffer_head = i;
 250:	80 03       	fmuls	r16, r16
    sbi(*_ucsrb, UDRIE0);
 252:	44 0e       	add	r4, r20
 254:	05 92       	las	Z, r0
 256:	04 41       	sbci	r16, 0x14	; 20
 258:	0e 06       	cpc	r0, r30
 25a:	98 05       	cpc	r25, r8
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 25c:	41 0e       	add	r4, r17
 25e:	07 99       	sbic	0x00, 7	; 0
      *_udr = c;
 260:	06 41       	sbci	r16, 0x16	; 22
 262:	0e 08       	sbc	r0, r14
 264:	9e 07       	cpc	r25, r30
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 266:	41 0e       	add	r4, r17
 268:	09 9f       	mul	r16, r25
 26a:	08 00       	.word	0x0008	; ????

Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	61 76       	andi	r22, 0x61	; 97
   2:	72 2d       	mov	r23, r2
   4:	6c 69       	ori	r22, 0x9C	; 156
   6:	62 63       	ori	r22, 0x32	; 50
   8:	20 32       	cpi	r18, 0x20	; 32
   a:	2e 30       	cpi	r18, 0x0E	; 14
   c:	2e 30       	cpi	r18, 0x0E	; 14
   e:	00 75       	andi	r16, 0x50	; 80
  10:	69 6e       	ori	r22, 0xE9	; 233
  12:	74 38       	cpi	r23, 0x84	; 132
  14:	5f 74       	andi	r21, 0x4F	; 79
  16:	00 75       	andi	r16, 0x50	; 80
  18:	69 6e       	ori	r22, 0xE9	; 233
  1a:	74 31       	cpi	r23, 0x14	; 20
  1c:	36 5f       	subi	r19, 0xF6	; 246
  1e:	74 00       	.word	0x0074	; ????
  20:	5f 5f       	subi	r21, 0xFF	; 255
  22:	65 65       	ori	r22, 0x55	; 85
  24:	70 72       	andi	r23, 0x20	; 32
  26:	6f 6d       	ori	r22, 0xDF	; 223
  28:	00 55       	subi	r16, 0x50	; 80
  2a:	44 52       	subi	r20, 0x24	; 36
  2c:	30 00       	.word	0x0030	; ????
  2e:	55 43       	sbci	r21, 0x35	; 53
  30:	53 52       	subi	r21, 0x23	; 35
  32:	30 41       	sbci	r19, 0x10	; 16
  34:	00 55       	subi	r16, 0x50	; 80
  36:	43 53       	subi	r20, 0x33	; 51
  38:	52 30       	cpi	r21, 0x02	; 2
  3a:	42 00       	.word	0x0042	; ????
  3c:	55 43       	sbci	r21, 0x35	; 53
  3e:	53 52       	subi	r21, 0x23	; 35
  40:	30 43       	sbci	r19, 0x30	; 48
  42:	00 55       	subi	r16, 0x50	; 80
  44:	42 52       	subi	r20, 0x22	; 34
  46:	52 30       	cpi	r21, 0x02	; 2
  48:	00 54       	subi	r16, 0x40	; 64
  4a:	57 41       	sbci	r21, 0x17	; 23
  4c:	4d 52       	subi	r20, 0x2D	; 45
  4e:	00 54       	subi	r16, 0x40	; 64
  50:	57 42       	sbci	r21, 0x27	; 39
  52:	52 00       	.word	0x0052	; ????
  54:	54 57       	subi	r21, 0x74	; 116
  56:	43 52       	subi	r20, 0x23	; 35
  58:	00 54       	subi	r16, 0x40	; 64
  5a:	57 53       	subi	r21, 0x37	; 55
  5c:	52 00       	.word	0x0052	; ????
  5e:	54 57       	subi	r21, 0x74	; 116
  60:	44 52       	subi	r20, 0x24	; 36
  62:	00 54       	subi	r16, 0x40	; 64
  64:	57 41       	sbci	r21, 0x17	; 23
  66:	52 00       	.word	0x0052	; ????
  68:	54 49       	sbci	r21, 0x94	; 148
  6a:	4d 53       	subi	r20, 0x3D	; 61
  6c:	4b 31       	cpi	r20, 0x1B	; 27
  6e:	00 54       	subi	r16, 0x40	; 64
  70:	49 46       	sbci	r20, 0x69	; 105
  72:	52 31       	cpi	r21, 0x12	; 18
  74:	00 54       	subi	r16, 0x40	; 64
  76:	43 43       	sbci	r20, 0x33	; 51
  78:	52 31       	cpi	r21, 0x12	; 18
  7a:	41 00       	.word	0x0041	; ????
  7c:	54 43       	sbci	r21, 0x34	; 52
  7e:	43 52       	subi	r20, 0x23	; 35
  80:	31 42       	sbci	r19, 0x21	; 33
  82:	00 54       	subi	r16, 0x40	; 64
  84:	43 43       	sbci	r20, 0x33	; 51
  86:	52 31       	cpi	r21, 0x12	; 18
  88:	43 00       	.word	0x0043	; ????
  8a:	54 43       	sbci	r21, 0x34	; 52
  8c:	4e 54       	subi	r20, 0x4E	; 78
  8e:	31 00       	.word	0x0031	; ????
  90:	4f 43       	sbci	r20, 0x3F	; 63
  92:	52 31       	cpi	r21, 0x12	; 18
  94:	41 00       	.word	0x0041	; ????
  96:	4f 43       	sbci	r20, 0x3F	; 63
  98:	52 31       	cpi	r21, 0x12	; 18
  9a:	42 00       	.word	0x0042	; ????
  9c:	49 43       	sbci	r20, 0x39	; 57
  9e:	52 31       	cpi	r21, 0x12	; 18
  a0:	00 47       	sbci	r16, 0x70	; 112
  a2:	54 43       	sbci	r21, 0x34	; 52
  a4:	43 52       	subi	r20, 0x23	; 35
  a6:	00 54       	subi	r16, 0x40	; 64
  a8:	49 4d       	sbci	r20, 0xD9	; 217
  aa:	53 4b       	sbci	r21, 0xB3	; 179
  ac:	32 00       	.word	0x0032	; ????
  ae:	54 49       	sbci	r21, 0x94	; 148
  b0:	46 52       	subi	r20, 0x26	; 38
  b2:	32 00       	.word	0x0032	; ????
  b4:	54 43       	sbci	r21, 0x34	; 52
  b6:	43 52       	subi	r20, 0x23	; 35
  b8:	32 41       	sbci	r19, 0x12	; 18
  ba:	00 54       	subi	r16, 0x40	; 64
  bc:	43 43       	sbci	r20, 0x33	; 51

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	52 32       	cpi	r21, 0x22	; 34
  c0:	42 00       	.word	0x0042	; ????
  c2:	54 43       	sbci	r21, 0x34	; 52
  c4:	4e 54       	subi	r20, 0x4E	; 78
  c6:	32 00       	.word	0x0032	; ????
  c8:	4f 43       	sbci	r20, 0x3F	; 63
  ca:	52 32       	cpi	r21, 0x22	; 34
  cc:	42 00       	.word	0x0042	; ????
  ce:	4f 43       	sbci	r20, 0x3F	; 63
  d0:	52 32       	cpi	r21, 0x22	; 34
  d2:	41 00       	.word	0x0041	; ????
  size_t n = 0;
  d4:	41 53       	subi	r20, 0x31	; 49
  d6:	53 52       	subi	r21, 0x23	; 35
  while (size--) {
  d8:	00 47       	sbci	r16, 0x70	; 112
  da:	54 43       	sbci	r21, 0x34	; 52
  dc:	43 52       	subi	r20, 0x23	; 35
    if (write(*buffer++)) n++;
  de:	00 41       	sbci	r16, 0x10	; 16
  e0:	44 4d       	sbci	r20, 0xD4	; 212
  e2:	55 58       	subi	r21, 0x85	; 133
  e4:	00 41       	sbci	r16, 0x10	; 16
  e6:	44 43       	sbci	r20, 0x34	; 52
  e8:	00 41       	sbci	r16, 0x10	; 16
  ea:	44 43       	sbci	r20, 0x34	; 52
  ec:	53 52       	subi	r21, 0x23	; 35
  ee:	41 00       	.word	0x0041	; ????
  f0:	41 44       	sbci	r20, 0x41	; 65
  f2:	43 53       	subi	r20, 0x33	; 51
  f4:	52 42       	sbci	r21, 0x22	; 34
  f6:	00 44       	sbci	r16, 0x40	; 64
  f8:	49 44       	sbci	r20, 0x49	; 73
  fa:	52 30       	cpi	r21, 0x02	; 2
  fc:	00 41       	sbci	r16, 0x10	; 16
    else break;
  }
  return n;
}
  fe:	43 53       	subi	r20, 0x33	; 51
 100:	52 00       	.word	0x0052	; ????
 102:	44 49       	sbci	r20, 0x94	; 148
 104:	44 52       	subi	r20, 0x24	; 36
 106:	31 00       	.word	0x0031	; ????
 108:	50 4f       	sbci	r21, 0xF0	; 240
 10a:	52 54       	subi	r21, 0x42	; 66
 10c:	42 00       	.word	0x0042	; ????
 10e:	44 44       	sbci	r20, 0x44	; 68
 110:	52 42       	sbci	r21, 0x22	; 34
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 112:	00 50       	subi	r16, 0x00	; 0
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 114:	49 4e       	sbci	r20, 0xE9	; 233
 116:	42 00       	.word	0x0042	; ????
 118:	50 4f       	sbci	r21, 0xF0	; 240
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 11a:	52 54       	subi	r21, 0x42	; 66
 11c:	43 00       	.word	0x0043	; ????
    tail = _tx_buffer_tail;
 11e:	44 44       	sbci	r20, 0x44	; 68
 120:	52 43       	sbci	r21, 0x32	; 50
 122:	00 50       	subi	r16, 0x00	; 0
 124:	49 4e       	sbci	r20, 0xE9	; 233
 126:	43 00       	.word	0x0043	; ????
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 128:	50 4f       	sbci	r21, 0xF0	; 240
 12a:	52 54       	subi	r21, 0x42	; 66
 12c:	44 00       	.word	0x0044	; ????
 12e:	44 44       	sbci	r20, 0x44	; 68
 130:	52 44       	sbci	r21, 0x42	; 66
 132:	00 50       	subi	r16, 0x00	; 0
  return tail - head - 1;
 134:	49 4e       	sbci	r20, 0xE9	; 233
}
 136:	44 00       	.word	0x0044	; ????
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 138:	4f 43       	sbci	r20, 0x3F	; 63
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 13a:	52 30       	cpi	r21, 0x02	; 2
 13c:	42 00       	.word	0x0042	; ????
 13e:	4f 43       	sbci	r20, 0x3F	; 63
 140:	52 30       	cpi	r21, 0x02	; 2
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 142:	41 00       	.word	0x0041	; ????
 144:	54 43       	sbci	r21, 0x34	; 52
 146:	4e 54       	subi	r20, 0x4E	; 78
 148:	30 00       	.word	0x0030	; ????
 14a:	54 43       	sbci	r21, 0x34	; 52
 14c:	43 52       	subi	r20, 0x23	; 35
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 14e:	30 42       	sbci	r19, 0x20	; 32
 150:	00 54       	subi	r16, 0x40	; 64
 152:	43 43       	sbci	r20, 0x33	; 51
 154:	52 30       	cpi	r21, 0x02	; 2
    return c;
 156:	41 00       	.word	0x0041	; ????
 158:	54 49       	sbci	r21, 0x94	; 148

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 15a:	4d 53       	subi	r20, 0x3D	; 61
 15c:	4b 30       	cpi	r20, 0x0B	; 11
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 15e:	00 54       	subi	r16, 0x40	; 64
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 160:	49 46       	sbci	r20, 0x69	; 105
  if (_rx_buffer_head == _rx_buffer_tail) {
 162:	52 30       	cpi	r21, 0x02	; 2
 164:	00 47       	sbci	r16, 0x70	; 112
 166:	54 43       	sbci	r21, 0x34	; 52
 168:	43 52       	subi	r20, 0x23	; 35
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 16a:	00 45       	sbci	r16, 0x50	; 80
 16c:	49 43       	sbci	r20, 0x39	; 57
 16e:	52 41       	sbci	r21, 0x12	; 18
 170:	00 45       	sbci	r16, 0x50	; 80
 172:	49 4d       	sbci	r20, 0xD9	; 217
 174:	53 4b       	sbci	r21, 0xB3	; 179
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 176:	00 45       	sbci	r16, 0x50	; 80
 178:	49 46       	sbci	r20, 0x69	; 105
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 17a:	52 00       	.word	0x0052	; ????
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 17c:	50 43       	sbci	r21, 0x30	; 48
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 17e:	49 43       	sbci	r20, 0x39	; 57
 180:	52 00       	.word	0x0052	; ????
 182:	50 43       	sbci	r21, 0x30	; 48
 184:	4d 53       	subi	r20, 0x3D	; 61
 186:	4b 32       	cpi	r20, 0x2B	; 43
 188:	00 50       	subi	r16, 0x00	; 0
 18a:	43 4d       	sbci	r20, 0xD3	; 211
 18c:	53 4b       	sbci	r21, 0xB3	; 179
}
 18e:	31 00       	.word	0x0031	; ????
 190:	50 43       	sbci	r21, 0x30	; 48
 192:	4d 53       	subi	r20, 0x3D	; 61
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 194:	4b 30       	cpi	r20, 0x0B	; 11
 196:	00 50       	subi	r16, 0x00	; 0
 198:	43 49       	sbci	r20, 0x93	; 147
 19a:	46 52       	subi	r20, 0x26	; 38
 19c:	00 53       	subi	r16, 0x30	; 48
 19e:	50 44       	sbci	r21, 0x40	; 64
 1a0:	52 00       	.word	0x0052	; ????
 1a2:	53 50       	subi	r21, 0x03	; 3
}
 1a4:	53 52       	subi	r21, 0x23	; 35
 1a6:	00 53       	subi	r16, 0x30	; 48
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1a8:	50 43       	sbci	r21, 0x30	; 48
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1aa:	52 00       	.word	0x0052	; ????
 1ac:	57 44       	sbci	r21, 0x47	; 71
 1ae:	54 43       	sbci	r21, 0x34	; 52
 1b0:	53 52       	subi	r21, 0x23	; 35
 1b2:	00 50       	subi	r16, 0x00	; 0
 1b4:	52 52       	subi	r21, 0x22	; 34
 1b6:	00 4f       	sbci	r16, 0xF0	; 240
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1b8:	53 43       	sbci	r21, 0x33	; 51
 1ba:	43 41       	sbci	r20, 0x13	; 19
 1bc:	4c 00       	.word	0x004c	; ????
 1be:	43 4c       	sbci	r20, 0xC3	; 195
 1c0:	4b 50       	subi	r20, 0x0B	; 11
 1c2:	52 00       	.word	0x0052	; ????

  *_udr = c;
 1c4:	53 52       	subi	r21, 0x23	; 35
 1c6:	45 47       	sbci	r20, 0x75	; 117
 1c8:	00 53       	subi	r16, 0x30	; 48
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 1ca:	50 00       	.word	0x0050	; ????
 1cc:	53 50       	subi	r21, 0x03	; 3
 1ce:	4d 43       	sbci	r20, 0x3D	; 61
 1d0:	53 52       	subi	r21, 0x23	; 35
 1d2:	00 4d       	sbci	r16, 0xD0	; 208
 1d4:	43 55       	subi	r20, 0x53	; 83
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 1d6:	43 52       	subi	r20, 0x23	; 35
 1d8:	00 4d       	sbci	r16, 0xD0	; 208
 1da:	43 55       	subi	r20, 0x53	; 83
 1dc:	53 52       	subi	r21, 0x23	; 35
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1de:	00 53       	subi	r16, 0x30	; 48
 1e0:	4d 43       	sbci	r20, 0x3D	; 61
 1e2:	52 00       	.word	0x0052	; ????
 1e4:	47 50       	subi	r20, 0x07	; 7
 1e6:	49 4f       	sbci	r20, 0xF9	; 249
 1e8:	52 32       	cpi	r21, 0x22	; 34
 1ea:	00 47       	sbci	r16, 0x70	; 112
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 1ec:	50 49       	sbci	r21, 0x90	; 144
 1ee:	4f 52       	subi	r20, 0x2F	; 47
 1f0:	31 00       	.word	0x0031	; ????
 1f2:	47 50       	subi	r20, 0x07	; 7
 1f4:	49 4f       	sbci	r20, 0xF9	; 249
 1f6:	52 30       	cpi	r21, 0x02	; 2
 1f8:	00 45       	sbci	r16, 0x50	; 80
  _written = true;
 1fa:	45 41       	sbci	r20, 0x15	; 21
 1fc:	52 00       	.word	0x0052	; ????
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 1fe:	45 45       	sbci	r20, 0x55	; 85
 200:	44 52       	subi	r20, 0x24	; 36
 202:	00 45       	sbci	r16, 0x50	; 80
 204:	45 43       	sbci	r20, 0x35	; 53
 206:	52 00       	.word	0x0052	; ????
 208:	5f 74       	andi	r21, 0x4F	; 79
 20a:	78 5f       	subi	r23, 0xF8	; 248
 20c:	62 75       	andi	r22, 0x52	; 82
 20e:	66 66       	ori	r22, 0x66	; 102
 210:	65 72       	andi	r22, 0x25	; 37
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 212:	5f 68       	ori	r21, 0x8F	; 143
 214:	65 61       	ori	r22, 0x15	; 21
 216:	64 00       	.word	0x0064	; ????
 218:	5f 72       	andi	r21, 0x2F	; 47
 21a:	78 5f       	subi	r23, 0xF8	; 248
 21c:	62 75       	andi	r22, 0x52	; 82
 21e:	66 66       	ori	r22, 0x66	; 102
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 220:	65 72       	andi	r22, 0x25	; 37
 222:	5f 74       	andi	r21, 0x4F	; 79
 224:	61 69       	ori	r22, 0x91	; 145
    if (bit_is_clear(SREG, SREG_I)) {
 226:	6c 00       	.word	0x006c	; ????
 228:	77 72       	andi	r23, 0x27	; 39
 22a:	69 74       	andi	r22, 0x49	; 73
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 22c:	65 00       	.word	0x0065	; ????
 22e:	66 6c       	ori	r22, 0xC6	; 198
 230:	75 73       	andi	r23, 0x35	; 53
 232:	68 00       	.word	0x0068	; ????
 234:	74 69       	ori	r23, 0x94	; 148
	_tx_udr_empty_irq();
 236:	6d 65       	ori	r22, 0x5D	; 93
 238:	72 30       	cpi	r23, 0x02	; 2
 23a:	5f 66       	ori	r21, 0x6F	; 111
 23c:	72 61       	ori	r23, 0x12	; 18
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 23e:	63 74       	andi	r22, 0x43	; 67
 240:	00 6c       	ori	r16, 0xC0	; 192
 242:	6f 6f       	ori	r22, 0xFF	; 255
 244:	70 2e       	mov	r7, r16
 246:	70 61       	ori	r23, 0x10	; 16
 248:	72 74       	andi	r23, 0x42	; 66
 24a:	2e 30       	cpi	r18, 0x0E	; 14

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 24c:	00 77       	andi	r16, 0x70	; 112
 24e:	72 69       	ori	r23, 0x92	; 146
    _tx_buffer_head = i;
 250:	74 65       	ori	r23, 0x54	; 84
    sbi(*_ucsrb, UDRIE0);
 252:	5f 65       	ori	r21, 0x5F	; 95
 254:	72 72       	andi	r23, 0x22	; 34
 256:	6f 72       	andi	r22, 0x2F	; 47
 258:	00 6f       	ori	r16, 0xF0	; 240
 25a:	6c 64       	ori	r22, 0x4C	; 76
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 25c:	53 52       	subi	r21, 0x23	; 35
 25e:	45 47       	sbci	r20, 0x75	; 117
      *_udr = c;
 260:	00 53       	subi	r16, 0x30	; 48
 262:	65 72       	andi	r22, 0x25	; 37
 264:	69 61       	ori	r22, 0x19	; 25
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 266:	6c 30       	cpi	r22, 0x0C	; 12
 268:	5f 61       	ori	r21, 0x1F	; 31
 26a:	76 61       	ori	r23, 0x16	; 22
 26c:	69 6c       	ori	r22, 0xC9	; 201
 26e:	61 62       	ori	r22, 0x21	; 33
 270:	6c 65       	ori	r22, 0x5C	; 92
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 272:	00 73       	andi	r16, 0x30	; 48
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
 274:	69 7a       	andi	r22, 0xA9	; 169
 276:	65 5f       	subi	r22, 0xF5	; 245
 278:	74 00       	.word	0x0074	; ????
 27a:	5f 5f       	subi	r21, 0xFF	; 255
 27c:	76 65       	ori	r23, 0x56	; 86
 27e:	63 74       	andi	r22, 0x43	; 67
 280:	6f 72       	andi	r22, 0x2F	; 47
 282:	5f 31       	cpi	r21, 0x1F	; 31
 284:	39 00       	.word	0x0039	; ????
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 286:	73 69       	ori	r23, 0x93	; 147
 288:	7a 65       	ori	r23, 0x5A	; 90
 28a:	74 79       	andi	r23, 0x94	; 148
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 28c:	70 65       	ori	r23, 0x50	; 80
 28e:	00 62       	ori	r16, 0x20	; 32
 290:	65 67       	ori	r22, 0x75	; 117
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 292:	69 6e       	ori	r22, 0xE9	; 233
 294:	00 69       	ori	r16, 0x90	; 144
 296:	6e 69       	ori	r22, 0x9E	; 158
 298:	74 56       	subi	r23, 0x64	; 100
 29a:	61 72       	andi	r22, 0x21	; 33
 29c:	69 61       	ori	r22, 0x19	; 25
 29e:	6e 74       	andi	r22, 0x4E	; 78
 2a0:	00 5f       	subi	r16, 0xF0	; 240
 2a2:	5a 4e       	sbci	r21, 0xEA	; 234
 2a4:	31 34       	cpi	r19, 0x41	; 65
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 2a6:	48 61       	ori	r20, 0x18	; 24
 2a8:	72 64       	ori	r23, 0x42	; 66
 2aa:	77 61       	ori	r23, 0x17	; 23
 2ac:	72 65       	ori	r23, 0x52	; 82
 2ae:	53 65       	ori	r21, 0x53	; 83
 2b0:	72 69       	ori	r23, 0x92	; 146
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 2b2:	61 6c       	ori	r22, 0xC1	; 193
 2b4:	35 66       	ori	r19, 0x65	; 101
 2b6:	6c 75       	andi	r22, 0x5C	; 92
 2b8:	73 68       	ori	r23, 0x83	; 131
 2ba:	45 76       	andi	r20, 0x65	; 101
	  _tx_udr_empty_irq();
 2bc:	2e 70       	andi	r18, 0x0E	; 14
 2be:	61 72       	andi	r22, 0x21	; 33
 2c0:	74 2e       	mov	r7, r20
 2c2:	32 00       	.word	0x0032	; ????
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 2c4:	5f 5a       	subi	r21, 0xAF	; 175
 2c6:	4e 31       	cpi	r20, 0x1E	; 30
 2c8:	34 48       	sbci	r19, 0x84	; 132
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2ca:	61 72       	andi	r22, 0x21	; 33
 2cc:	64 77       	andi	r22, 0x74	; 116
 2ce:	61 72       	andi	r22, 0x21	; 33
 2d0:	65 53       	subi	r22, 0x35	; 53
 2d2:	65 72       	andi	r22, 0x25	; 37
 2d4:	69 61       	ori	r22, 0x19	; 25
 2d6:	6c 43       	sbci	r22, 0x3C	; 60
 2d8:	32 45       	sbci	r19, 0x52	; 82
 2da:	50 56       	subi	r21, 0x60	; 96
 2dc:	68 53       	subi	r22, 0x38	; 56
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 2de:	31 5f       	subi	r19, 0xF1	; 241
 2e0:	53 31       	cpi	r21, 0x13	; 19
      return write((const uint8_t *)str, strlen(str));
 2e2:	5f 53       	subi	r21, 0x3F	; 63
 2e4:	31 5f       	subi	r19, 0xF1	; 241
 2e6:	53 31       	cpi	r21, 0x13	; 19
 2e8:	5f 53       	subi	r21, 0x3F	; 63
 2ea:	31 5f       	subi	r19, 0xF1	; 241
 2ec:	00 6d       	ori	r16, 0xD0	; 208
 2ee:	61 69       	ori	r22, 0x91	; 145
 2f0:	6e 00       	.word	0x006e	; ????
 2f2:	5f 5f       	subi	r21, 0xFF	; 255
 2f4:	63 78       	andi	r22, 0x83	; 131
 2f6:	61 5f       	subi	r22, 0xF1	; 241
 2f8:	70 75       	andi	r23, 0x50	; 80
 2fa:	72 65       	ori	r23, 0x52	; 82
    }
 2fc:	5f 76       	andi	r21, 0x6F	; 111
 2fe:	69 72       	andi	r22, 0x29	; 41
 300:	74 75       	andi	r23, 0x54	; 84
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 302:	61 6c       	ori	r22, 0xC1	; 193
 304:	00 63       	ori	r16, 0x30	; 48
 306:	6f 6e       	ori	r22, 0xEF	; 239
 308:	66 69       	ori	r22, 0x96	; 150
 30a:	67 00       	.word	0x0067	; ????
 30c:	75 69       	ori	r23, 0x95	; 149
 30e:	6e 74       	andi	r22, 0x4E	; 78
 310:	38 5f       	subi	r19, 0xF8	; 248
 312:	74 00       	.word	0x0074	; ????
 314:	73 65       	ori	r23, 0x53	; 83
 316:	72 69       	ori	r23, 0x92	; 146
 318:	61 6c       	ori	r22, 0xC1	; 193
 31a:	45 76       	andi	r20, 0x65	; 101
 31c:	65 6e       	ori	r22, 0xE5	; 229
 31e:	74 52       	subi	r23, 0x24	; 36
 320:	75 6e       	ori	r23, 0xE5	; 229
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 322:	00 5f       	subi	r16, 0xF0	; 240

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 324:	5a 4e       	sbci	r21, 0xEA	; 234
 326:	35 50       	subi	r19, 0x05	; 5
 328:	72 69       	ori	r23, 0x92	; 146
 32a:	6e 74       	andi	r22, 0x4E	; 78
 32c:	43 32       	cpi	r20, 0x23	; 35
 32e:	45 76       	andi	r20, 0x65	; 101

  do {
    char c = n % base;
 330:	00 62       	ori	r16, 0x20	; 32
 332:	6f 6f       	ori	r22, 0xFF	; 255
 334:	6c 00       	.word	0x006c	; ????
 336:	5f 72       	andi	r21, 0x2F	; 47
 338:	78 5f       	subi	r23, 0xF8	; 248
 33a:	62 75       	andi	r22, 0x52	; 82
 33c:	66 66       	ori	r22, 0x66	; 102
 33e:	65 72       	andi	r22, 0x25	; 37
 340:	5f 68       	ori	r21, 0x8F	; 143
    n /= base;
 342:	65 61       	ori	r22, 0x15	; 21
 344:	64 00       	.word	0x0064	; ????

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 346:	73 65       	ori	r23, 0x53	; 83
 348:	74 75       	andi	r23, 0x54	; 84
 34a:	70 00       	.word	0x0070	; ????
 34c:	72 65       	ori	r23, 0x52	; 82
 34e:	61 64       	ori	r22, 0x41	; 65
 350:	00 5f       	subi	r16, 0xF0	; 240
 352:	5f 62       	ori	r21, 0x2F	; 47
 354:	61 73       	andi	r22, 0x31	; 49
 356:	65 5f       	subi	r22, 0xF5	; 245
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 358:	63 74       	andi	r22, 0x43	; 67
 35a:	6f 72       	andi	r22, 0x2F	; 47
 35c:	20 00       	.word	0x0020	; ????
 35e:	70 65       	ori	r23, 0x50	; 80
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 360:	65 6b       	ori	r22, 0xB5	; 181
 362:	00 74       	andi	r16, 0x40	; 64
 364:	69 6d       	ori	r22, 0xD9	; 217
}
 366:	65 72       	andi	r22, 0x25	; 37
 368:	30 5f       	subi	r19, 0xF0	; 240
 36a:	6d 69       	ori	r22, 0x9D	; 157
 36c:	6c 6c       	ori	r22, 0xCC	; 204
 36e:	69 73       	andi	r22, 0x39	; 57
 370:	00 61       	ori	r16, 0x10	; 16
 372:	76 61       	ori	r23, 0x16	; 22
 374:	69 6c       	ori	r22, 0xC9	; 201
 376:	61 62       	ori	r22, 0x21	; 33
 378:	6c 65       	ori	r22, 0x5C	; 92
 37a:	46 6f       	ori	r20, 0xF6	; 246
 37c:	72 57       	subi	r23, 0x72	; 114
 37e:	72 69       	ori	r23, 0x92	; 146
 380:	74 65       	ori	r23, 0x54	; 84
 382:	00 5f       	subi	r16, 0xF0	; 240
 384:	75 62       	ori	r23, 0x25	; 37
 386:	72 72       	andi	r23, 0x22	; 34
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 388:	68 00       	.word	0x0068	; ????
 38a:	3c 61       	ori	r19, 0x1C	; 28
 38c:	72 74       	andi	r23, 0x42	; 66
 38e:	69 66       	ori	r22, 0x69	; 105
 390:	69 63       	ori	r22, 0x39	; 57
 392:	69 61       	ori	r22, 0x19	; 25
 394:	6c 3e       	cpi	r22, 0xEC	; 236
 396:	00 5f       	subi	r16, 0xF0	; 240
 398:	6c 6f       	ori	r22, 0xFC	; 252
 39a:	6f 70       	andi	r22, 0x0F	; 15
 39c:	43 6f       	ori	r20, 0xF3	; 243
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 39e:	75 6e       	ori	r23, 0xE5	; 229
 3a0:	74 65       	ori	r23, 0x54	; 84
 3a2:	72 00       	.word	0x0072	; ????
 3a4:	62 79       	andi	r22, 0x92	; 146
 3a6:	74 65       	ori	r23, 0x54	; 84
 3a8:	00 70       	andi	r16, 0x00	; 0
 3aa:	72 69       	ori	r23, 0x92	; 146
 3ac:	6e 74       	andi	r22, 0x4E	; 78
	unsigned char f = timer0_fract;
 3ae:	4e 75       	andi	r20, 0x5E	; 94
 3b0:	6d 62       	ori	r22, 0x2D	; 45

	m += MILLIS_INC;
	f += FRACT_INC;
 3b2:	65 72       	andi	r22, 0x25	; 37
 3b4:	00 72       	andi	r16, 0x20	; 32
	if (f >= FRACT_MAX) {
 3b6:	78 5f       	subi	r23, 0xF8	; 248
 3b8:	62 75       	andi	r22, 0x52	; 82
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 3ba:	66 66       	ori	r22, 0x66	; 102
 3bc:	65 72       	andi	r22, 0x25	; 37
 3be:	5f 69       	ori	r21, 0x9F	; 159
 3c0:	6e 64       	ori	r22, 0x4E	; 78
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 3c2:	65 78       	andi	r22, 0x85	; 133
 3c4:	5f 74       	andi	r21, 0x4F	; 79
		m += 1;
 3c6:	00 62       	ori	r16, 0x20	; 32
 3c8:	61 75       	andi	r22, 0x51	; 81
 3ca:	64 00       	.word	0x0064	; ????
	}

	timer0_fract = f;
 3cc:	75 6e       	ori	r23, 0xE5	; 229
 3ce:	73 69       	ori	r23, 0x93	; 147
	timer0_millis = m;
 3d0:	67 6e       	ori	r22, 0xE7	; 231
 3d2:	65 64       	ori	r22, 0x45	; 69
 3d4:	20 63       	ori	r18, 0x30	; 48
 3d6:	68 61       	ori	r22, 0x18	; 24
 3d8:	72 00       	.word	0x0072	; ????
 3da:	5f 5a       	subi	r21, 0xAF	; 175
 3dc:	4e 31       	cpi	r20, 0x1E	; 30
 3de:	34 48       	sbci	r19, 0x84	; 132
	timer0_overflow_count++;
 3e0:	61 72       	andi	r22, 0x21	; 33
 3e2:	64 77       	andi	r22, 0x74	; 116
 3e4:	61 72       	andi	r22, 0x21	; 33
 3e6:	65 53       	subi	r22, 0x35	; 53
 3e8:	65 72       	andi	r22, 0x25	; 37
 3ea:	69 61       	ori	r22, 0x19	; 25
 3ec:	6c 31       	cpi	r22, 0x1C	; 28
 3ee:	36 5f       	subi	r19, 0xF6	; 246
 3f0:	72 78       	andi	r23, 0x82	; 130
 3f2:	5f 63       	ori	r21, 0x3F	; 63
 3f4:	6f 6d       	ori	r22, 0xDF	; 223
 3f6:	70 6c       	ori	r23, 0xC0	; 192
 3f8:	65 74       	andi	r22, 0x45	; 69
 3fa:	65 5f       	subi	r22, 0xF5	; 245
 3fc:	69 72       	andi	r22, 0x29	; 41
 3fe:	71 45       	sbci	r23, 0x51	; 81
 400:	76 2e       	mov	r7, r22
 402:	70 61       	ori	r23, 0x10	; 16
 404:	72 74       	andi	r23, 0x42	; 66
}
 406:	2e 30       	cpi	r18, 0x0E	; 14
 408:	00 5f       	subi	r16, 0xF0	; 240
 40a:	5f 69       	ori	r21, 0x9F	; 159
 40c:	6e 69       	ori	r22, 0x9E	; 158
 40e:	74 69       	ori	r23, 0x94	; 148
 410:	61 6c       	ori	r22, 0xC1	; 193
 412:	69 7a       	andi	r22, 0xA9	; 169
 414:	65 5f       	subi	r22, 0xF5	; 245
 416:	70 00       	.word	0x0070	; ????
 418:	47 4e       	sbci	r20, 0xE7	; 231
 41a:	55 20       	and	r5, r5
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 41c:	47 49       	sbci	r20, 0x97	; 151
 41e:	4d 50       	subi	r20, 0x0D	; 13
 420:	4c 45       	sbci	r20, 0x5C	; 92
 422:	20 35       	cpi	r18, 0x50	; 80
 424:	2e 34       	cpi	r18, 0x4E	; 78
 426:	2e 30       	cpi	r18, 0x0E	; 14
 428:	20 2d       	mov	r18, r0
 42a:	6d 6e       	ori	r22, 0xED	; 237
 42c:	2d 66       	ori	r18, 0x6D	; 109
 42e:	6c 61       	ori	r22, 0x1C	; 28
 430:	73 68       	ori	r23, 0x83	; 131
 432:	3d 31       	cpi	r19, 0x1D	; 29
 434:	20 2d       	mov	r18, r0
 436:	6d 6d       	ori	r22, 0xDD	; 221
 438:	63 75       	andi	r22, 0x53	; 83
 43a:	3d 61       	ori	r19, 0x1D	; 29
 43c:	76 72       	andi	r23, 0x26	; 38
  Serial._tx_udr_empty_irq();
 43e:	35 20       	and	r3, r5
 440:	2d 6d       	ori	r18, 0xDD	; 221
 442:	6e 2d       	mov	r22, r14
 444:	66 6c       	ori	r22, 0xC6	; 198
}
 446:	61 73       	andi	r22, 0x31	; 49
 448:	68 3d       	cpi	r22, 0xD8	; 216
 44a:	31 20       	and	r3, r1
 44c:	2d 6d       	ori	r18, 0xDD	; 221
 44e:	6e 6f       	ori	r22, 0xFE	; 254
 450:	2d 73       	andi	r18, 0x3D	; 61
 452:	6b 69       	ori	r22, 0x9B	; 155
 454:	70 2d       	mov	r23, r0
 456:	62 75       	andi	r22, 0x52	; 82
 458:	67 20       	and	r6, r7
 45a:	2d 6d       	ori	r18, 0xDD	; 221
 45c:	6d 63       	ori	r22, 0x3D	; 61
 45e:	75 3d       	cpi	r23, 0xD5	; 213
 460:	61 76       	andi	r22, 0x61	; 97
 462:	72 35       	cpi	r23, 0x52	; 82
 464:	20 2d       	mov	r18, r0
 466:	67 20       	and	r6, r7
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 468:	2d 4f       	sbci	r18, 0xFD	; 253
 46a:	73 20       	and	r7, r3
 46c:	2d 4f       	sbci	r18, 0xFD	; 253
 46e:	73 20       	and	r7, r3
 470:	2d 66       	ori	r18, 0x6D	; 109
 472:	6d 61       	ori	r22, 0x1D	; 29
 474:	74 68       	ori	r23, 0x84	; 132
 476:	2d 65       	ori	r18, 0x5D	; 93
 478:	72 72       	andi	r23, 0x22	; 34
 47a:	6e 6f       	ori	r22, 0xFE	; 254

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 47c:	20 2d       	mov	r18, r0
 47e:	66 73       	andi	r22, 0x36	; 54
 480:	69 67       	ori	r22, 0x79	; 121
 482:	6e 65       	ori	r22, 0x5E	; 94
 484:	64 2d       	mov	r22, r4
 486:	7a 65       	ori	r23, 0x5A	; 90
 488:	72 6f       	ori	r23, 0xF2	; 242
 48a:	73 20       	and	r7, r3
 48c:	2d 66       	ori	r18, 0x6D	; 109
 48e:	74 72       	andi	r23, 0x24	; 36
 490:	61 70       	andi	r22, 0x01	; 1
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 492:	70 69       	ori	r23, 0x90	; 144
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 494:	6e 67       	ori	r22, 0x7E	; 126
 496:	2d 6d       	ori	r18, 0xDD	; 221
 498:	61 74       	andi	r22, 0x41	; 65
 49a:	68 20       	and	r6, r8

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 49c:	2d 66       	ori	r18, 0x6D	; 109
 49e:	6e 6f       	ori	r22, 0xFE	; 254
 4a0:	2d 74       	andi	r18, 0x4D	; 77
 4a2:	72 61       	ori	r23, 0x12	; 18
      _rx_buffer[_rx_buffer_head] = c;
 4a4:	70 76       	andi	r23, 0x60	; 96
 4a6:	20 2d       	mov	r18, r0
 4a8:	66 6e       	ori	r22, 0xE6	; 230
 4aa:	6f 2d       	mov	r22, r15
 4ac:	6f 70       	andi	r22, 0x0F	; 15
 4ae:	65 6e       	ori	r22, 0xE5	; 229
      _rx_buffer_head = i;
 4b0:	6d 70       	andi	r22, 0x0D	; 13
 4b2:	20 2d       	mov	r18, r0
 4b4:	66 6e       	ori	r22, 0xE6	; 230
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 4b6:	6f 2d       	mov	r22, r15
    Serial._rx_complete_irq();
  }
 4b8:	6f 70       	andi	r22, 0x0F	; 15
 4ba:	65 6e       	ori	r22, 0xE5	; 229
 4bc:	61 63       	ori	r22, 0x31	; 49
 4be:	63 20       	and	r6, r3
 4c0:	2d 66       	ori	r18, 0x6D	; 109
 4c2:	6e 6f       	ori	r22, 0xFE	; 254
 4c4:	2d 65       	ori	r18, 0x5D	; 93
 4c6:	78 63       	ori	r23, 0x38	; 56
 4c8:	65 70       	andi	r22, 0x05	; 5
 4ca:	74 69       	ori	r23, 0x94	; 148

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 4cc:	6f 6e       	ori	r22, 0xEF	; 239
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 4ce:	73 20       	and	r7, r3
 4d0:	2d 66       	ori	r18, 0x6D	; 109
 4d2:	75 73       	andi	r23, 0x35	; 53
	sbi(TCCR0A, WGM00);
 4d4:	65 2d       	mov	r22, r5
 4d6:	6c 69       	ori	r22, 0x9C	; 156
 4d8:	6e 6b       	ori	r22, 0xBE	; 190
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 4da:	65 72       	andi	r22, 0x25	; 37
 4dc:	2d 70       	andi	r18, 0x0D	; 13
 4de:	6c 75       	andi	r22, 0x5C	; 92
	sbi(TCCR0B, CS00);
 4e0:	67 69       	ori	r22, 0x97	; 151
 4e2:	6e 20       	and	r6, r14
 4e4:	2d 66       	ori	r18, 0x6D	; 109

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 4e6:	6c 74       	andi	r22, 0x4C	; 76
 4e8:	72 61       	ori	r23, 0x12	; 18
 4ea:	6e 73       	andi	r22, 0x3E	; 62
 4ec:	00 70       	andi	r16, 0x00	; 0
 4ee:	72 69       	ori	r23, 0x92	; 146
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 4f0:	6e 74       	andi	r22, 0x4E	; 78
 4f2:	00 5f       	subi	r16, 0xF0	; 240

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4f4:	5f 69       	ori	r21, 0x9F	; 159
 4f6:	52 65       	ori	r21, 0x52	; 82
 4f8:	73 74       	andi	r23, 0x43	; 67
 4fa:	6f 72       	andi	r22, 0x2F	; 47
 4fc:	65 00       	.word	0x0065	; ????
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 4fe:	75 69       	ori	r23, 0x95	; 149
 500:	6e 74       	andi	r22, 0x4E	; 78
 502:	31 36       	cpi	r19, 0x61	; 97
 504:	5f 74       	andi	r21, 0x4F	; 79
 506:	00 5f       	subi	r16, 0xF0	; 240
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 508:	76 70       	andi	r23, 0x06	; 6
 50a:	74 72       	andi	r23, 0x24	; 36
 50c:	2e 50       	subi	r18, 0x0E	; 14
 50e:	72 69       	ori	r23, 0x92	; 146
 510:	6e 74       	andi	r22, 0x4E	; 78

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 512:	00 6c       	ori	r16, 0xC0	; 192
 514:	6f 6e       	ori	r22, 0xEF	; 239
 516:	67 20       	and	r6, r7
 518:	75 6e       	ori	r23, 0xE5	; 229
 51a:	73 69       	ori	r23, 0x93	; 147

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 51c:	67 6e       	ori	r22, 0xE7	; 231
 51e:	65 64       	ori	r22, 0x45	; 69
 520:	20 69       	ori	r18, 0x90	; 144
 522:	6e 74       	andi	r22, 0x4E	; 78
 524:	00 5f       	subi	r16, 0xF0	; 240
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 526:	72 78       	andi	r23, 0x82	; 130
 528:	5f 63       	ori	r21, 0x3F	; 63
 52a:	6f 6d       	ori	r22, 0xDF	; 223
 52c:	70 6c       	ori	r23, 0xC0	; 192
 52e:	65 74       	andi	r22, 0x45	; 69
		sbi(ADCSRA, ADPS1);
 530:	65 5f       	subi	r22, 0xF5	; 245
 532:	69 72       	andi	r22, 0x29	; 41
 534:	71 00       	.word	0x0071	; ????
 536:	74 69       	ori	r23, 0x94	; 148
 538:	6d 65       	ori	r22, 0x5D	; 93
		sbi(ADCSRA, ADPS0);
 53a:	72 30       	cpi	r23, 0x02	; 2
 53c:	5f 6f       	ori	r21, 0xFF	; 255
 53e:	76 65       	ori	r23, 0x56	; 86
 540:	72 66       	ori	r23, 0x62	; 98
 542:	6c 6f       	ori	r22, 0xFC	; 252
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 544:	77 5f       	subi	r23, 0xF7	; 247
 546:	63 6f       	ori	r22, 0xF3	; 243
 548:	75 6e       	ori	r23, 0xE5	; 229
 54a:	74 00       	.word	0x0074	; ????
 54c:	53 74       	andi	r21, 0x43	; 67
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 54e:	72 65       	ori	r23, 0x52	; 82
 550:	61 6d       	ori	r22, 0xD1	; 209

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 552:	00 5f       	subi	r16, 0xF0	; 240
 554:	74 78       	andi	r23, 0x84	; 132
 556:	5f 62       	ori	r21, 0x2F	; 47
 558:	75 66       	ori	r23, 0x65	; 101
 55a:	66 65       	ori	r22, 0x56	; 86
 55c:	72 00       	.word	0x0072	; ????
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
 55e:	5f 74       	andi	r21, 0x4F	; 79
 560:	78 5f       	subi	r23, 0xF8	; 248
 562:	75 64       	ori	r23, 0x45	; 69
 564:	72 5f       	subi	r23, 0xF2	; 242
 566:	65 6d       	ori	r22, 0xD5	; 213
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 568:	70 74       	andi	r23, 0x40	; 64
 56a:	79 5f       	subi	r23, 0xF9	; 249
 56c:	69 72       	andi	r22, 0x29	; 41
 56e:	71 00       	.word	0x0071	; ????
 570:	70 72       	andi	r23, 0x20	; 32
  *_ubrrl = baud_setting;
 572:	69 6e       	ori	r22, 0xE9	; 233
 574:	74 6c       	ori	r23, 0xC4	; 196
 576:	6e 00       	.word	0x006e	; ????
 578:	5f 5f       	subi	r21, 0xFF	; 255
 57a:	73 74       	andi	r23, 0x43	; 67
 57c:	61 74       	andi	r22, 0x41	; 65

  _written = false;
 57e:	69 63       	ori	r22, 0x39	; 57
 580:	5f 69       	ori	r21, 0x9F	; 159

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 582:	6e 69       	ori	r22, 0x9E	; 158
 584:	74 69       	ori	r23, 0x94	; 148
 586:	61 6c       	ori	r22, 0xC1	; 193
 588:	69 7a       	andi	r22, 0xA9	; 169
 58a:	61 74       	andi	r22, 0x41	; 65
 58c:	69 6f       	ori	r22, 0xF9	; 249
  
  sbi(*_ucsrb, RXEN0);
 58e:	6e 5f       	subi	r22, 0xFE	; 254
 590:	61 6e       	ori	r22, 0xE1	; 225
 592:	64 5f       	subi	r22, 0xF4	; 244
 594:	64 65       	ori	r22, 0x54	; 84
 596:	73 74       	andi	r23, 0x43	; 67
 598:	72 75       	andi	r23, 0x52	; 82
 59a:	63 74       	andi	r22, 0x43	; 67
  sbi(*_ucsrb, TXEN0);
 59c:	69 6f       	ori	r22, 0xF9	; 249
 59e:	6e 5f       	subi	r22, 0xFE	; 254
 5a0:	30 00       	.word	0x0030	; ????
 5a2:	5f 5f       	subi	r21, 0xFF	; 255
 5a4:	70 72       	andi	r23, 0x20	; 32
 5a6:	69 6f       	ori	r22, 0xF9	; 249
 5a8:	72 69       	ori	r23, 0x92	; 146
  sbi(*_ucsrb, RXCIE0);
 5aa:	74 79       	andi	r23, 0x94	; 148
 5ac:	00 74       	andi	r16, 0x40	; 64
 5ae:	68 69       	ori	r22, 0x98	; 152
 5b0:	73 00       	.word	0x0073	; ????
 5b2:	5f 47       	sbci	r21, 0x7F	; 127
 5b4:	4c 4f       	sbci	r20, 0xFC	; 252
 5b6:	42 41       	sbci	r20, 0x12	; 18
  cbi(*_ucsrb, UDRIE0);
 5b8:	4c 5f       	subi	r20, 0xFC	; 252
 5ba:	5f 73       	andi	r21, 0x3F	; 63
 5bc:	75 62       	ori	r23, 0x25	; 37
 5be:	5f 49       	sbci	r21, 0x9F	; 159
 5c0:	5f 5f       	subi	r21, 0xFF	; 255
 5c2:	5f 76       	andi	r21, 0x6F	; 111
 5c4:	65 63       	ori	r22, 0x35	; 53
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 5c6:	74 6f       	ori	r23, 0xF4	; 244

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 5c8:	72 5f       	subi	r23, 0xF2	; 242
	m = timer0_millis;
 5ca:	31 38       	cpi	r19, 0x81	; 129
 5cc:	00 5f       	subi	r16, 0xF0	; 240
 5ce:	5f 54       	subi	r21, 0x4F	; 79
 5d0:	6f 44       	sbci	r22, 0x4F	; 79
 5d2:	6f 00       	.word	0x006f	; ????
 5d4:	48 61       	ori	r20, 0x18	; 24
 5d6:	72 64       	ori	r23, 0x42	; 66
 5d8:	77 61       	ori	r23, 0x17	; 23
	SREG = oldSREG;
 5da:	72 65       	ori	r23, 0x52	; 82

void setup()
{
  Serial.begin(57600);         // 9600 bps
    
  _startTime_ms = millis();
 5dc:	53 65       	ori	r21, 0x53	; 83
 5de:	72 69       	ori	r23, 0x92	; 146
 5e0:	61 6c       	ori	r22, 0xC1	; 193
 5e2:	00 62       	ori	r16, 0x20	; 32
 5e4:	61 75       	andi	r22, 0x51	; 81
 5e6:	64 5f       	subi	r22, 0xF4	; 244
 5e8:	73 65       	ori	r23, 0x53	; 83
 5ea:	74 74       	andi	r23, 0x44	; 68
}

void loop() 
{
  if (0 == _loopCounter--) {
 5ec:	69 6e       	ori	r22, 0xE9	; 233
 5ee:	67 00       	.word	0x0067	; ????
 5f0:	5f 74       	andi	r21, 0x4F	; 79
 5f2:	78 5f       	subi	r23, 0xF8	; 248
 5f4:	62 75       	andi	r22, 0x52	; 82
 5f6:	66 66       	ori	r22, 0x66	; 102
 5f8:	65 72       	andi	r22, 0x25	; 37
 5fa:	5f 74       	andi	r21, 0x4F	; 79
 5fc:	61 69       	ori	r22, 0x91	; 145
 5fe:	6c 00       	.word	0x006c	; ????
 600:	5f 5a       	subi	r21, 0xAF	; 175
 602:	4e 31       	cpi	r20, 0x1E	; 30
 604:	34 48       	sbci	r19, 0x84	; 132
 606:	61 72       	andi	r22, 0x21	; 33
 608:	64 77       	andi	r22, 0x74	; 116
 60a:	61 72       	andi	r22, 0x21	; 33
 60c:	65 53       	subi	r22, 0x35	; 53
 60e:	65 72       	andi	r22, 0x25	; 37
 610:	69 61       	ori	r22, 0x19	; 25
 612:	6c 35       	cpi	r22, 0x5C	; 92
 614:	77 72       	andi	r23, 0x27	; 39
 616:	69 74       	andi	r22, 0x49	; 73
 618:	65 45       	sbci	r22, 0x55	; 85
 61a:	68 2e       	mov	r6, r24
 61c:	70 61       	ori	r23, 0x10	; 16
 61e:	72 74       	andi	r23, 0x42	; 66
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 620:	2e 33       	cpi	r18, 0x3E	; 62

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 622:	00 5f       	subi	r16, 0xF0	; 240
	m = timer0_millis;
 624:	5f 76       	andi	r21, 0x6F	; 111
 626:	74 62       	ori	r23, 0x24	; 36
 628:	6c 5f       	subi	r22, 0xFC	; 252
 62a:	70 74       	andi	r23, 0x40	; 64
 62c:	72 5f       	subi	r23, 0xF2	; 242
 62e:	74 79       	andi	r23, 0x94	; 148
 630:	70 65       	ori	r23, 0x50	; 80
 632:	00 5f       	subi	r16, 0xF0	; 240
	SREG = oldSREG;
 634:	5f 76       	andi	r21, 0x6F	; 111
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 636:	65 63       	ori	r22, 0x35	; 53
 638:	74 6f       	ori	r23, 0xF4	; 244
 63a:	72 5f       	subi	r23, 0xF2	; 242
 63c:	31 36       	cpi	r19, 0x61	; 97
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 63e:	00 5f       	subi	r16, 0xF0	; 240
 640:	75 62       	ori	r23, 0x25	; 37
 642:	72 72       	andi	r23, 0x22	; 34
 644:	6c 00       	.word	0x006c	; ????
 646:	5f 74       	andi	r21, 0x4F	; 79
 648:	69 6d       	ori	r22, 0xD9	; 217
 64a:	65 6f       	ori	r22, 0xF5	; 245
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 64c:	75 74       	andi	r23, 0x45	; 69
 64e:	00 73       	andi	r16, 0x30	; 48
 650:	69 7a       	andi	r22, 0xA9	; 169
 652:	65 00       	.word	0x0065	; ????
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 654:	73 72       	andi	r23, 0x23	; 35
 656:	65 67       	ori	r22, 0x75	; 117
 658:	5f 73       	andi	r21, 0x3F	; 63
 65a:	61 76       	andi	r22, 0x61	; 97
 65c:	65 00       	.word	0x0065	; ????
 65e:	5f 5f       	subi	r21, 0xFF	; 255
 660:	69 43       	sbci	r22, 0x39	; 57
 662:	6c 69       	ori	r22, 0x9C	; 156
 664:	52 65       	ori	r21, 0x52	; 82
 666:	74 56       	subi	r23, 0x64	; 100
 668:	61 6c       	ori	r22, 0xC1	; 193
 66a:	00 5f       	subi	r16, 0xF0	; 240
 66c:	5a 4e       	sbci	r21, 0xEA	; 234
 66e:	31 34       	cpi	r19, 0x41	; 65
 670:	48 61       	ori	r20, 0x18	; 24
 672:	72 64       	ori	r23, 0x42	; 66
 674:	77 61       	ori	r23, 0x17	; 23
 676:	72 65       	ori	r23, 0x52	; 82
 678:	53 65       	ori	r21, 0x53	; 83
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 67a:	72 69       	ori	r23, 0x92	; 146
 67c:	61 6c       	ori	r22, 0xC1	; 193
 67e:	31 37       	cpi	r19, 0x71	; 113
 680:	5f 74       	andi	r21, 0x4F	; 79
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
 682:	78 5f       	subi	r23, 0xF8	; 248
 684:	75 64       	ori	r23, 0x45	; 69
 686:	72 5f       	subi	r23, 0xF2	; 242
 688:	65 6d       	ori	r22, 0xD5	; 213
 68a:	70 74       	andi	r23, 0x40	; 64
 68c:	79 5f       	subi	r23, 0xF9	; 249
 68e:	69 72       	andi	r22, 0x29	; 41
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 690:	71 45       	sbci	r23, 0x51	; 81
 692:	76 2e       	mov	r7, r22
 694:	70 61       	ori	r23, 0x10	; 16
 696:	72 74       	andi	r23, 0x42	; 66
 698:	2e 31       	cpi	r18, 0x1E	; 30
 69a:	00 5f       	subi	r16, 0xF0	; 240
 69c:	75 63       	ori	r23, 0x35	; 53
 69e:	73 72       	andi	r23, 0x23	; 35
 6a0:	61 00       	.word	0x0061	; ????
 6a2:	5f 75       	andi	r21, 0x5F	; 95
 6a4:	63 73       	andi	r22, 0x33	; 51
 6a6:	72 62       	ori	r23, 0x22	; 34
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 6a8:	00 5f       	subi	r16, 0xF0	; 240
 6aa:	75 63       	ori	r23, 0x35	; 53
 6ac:	73 72       	andi	r23, 0x23	; 35
 6ae:	63 00       	.word	0x0063	; ????
 6b0:	74 78       	andi	r23, 0x84	; 132
 6b2:	5f 62       	ori	r21, 0x2F	; 47
 6b4:	75 66       	ori	r23, 0x65	; 101
 6b6:	66 65       	ori	r22, 0x56	; 86
 6b8:	72 5f       	subi	r23, 0xF2	; 242
 6ba:	69 6e       	ori	r22, 0xE9	; 233
 6bc:	64 65       	ori	r22, 0x54	; 84
 6be:	78 5f       	subi	r23, 0xF8	; 248
 6c0:	74 00       	.word	0x0074	; ????
 6c2:	6c 6f       	ori	r22, 0xFC	; 252
 6c4:	6f 70       	andi	r22, 0x0F	; 15
 6c6:	00 5f       	subi	r16, 0xF0	; 240
 6c8:	73 74       	andi	r23, 0x43	; 67
 6ca:	61 72       	andi	r22, 0x21	; 33
 6cc:	74 4d       	sbci	r23, 0xD4	; 212
 6ce:	69 6c       	ori	r22, 0xC9	; 201
 6d0:	6c 69       	ori	r22, 0x9C	; 156
 6d2:	73 00       	.word	0x0073	; ????
 6d4:	5f 75       	andi	r21, 0x5F	; 95
 6d6:	64 72       	andi	r22, 0x24	; 36
 6d8:	00 5f       	subi	r16, 0xF0	; 240
 6da:	72 78       	andi	r23, 0x82	; 130
 6dc:	5f 62       	ori	r21, 0x2F	; 47
 6de:	75 66       	ori	r23, 0x65	; 101
 6e0:	66 65       	ori	r22, 0x56	; 86
 6e2:	72 00       	.word	0x0072	; ????
 6e4:	65 6e       	ori	r22, 0xE5	; 229
 6e6:	64 54       	subi	r22, 0x44	; 68
 6e8:	69 6d       	ori	r22, 0xD9	; 217
 6ea:	65 5f       	subi	r22, 0xF5	; 245
 6ec:	6d 73       	andi	r22, 0x3D	; 61
 6ee:	00 62       	ori	r16, 0x20	; 32
 6f0:	61 73       	andi	r22, 0x31	; 49
 6f2:	65 00       	.word	0x0065	; ????
 6f4:	5f 73       	andi	r21, 0x3F	; 63
 6f6:	74 61       	ori	r23, 0x14	; 20
 6f8:	72 74       	andi	r23, 0x42	; 66
 6fa:	54 69       	ori	r21, 0x94	; 148
 6fc:	6d 65       	ori	r22, 0x5D	; 93
 6fe:	5f 6d       	ori	r21, 0xDF	; 223
 700:	73 00       	.word	0x0073	; ????
 702:	5f 77       	andi	r21, 0x7F	; 127
 704:	72 69       	ori	r23, 0x92	; 146
 706:	74 74       	andi	r23, 0x44	; 68
 708:	65 6e       	ori	r22, 0xE5	; 229
 70a:	00 69       	ori	r16, 0x90	; 144
 70c:	6e 69       	ori	r22, 0x9E	; 158
 70e:	74 00       	.word	0x0074	; ????

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
   0:	be 00       	.word	0x00be	; ????
   2:	00 00       	nop
   4:	c0 00       	.word	0x00c0	; ????
   6:	00 00       	nop
   8:	03 00       	.word	0x0003	; ????
   a:	92 20       	and	r9, r2
   c:	02 c0       	rjmp	.+4      	; 0x12 <__FUSE_REGION_LENGTH__+0xf>
   e:	00 00       	nop
  10:	00 c2       	rjmp	.+1024   	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
  12:	00 00       	nop
  14:	00 03       	mulsu	r16, r16
  16:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x146>
  1a:	c2 00       	.word	0x00c2	; ????
  1c:	00 00       	nop
  1e:	c4 00       	.word	0x00c4	; ????
  20:	00 00       	nop
  22:	03 00       	.word	0x0003	; ????
  24:	92 20       	and	r9, r2
  26:	04 c4       	rjmp	.+2056   	; 0x830 <__data_load_end+0xb8>
  28:	00 00       	nop
  2a:	00 c6       	rjmp	.+3072   	; 0xc2c <__stack+0x32d>
  2c:	00 00       	nop
  2e:	00 03       	mulsu	r16, r16
  30:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x346>
  34:	c6 00       	.word	0x00c6	; ????
  36:	00 00       	nop
  38:	c8 00       	.word	0x00c8	; ????
  3a:	00 00       	nop
  3c:	03 00       	.word	0x0003	; ????
  3e:	92 20       	and	r9, r2
  40:	06 c8       	rjmp	.-4084   	; 0xfffff04e <__eeprom_end+0xff7ef04e>
  42:	00 00       	nop
  44:	00 ca       	rjmp	.-3072   	; 0xfffff446 <__eeprom_end+0xff7ef446>
  46:	00 00       	nop
  48:	00 03       	mulsu	r16, r16
  4a:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x546>
  4e:	ca 00       	.word	0x00ca	; ????
  50:	00 00       	nop
  52:	cc 00       	.word	0x00cc	; ????
  54:	00 00       	nop
  56:	03 00       	.word	0x0003	; ????
  58:	92 20       	and	r9, r2
  5a:	08 cc       	rjmp	.-2032   	; 0xfffff86c <__eeprom_end+0xff7ef86c>
  5c:	00 00       	nop
  5e:	00 ce       	rjmp	.-1024   	; 0xfffffc60 <__eeprom_end+0xff7efc60>
  60:	00 00       	nop
  62:	00 03       	mulsu	r16, r16
  64:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x746>
  68:	ce 00       	.word	0x00ce	; ????
  6a:	00 00       	nop
  6c:	12 01       	movw	r2, r4
  6e:	00 00       	nop
  70:	03 00       	.word	0x0003	; ????
  72:	92 20       	and	r9, r2
  74:	0a 00       	.word	0x000a	; ????
  76:	00 00       	nop
  78:	00 00       	nop
  7a:	00 00       	nop
  7c:	00 be       	out	0x30, r0	; 48
  7e:	00 00       	nop
  80:	00 d8       	rcall	.-4096   	; 0xfffff082 <__eeprom_end+0xff7ef082>
  82:	00 00       	nop
  84:	00 06       	cpc	r0, r16
  86:	00 68       	ori	r16, 0x80	; 128
  88:	93 01       	movw	r18, r6
  8a:	69 93       	st	Y+, r22
  8c:	01 d8       	rcall	.-4094   	; 0xfffff090 <__eeprom_end+0xff7ef090>
  8e:	00 00       	nop
  90:	00 10       	cpse	r0, r0
  92:	01 00       	.word	0x0001	; ????
  94:	00 06       	cpc	r0, r16
  96:	00 5c       	subi	r16, 0xC0	; 192
  98:	93 01       	movw	r18, r6
  9a:	5d 93       	st	X+, r21
  9c:	01 10       	cpse	r0, r1
  9e:	01 00       	.word	0x0001	; ????
  a0:	00 12       	cpse	r0, r16
  a2:	01 00       	.word	0x0001	; ????
  a4:	00 04       	cpc	r0, r0
  a6:	00 f3       	brcs	.-64     	; 0x68 <__ctors_start>
  a8:	01 68       	ori	r16, 0x81	; 129
  aa:	9f 00       	.word	0x009f	; ????
  ac:	00 00       	nop
  ae:	00 00       	nop
  b0:	00 00       	nop
  b2:	00 be       	out	0x30, r0	; 48
  b4:	00 00       	nop
  b6:	00 d8       	rcall	.-4096   	; 0xfffff0b8 <__eeprom_end+0xff7ef0b8>
  b8:	00 00       	nop
  ba:	00 06       	cpc	r0, r16
  bc:	00 66       	ori	r16, 0x60	; 96

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  be:	93 01       	movw	r18, r6
  c0:	67 93       	lat	Z, r22
  c2:	01 d8       	rcall	.-4094   	; 0xfffff0c6 <__eeprom_end+0xff7ef0c6>
  c4:	00 00       	nop
  c6:	00 de       	rcall	.-1024   	; 0xfffffcc8 <__eeprom_end+0xff7efcc8>
  c8:	00 00       	nop
  ca:	00 07       	cpc	r16, r16
  cc:	00 f3       	brcs	.-64     	; 0x8e <__do_clear_bss+0x2>
  ce:	01 66       	ori	r16, 0x61	; 97
  d0:	8c 00       	.word	0x008c	; ????
  d2:	22 9f       	mul	r18, r18
  size_t n = 0;
  d4:	de 00       	.word	0x00de	; ????
  d6:	00 00       	nop
  while (size--) {
  d8:	fa 00       	.word	0x00fa	; ????
  da:	00 00       	nop
  dc:	09 00       	.word	0x0009	; ????
    if (write(*buffer++)) n++;
  de:	f3 01       	movw	r30, r6
  e0:	66 8c       	ldd	r6, Z+30	; 0x1e
  e2:	00 22       	and	r0, r16
  e4:	23 01       	movw	r4, r6
  e6:	9f fa       	.word	0xfa9f	; ????
  e8:	00 00       	nop
  ea:	00 fc       	sbrc	r0, 0
  ec:	00 00       	nop
  ee:	00 07       	cpc	r16, r16
  f0:	00 8c       	ldd	r0, Z+24	; 0x18
  f2:	00 f3       	brcs	.-64     	; 0xb4 <__do_global_ctors+0x18>
  f4:	01 66       	ori	r16, 0x61	; 97
  f6:	22 9f       	mul	r18, r18
  f8:	fc 00       	.word	0x00fc	; ????
  fa:	00 00       	nop
  fc:	fe 00       	.word	0x00fe	; ????
    else break;
  }
  return n;
}
  fe:	00 00       	nop
 100:	09 00       	.word	0x0009	; ????
 102:	f3 01       	movw	r30, r6
 104:	66 8c       	ldd	r6, Z+30	; 0x1e
 106:	00 22       	and	r0, r16
 108:	23 01       	movw	r4, r6
 10a:	9f 00       	.word	0x009f	; ????
 10c:	00 00       	nop
 10e:	00 00       	nop
 110:	00 00       	nop
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 112:	00 be       	out	0x30, r0	; 48
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 114:	00 00       	nop
 116:	00 d8       	rcall	.-4096   	; 0xfffff118 <__eeprom_end+0xff7ef118>
 118:	00 00       	nop
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 11a:	00 06       	cpc	r0, r16
 11c:	00 64       	ori	r16, 0x40	; 64
    tail = _tx_buffer_tail;
 11e:	93 01       	movw	r18, r6
 120:	65 93       	las	Z, r22
 122:	01 d8       	rcall	.-4094   	; 0xfffff126 <__eeprom_end+0xff7ef126>
 124:	00 00       	nop
 126:	00 fa       	bst	r0, 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 128:	00 00       	nop
 12a:	00 07       	cpc	r16, r16
 12c:	00 8c       	ldd	r0, Z+24	; 0x18
 12e:	00 20       	and	r0, r0
 130:	7e 00       	.word	0x007e	; ????
 132:	22 9f       	mul	r18, r18
  return tail - head - 1;
 134:	fa 00       	.word	0x00fa	; ????
}
 136:	00 00       	nop
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 138:	fc 00       	.word	0x00fc	; ????
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 13a:	00 00       	nop
 13c:	06 00       	.word	0x0006	; ????
 13e:	7e 00       	.word	0x007e	; ????
 140:	8c 00       	.word	0x008c	; ????
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 142:	1c 9f       	mul	r17, r28
 144:	fc 00       	.word	0x00fc	; ????
 146:	00 00       	nop
 148:	fe 00       	.word	0x00fe	; ????
 14a:	00 00       	nop
 14c:	07 00       	.word	0x0007	; ????
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 14e:	8c 00       	.word	0x008c	; ????
 150:	20 7e       	andi	r18, 0xE0	; 224
 152:	00 22       	and	r0, r16
 154:	9f fe       	.word	0xfe9f	; ????
    return c;
 156:	00 00       	nop
 158:	00 04       	cpc	r0, r0

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 15a:	01 00       	.word	0x0001	; ????
 15c:	00 08       	sbc	r0, r0
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 15e:	00 8c       	ldd	r0, Z+24	; 0x18
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 160:	00 20       	and	r0, r0
  if (_rx_buffer_head == _rx_buffer_tail) {
 162:	f3 01       	movw	r30, r6
 164:	64 22       	and	r6, r20
 166:	9f 00       	.word	0x009f	; ????
 168:	00 00       	nop
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 16a:	00 00       	nop
 16c:	00 00       	nop
 16e:	00 d2       	rcall	.+1024   	; 0x570 <main+0xa4>
 170:	00 00       	nop
 172:	00 d8       	rcall	.-4096   	; 0xfffff174 <__eeprom_end+0xff7ef174>
 174:	00 00       	nop
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 176:	00 02       	muls	r16, r16
 178:	00 30       	cpi	r16, 0x00	; 0
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 17a:	9f d8       	rcall	.-3778   	; 0xfffff2ba <__eeprom_end+0xff7ef2ba>
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 17c:	00 00       	nop
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 17e:	00 04       	cpc	r0, r0
 180:	01 00       	.word	0x0001	; ????
 182:	00 06       	cpc	r0, r16
 184:	00 6c       	ori	r16, 0xC0	; 192
 186:	93 01       	movw	r18, r6
 188:	6d 93       	st	X+, r22
 18a:	01 00       	.word	0x0001	; ????
 18c:	00 00       	nop
}
 18e:	00 00       	nop
 190:	00 00       	nop
 192:	00 14       	cp	r0, r0
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 194:	01 00       	.word	0x0001	; ????
 196:	00 18       	sub	r0, r0
 198:	01 00       	.word	0x0001	; ????
 19a:	00 06       	cpc	r0, r16
 19c:	00 68       	ori	r16, 0x80	; 128
 19e:	93 01       	movw	r18, r6
 1a0:	69 93       	st	Y+, r22
 1a2:	01 18       	sub	r0, r1
}
 1a4:	01 00       	.word	0x0001	; ????
 1a6:	00 1a       	sub	r0, r16
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1a8:	01 00       	.word	0x0001	; ????
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1aa:	00 04       	cpc	r0, r0
 1ac:	00 f3       	brcs	.-64     	; 0x16e <_ZN14HardwareSerial4peekEv+0xe>
 1ae:	01 68       	ori	r16, 0x81	; 129
 1b0:	9f 00       	.word	0x009f	; ????
 1b2:	00 00       	nop
 1b4:	00 00       	nop
 1b6:	00 00       	nop
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1b8:	00 1a       	sub	r0, r16
 1ba:	01 00       	.word	0x0001	; ????
 1bc:	00 26       	eor	r0, r16
 1be:	01 00       	.word	0x0001	; ????
 1c0:	00 06       	cpc	r0, r16
 1c2:	00 68       	ori	r16, 0x80	; 128

  *_udr = c;
 1c4:	93 01       	movw	r18, r6
 1c6:	69 93       	st	Y+, r22
 1c8:	01 26       	eor	r0, r17
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 1ca:	01 00       	.word	0x0001	; ????
 1cc:	00 38       	cpi	r16, 0x80	; 128
 1ce:	01 00       	.word	0x0001	; ????
 1d0:	00 06       	cpc	r0, r16
 1d2:	00 6e       	ori	r16, 0xE0	; 224
 1d4:	93 01       	movw	r18, r6
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 1d6:	6f 93       	push	r22
 1d8:	01 00       	.word	0x0001	; ????
 1da:	00 00       	nop
 1dc:	00 00       	nop
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1de:	00 00       	nop
 1e0:	00 38       	cpi	r16, 0x80	; 128
 1e2:	01 00       	.word	0x0001	; ????
 1e4:	00 3e       	cpi	r16, 0xE0	; 224
 1e6:	01 00       	.word	0x0001	; ????
 1e8:	00 06       	cpc	r0, r16
 1ea:	00 68       	ori	r16, 0x80	; 128
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 1ec:	93 01       	movw	r18, r6
 1ee:	69 93       	st	Y+, r22
 1f0:	01 3e       	cpi	r16, 0xE1	; 225
 1f2:	01 00       	.word	0x0001	; ????
 1f4:	00 60       	ori	r16, 0x00	; 0
 1f6:	01 00       	.word	0x0001	; ????
 1f8:	00 06       	cpc	r0, r16
  _written = true;
 1fa:	00 6e       	ori	r16, 0xE0	; 224
 1fc:	93 01       	movw	r18, r6
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 1fe:	6f 93       	push	r22
 200:	01 00       	.word	0x0001	; ????
 202:	00 00       	nop
 204:	00 00       	nop
 206:	00 00       	nop
 208:	00 4e       	sbci	r16, 0xE0	; 224
 20a:	01 00       	.word	0x0001	; ????
 20c:	00 5a       	subi	r16, 0xA0	; 160
 20e:	01 00       	.word	0x0001	; ????
 210:	00 01       	movw	r0, r0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 212:	00 68       	ori	r16, 0x80	; 128
	...
 21c:	60 01       	movw	r12, r0
 21e:	00 00       	nop
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 220:	66 01       	movw	r12, r12
 222:	00 00       	nop
 224:	06 00       	.word	0x0006	; ????
    if (bit_is_clear(SREG, SREG_I)) {
 226:	68 93       	.word	0x9368	; ????
 228:	01 69       	ori	r16, 0x91	; 145
 22a:	93 01       	movw	r18, r6
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 22c:	66 01       	movw	r12, r12
 22e:	00 00       	nop
 230:	70 01       	movw	r14, r0
 232:	00 00       	nop
 234:	06 00       	.word	0x0006	; ????
	_tx_udr_empty_irq();
 236:	6e 93       	st	-X, r22
 238:	01 6f       	ori	r16, 0xF1	; 241
 23a:	93 01       	movw	r18, r6
 23c:	70 01       	movw	r14, r0
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 23e:	00 00       	nop
 240:	76 01       	movw	r14, r12
 242:	00 00       	nop
 244:	04 00       	.word	0x0004	; ????
 246:	f3 01       	movw	r30, r6
 248:	68 9f       	mul	r22, r24
 24a:	76 01       	movw	r14, r12

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 24c:	00 00       	nop
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 24e:	7c 01       	movw	r14, r24
    _tx_buffer_head = i;
 250:	00 00       	nop
    sbi(*_ucsrb, UDRIE0);
 252:	06 00       	.word	0x0006	; ????
 254:	6e 93       	st	-X, r22
 256:	01 6f       	ori	r16, 0xF1	; 241
 258:	93 01       	movw	r18, r6
	...
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
      *_udr = c;
 262:	7c 01       	movw	r14, r24
 264:	00 00       	nop
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 266:	84 01       	movw	r16, r8
 268:	00 00       	nop
 26a:	06 00       	.word	0x0006	; ????
 26c:	68 93       	.word	0x9368	; ????
 26e:	01 69       	ori	r16, 0x91	; 145
 270:	93 01       	movw	r18, r6
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 272:	84 01       	movw	r16, r8
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
 274:	00 00       	nop
 276:	94 01       	movw	r18, r8
 278:	00 00       	nop
 27a:	06 00       	.word	0x0006	; ????
 27c:	6e 93       	st	-X, r22
 27e:	01 6f       	ori	r16, 0xF1	; 241
 280:	93 01       	movw	r18, r6
	...
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 28a:	a8 01       	movw	r20, r16
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 28c:	00 00       	nop
 28e:	ac 01       	movw	r20, r24
 290:	00 00       	nop
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 292:	06 00       	.word	0x0006	; ????
 294:	68 93       	.word	0x9368	; ????
 296:	01 69       	ori	r16, 0x91	; 145
 298:	93 01       	movw	r18, r6
 29a:	ac 01       	movw	r20, r24
 29c:	00 00       	nop
 29e:	e4 01       	movw	r28, r8
 2a0:	00 00       	nop
 2a2:	06 00       	.word	0x0006	; ????
 2a4:	6e 93       	st	-X, r22
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 2a6:	01 6f       	ori	r16, 0xF1	; 241
 2a8:	93 01       	movw	r18, r6
 2aa:	e4 01       	movw	r28, r8
 2ac:	00 00       	nop
 2ae:	ec 01       	movw	r28, r24
 2b0:	00 00       	nop
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 2b2:	04 00       	.word	0x0004	; ????
 2b4:	f3 01       	movw	r30, r6
 2b6:	68 9f       	mul	r22, r24
	...
	  _tx_udr_empty_irq();
 2c0:	de 01       	movw	r26, r28
 2c2:	00 00       	nop
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 2c4:	e4 01       	movw	r28, r8
 2c6:	00 00       	nop
 2c8:	06 00       	.word	0x0006	; ????
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2ca:	6e 93       	st	-X, r22
 2cc:	01 6f       	ori	r16, 0xF1	; 241
 2ce:	93 01       	movw	r18, r6
 2d0:	e4 01       	movw	r28, r8
 2d2:	00 00       	nop
 2d4:	ea 01       	movw	r28, r20
 2d6:	00 00       	nop
 2d8:	04 00       	.word	0x0004	; ????
 2da:	f3 01       	movw	r30, r6
 2dc:	68 9f       	mul	r22, r24
	...
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 2e6:	ec 01       	movw	r28, r24
 2e8:	00 00       	nop
 2ea:	ee 01       	movw	r28, r28
 2ec:	00 00       	nop
 2ee:	03 00       	.word	0x0003	; ????
 2f0:	92 20       	and	r9, r2
 2f2:	02 ee       	ldi	r16, 0xE2	; 226
 2f4:	01 00       	.word	0x0001	; ????
 2f6:	00 f0       	brcs	.+0      	; 0x2f8 <_ZN5Print5writeEPKc.constprop.14+0x1a>
 2f8:	01 00       	.word	0x0001	; ????
 2fa:	00 03       	mulsu	r16, r16
    }
 2fc:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x146>
 300:	f0 01       	movw	r30, r0
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 302:	00 00       	nop
 304:	f2 01       	movw	r30, r4
 306:	00 00       	nop
 308:	03 00       	.word	0x0003	; ????
 30a:	92 20       	and	r9, r2
 30c:	04 f2       	brlt	.-128    	; 0x28e <_ZN14HardwareSerial5flushEv+0x8>
 30e:	01 00       	.word	0x0001	; ????
 310:	00 f4       	brcc	.+0      	; 0x312 <_ZN5Print11printNumberEmh.constprop.12+0x10>
 312:	01 00       	.word	0x0001	; ????
 314:	00 03       	mulsu	r16, r16
 316:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x346>
 31a:	f4 01       	movw	r30, r8
 31c:	00 00       	nop
 31e:	f6 01       	movw	r30, r12
 320:	00 00       	nop
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 322:	03 00       	.word	0x0003	; ????

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 324:	92 20       	and	r9, r2
 326:	06 f6       	brtc	.-128    	; 0x2a8 <_ZN14HardwareSerial5flushEv+0x22>
 328:	01 00       	.word	0x0001	; ????
 32a:	00 f8       	bld	r0, 0
 32c:	01 00       	.word	0x0001	; ????
 32e:	00 03       	mulsu	r16, r16

  do {
    char c = n % base;
 330:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x546>
 334:	f8 01       	movw	r30, r16
 336:	00 00       	nop
 338:	86 02       	muls	r24, r22
 33a:	00 00       	nop
 33c:	03 00       	.word	0x0003	; ????
 33e:	92 20       	and	r9, r2
 340:	08 00       	.word	0x0008	; ????
    n /= base;
 342:	00 00       	nop
 344:	00 00       	nop

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 346:	00 00       	nop
 348:	00 ec       	ldi	r16, 0xC0	; 192
 34a:	01 00       	.word	0x0001	; ????
 34c:	00 fc       	sbrc	r0, 0
 34e:	01 00       	.word	0x0001	; ????
 350:	00 06       	cpc	r0, r16
 352:	00 68       	ori	r16, 0x80	; 128
 354:	93 01       	movw	r18, r6
 356:	69 93       	st	Y+, r22
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 358:	01 fc       	sbrc	r0, 1
 35a:	01 00       	.word	0x0001	; ????
 35c:	00 7c       	andi	r16, 0xC0	; 192
 35e:	02 00       	.word	0x0002	; ????
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 360:	00 06       	cpc	r0, r16
 362:	00 6c       	ori	r16, 0xC0	; 192
 364:	93 01       	movw	r18, r6
}
 366:	6d 93       	st	X+, r22
 368:	01 7c       	andi	r16, 0xC1	; 193
 36a:	02 00       	.word	0x0002	; ????
 36c:	00 86       	std	Z+8, r0	; 0x08
 36e:	02 00       	.word	0x0002	; ????
 370:	00 04       	cpc	r0, r0
 372:	00 f3       	brcs	.-64     	; 0x334 <_ZN5Print11printNumberEmh.constprop.12+0x32>
 374:	01 68       	ori	r16, 0x81	; 129
 376:	9f 00       	.word	0x009f	; ????
 378:	00 00       	nop
 37a:	00 00       	nop
 37c:	00 00       	nop
 37e:	00 ec       	ldi	r16, 0xC0	; 192
 380:	01 00       	.word	0x0001	; ????
 382:	00 20       	and	r0, r0
 384:	02 00       	.word	0x0002	; ????
 386:	00 01       	movw	r0, r0
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 388:	00 66       	ori	r16, 0x60	; 96
 38a:	20 02       	muls	r18, r16
 38c:	00 00       	nop
 38e:	5c 02       	muls	r21, r28
 390:	00 00       	nop
 392:	01 00       	.word	0x0001	; ????
 394:	5f 5c       	subi	r21, 0xCF	; 207
 396:	02 00       	.word	0x0002	; ????
 398:	00 70       	andi	r16, 0x00	; 0
 39a:	02 00       	.word	0x0002	; ????
 39c:	00 01       	movw	r0, r0
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 39e:	00 66       	ori	r16, 0x60	; 96
 3a0:	70 02       	muls	r23, r16
 3a2:	00 00       	nop
 3a4:	86 02       	muls	r24, r22
 3a6:	00 00       	nop
 3a8:	04 00       	.word	0x0004	; ????
 3aa:	f3 01       	movw	r30, r6
 3ac:	66 9f       	mul	r22, r22
	...
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
 3b6:	5e 02       	muls	r21, r30
 3b8:	00 00       	nop
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 3ba:	70 02       	muls	r23, r16
 3bc:	00 00       	nop
 3be:	01 00       	.word	0x0001	; ????
 3c0:	69 00       	.word	0x0069	; ????
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 3c2:	00 00       	nop
 3c4:	00 00       	nop
		m += 1;
 3c6:	00 00       	nop
 3c8:	00 60       	ori	r16, 0x00	; 0
 3ca:	02 00       	.word	0x0002	; ????
	}

	timer0_fract = f;
 3cc:	00 70       	andi	r16, 0x00	; 0
 3ce:	02 00       	.word	0x0002	; ????
	timer0_millis = m;
 3d0:	00 02       	muls	r16, r16
 3d2:	00 31       	cpi	r16, 0x10	; 16
 3d4:	9f 72       	andi	r25, 0x2F	; 47
 3d6:	02 00       	.word	0x0002	; ????
 3d8:	00 86       	std	Z+8, r0	; 0x08
 3da:	02 00       	.word	0x0002	; ????
 3dc:	00 02       	muls	r16, r16
 3de:	00 30       	cpi	r16, 0x00	; 0
	timer0_overflow_count++;
 3e0:	9f 00       	.word	0x009f	; ????
 3e2:	00 00       	nop
 3e4:	00 00       	nop
 3e6:	00 00       	nop
 3e8:	00 12       	cpse	r0, r16
 3ea:	02 00       	.word	0x0002	; ????
 3ec:	00 5c       	subi	r16, 0xC0	; 192
 3ee:	02 00       	.word	0x0002	; ????
 3f0:	00 01       	movw	r0, r0
 3f2:	00 5f       	subi	r16, 0xF0	; 240
	...
 3fc:	12 02       	muls	r17, r18
 3fe:	00 00       	nop
 400:	5c 02       	muls	r21, r28
 402:	00 00       	nop
 404:	06 00       	.word	0x0006	; ????
}
 406:	6c 93       	st	X, r22
 408:	01 6d       	ori	r16, 0xD1	; 209
 40a:	93 01       	movw	r18, r6
	...
 414:	20 02       	muls	r18, r16
 416:	00 00       	nop
 418:	5c 02       	muls	r21, r28
 41a:	00 00       	nop
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 41c:	01 00       	.word	0x0001	; ????
 41e:	60 00       	.word	0x0060	; ????
 420:	00 00       	nop
 422:	00 00       	nop
 424:	00 00       	nop
 426:	00 4e       	sbci	r16, 0xE0	; 224
 428:	02 00       	.word	0x0002	; ????
 42a:	00 5c       	subi	r16, 0xC0	; 192
 42c:	02 00       	.word	0x0002	; ????
 42e:	00 01       	movw	r0, r0
 430:	00 69       	ori	r16, 0x90	; 144
	...
 43a:	50 02       	muls	r21, r16
 43c:	00 00       	nop
  Serial._tx_udr_empty_irq();
 43e:	5c 02       	muls	r21, r28
 440:	00 00       	nop
 442:	02 00       	.word	0x0002	; ????
 444:	31 9f       	mul	r19, r17
	...
}
 44e:	86 02       	muls	r24, r22
 450:	00 00       	nop
 452:	88 02       	muls	r24, r24
 454:	00 00       	nop
 456:	03 00       	.word	0x0003	; ????
 458:	92 20       	and	r9, r2
 45a:	02 88       	ldd	r0, Z+18	; 0x12
 45c:	02 00       	.word	0x0002	; ????
 45e:	00 8a       	std	Z+16, r0	; 0x10
 460:	02 00       	.word	0x0002	; ????
 462:	00 03       	mulsu	r16, r16
 464:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x146>
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 468:	8a 02       	muls	r24, r26
 46a:	00 00       	nop
 46c:	ca 02       	muls	r28, r26
 46e:	00 00       	nop
 470:	03 00       	.word	0x0003	; ????
 472:	92 20       	and	r9, r2
 474:	04 00       	.word	0x0004	; ????
 476:	00 00       	nop
 478:	00 00       	nop
 47a:	00 00       	nop

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 47c:	00 86       	std	Z+8, r0	; 0x08
 47e:	02 00       	.word	0x0002	; ????
 480:	00 8e       	std	Z+24, r0	; 0x18
 482:	02 00       	.word	0x0002	; ????
 484:	00 06       	cpc	r0, r16
 486:	00 68       	ori	r16, 0x80	; 128
 488:	93 01       	movw	r18, r6
 48a:	69 93       	st	Y+, r22
 48c:	01 8e       	std	Z+25, r0	; 0x19
 48e:	02 00       	.word	0x0002	; ????
 490:	00 c8       	rjmp	.-4096   	; 0xfffff492 <__eeprom_end+0xff7ef492>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 492:	02 00       	.word	0x0002	; ????
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 494:	00 06       	cpc	r0, r16
 496:	00 6c       	ori	r16, 0xC0	; 192
 498:	93 01       	movw	r18, r6
 49a:	6d 93       	st	X+, r22

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 49c:	01 c8       	rjmp	.-4094   	; 0xfffff4a0 <__eeprom_end+0xff7ef4a0>
 49e:	02 00       	.word	0x0002	; ????
 4a0:	00 ca       	rjmp	.-3072   	; 0xfffff8a2 <__eeprom_end+0xff7ef8a2>
 4a2:	02 00       	.word	0x0002	; ????
      _rx_buffer[_rx_buffer_head] = c;
 4a4:	00 04       	cpc	r0, r0
 4a6:	00 f3       	brcs	.-64     	; 0x468 <__vector_18>
 4a8:	01 68       	ori	r16, 0x81	; 129
 4aa:	9f 00       	.word	0x009f	; ????
 4ac:	00 00       	nop
 4ae:	00 00       	nop
      _rx_buffer_head = i;
 4b0:	00 00       	nop
 4b2:	00 de       	rcall	.-1024   	; 0xb4 <__do_global_ctors+0x18>
 4b4:	02 00       	.word	0x0002	; ????
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 4b6:	00 f8       	bld	r0, 0
    Serial._rx_complete_irq();
  }
 4b8:	02 00       	.word	0x0002	; ????
 4ba:	00 06       	cpc	r0, r16
 4bc:	00 68       	ori	r16, 0x80	; 128
 4be:	93 01       	movw	r18, r6
 4c0:	69 93       	st	Y+, r22
 4c2:	01 f8       	bld	r0, 1
 4c4:	02 00       	.word	0x0002	; ????
 4c6:	00 fb       	bst	r16, 0
 4c8:	02 00       	.word	0x0002	; ????
 4ca:	00 06       	cpc	r0, r16

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 4cc:	00 66       	ori	r16, 0x60	; 96
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 4ce:	93 01       	movw	r18, r6
 4d0:	67 93       	lat	Z, r22
 4d2:	01 fb       	bst	r16, 1
	sbi(TCCR0A, WGM00);
 4d4:	02 00       	.word	0x0002	; ????
 4d6:	00 fc       	sbrc	r0, 0
 4d8:	02 00       	.word	0x0002	; ????
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 4da:	00 04       	cpc	r0, r0
 4dc:	00 f3       	brcs	.-64     	; 0x49e <__vector_18+0x36>
 4de:	01 68       	ori	r16, 0x81	; 129
	sbi(TCCR0B, CS00);
 4e0:	9f fc       	.word	0xfc9f	; ????
 4e2:	02 00       	.word	0x0002	; ????
 4e4:	00 00       	nop

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 4e6:	03 00       	.word	0x0003	; ????
 4e8:	00 06       	cpc	r0, r16
 4ea:	00 68       	ori	r16, 0x80	; 128
 4ec:	93 01       	movw	r18, r6
 4ee:	69 93       	st	Y+, r22
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 4f0:	01 00       	.word	0x0001	; ????
 4f2:	03 00       	.word	0x0003	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4f4:	00 02       	muls	r16, r16
 4f6:	03 00       	.word	0x0003	; ????
 4f8:	00 04       	cpc	r0, r0
 4fa:	00 f3       	brcs	.-64     	; 0x4bc <__vector_18+0x54>
 4fc:	01 68       	ori	r16, 0x81	; 129
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 4fe:	9f 00       	.word	0x009f	; ????
 500:	00 00       	nop
 502:	00 00       	nop
 504:	00 00       	nop
 506:	00 02       	muls	r16, r16
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 508:	03 00       	.word	0x0003	; ????
 50a:	00 04       	cpc	r0, r0
 50c:	03 00       	.word	0x0003	; ????
 50e:	00 03       	mulsu	r16, r16
 510:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x46>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 514:	04 03       	mulsu	r16, r20
 516:	00 00       	nop
 518:	06 03       	mulsu	r16, r22
 51a:	00 00       	nop

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 51c:	03 00       	.word	0x0003	; ????
 51e:	92 20       	and	r9, r2
 520:	03 06       	cpc	r0, r19
 522:	03 00       	.word	0x0003	; ????
 524:	00 08       	sbc	r0, r0
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 526:	03 00       	.word	0x0003	; ????
 528:	00 03       	mulsu	r16, r16
 52a:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x246>
 52e:	08 03       	fmul	r16, r16
		sbi(ADCSRA, ADPS1);
 530:	00 00       	nop
 532:	0a 03       	fmul	r16, r18
 534:	00 00       	nop
 536:	03 00       	.word	0x0003	; ????
 538:	92 20       	and	r9, r2
		sbi(ADCSRA, ADPS0);
 53a:	05 0a       	sbc	r0, r21
 53c:	03 00       	.word	0x0003	; ????
 53e:	00 0c       	add	r0, r0
 540:	03 00       	.word	0x0003	; ????
 542:	00 03       	mulsu	r16, r16
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 544:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x446>
 548:	0c 03       	fmul	r16, r20
 54a:	00 00       	nop
 54c:	0e 03       	fmul	r16, r22
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 54e:	00 00       	nop
 550:	03 00       	.word	0x0003	; ????

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 552:	92 20       	and	r9, r2
 554:	07 0e       	add	r0, r23
 556:	03 00       	.word	0x0003	; ????
 558:	00 10       	cpse	r0, r0
 55a:	03 00       	.word	0x0003	; ????
 55c:	00 03       	mulsu	r16, r16
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
 55e:	00 92 20 08 	sts	0x0820, r0	; 0x800820 <__bss_end+0x646>
 562:	10 03       	mulsu	r17, r16
 564:	00 00       	nop
 566:	12 03       	mulsu	r17, r18
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 568:	00 00       	nop
 56a:	03 00       	.word	0x0003	; ????
 56c:	92 20       	and	r9, r2
 56e:	09 12       	cpse	r0, r25
 570:	03 00       	.word	0x0003	; ????
  *_ubrrl = baud_setting;
 572:	00 16       	cp	r0, r16
 574:	03 00       	.word	0x0003	; ????
 576:	00 03       	mulsu	r16, r16
 578:	00 92 20 0a 	sts	0x0A20, r0	; 0x800a20 <__bss_end+0x846>
 57c:	16 03       	mulsu	r17, r22

  _written = false;
 57e:	00 00       	nop
 580:	18 03       	fmul	r17, r16

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 582:	00 00       	nop
 584:	02 00       	.word	0x0002	; ????
 586:	8c 0a       	sbc	r8, r28
 588:	18 03       	fmul	r17, r16
 58a:	00 00       	nop
 58c:	84 03       	fmuls	r16, r20
  
  sbi(*_ucsrb, RXEN0);
 58e:	00 00       	nop
 590:	02 00       	.word	0x0002	; ????
 592:	8c 2b       	or	r24, r28
	...
  sbi(*_ucsrb, TXEN0);
 59c:	02 03       	mulsu	r16, r18
 59e:	00 00       	nop
 5a0:	38 03       	fmul	r19, r16
 5a2:	00 00       	nop
 5a4:	0c 00       	.word	0x000c	; ????
 5a6:	66 93       	lac	Z, r22
 5a8:	01 67       	ori	r16, 0x71	; 113
  sbi(*_ucsrb, RXCIE0);
 5aa:	93 01       	movw	r18, r6
 5ac:	68 93       	.word	0x9368	; ????
 5ae:	01 69       	ori	r16, 0x91	; 145
 5b0:	93 01       	movw	r18, r6
 5b2:	38 03       	fmul	r19, r16
 5b4:	00 00       	nop
 5b6:	40 03       	mulsu	r20, r16
  cbi(*_ucsrb, UDRIE0);
 5b8:	00 00       	nop
 5ba:	0c 00       	.word	0x000c	; ????
 5bc:	66 93       	lac	Z, r22
 5be:	01 67       	ori	r16, 0x71	; 113
 5c0:	93 01       	movw	r18, r6
 5c2:	68 93       	.word	0x9368	; ????
 5c4:	01 69       	ori	r16, 0x91	; 145
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 5c6:	93 01       	movw	r18, r6

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 5c8:	46 03       	mulsu	r20, r22
	m = timer0_millis;
 5ca:	00 00       	nop
 5cc:	65 03       	mulsu	r22, r21
 5ce:	00 00       	nop
 5d0:	0c 00       	.word	0x000c	; ????
 5d2:	62 93       	st	-Z, r22
 5d4:	01 63       	ori	r16, 0x31	; 49
 5d6:	93 01       	movw	r18, r6
 5d8:	64 93       	xch	Z, r22
	SREG = oldSREG;
 5da:	01 65       	ori	r16, 0x51	; 81

void setup()
{
  Serial.begin(57600);         // 9600 bps
    
  _startTime_ms = millis();
 5dc:	93 01       	movw	r18, r6
	...
 5e6:	02 03       	mulsu	r16, r18
 5e8:	00 00       	nop
 5ea:	2a 03       	fmul	r18, r18
}

void loop() 
{
  if (0 == _loopCounter--) {
 5ec:	00 00       	nop
 5ee:	01 00       	.word	0x0001	; ????
 5f0:	64 2a       	or	r6, r20
 5f2:	03 00       	.word	0x0003	; ????
 5f4:	00 38       	cpi	r16, 0x80	; 128
 5f6:	03 00       	.word	0x0003	; ????
 5f8:	00 04       	cpc	r0, r0
 5fa:	00 f3       	brcs	.-64     	; 0x5bc <main+0xf0>
 5fc:	01 64       	ori	r16, 0x41	; 65
 5fe:	9f 00       	.word	0x009f	; ????
 600:	00 00       	nop
 602:	00 00       	nop
 604:	00 00       	nop
 606:	00 22       	and	r0, r16
 608:	03 00       	.word	0x0003	; ????
 60a:	00 38       	cpi	r16, 0x80	; 128
 60c:	03 00       	.word	0x0003	; ????
 60e:	00 03       	mulsu	r16, r16
 610:	00 91 76 9f 	lds	r16, 0x9F76	; 0x809f76 <__bss_end+0x9d9c>
 614:	38 03       	fmul	r19, r16
 616:	00 00       	nop
 618:	7a 03       	fmul	r23, r18
 61a:	00 00       	nop
 61c:	06 00       	.word	0x0006	; ????
 61e:	60 93 01 61 	sts	0x6101, r22	; 0x806101 <__bss_end+0x5f27>
	unsigned long m;
	uint8_t oldSREG = SREG;

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 622:	93 01       	movw	r18, r6
	...
	m = timer0_millis;
 62c:	42 03       	mulsu	r20, r18
 62e:	00 00       	nop
 630:	44 03       	mulsu	r20, r20
 632:	00 00       	nop
	SREG = oldSREG;
 634:	01 00       	.word	0x0001	; ????
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 636:	66 44       	sbci	r22, 0x46	; 70
 638:	03 00       	.word	0x0003	; ????
 63a:	00 50       	subi	r16, 0x00	; 0
 63c:	03 00       	.word	0x0003	; ????
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 63e:	00 01       	movw	r0, r0
 640:	00 6e       	ori	r16, 0xE0	; 224
 642:	50 03       	mulsu	r21, r16
 644:	00 00       	nop
 646:	52 03       	mulsu	r21, r18
 648:	00 00       	nop
 64a:	03 00       	.word	0x0003	; ????
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 64c:	8e 50       	subi	r24, 0x0E	; 14
 64e:	9f 52       	subi	r25, 0x2F	; 47
 650:	03 00       	.word	0x0003	; ????
 652:	00 54       	subi	r16, 0x40	; 64
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 654:	03 00       	.word	0x0003	; ????
 656:	00 01       	movw	r0, r0
 658:	00 6e       	ori	r16, 0xE0	; 224
	...
 662:	88 03       	fmulsu	r16, r16
 664:	00 00       	nop
 666:	8a 03       	fmulsu	r16, r18
 668:	00 00       	nop
 66a:	03 00       	.word	0x0003	; ????
 66c:	92 20       	and	r9, r2
 66e:	02 8a       	std	Z+18, r0	; 0x12
 670:	03 00       	.word	0x0003	; ????
 672:	00 8c       	ldd	r0, Z+24	; 0x18
 674:	03 00       	.word	0x0003	; ????
 676:	00 03       	mulsu	r16, r16
 678:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x146>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 67c:	8c 03       	fmulsu	r16, r20
 67e:	00 00       	nop
 680:	94 03       	fmuls	r17, r20
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
 682:	00 00       	nop
 684:	03 00       	.word	0x0003	; ????
 686:	92 20       	and	r9, r2
 688:	04 94       	.word	0x9404	; ????
 68a:	03 00       	.word	0x0003	; ????
 68c:	00 96       	adiw	r24, 0x00	; 0
 68e:	03 00       	.word	0x0003	; ????
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 690:	00 03       	mulsu	r16, r16
 692:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x346>
 696:	96 03       	fmuls	r17, r22
 698:	00 00       	nop
 69a:	98 03       	fmulsu	r17, r16
 69c:	00 00       	nop
 69e:	03 00       	.word	0x0003	; ????
 6a0:	92 20       	and	r9, r2
 6a2:	06 98       	cbi	0x00, 6	; 0
 6a4:	03 00       	.word	0x0003	; ????
 6a6:	00 9a       	sbi	0x00, 0	; 0
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 6a8:	03 00       	.word	0x0003	; ????
 6aa:	00 03       	mulsu	r16, r16
 6ac:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x546>
 6b0:	9a 03       	fmulsu	r17, r18
 6b2:	00 00       	nop
 6b4:	9c 03       	fmulsu	r17, r20
 6b6:	00 00       	nop
 6b8:	03 00       	.word	0x0003	; ????
 6ba:	92 20       	and	r9, r2
 6bc:	08 9c       	mul	r0, r8
 6be:	03 00       	.word	0x0003	; ????
 6c0:	00 9e       	mul	r0, r16
 6c2:	03 00       	.word	0x0003	; ????
 6c4:	00 03       	mulsu	r16, r16
 6c6:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x746>
 6ca:	9e 03       	fmulsu	r17, r22
 6cc:	00 00       	nop
 6ce:	1c 04       	cpc	r1, r12
 6d0:	00 00       	nop
 6d2:	03 00       	.word	0x0003	; ????
 6d4:	92 20       	and	r9, r2
 6d6:	0a 00       	.word	0x000a	; ????
 6d8:	00 00       	nop
 6da:	00 00       	nop
 6dc:	00 00       	nop
 6de:	00 ae       	std	Z+56, r0	; 0x38
 6e0:	03 00       	.word	0x0003	; ????
 6e2:	00 b2       	in	r0, 0x10	; 16
 6e4:	03 00       	.word	0x0003	; ????
 6e6:	00 0c       	add	r0, r0
 6e8:	00 68       	ori	r16, 0x80	; 128
 6ea:	93 01       	movw	r18, r6
 6ec:	69 93       	st	Y+, r22
 6ee:	01 6a       	ori	r16, 0xA1	; 161
 6f0:	93 01       	movw	r18, r6
 6f2:	6b 93       	.word	0x936b	; ????
 6f4:	01 b2       	in	r0, 0x11	; 17
 6f6:	03 00       	.word	0x0003	; ????
 6f8:	00 c0       	rjmp	.+0      	; 0x6fa <__udivmodsi4_loop+0x4>
 6fa:	03 00       	.word	0x0003	; ????
 6fc:	00 03       	mulsu	r16, r16
 6fe:	00 88       	ldd	r0, Z+16	; 0x10
 700:	01 9f       	mul	r16, r17
 702:	c0 03       	fmuls	r20, r16
 704:	00 00       	nop
 706:	c2 03       	fmuls	r20, r18
 708:	00 00       	nop
 70a:	0c 00       	.word	0x000c	; ????
 70c:	68 93       	.word	0x9368	; ????
 70e:	01 69       	ori	r16, 0x91	; 145
 710:	93 01       	movw	r18, r6
 712:	6a 93       	st	-Y, r22
 714:	01 6b       	ori	r16, 0xB1	; 177
 716:	93 01       	movw	r18, r6
 718:	c2 03       	fmuls	r20, r18
 71a:	00 00       	nop
 71c:	cc 03       	fmulsu	r20, r20
 71e:	00 00       	nop
 720:	03 00       	.word	0x0003	; ????
 722:	88 01       	movw	r16, r16
 724:	9f cc       	rjmp	.-1730   	; 0x64 <__SREG__+0x25>
 726:	03 00       	.word	0x0003	; ????
 728:	00 f0       	brcs	.+0      	; 0x72a <__udivmodsi4_ep+0x1a>
 72a:	03 00       	.word	0x0003	; ????
 72c:	00 0c       	add	r0, r0
 72e:	00 68       	ori	r16, 0x80	; 128
 730:	93 01       	movw	r18, r6
 732:	69 93       	st	Y+, r22
 734:	01 6a       	ori	r16, 0xA1	; 161
 736:	93 01       	movw	r18, r6
 738:	6b 93       	.word	0x936b	; ????
 73a:	01 f0       	breq	.+0      	; 0x73c <abort+0x2>
 73c:	03 00       	.word	0x0003	; ????
 73e:	00 06       	cpc	r0, r16
 740:	04 00       	.word	0x0004	; ????
 742:	00 05       	cpc	r16, r0
 744:	00 03       	mulsu	r16, r16
 746:	39 01       	movw	r6, r18
 748:	80 00       	.word	0x0080	; ????
	...
 752:	b2 03       	fmuls	r19, r18
 754:	00 00       	nop
 756:	b6 03       	fmuls	r19, r22
 758:	00 00       	nop
 75a:	01 00       	.word	0x0001	; ????
 75c:	63 b6       	in	r6, 0x33	; 51
 75e:	03 00       	.word	0x0003	; ????
 760:	00 c4       	rjmp	.+2048   	; 0xf62 <__stack+0x663>
 762:	03 00       	.word	0x0003	; ????
 764:	00 01       	movw	r0, r0
 766:	00 62       	ori	r16, 0x20	; 32
 768:	c4 03       	fmuls	r20, r20
 76a:	00 00       	nop
 76c:	c6 03       	fmuls	r20, r22
 76e:	00 00       	nop
 770:	03 00       	.word	0x0003	; ????
 772:	83 03       	fmuls	r16, r19
 774:	9f c6       	rjmp	.+3390   	; 0x14b4 <__stack+0xbb5>
 776:	03 00       	.word	0x0003	; ????
 778:	00 12       	cpse	r0, r16
 77a:	04 00       	.word	0x0004	; ????
 77c:	00 01       	movw	r0, r0
 77e:	00 62       	ori	r16, 0x20	; 32
 780:	12 04       	cpc	r1, r2
 782:	00 00       	nop
 784:	16 04       	cpc	r1, r6
 786:	00 00       	nop
 788:	05 00       	.word	0x0005	; ????
 78a:	03 38       	cpi	r16, 0x83	; 131
 78c:	01 80       	ldd	r0, Z+1	; 0x01
	...
 796:	00 52       	subi	r16, 0x20	; 32
 798:	05 00       	.word	0x0005	; ????
 79a:	00 c6       	rjmp	.+3072   	; 0x139c <__stack+0xa9d>
 79c:	05 00       	.word	0x0005	; ????
 79e:	00 04       	cpc	r0, r0
 7a0:	00 0a       	sbc	r0, r16
 7a2:	00 e1       	ldi	r16, 0x10	; 16
 7a4:	9f 00       	.word	0x009f	; ????
 7a6:	00 00       	nop
 7a8:	00 00       	nop
 7aa:	00 00       	nop
 7ac:	00 52       	subi	r16, 0x20	; 32
 7ae:	05 00       	.word	0x0005	; ????
 7b0:	00 c6       	rjmp	.+3072   	; 0x13b2 <__stack+0xab3>
 7b2:	05 00       	.word	0x0005	; ????
 7b4:	00 02       	muls	r16, r16
 7b6:	00 36       	cpi	r16, 0x60	; 96
 7b8:	9f 00       	.word	0x009f	; ????
 7ba:	00 00       	nop
 7bc:	00 00       	nop
 7be:	00 00       	nop
 7c0:	00 52       	subi	r16, 0x20	; 32
 7c2:	05 00       	.word	0x0005	; ????
 7c4:	00 68       	ori	r16, 0x80	; 128
 7c6:	05 00       	.word	0x0005	; ????
 7c8:	00 03       	mulsu	r16, r16
 7ca:	00 08       	sbc	r0, r0
 7cc:	22 9f       	mul	r18, r18
 7ce:	68 05       	cpc	r22, r8
 7d0:	00 00       	nop
 7d2:	c6 05       	cpc	r28, r6
 7d4:	00 00       	nop
 7d6:	02 00       	.word	0x0002	; ????
 7d8:	40 9f       	mul	r20, r16
	...
 7e2:	da 05       	cpc	r29, r10
 7e4:	00 00       	nop
 7e6:	dc 05       	cpc	r29, r12
 7e8:	00 00       	nop
 7ea:	0c 00       	.word	0x000c	; ????
 7ec:	68 93       	.word	0x9368	; ????
 7ee:	01 69       	ori	r16, 0x91	; 145
 7f0:	93 01       	movw	r18, r6
 7f2:	6a 93       	st	-Y, r22
 7f4:	01 6b       	ori	r16, 0xB1	; 177
 7f6:	93 01       	movw	r18, r6
	...
 800:	c8 05       	cpc	r28, r8
 802:	00 00       	nop
 804:	dc 05       	cpc	r29, r12
 806:	00 00       	nop
 808:	01 00       	.word	0x0001	; ????
 80a:	62 00       	.word	0x0062	; ????
 80c:	00 00       	nop
 80e:	00 00       	nop
 810:	00 00       	nop
 812:	00 34       	cpi	r16, 0x40	; 64
 814:	06 00       	.word	0x0006	; ????
 816:	00 36       	cpi	r16, 0x60	; 96
 818:	06 00       	.word	0x0006	; ????
 81a:	00 0c       	add	r0, r0
 81c:	00 5c       	subi	r16, 0xC0	; 192
 81e:	93 01       	movw	r18, r6
 820:	5d 93       	st	X+, r21
 822:	01 5e       	subi	r16, 0xE1	; 225
 824:	93 01       	movw	r18, r6
 826:	5f 93       	push	r21
 828:	01 00       	.word	0x0001	; ????
 82a:	00 00       	nop
 82c:	00 00       	nop
 82e:	00 00       	nop
 830:	00 22       	and	r0, r16
 832:	06 00       	.word	0x0006	; ????
 834:	00 36       	cpi	r16, 0x60	; 96
 836:	06 00       	.word	0x0006	; ????
 838:	00 01       	movw	r0, r0
 83a:	00 68       	ori	r16, 0x80	; 128
	...
 844:	3e 06       	cpc	r3, r30
 846:	00 00       	nop
 848:	4c 06       	cpc	r4, r28
 84a:	00 00       	nop
 84c:	02 00       	.word	0x0002	; ????
 84e:	3a 9f       	mul	r19, r26
	...
 858:	3e 06       	cpc	r3, r30
 85a:	00 00       	nop
 85c:	4c 06       	cpc	r4, r28
 85e:	00 00       	nop
 860:	06 00       	.word	0x0006	; ????
 862:	0c c0       	rjmp	.+24     	; 0x87c <__data_load_end+0x104>
 864:	c6 2d       	mov	r28, r6
 866:	00 9f       	mul	r16, r16
	...
 870:	54 06       	cpc	r5, r20
 872:	00 00       	nop
 874:	7a 06       	cpc	r7, r26
 876:	00 00       	nop
 878:	02 00       	.word	0x0002	; ????
 87a:	3a 9f       	mul	r19, r26
	...
 884:	54 06       	cpc	r5, r20
 886:	00 00       	nop
 888:	70 06       	cpc	r7, r16
 88a:	00 00       	nop
 88c:	0a 00       	.word	0x000a	; ????
 88e:	7c 00       	.word	0x007c	; ????
 890:	03 30       	cpi	r16, 0x03	; 3
 892:	01 80       	ldd	r0, Z+1	; 0x01
 894:	00 06       	cpc	r0, r16
 896:	1c 9f       	mul	r17, r28
 898:	70 06       	cpc	r7, r16
 89a:	00 00       	nop
 89c:	79 06       	cpc	r7, r25
 89e:	00 00       	nop
 8a0:	0c 00       	.word	0x000c	; ????
 8a2:	62 93       	st	-Z, r22
 8a4:	01 63       	ori	r16, 0x31	; 49
 8a6:	93 01       	movw	r18, r6
 8a8:	64 93       	xch	Z, r22
 8aa:	01 65       	ori	r16, 0x51	; 81
 8ac:	93 01       	movw	r18, r6
	...
 8b6:	90 06       	cpc	r9, r16
 8b8:	00 00       	nop
 8ba:	e8 06       	cpc	r14, r24
 8bc:	00 00       	nop
 8be:	02 00       	.word	0x0002	; ????
 8c0:	31 9f       	mul	r19, r17
	...
 8ca:	90 06       	cpc	r9, r16
 8cc:	00 00       	nop
 8ce:	e8 06       	cpc	r14, r24
 8d0:	00 00       	nop
 8d2:	03 00       	.word	0x0003	; ????
 8d4:	09 ff       	.word	0xff09	; ????
 8d6:	9f 00       	.word	0x009f	; ????
 8d8:	00 00       	nop
 8da:	00 00       	nop
 8dc:	00 00       	nop
 8de:	00 1c       	adc	r0, r0
 8e0:	04 00       	.word	0x0004	; ????
 8e2:	00 1e       	adc	r0, r16
 8e4:	04 00       	.word	0x0004	; ????
 8e6:	00 03       	mulsu	r16, r16
 8e8:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x46>
 8ec:	1e 04       	cpc	r1, r14
 8ee:	00 00       	nop
 8f0:	20 04       	cpc	r2, r0
 8f2:	00 00       	nop
 8f4:	03 00       	.word	0x0003	; ????
 8f6:	92 20       	and	r9, r2
 8f8:	03 20       	and	r0, r3
 8fa:	04 00       	.word	0x0004	; ????
 8fc:	00 28       	or	r0, r0
 8fe:	04 00       	.word	0x0004	; ????
 900:	00 03       	mulsu	r16, r16
 902:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x246>
 906:	28 04       	cpc	r2, r8
 908:	00 00       	nop
 90a:	2a 04       	cpc	r2, r10
 90c:	00 00       	nop
 90e:	03 00       	.word	0x0003	; ????
 910:	92 20       	and	r9, r2
 912:	05 2a       	or	r0, r21
 914:	04 00       	.word	0x0004	; ????
 916:	00 2c       	mov	r0, r0
 918:	04 00       	.word	0x0004	; ????
 91a:	00 03       	mulsu	r16, r16
 91c:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x446>
 920:	2c 04       	cpc	r2, r12
 922:	00 00       	nop
 924:	2e 04       	cpc	r2, r14
 926:	00 00       	nop
 928:	03 00       	.word	0x0003	; ????
 92a:	92 20       	and	r9, r2
 92c:	07 2e       	mov	r0, r23
 92e:	04 00       	.word	0x0004	; ????
 930:	00 30       	cpi	r16, 0x00	; 0
 932:	04 00       	.word	0x0004	; ????
 934:	00 03       	mulsu	r16, r16
 936:	00 92 20 08 	sts	0x0820, r0	; 0x800820 <__bss_end+0x646>
 93a:	30 04       	cpc	r3, r0
 93c:	00 00       	nop
 93e:	32 04       	cpc	r3, r2
 940:	00 00       	nop
 942:	03 00       	.word	0x0003	; ????
 944:	92 20       	and	r9, r2
 946:	09 32       	cpi	r16, 0x29	; 41
 948:	04 00       	.word	0x0004	; ????
 94a:	00 34       	cpi	r16, 0x40	; 64
 94c:	04 00       	.word	0x0004	; ????
 94e:	00 03       	mulsu	r16, r16
 950:	00 92 20 0a 	sts	0x0A20, r0	; 0x800a20 <__bss_end+0x846>
 954:	34 04       	cpc	r3, r4
 956:	00 00       	nop
 958:	36 04       	cpc	r3, r6
 95a:	00 00       	nop
 95c:	03 00       	.word	0x0003	; ????
 95e:	92 20       	and	r9, r2
 960:	0b 36       	cpi	r16, 0x6B	; 107
 962:	04 00       	.word	0x0004	; ????
 964:	00 38       	cpi	r16, 0x80	; 128
 966:	04 00       	.word	0x0004	; ????
 968:	00 03       	mulsu	r16, r16
 96a:	00 92 20 0c 	sts	0x0C20, r0	; 0x800c20 <__bss_end+0xa46>
 96e:	38 04       	cpc	r3, r8
 970:	00 00       	nop
 972:	3a 04       	cpc	r3, r10
 974:	00 00       	nop
 976:	03 00       	.word	0x0003	; ????
 978:	92 20       	and	r9, r2
 97a:	0d 3a       	cpi	r16, 0xAD	; 173
 97c:	04 00       	.word	0x0004	; ????
 97e:	00 3c       	cpi	r16, 0xC0	; 192
 980:	04 00       	.word	0x0004	; ????
 982:	00 03       	mulsu	r16, r16
 984:	00 92 20 0e 	sts	0x0E20, r0	; 0x800e20 <__bss_end+0xc46>
 988:	3c 04       	cpc	r3, r12
 98a:	00 00       	nop
 98c:	3e 04       	cpc	r3, r14
 98e:	00 00       	nop
 990:	03 00       	.word	0x0003	; ????
 992:	92 20       	and	r9, r2
 994:	0f 3e       	cpi	r16, 0xEF	; 239
 996:	04 00       	.word	0x0004	; ????
 998:	00 68       	ori	r16, 0x80	; 128
 99a:	04 00       	.word	0x0004	; ????
 99c:	00 03       	mulsu	r16, r16
 99e:	00 92 20 10 	sts	0x1020, r0	; 0x801020 <__bss_end+0xe46>
	...
 9aa:	68 04       	cpc	r6, r8
 9ac:	00 00       	nop
 9ae:	6a 04       	cpc	r6, r10
 9b0:	00 00       	nop
 9b2:	03 00       	.word	0x0003	; ????
 9b4:	92 20       	and	r9, r2
 9b6:	02 6a       	ori	r16, 0xA2	; 162
 9b8:	04 00       	.word	0x0004	; ????
 9ba:	00 6c       	ori	r16, 0xC0	; 192
 9bc:	04 00       	.word	0x0004	; ????
 9be:	00 03       	mulsu	r16, r16
 9c0:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x146>
 9c4:	6c 04       	cpc	r6, r12
 9c6:	00 00       	nop
 9c8:	74 04       	cpc	r7, r4
 9ca:	00 00       	nop
 9cc:	03 00       	.word	0x0003	; ????
 9ce:	92 20       	and	r9, r2
 9d0:	04 74       	andi	r16, 0x44	; 68
 9d2:	04 00       	.word	0x0004	; ????
 9d4:	00 76       	andi	r16, 0x60	; 96
 9d6:	04 00       	.word	0x0004	; ????
 9d8:	00 03       	mulsu	r16, r16
 9da:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x346>
 9de:	76 04       	cpc	r7, r6
 9e0:	00 00       	nop
 9e2:	78 04       	cpc	r7, r8
 9e4:	00 00       	nop
 9e6:	03 00       	.word	0x0003	; ????
 9e8:	92 20       	and	r9, r2
 9ea:	06 78       	andi	r16, 0x86	; 134
 9ec:	04 00       	.word	0x0004	; ????
 9ee:	00 7a       	andi	r16, 0xA0	; 160
 9f0:	04 00       	.word	0x0004	; ????
 9f2:	00 03       	mulsu	r16, r16
 9f4:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x546>
 9f8:	7a 04       	cpc	r7, r10
 9fa:	00 00       	nop
 9fc:	7c 04       	cpc	r7, r12
 9fe:	00 00       	nop
 a00:	03 00       	.word	0x0003	; ????
 a02:	92 20       	and	r9, r2
 a04:	08 7c       	andi	r16, 0xC8	; 200
 a06:	04 00       	.word	0x0004	; ????
 a08:	00 cc       	rjmp	.-2048   	; 0x20a <_ZN14HardwareSerial5writeEh+0x1e>
 a0a:	04 00       	.word	0x0004	; ????
 a0c:	00 03       	mulsu	r16, r16
 a0e:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x746>
	...
 a1a:	94 04       	cpc	r9, r4
 a1c:	00 00       	nop
 a1e:	b6 04       	cpc	r11, r6
 a20:	00 00       	nop
 a22:	01 00       	.word	0x0001	; ????
 a24:	69 00       	.word	0x0069	; ????
 a26:	00 00       	nop
 a28:	00 00       	nop
 a2a:	00 00       	nop
 a2c:	00 9c       	mul	r0, r0
 a2e:	04 00       	.word	0x0004	; ????
 a30:	00 b6       	in	r0, 0x30	; 48
 a32:	04 00       	.word	0x0004	; ????
 a34:	00 01       	movw	r0, r0
 a36:	00 68       	ori	r16, 0x80	; 128
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	be 00       	.word	0x00be	; ????
   2:	00 00       	nop
   4:	cc 04       	cpc	r12, r12
   6:	00 00       	nop
   8:	cc 04       	cpc	r12, r12
   a:	00 00       	nop
   c:	90 06       	cpc	r9, r16
   e:	00 00       	nop
  10:	90 06       	cpc	r9, r16
  12:	00 00       	nop
  14:	ea 06       	cpc	r14, r26
	...
