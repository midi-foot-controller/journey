JB_CPU_Usage_Basic.ino.elf:     file format elf32-avr

Contents of section .data:
 800100 c0c62d00 00401454 00401050 00000000  ..-..@.T.@.P....
 800110 0202f701 5903e901 f001ed01 ea010000  ....Y...........
 800120 00007102 8d015903 5803c602 27021302  ..q...Y.X...'...
 800130 42024c6f 6f70733a 20005469 6d653a20  B.Loops: .Time: 
 800140 005b6d73 5d00                        .[ms].          
Contents of section .text:
 0000 0c945d00 0c948500 0c948500 0c948500  ..].............
 0010 0c948500 0c948500 0c948500 0c948500  ................
 0020 0c948500 0c948500 0c948500 0c948500  ................
 0030 0c948500 0c948500 0c948500 0c948500  ................
 0040 0c94b103 0c948500 0c948500 0c948500  ................
 0050 0c948500 0c948500 0c948500 0c948500  ................
 0060 0c94fb03 0c948500 00000008 00020100  ................
 0070 00030407 00000000 00000000 00000000  ................
 0080 25002800 2b000000 00002400 27002a00  %.(.+.....$.'.*.
 0090 04040404 04040404 02020202 02020303  ................
 00a0 03030303 01020408 10204080 01020408  ......... @.....
 00b0 10200102 04081020 25051124 1fbecfef  . ..... %..$....
 00c0 d8e0debf cdbf11e0 a0e0b1e0 e6e4fde0  ................
 00d0 02c00590 0d92a634 b107d9f7 21e0a6e4  .......4....!...
 00e0 b1e001c0 1d92a13e b207e1f7 10e0cde5  .......>........
 00f0 d0e004c0 2197fe01 0e949606 cc35d107  ....!........5..
 0100 c9f70e94 ac050c94 a1060c94 000090e0  ................
 0110 fc01ec55 ff4f2491 fc01e057 ff4f8491  ...U.O$....W.O..
 0120 882399f0 90e0880f 991ffc01 ea57ff4f  .#...........W.O
 0130 a591b491 fc01e458 ff4f8591 94918fb7  .......X.O......
 0140 f894ec91 e22bec93 8fbf0895 90e0fc01  .....+..........
 0150 e859ff4f 2491fc01 ec55ff4f 3491fc01  .Y.O$....U.O4...
 0160 e057ff4f e491ee23 09f43cc0 222339f1  .W.O...#..<."#9.
 0170 233091f0 38f42130 a9f02230 01f584b5  #0..8.!0.."0....
 0180 8f7d12c0 273091f0 2830a1f0 2430b9f4  .}..'0..(0..$0..
 0190 80918000 8f7d03c0 80918000 8f778093  .....}.......w..
 01a0 80000dc0 84b58f77 84bd09c0 8091b000  .......w........
 01b0 8f7703c0 8091b000 8f7d8093 b000f0e0  .w.......}......
 01c0 ee0fff1f e458ff4f a591b491 9fb7f894  .....X.O........
 01d0 611104c0 8c913095 382302c0 ec913e2b  a.....0.8#....>+
 01e0 3c939fbf 0895af92 bf92cf92 df92ef92  <...............
 01f0 ff920f93 1f93cf93 df938c01 5c018ee0  ............\...
 0200 a80eb11c c42ed12c c0e0d0e0 e62ef12c  .......,.......,
 0210 cc15dd05 79f0b701 0c2e02c0 75956795  ....y.......u.g.
 0220 0a94e2f7 6170f501 81915f01 0e94a600  ....ap...._.....
 0230 2196eecf 61e0f801 85850e94 a60060e0  !...a.........`.
 0240 f8018585 df91cf91 1f910f91 ff90ef90  ................
 0250 df90cf90 bf90af90 0c94a600 3fb7f894  ............?...
 0260 8091ba01 9091bb01 a091bc01 b091bd01  ................
 0270 26b5a89b 05c02f3f 19f00196 a11db11d  &...../?........
 0280 3fbfba2f a92f982f 8827820f 911da11d  ?../././.'......
 0290 b11dbc01 cd0142e0 660f771f 881f991f  ......B.f.w.....
 02a0 4a95d1f7 08958f92 9f92af92 bf92cf92  J...............
 02b0 df92ef92 ff926b01 7c010e94 2e014b01  ......k.|.....K.
 02c0 5c01c114 d104e104 f104f1f0 0e942e01  \...............
 02d0 dc01cb01 88199909 aa09bb09 883e9340  .............>.@
 02e0 a105b105 70f321e0 c21ad108 e108f108  ....p.!.........
 02f0 88ee880e 83e0981e a11cb11c c114d104  ................
 0300 e104f104 19f7ddcf ff90ef90 df90cf90  ................
 0310 bf90af90 9f908f90 0895cf92 df92ef92  ................
 0320 ff920f93 1f93cf93 df936c01 7a018b01  ..........l.z...
 0330 c0e0d0e0 ce15df05 81f0d801 6d918d01  ............m...
 0340 d601ed91 fc910190 f081e02d c6010995  ...........-....
 0350 892b11f0 2196eecf 7e01c701 df91cf91  .+..!...~.......
 0360 1f910f91 ff90ef90 df90cf90 089585ed  ................
 0370 8093bc00 8091bc00 84fdfccf 10928b01  ................
 0380 08954091 6701262f 30e0240f 311d2132  ..@.g.&/0.$.1.!2
 0390 3105dcf4 20918b01 2430c9f4 fc0180e0  1... ...$0......
 03a0 90e08617 58f43091 67012191 dc01a95b  ....X.0.g.!....[
 03b0 be4fa30f b11d2c93 0196f3cf 80916701  .O....,.......g.
 03c0 680f6093 670180e0 089581e0 089582e0  h.`.g...........
 03d0 08950895 8fef9fef 08958fef 9fef0895  ................
 03e0 80914601 90e09195 81959109 0895cf93  ..F.............
 03f0 df93cb01 ea01642f 0e94c101 ce01df91  ......d/........
 0400 cf910895 cf93df93 1f92cdb7 deb76983  ..............i.
 0410 61e0ce01 01960e94 c10181e0 90e00f90  a...............
 0420 df91cf91 0895fc01 86898f3f 79f02185  ...........?y.!.
 0430 32856623 19f0232b 31f403c0 21303105  2.f#..#+1...!01.
 0440 11f461e0 01c060e0 0c94a600 0895ef92  ..a...`.........
 0450 ff921f93 cf93df93 ec01162f 7a01862f  .........../z../
 0460 0e948700 1e8bfa86 e986e881 f9810484  ................
 0470 f585e02d 60e0ce01 df91cf91 1f91ff90  ...-`...........
 0480 ef900994 0f931f93 cf93df93 ec01162f  .............../
 0490 042f61e0 413009f0 60e08b85 0e94a600  ./a.A0..`.......
 04a0 8c858f3f 19f060e0 0e94a600 023081f0  ...?..`......0..
 04b0 8c8184ff 02c048e0 0cc0612f 70e084e0  ......H...a/p...
 04c0 75956795 8a95e1f7 44e0ce01 0e94f300  u.g.....D.......
 04d0 44e0612f ce01df91 cf911f91 0f910c94  D.a/............
 04e0 f300dc01 ed91fc91 0684f785 e02d41e0  .............-A.
 04f0 099581e0 90e00895 dc01ed91 fc910684  ................
 0500 f785e02d 40e00994 cf93df93 cdb7deb7  ...-@...........
 0510 28970fb6 f894debf 0fbecdbf 40910401  (...........@...
 0520 50910501 60910601 70910701 4d835e83  P...`...p...M.^.
 0530 6f837887 40910801 50910901 60910a01  o.x.@...P...`...
 0540 70910b01 49835a83 6b837c83 2091d101  p...I.Z.k.|. ...
 0550 821710f0 8fef820f 3091d201 90e0fe01  ........0.......
 0560 e80ff91f 303121f4 243011f4 618101c0  ....01!.$0..a...
 0570 65816068 8aec91e0 28960fb6 f894debf  e.`h....(.......
 0580 0fbecdbf df91cf91 0c947c02 0f931f93  ..........|.....
 0590 cf93df93 ec014230 18f08c81 88608c83  ......B0.....`..
 05a0 4f836887 222329f0 413019f4 8c818460  O.h."#).A0.....`
 05b0 8c8364e6 70e080e0 90e00e94 53016c81  ..d.p.......S.l.
 05c0 64fd31c0 e881f981 0684f785 e02d42e0  d.1..........-B.
 05d0 63e0ce01 09958be4 96e40197 f1f7e881  c...............
 05e0 f9810684 f785e02d 42e063e0 ce010995  .......-B.c.....
 05f0 03e512e0 c8010197 f1f7e881 f9810684  ................
 0600 f785e02d 42e063e0 ce010995 c8010197  ...-B.c.........
 0610 f1f7e881 f9810684 f785e02d 42e062e0  ...........-B.b.
 0620 ce010995 17c06062 ce010e94 7c028be4  ......`b....|...
 0630 96e40197 f1f76c81 6062ce01 0e947c02  ......l.`b....|.
 0640 03e512e0 c8010197 f1f76c81 6062ce01  ..........l.`b..
 0650 0e947c02 c8010197 f1f76c81 6062ce01  ..|.......l.`b..
 0660 0e947c02 8bee90e0 0197f1f7 84e08d83  ..|.............
 0670 6ce0ce01 0e947c02 61e0ce01 0e947c02  l.....|.a.....|.
 0680 8be39fe1 0197f1f7 82e08e83 66e0ce01  ............f...
 0690 0e947c02 e881f981 0484f585 e02d6fef  ..|..........-o.
 06a0 ce01df91 cf911f91 0f910994 08950895  ................
 06b0 089580e0 90e00895 009769f0 fc010190  ..........i.....
 06c0 0020e9f7 3197af01 481b590b bc018aec  . ..1...H.Y.....
 06d0 91e00c94 8d0180e0 90e00895 8f929f92  ................
 06e0 af92bf92 0f931f93 cf93df93 cdb7deb7  ................
 06f0 a1970fb6 f894debf 0fbecdbf 19a24230  ..............B0
 0700 08f44ae0 8e010f5d 1f4f842e 912ca12c  ..J....].O...,.,
 0710 b12ca501 94010e94 7406e62f b901ca01  .,......t../....
 0720 01501109 ea3014f4 e05d01c0 e95cd801  .P...0...]...\..
 0730 ec93232b 242b252b 61f7c801 0e945c03  ..#+$+%+a.....\.
 0740 a1960fb6 f894debf 0fbecdbf df91cf91  ................
 0750 1f910f91 bf90af90 9f908f90 08950e94  ................
 0760 9c061f92 0f920fb6 0f921124 2f933f93  ...........$/.?.
 0770 8f939f93 af93bf93 8091b601 9091b701  ................
 0780 a091b801 b091b901 3091b501 23e0230f  ........0...#.#.
 0790 2d3720f4 0196a11d b11d05c0 26e8230f  -7 .........&.#.
 07a0 0296a11d b11d2093 b5018093 b6019093  ...... .........
 07b0 b701a093 b801b093 b9018091 ba019091  ................
 07c0 bb01a091 bc01b091 bd010196 a11db11d  ................
 07d0 8093ba01 9093bb01 a093bc01 b093bd01  ................
 07e0 bf91af91 9f918f91 3f912f91 0f900fbe  ........?./.....
 07f0 0f901f90 18951f92 0f920fb6 0f921124  ...............$
 0800 2f933f93 4f935f93 6f937f93 8f939f93  /.?.O._.o.......
 0810 af93bf93 ef93ff93 8091b900 887f8036  ...............6
 0820 09f49cc0 68f58832 09f45bc0 90f48031  ....h..2..[....1
 0830 09f454c0 38f48823 09f4f2c0 883009f4  ..T.8..#.....0..
 0840 4dc0f2c0 883109f4 4cc08032 09f45dc0  M....1..L..2..].
 0850 ebc08034 09f468c0 48f48033 09f455c0  ...4..h.H..3..U.
 0860 883309f0 e1c08093 8a01d4c0 803509f4  .3...........5..
 0870 4fc08835 09f45dc0 883409f0 d5c0d2c0  O..5..]..4......
 0880 883909f4 c3c0a8f4 883709f4 67c038f4  .9.......7..g.8.
 0890 883609f4 63c08037 09f460c0 c5c08838  .6..c..7..`....8
 08a0 09f4b4c0 803909f4 5fc08038 09f0bcc0  .....9.._..8....
 08b0 5bc0803b 09f484c0 38f4803a 09f466c0  [..;....8..:..f.
 08c0 883a09f4 7dc0b0c0 803c09f4 a3c0883c  .:..}....<.....<
 08d0 09f4a0c0 883b09f4 86c0a6c0 8091b001  .....;..........
 08e0 10c09091 af018091 ae019817 70f5e091  ............p...
 08f0 af0181e0 8e0f8093 af01f0e0 e257fe4f  .............W.O
 0900 80818093 bb0085ec 82c08093 8a018ac0  ................
 0910 e091af01 81e08e0f 8093af01 8091bb00  ................
 0920 f0e0e257 fe4f8083 9091af01 8091ae01  ...W.O..........
 0930 6ac0e091 af0181e0 8e0f8093 af018091  j...............
 0940 bb00f0e0 e257fe4f 80838091 8d018111  .....W.O........
 0950 69c081e0 80938c01 84ea5dc0 83e08093  i.........].....
 0960 8b011092 8901cfcf 80918901 803208f0  .............2..
 0970 4dc0e091 890181e0 8e0f8093 89018091  M...............
 0980 bb00f0e0 e759fe4f 8083bdcf 85ec8093  .....Y.O........
 0990 bc001092 8b018091 89018032 30f4e091  ...........20...
 09a0 8901f0e0 e759fe4f 10826091 890170e0  .....Y.O..`...p.
 09b0 89e691e0 e0e0f0e0 09951092 890134c0  ..............4.
 09c0 84e08093 8b011092 68011092 6701e0e0  ........h...g...
 09d0 f0e00995 80916701 811105c0 81e08093  ......g.........
 09e0 67011092 4701e091 680181e0 8e0f8093  g...G...h.......
 09f0 6801f0e0 e95bfe4f 80818093 bb009091  h....[.O........
 0a00 68018091 67019817 08f47dcf 85e88093  h...g.....}.....
 0a10 bc000ac0 85ec8093 bc001092 8b0104c0  ................
 0a20 10928a01 0e94b701 ff91ef91 bf91af91  ................
 0a30 9f918f91 7f916f91 5f914f91 3f912f91  ......o._.O.?./.
 0a40 0f900fbe 0f901f90 18950f93 1f93cf93  ................
 0a50 df931092 c1011092 c00188ee 93e0a0e0  ................
 0a60 b0e08093 c2019093 c301a093 c401b093  ................
 0a70 c50180e1 91e09093 bf018093 be011092  ................
 0a80 cd011092 cc0182e2 91e09093 cb018093  ................
 0a90 ca018ee0 8093d501 8fef8093 d6018ce0  ................
 0aa0 8093d701 84e08093 d80185e0 8093d901  ................
 0ab0 86e08093 da0187e0 8093db01 88e08093  ................
 0ac0 dc0189e0 8093dd01 8ae08093 de018be0  ................
 0ad0 8093df01 08ed11e0 ccedd1e0 f8018191  ................
 0ae0 8f010e94 8700c017 d107c1f7 00ee11e0  ................
 0af0 89910e94 87000c17 1d07d1f7 8091d501  ................
 0b00 0e948700 8091d601 8f3f11f0 0e948700  .........?......
 0b10 8091d701 0e948700 80e18093 ce0160e0  ..............`.
 0b20 8091d501 0e94a600 60e08091 d7010e94  ........`.......
 0b30 a6008091 d6018f3f 19f060e0 0e94a600  .......?..`.....
 0b40 8fef8093 e0011092 d4011092 d301df91  ................
 0b50 cf911f91 0f910895 789484b5 826084bd  ........x....`..
 0b60 84b58160 84bd85b5 826085bd 85b58160  ...`.....`.....`
 0b70 85bd8091 6e008160 80936e00 10928100  ....n..`..n.....
 0b80 80918100 82608093 81008091 81008160  .....`.........`
 0b90 80938100 80918000 81608093 80008091  .........`......
 0ba0 b1008460 8093b100 8091b000 81608093  ...`.........`..
 0bb0 b0008091 7a008460 80937a00 80917a00  ....z..`..z...z.
 0bc0 82608093 7a008091 7a008160 80937a00  .`..z...z..`..z.
 0bd0 80917a00 80688093 7a001092 c10068ee  ..z..h..z.....h.
 0be0 73e080e0 90e00e94 530120e0 42e060e1  s.......S. .B.`.
 0bf0 8aec91e0 0e94c602 2fb7f894 8091b601  ......../.......
 0c00 9091b701 a091b801 b091b901 2fbf8093  ............/...
 0c10 b1019093 b201a093 b301b093 b401cbe3  ................
 0c20 dfe100e0 10e08091 00019091 0101a091  ................
 0c30 0201b091 0301ac01 bd014150 51096109  ..........APQ.a.
 0c40 71094093 00015093 01016093 02017093  q.@...P...`...p.
 0c50 0301892b 8a2b8b2b 09f03fc0 8fb7f894  ...+.+.+..?.....
 0c60 c090b601 d090b701 e090b801 f090b901  ................
 0c70 8fbf61e0 8aec91e0 0e947c02 ce010197  ..a.......|.....
 0c80 f1f780e0 0e948402 82e391e0 0e945c03  ..............\.
 0c90 4ae060ec 76ec8de2 90e00e94 6e0381e0  J.`.v.......n...
 0ca0 0e948402 8ae391e0 0e945c03 8091b101  ..........\.....
 0cb0 9091b201 a091b301 b091b401 a7019601  ................
 0cc0 281b390b 4a0b5b0b ca01b901 4ae00e94  (.9.J.[.....J...
 0cd0 6e0381e4 91e00e94 5c030115 110509f4  n.......\.......
 0ce0 a2cf0e94 00009fcf a1e21a2e aa1bbb1b  ................
 0cf0 fd010dc0 aa1fbb1f ee1fff1f a217b307  ................
 0d00 e407f507 20f0a21b b30be40b f50b661f  .... .........f.
 0d10 771f881f 991f1a94 69f76095 70958095  w.......i.`.p...
 0d20 90959b01 ac01bd01 cf010895 ee0fff1f  ................
 0d30 0590f491 e02d0994 81e090e0 f8940c94  .....-..........
 0d40 a106f894 ffcf                        ......          
Contents of section .comment:
 0000 4743433a 2028474e 55292035 2e342e30  GCC: (GNU) 5.4.0
 0010 00                                   .               
Contents of section .note.gnu.avr.deviceinfo:
 0000 04000000 2d000000 01000000 41565200  ....-.......AVR.
 0010 00000000 00800000 00010000 00080000  ................
 0020 00000000 00040000 08000000 01000000  ................
 0030 0061746d 65676133 32387000 00000000  .atmega328p.....
Contents of section .debug_aranges:
 0000 2c000000 0200f405 00000400 00000000  ,...............
 0010 0e010000 3c090000 4a0a0000 0e010000  ....<...J.......
 0020 580b0000 90010000 00000000 00000000  X...............
 0030 1c000000 02004e28 00000400 00000000  ......N(........
 0040 420d0000 04000000 00000000 00000000  B...............
 0050 1c000000 0200fc28 00000400 00000000  .......(........
 0060 e80c0000 44000000 00000000 00000000  ....D...........
 0070 1c000000 0200aa29 00000400 00000000  .......)........
 0080 c6000000 16000000 00000000 00000000  ................
 0090 1c000000 0200582a 00000400 00000000  ......X*........
 00a0 dc000000 10000000 00000000 00000000  ................
 00b0 1c000000 0200062b 00000400 00000000  .......+........
 00c0 ec000000 16000000 00000000 00000000  ................
 00d0 1c000000 0200b42b 00000400 00000000  .......+........
 00e0 2c0d0000 0c000000 00000000 00000000  ,...............
Contents of section .debug_info:
 0000 f0050000 02000000 00000401 00000000  ................
 0010 00000000 020f0000 00010803 17000000  ................
 0020 02070414 00000005 1b000000 ff030006  ................
 0030 20000000 00002200 00000105 03000081   .....".........
 0040 00072900 00000000 14000000 010503c6  ..).............
 0050 00800008 2e000000 00001400 00000105  ................
 0060 03c00080 00093500 00000000 14000000  ......5.........
 0070 010503c1 0080000a 3c000000 00001400  ........<.......
 0080 00000105 03c20080 000b4300 00000000  ..........C.....
 0090 1b000000 010503c4 0080000c 49000000  ............I...
 00a0 00001400 00000105 03bd0080 000d4f00  ..............O.
 00b0 00000000 14000000 010503b8 0080000e  ................
 00c0 54000000 00001400 00000105 03bc0080  T...............
 00d0 000f5900 00000000 14000000 010503b9  ..Y.............
 00e0 00800010 5e000000 00001400 00000105  ....^...........
 00f0 03bb0080 00116300 00000000 14000000  ......c.........
 0100 010503ba 00800012 68000000 00001400  ........h.......
 0110 00000105 036f0080 00136f00 00000000  .....o....o.....
 0120 14000000 01050336 00800014 75000000  .......6....u...
 0130 00001400 00000105 03800080 00157c00  ..............|.
 0140 00000000 14000000 01050381 00800016  ................
 0150 83000000 00001400 00000105 03820080  ................
 0160 00178a00 00000000 1b000000 01050384  ................
 0170 00800018 90000000 00001b00 00000105  ................
 0180 03880080 00199600 00000000 1b000000  ................
 0190 0105038a 0080001a 9c000000 00001b00  ................
 01a0 00000105 03860080 001ba100 00000000  ................
 01b0 14000000 01050343 0080001c a7000000  .......C........
 01c0 00001400 00000105 03700080 001dae00  .........p......
 01d0 00000000 14000000 01050337 0080001e  ...........7....
 01e0 b4000000 00001400 00000105 03b00080  ................
 01f0 001fbb00 00000000 14000000 010503b1  ................
 0200 00800020 c2000000 00001400 00000105  ... ............
 0210 03b20080 0021c800 00000000 14000000  .....!..........
 0220 010503b4 00800022 ce000000 00001400  ......."........
 0230 00000105 03b30080 0023d400 00000000  .........#......
 0240 14000000 010503b6 00800024 d9000000  ...........$....
 0250 00001400 00000105 03430080 0025df00  .........C...%..
 0260 00000000 14000000 0105037c 00800026  ...........|...&
 0270 e5000000 00001b00 00000105 03780080  .............x..
 0280 0027e900 00000000 14000000 0105037a  .'.............z
 0290 00800028 f0000000 00001400 00000105  ...(............
 02a0 037b0080 0029f700 00000000 14000000  .{...)..........
 02b0 0105037e 0080002a fd000000 00001400  ...~...*........
 02c0 00000105 03500080 002b0201 00000000  .....P...+......
 02d0 14000000 0105037f 0080002c 08010000  ...........,....
 02e0 00001400 00000105 03250080 002d0e01  .........%...-..
 02f0 00000000 14000000 01050324 0080002e  ...........$....
 0300 13010000 00001400 00000105 03230080  .............#..
 0310 002f1801 00000000 14000000 01050328  ./.............(
 0320 00800030 1e010000 00001400 00000105  ...0............
 0330 03270080 00312301 00000000 14000000  .'...1#.........
 0340 01050326 00800032 28010000 00001400  ...&...2(.......
 0350 00000105 032b0080 00332e01 00000000  .....+...3......
 0360 14000000 0105032a 00800034 33010000  .......*...43...
 0370 00001400 00000105 03290080 00353801  .........)...58.
 0380 00000000 14000000 01050348 00800036  ...........H...6
 0390 3e010000 00001400 00000105 03470080  >............G..
 03a0 00374401 00000000 14000000 01050346  .7D............F
 03b0 00800038 4a010000 00001400 00000105  ...8J...........
 03c0 03450080 00395101 00000000 14000000  .E...9Q.........
 03d0 01050344 0080003a 58010000 00001400  ...D...:X.......
 03e0 00000105 036e0080 003b5f01 00000000  .....n...;_.....
 03f0 14000000 01050335 0080003c 65010000  .......5...<e...
 0400 00001400 00000105 03430080 003d6b01  .........C...=k.
 0410 00000000 14000000 01050369 0080003e  ...........i...>
 0420 71010000 00001400 00000105 033d0080  q............=..
 0430 003f7701 00000000 14000000 0105033c  .?w............<
 0440 00800040 7c010000 00001400 00000105  ...@|...........
 0450 03680080 00418201 00000000 14000000  .h...A..........
 0460 0105036d 00800042 89010000 00001400  ...m...B........
 0470 00000105 036c0080 00439001 00000000  .....l...C......
 0480 14000000 0105036b 00800044 97010000  .......k...D....
 0490 00001400 00000105 033b0080 00459d01  .........;...E..
 04a0 00000000 14000000 0105034e 00800046  ...........N...F
 04b0 a2010000 00001400 00000105 034d0080  .............M..
 04c0 0047a701 00000000 14000000 0105034c  .G.............L
 04d0 00800048 ac010000 00001400 00000105  ...H............
 04e0 03600080 0049b301 00000000 14000000  .`...I..........
 04f0 01050364 0080004a b7010000 00001400  ...d...J........
 0500 00000105 03660080 004bbe01 00000000  .....f...K......
 0510 14000000 01050361 0080004c c4010000  .......a...L....
 0520 00001400 00000105 035f0080 004dc901  ........._...M..
 0530 00000000 1b000000 0105035d 0080004e  ...........]...N
 0540 cc010000 00001400 00000105 03570080  .............W..
 0550 004fd301 00000000 14000000 01050355  .O.............U
 0560 00800050 d9010000 00001400 00000105  ...P............
 0570 03540080 0051df01 00000000 14000000  .T...Q..........
 0580 01050353 00800052 e4010000 00001400  ...S...R........
 0590 00000105 034b0080 0053eb01 00000000  .....K...S......
 05a0 14000000 0105034a 00800054 f2010000  .......J...T....
 05b0 00001400 00000105 033e0080 0055f901  .........>...U..
 05c0 00000000 1b000000 01050341 00800056  ...........A...V
 05d0 fe010000 00001400 00000105 03400080  .............@..
 05e0 00570302 00000000 14000000 0105033f  .W.............?
 05f0 00800000 56220000 0200a205 00000401  ....V"..........
 0600 fa040000 02180400 00900000 00000000  ................
 0610 00000000 001a0000 00020268 0700002f  ...........h.../
 0620 00000003 3a000000 3a000000 04000502  ....:...:.......
 0630 05696e74 00061406 00000409 25410000  .int........%A..
 0640 00270100 00070e06 00002701 00000223  .'........'....#
 0650 0001084c 02000009 283a0000 00022302  ...L....(:....#.
 0660 0309f605 00000467 018b0500 00018200  .......g........
 0670 00009300 00000aaf 07000001 0be90500  ................
 0680 000b3a00 00000009 f6050000 043e018b  ..:..........>..
 0690 05000001 a8000000 b4000000 0aaf0700  ................
 06a0 00010bf0 05000000 0c590400 0004cb01  .........Y......
 06b0 8b050000 0301ca00 0000db00 00000aaf  ................
 06c0 07000001 0be90500 000b5101 00000009  ..........Q.....
 06d0 27020000 0934018b 05000001 f0000000  '....4..........
 06e0 fc000000 0aaf0700 00010bf0 05000000  ................
 06f0 0d270200 00042201 8b050000 01021001  .'....".........
 0700 41000000 01150100 000aaf07 0000010b  A...............
 0710 650f0000 0b8b0500 0000000e 02250000  e............%..
 0720 000f0207 28060000 10020800 00022d01  ....(.........-.
 0730 000008c5 51010000 11a60200 00001178  ....Q..........x
 0740 07000001 00121a03 00000f7e 5c010000  ...........~\...
 0750 0f0108d3 04000013 4c434400 0b08c725  ........LCD....%
 0760 03000025 03000014 25030000 02230001  ...%....%....#..
 0770 15ec0200 00082102 51010000 02230402  ......!.Q....#..
 0780 15a00400 00082302 51010000 02230502  ......#.Q....#..
 0790 151a0200 00082502 51010000 02230602  ......%.Q....#..
 07a0 15e20700 00082602 51010000 02230702  ......&.Q....#..
 07b0 15780400 00082702 51010000 02230802  .x....'.Q....#..
 07c0 15110800 00082802 34010000 02230902  ......(.4....#..
 07d0 16ba0400 0007de01 01ed0100 00f40100  ................
 07e0 000a3607 00000100 17ec0700 00075201  ..6...........R.
 07f0 01010602 00000d02 00000a36 07000001  ...........6....
 0800 00168107 000007c0 01011e02 00002f02  ............../.
 0810 00000a36 07000001 0b510100 000b5101  ...6.....Q....Q.
 0820 00000016 c3030000 07400101 40020000  .........@..@...
 0830 47020000 0a360700 00010018 27020000  G....6......'...
 0840 077b0101 8b050000 01021000 63010000  .{..........c...
 0850 01650200 00710200 000a3607 0000010b  .e...q....6.....
 0860 51010000 0019e408 00000770 01010301  Q..........p....
 0870 84020000 90020000 0a360700 00010b51  .........6.....Q
 0880 01000000 16f50300 0007b401 01a10200  ................
 0890 00a80200 000a3607 00000100 1ab70200  ......6.........
 08a0 00075b01 01021004 63010000 01c10200  ..[.....c.......
 08b0 00d70200 000a3607 0000010b 51010000  ......6.....Q...
 08c0 0b510100 000b5101 0000001b 57060000  .Q....Q.....W...
 08d0 08050201 01021006 63010000 01f10200  ........c.......
 08e0 00fd0200 000a3607 0000010b 51010000  ......6.....Q...
 08f0 001cd408 000008f2 01010102 10056301  ..............c.
 0900 00000113 0300000a 36070000 010b5101  ........6.....Q.
 0910 00000b34 01000000 001d1406 0000018d  ...4............
 0920 0300001a 34020000 095a0101 02100325  ....4....Z.....%
 0930 03000001 48030000 4f030000 0a971800  ....H...O.......
 0940 0001001e e3030000 093f013a 00000001  .........?.:....
 0950 02100225 03000001 6c030000 73030000  ...%....l...s...
 0960 0a971800 0001001f 01c30300 00092e22  ..............."
 0970 03000001 01850300 000a9718 00000100  ................
 0980 0006a708 0000170e 38850500 00680500  ........8....h..
 0990 00146805 00000223 000108ac 0600000e  ..h....#........
 09a0 b5510100 0002230b 03087606 00000eb6  .Q....#...v.....
 09b0 51010000 02230c03 08940700 000eb751  Q....#.........Q
 09c0 01000002 230d0308 8b020000 0eb86e05  ....#.........n.
 09d0 00000223 0e0308c4 0600000e b9510100  ...#.........Q..
 09e0 00022316 03207e04 00000101 0210078d  ..#.. ~.........
 09f0 03000001 01090400 00150400 000a7307  ..............s.
 0a00 0000010b 51010000 00199006 0000023a  ....Q..........:
 0a10 01010301 28040000 2f040000 0a730700  ....(.../....s..
 0a20 00010019 98030000 02450101 03014204  .........E....B.
 0a30 00005304 00000a73 07000001 0b510100  ..S....s.....Q..
 0a40 000b5101 00000021 7e060000 02f10103  ..Q....!~.......
 0a50 01650400 00a80400 000a7307 0000010b  .e........s.....
 0a60 51010000 0b510100 000b5101 00000b51  Q....Q....Q....Q
 0a70 0100000b 51010000 0b510100 000b5101  ....Q....Q....Q.
 0a80 00000b51 0100000b 51010000 0b510100  ...Q....Q....Q..
 0a90 000b5101 00000b51 01000000 16c30300  ..Q....Q........
 0aa0 00024301 01b90400 00f20400 000a7307  ..C...........s.
 0ab0 0000010b 51010000 0b510100 000b5101  ....Q....Q....Q.
 0ac0 00000b51 0100000b 51010000 0b510100  ...Q....Q....Q..
 0ad0 000b5101 00000b51 0100000b 51010000  ..Q....Q....Q...
 0ae0 0b510100 00001a57 06000002 bd010102  .Q.....W........
 0af0 10068d03 0000010b 05000017 0500000a  ................
 0b00 73070000 010b5101 0000001a d4080000  s.....Q.........
 0b10 02a70101 0210058d 03000001 30050000  ............0...
 0b20 41050000 0a730700 00010b51 0100000b  A....s.....Q....
 0b30 34010000 00223a02 00000286 01010210  4....":.........
 0b40 078d0300 00015605 00000a73 07000001  ......V....s....
 0b50 0b510100 000b5101 00000000 234c4344  .Q....Q.....#LCD
 0b60 00012451 0100007e 05000025 7e050000  ..$Q...~...%~...
 0b70 07000f02 079d0200 00261406 00000112  .........&......
 0b80 96020000 10d82d01 00000f01 06dc0400  ......-.........
 0b90 00064a06 00000c0b 31250300 00e90500  ..J.....1%......
 0ba0 00142503 00000223 0001088b 0700000b  ..%....#........
 0bb0 34e90500 00022304 02083a08 00000b35  4.....#...:....5
 0bc0 e9050000 02230802 27c30300 000b3f01  .....#..'.....?.
 0bd0 01e10500 000a470a 00000100 000f0407  ......G.........
 0be0 23060000 0e02f605 00002896 05000006  #.........(.....
 0bf0 9a080000 0c112125 0300000e 07000014  ......!%........
 0c00 9d050000 02230001 16c30300 00063101  .....#........1.
 0c10 01250600 002c0600 000a6b0a 00000100  .%...,....k.....
 0c20 1b340200 00060f01 01010210 03fb0500  .4..............
 0c30 00014606 00004d06 00000a6b 0a000001  ..F...M....k....
 0c40 0018d003 00000604 01013a00 00000102  ..........:.....
 0c50 1006fb05 0000016b 06000072 0600000a  .......k...r....
 0c60 6b0a0000 01001e7f 03000006 f4013a00  k.............:.
 0c70 00000102 1005fb05 0000018f 06000096  ................
 0c80 0600000a 6b0a0000 01001eb0 04000006  ....k...........
 0c90 ec013a00 00000102 1004fb05 000001b3  ..:.............
 0ca0 060000ba 0600000a 6b0a0000 01001e27  ........k......'
 0cb0 02000006 da018b05 00000102 1001fb05  ................
 0cc0 000001d7 060000e8 0600000a 6b0a0000  ............k...
 0cd0 010b650f 00000b8b 05000000 0d270200  ..e..........'..
 0ce0 0006c101 8b050000 01021000 fb050000  ................
 0cf0 01010700 000a6b0a 0000010b 51010000  ......k.....Q...
 0d00 00001205 0600000f 802d0100 00124c04  .........-....L.
 0d10 0000127e 51010000 12fc0500 000f82e9  ...~Q...........
 0d20 0500000f 01024c03 00000e02 63010000  ......L.....c...
 0d30 29dc0100 00014a07 00005507 00002abf  ).....J...U...*.
 0d40 06000055 07000001 00283607 000029f4  ...U.....(6...).
 0d50 01000001 68070000 73070000 2abf0600  ....h...s...*...
 0d60 00550700 0001000e 028d0300 002bf103  .U...........+..
 0d70 00000286 01890700 00aa0700 002abf06  .............*..
 0d80 0000aa07 0000012c e6020000 02865101  .......,......Q.
 0d90 00002d02 04000002 86510100 00002873  ..-......Q....(s
 0da0 0700000e 02410000 00296d00 000001c3  .....A...)m.....
 0db0 070000e2 0700002a bf060000 e2070000  .......*........
 0dc0 012e6e00 0467e905 00002ca2 08000004  ..n..g....,.....
 0dd0 673a0000 000028af 07000029 93000000  g:....(....)....
 0de0 01f50700 000b0800 002abf06 0000e207  .........*......
 0df0 0000012e 73747200 043ef005 00000029  ....str..>.....)
 0e00 15040000 01190800 00240800 002abf06  .........$...*..
 0e10 0000aa07 00000100 292f0400 00013208  ........)/....2.
 0e20 00006108 00002abf 060000aa 07000001  ..a...*.........
 0e30 2fe60200 00024501 51010000 2f080200  /.....E.Q.../...
 0e40 00024501 51010000 30316900 02470151  ..E.Q...01i..G.Q
 0e50 01000000 0029b400 0000016f 080000af  .....).....o....
 0e60 0800002a bf060000 e2070000 012e6e00  ...*..........n.
 0e70 04cbe905 00002ca2 08000004 cb510100  ......,......Q..
 0e80 00326275 660004cd af080000 32737472  .2buf.......2str
 0e90 0004cebf 08000030 32630004 d6960500  .......02c......
 0ea0 00000024 96050000 bf080000 257e0500  ...$........%~..
 0eb0 0020000e 02960500 0029db00 000003d3  . .......)......
 0ec0 080000e9 0800002a bf060000 e2070000  .......*........
 0ed0 012e7374 72000934 f0050000 00290d02  ..str..4.....)..
 0ee0 000001f7 0800002e 0900002a bf060000  ...........*....
 0ef0 55070000 012e636f 6c0007c0 51010000  U.....col...Q...
 0f00 2e726f77 0007c051 0100002d 60080000  .row...Q...-`...
 0f10 07c24309 00002d3b 04000007 c3480900  ..C...-;.....H..
 0f20 0000243e 0900003e 09000025 7e050000  ..$>...>...%~...
 0f30 03002819 07000028 2e090000 282e0900  ..(....(....(...
 0f40 0033a303 0000011d 01013c0a 00002e70  .3........<....p
 0f50 696e0001 1d510100 002c0204 0000011d  in...Q...,......
 0f60 51010000 32626974 00011f51 0100002d  Q...2bit...Q...-
 0f70 44070000 01205101 00003272 65670001  D.... Q...2reg..
 0f80 213c0a00 00326f75 74000121 3c0a0000  !<...2out..!<...
 0f90 34ad0900 002d5104 00000136 51010000  4....-Q....6Q...
 0fa0 0034be09 00002d51 04000001 30510100  .4....-Q....0Q..
 0fb0 000034cf 0900002d 51040000 012a5101  ..4....-Q....*Q.
 0fc0 00000034 eb090000 2d640300 0001270e  ...4....-d....'.
 0fd0 0700002d 1a060000 01270e07 00000034  ...-.....'.....4
 0fe0 070a0000 2d640300 0001260e 0700002d  ....-d....&....-
 0ff0 1a060000 01260e07 00000034 230a0000  .....&.....4#...
 1000 2d640300 0001200e 0700002d 1a060000  -d.... ....-....
 1010 01205101 00000030 2d640300 00011f0e  . Q....0-d......
 1020 0700002d 1a060000 011f5101 00000000  ...-......Q.....
 1030 0e02420a 00003551 0100000e 029d0500  ..B...5Q........
 1040 0029d405 0000035b 0a000066 0a00002a  .).....[...f...*
 1050 bf060000 660a0000 01002847 0a00000e  ....f.....(G....
 1060 02fb0500 00291406 0000017f 0a00008a  .....)..........
 1070 0a00002a bf060000 8a0a0000 0100286b  ...*..........(k
 1080 0a000029 53040000 019d0a00 002b0b00  ...)S........+..
 1090 002abf06 0000aa07 0000012c fb030000  .*.........,....
 10a0 02f15101 00002e72 730002f1 51010000  ..Q....rs...Q...
 10b0 2e727700 02f15101 00002c2d 02000002  .rw...Q...,-....
 10c0 f1510100 002e6430 0002f251 0100002e  .Q....d0...Q....
 10d0 64310002 f2510100 002e6432 0002f251  d1...Q....d2...Q
 10e0 0100002e 64330002 f2510100 002e6434  ....d3...Q....d4
 10f0 0002f351 0100002e 64350002 f3510100  ...Q....d5...Q..
 1100 002e6436 0002f351 0100002e 64370002  ..d6...Q....d7..
 1110 f3510100 00326900 02f55101 00000029  .Q...2i...Q....)
 1120 2f020000 01390b00 00440b00 002abf06  /....9...D...*..
 1130 00005507 00000100 29a80400 0001520b  ..U.....).....R.
 1140 0000c20b 00002abf 060000aa 07000001  ......*.........
 1150 2e727300 02435101 00002c2d 02000002  .rs..CQ...,-....
 1160 43510100 002e6430 00024451 0100002e  CQ....d0..DQ....
 1170 64310002 44510100 002e6432 00024451  d1..DQ....d2..DQ
 1180 0100002e 64330002 44510100 002e6434  ....d3..DQ....d4
 1190 00024551 0100002e 64350002 45510100  ..EQ....d5..EQ..
 11a0 002e6436 00024551 0100002e 64370002  ..d6..EQ....d7..
 11b0 45510100 0000360d 07000001 0101e50b  EQ....6.........
 11c0 00002ceb 0400000d 2a3a0000 002cb406  ..,.....*:...,..
 11d0 00000d2a 3a000000 00374d09 00000e01  ...*:....7M.....
 11e0 00004c01 00000392 200201b6 0c000038  ..L..... ......8
 11f0 5a090000 00000000 39700900 0001623a  Z.......9p....b:
 1200 7b090000 21000000 3a860900 00340000  {...!...:....4..
 1210 003b9109 00003c65 09000001 3d0e0100  .;....<e....=...
 1220 00180100 00460c00 003a240a 00004c00  .....F...:$...L.
 1230 0000392f 0a000001 62003d18 01000020  ..9/....b.=.... 
 1240 01000066 0c00003a 0c0a0000 a3000000  ...f...:........
 1250 3a170a00 00210000 00003d24 01000034  :....!....=$...4
 1260 01000086 0c00003a f0090000 ce000000  .......:........
 1270 3afb0900 00340000 00003d34 0100003e  :....4....=4...>
 1280 010000a2 0c00003a d4090000 e6000000  .......:........
 1290 3bdf0900 00003e3e 0100004c 0100003a  ;.....>>...L...:
 12a0 a1090000 fe000000 00003374 03000001  ..........3t....
 12b0 4b0101cf 0c00002c 51060000 014b5101  K......,Q....KQ.
 12c0 00000036 56070000 010101e7 0c00002d  ...6V..........-
 12d0 51060000 014b5101 0000003f 37070000  Q....KQ....?7...
 12e0 018a014c 010000e6 01000003 92200201  ...L......... ..
 12f0 3c0e0000 4070696e 00018a51 01000011  <...@pin...Q....
 1300 01000041 76616c00 018a5101 00000166  ...Aval...Q....f
 1310 42510600 00018c51 01000001 62436269  BQ.....Q....bCbi
 1320 7400018d 51010000 af010000 44440700  t...Q.......DD..
 1330 00018e51 010000db 01000043 6f757400  ...Q.......Cout.
 1340 018f3c0a 0000ee01 00004451 04000001  ..<.......DQ....
 1350 99510100 00060200 003d4c01 00005601  .Q.......=L...V.
 1360 00008f0d 00004464 03000001 8c0e0700  ......Dd........
 1370 00190200 00421a06 0000018c 51010000  .....B......Q...
 1380 0162003d 56010000 5e010000 bb0d0000  .b.=V...^.......
 1390 44640300 00018d0e 070000b6 02000044  Dd.............D
 13a0 1a060000 018d5101 0000af01 0000003d  ......Q........=
 13b0 5e010000 66010000 e70d0000 44640300  ^...f.......Dd..
 13c0 00018e0e 07000053 03000044 1a060000  .......S...D....
 13d0 018e5101 0000db01 00000045 b60c0000  ..Q........E....
 13e0 70010000 be010000 0195130e 000038c3  p.............8.
 13f0 0c0000f0 0300003e a4010000 a8010000  .......>........
 1400 3bdb0c00 0000003e be010000 cc010000  ;......>........
 1410 44640300 0001970e 07000003 04000044  Dd.............D
 1420 1a060000 01970e07 0000ee01 00000000  ................
 1430 46240800 00e60100 005c0200 001b0400  F$.......\......
 1440 00560e00 0001cf0e 00003832 080000b2  .V........82....
 1450 04000038 3c080000 f8040000 38480800  ...8<.......8H..
 1460 00240500 003d0c02 00003402 0000910e  .$...=....4.....
 1470 00003a55 08000050 05000047 30020000  ..:U...P...G0...
 1480 e70c0000 00480b08 00003402 00000000  .....H....4.....
 1490 0000024b 01381908 00007b05 0000493e  ...K.8....{...I>
 14a0 020000e7 0c0000bd 0e00004a 01660131  ...........J.f.1
 14b0 004b5c02 000001e7 0c00004a 01660130  .K\........J.f.0
 14c0 0000004c b5080000 034f01e9 0500005c  ...L.....O.....\
 14d0 020000a6 02000003 92200201 140f0000  ......... ......
 14e0 436d0003 50e90500 00b10500 00445104  Cm..P........DQ.
 14f0 00000351 51010000 cf050000 4d740003  ...QQ.......Mt..
 1500 51510100 00016200 4eaf0200 00141c01  QQ....b.N.......
 1510 4fe00200 00036a01 a6020000 1a030000  O.....j.........
 1520 ee050000 01650f00 00406d73 00036ae9  .....e...@ms..j.
 1530 0500006b 06000044 44060000 036c2407  ...k...DD....l$.
 1540 00009f06 000047be 020000cf 0e000047  ......G........G
 1550 d0020000 cf0e0000 000e026b 0f000028  ...........k...(
 1560 51010000 50fc0000 001a0300 006e0300  Q...P........n..
 1570 00e10600 008a0f00 0001d50f 000051bf  ..............Q.
 1580 060000e2 07000001 5e070000 52a50600  ........^...R...
 1590 00042265 0f000094 07000052 a3070000  .."e.......R....
 15a0 04228b05 0000f407 0000436e 0004248b  ."........Cn..$.
 15b0 05000050 08000053 50030000 4a066893  ...P...SP...J.h.
 15c0 01699301 027c0000 00549c06 00000571  .i...|...T.....q
 15d0 01016e03 00008203 00000392 20020155  ..n......... ..U
 15e0 84030000 01510100 0001011e 1000002f  .....Q........./
 15f0 db020000 052e0165 0f00002f 6d030000  .......e.../m...
 1600 052e0151 01000031 69000530 01510100  ...Q...1i..0.Q..
 1610 00005683 06000005 2e010151 01000001  ..V........Q....
 1620 66100000 2fdb0200 00052e01 650f0000  f.../.......e...
 1630 2f6d0300 00052e01 51010000 31690005  /m......Q...1i..
 1640 30015101 00003057 07100000 57fb0f00  0.Q...0W....W...
 1650 00303b13 10000000 0000371e 10000082  .0;.......7.....
 1660 030000d2 03000003 92200201 bb100000  ......... ......
 1670 38301000 00740800 00383c10 0000d608  80...t...8<.....
 1680 00003b48 1000003e a2030000 ca030000  ..;H...>........
 1690 57071000 0057fb0f 00003ea2 030000ca  W....W....>.....
 16a0 0300003a 13100000 02090000 00000058  ...:...........X
 16b0 2c060000 d2030000 d4030000 03922002  ,............. .
 16c0 d5100000 01e71000 0059bf06 00008a0a  .........Y......
 16d0 00000106 68930169 93010058 4d060000  ....h..i...XM...
 16e0 d4030000 da030000 03922002 01110000  .......... .....
 16f0 011d1100 0051bf06 00008a0a 0000012d  .....Q.........-
 1700 0900005a e6020000 0606013a 0000007f  ...Z.......:....
 1710 00587206 0000da03 0000e003 00000392  .Xr.............
 1720 20023711 00000152 11000051 bf060000   .7....R...Q....
 1730 8a0a0000 01530900 005be602 000006f6  .....S...[......
 1740 3a000000 7f005896 060000e0 030000ee  :.....X.........
 1750 03000003 9220026c 11000001 7b110000  ..... .l....{...
 1760 51bf0600 008a0a00 00017909 00000050  Q.........y....P
 1770 ba060000 ee030000 04040000 9f090000  ................
 1780 95110000 01d81100 0051bf06 00008a0a  .........Q......
 1790 000001ce 09000052 db020000 06da650f  .......R......e.
 17a0 0000f409 00005243 03000006 da8b0500  ......RC........
 17b0 002a0a00 005cfc03 00001e10 00004a06  .*...\........J.
 17c0 68930169 930103f3 01660000 50e80600  h..i.....f..P...
 17d0 00040400 00260400 00620a00 00f21100  .....&...b......
 17e0 00012a12 000051bf 0600008a 0a000001  ..*...Q.........
 17f0 aa0a0000 52db0200 0006c151 010000d0  ....R......Q....
 1800 0a00005c 1a040000 1e100000 4a066893  ...\........J.h.
 1810 01699301 028c014a 01660131 000058f2  .i.....J.f.1..X.
 1820 04000026 0400004e 04000003 92200244  ...&...N..... .D
 1830 12000001 6c120000 51bf0600 00aa0700  ....l...Q.......
 1840 0001fc0a 000052e6 02000002 bd510100  ......R......Q..
 1850 00420b00 005d4c04 000001e7 0c000000  .B...]L.........
 1860 50170500 004e0400 00840400 00870b00  P....N..........
 1870 00861200 0001df12 000051bf 060000aa  ..........Q.....
 1880 07000001 dd0b0000 4070696e 0002a751  ........@pin...Q
 1890 01000023 0c000040 706f6c00 02a73401  ...#...@pol...4.
 18a0 00005b0c 00004964 040000e5 0b0000c6  ..[...Id........
 18b0 1200004a 01680281 00005e84 04000001  ...J.h....^.....
 18c0 4a066893 01699301 03f30168 4a016601  J.h..i.....hJ.f.
 18d0 30000029 41050000 01ed1200 00211300  0..)A........!..
 18e0 002abf06 0000aa07 0000012c e6020000  .*.........,....
 18f0 02865101 00002c02 04000002 86510100  ..Q...,......Q..
 1900 00305793 07000057 89070000 303b9e07  .0W....W....0;..
 1910 00000000 0046df12 00008404 0000e204  .....F..........
 1920 00009d0c 00003b13 000001da 13000038  ......;........8
 1930 ed120000 e60c0000 38f71200 002c0d00  ........8....,..
 1940 00380213 0000630d 00003dba 040000d0  .8....c...=.....
 1950 0400009f 13000038 93070000 8f0d0000  .......8........
 1960 38890700 00a20d00 003eba04 0000d004  8........>......
 1970 00003b9e 0700005c d0040000 3c0e0000  ..;....\....<...
 1980 4a066893 01699301 028c004a 01640134  J.h..i.....J.d.4
 1990 00000047 a0040000 e70c0000 49ac0400  ...G........I...
 19a0 00e70c00 00bb1300 004a0166 0130004b  .........J.f.0.K
 19b0 e2040000 013c0e00 004a0668 93016993  .....<...J.h..i.
 19c0 0103f301 684a0166 03f30166 00005847  ....hJ.f...f..XG
 19d0 020000e2 040000f8 04000003 922002f4  ............. ..
 19e0 13000001 31140000 51bf0600 00550700  ....1...Q....U..
 19f0 0001ba0d 00005fe6 02000007 7b015101  ......_.....{.Q.
 1a00 0000e00d 000053f2 0400004a 06689301  ......S....J.h..
 1a10 69930103 f301684a 016603f3 01664a01  i.....hJ.f...fJ.
 1a20 64013100 00587102 0000f804 00000805  d.1..Xq.........
 1a30 00000392 20024b14 00000189 14000051  .... .K........Q
 1a40 bf060000 55070000 01010e00 005fe602  ....U........_..
 1a50 00000770 01510100 00270e00 005e0805  ...p.Q...'...^..
 1a60 0000014a 06689301 69930103 f301684a  ...J.h..i.....hJ
 1a70 016603f3 01664a01 64013000 0060e908  .f...fJ.d.0..`..
 1a80 00000805 00008c05 0000480e 000001e4  ..........H.....
 1a90 14000038 0c090000 8f0e0000 39170900  ...8........9...
 1aa0 00028c05 39220900 00028c01 3c010900  ....9"......<...
 1ab0 000061f7 08000006 03ca0180 009f4b8c  ..a...........K.
 1ac0 05000001 31140000 4a066893 01699301  ....1...J.h..i..
 1ad0 0503ca01 80000000 33880800 00037801  ........3.....x.
 1ae0 01fc1400 002e7573 0003782d 01000000  ......us..x-....
 1af0 29900200 00010a15 00001515 00002abf  ).............*.
 1b00 06000055 07000001 0050a802 00008c05  ...U.....P......
 1b10 0000ac06 0000bb0e 00002f15 00000110  ........../.....
 1b20 18000051 bf060000 55070000 01040f00  ...Q....U.......
 1b30 00527904 0000075b 51010000 4a0f0000  .Ry....[Q...J...
 1b40 52e60700 00075b51 01000077 0f000052  R.....[Q...w...R
 1b50 a0070000 075b5101 0000980f 000045e4  .....[Q.......E.
 1b60 140000d6 050000de 05000007 7c871500  ............|...
 1b70 0038f114 0000b90f 00000045 e4140000  .8.........E....
 1b80 f0050000 fa050000 0780a415 000038f1  ..............8.
 1b90 140000cf 0f000000 45e41400 000c0600  ........E.......
 1ba0 00120600 000784c1 15000038 f1140000  ...........8....
 1bb0 e50f0000 0045e414 00002e06 00003606  .....E........6.
 1bc0 00000792 de150000 38f11400 00fb0f00  ........8.......
 1bd0 000045e4 14000040 0600004a 06000007  ..E....@...J....
 1be0 96fb1500 0038f114 00001110 00000045  .....8.........E
 1bf0 e4140000 54060000 5a060000 079a1816  ....T...Z.......
 1c00 000038f1 14000027 10000000 45e41400  ..8....'....E...
 1c10 00640600 006c0600 0007a035 16000038  .d...l.....5...8
 1c20 f1140000 3d100000 00453c07 00007006  ....=....E<...p.
 1c30 00007806 000007a4 6c160000 384a0700  ..x.....l...8J..
 1c40 00521000 005c7806 00003114 00004a06  .R...\x...1...J.
 1c50 68930169 9301028c 004a0166 013c0000  h..i.....J.f.<..
 1c60 45fc1400 00780600 00880600 0007a7c0  E....x..........
 1c70 16000038 0a150000 6a100000 45e41400  ...8....j...E...
 1c80 00800600 00880600 0007b7a5 16000038  ...............8
 1c90 f1140000 82100000 005c8006 00003114  .........\....1.
 1ca0 00004a06 68930169 9301028c 004a0166  ..J.h..i.....J.f
 1cb0 01310000 625a0700 00940600 00180000  .1..bZ..........
 1cc0 0007aef6 16000038 68070000 98100000  .......8h.......
 1cd0 5eac0600 00014a06 68930169 930103f3  ^.....J.h..i....
 1ce0 01684a01 660209ff 000049be 0500001c  .hJ.f.....I.....
 1cf0 0f000015 1700004a 0c669301 67930168  .......J.f..g..h
 1d00 93016993 01020864 0063d605 00003417  ..i....d.c....4.
 1d10 00004a06 68930169 9301028c 004a0166  ..J.h..i.....J.f
 1d20 01334a01 64013200 63f00500 00531700  .3J.d.2.c....S..
 1d30 004a0668 93016993 01028c00 4a016601  .J.h..i.....J.f.
 1d40 334a0164 01320063 0c060000 72170000  3J.d.2.c....r...
 1d50 4a066893 01699301 028c004a 01660133  J.h..i.....J.f.3
 1d60 4a016401 32006324 06000091 1700004a  J.d.2.c$.......J
 1d70 06689301 69930102 8c004a01 6601324a  .h..i.....J.f.2J
 1d80 01640132 00492e06 00003114 0000aa17  .d.2.I....1.....
 1d90 00004a06 68930169 9301028c 00004940  ..J.h..i......I@
 1da0 06000031 140000c3 1700004a 06689301  ...1.......J.h..
 1db0 69930102 8c000049 54060000 31140000  i......IT...1...
 1dc0 dc170000 4a066893 01699301 028c0000  ....J.h..i......
 1dd0 49640600 00311400 00f51700 004a0668  Id...1.......J.h
 1de0 93016993 01028c00 005c9406 00003114  ..i......\....1.
 1df0 00004a06 68930169 9301028c 004a0166  ..J.h..i.....J.f
 1e00 01360000 58d70200 00ac0600 00ae0600  .6..X...........
 1e10 00039220 022a1800 00014a18 000059bf  ... .*....J...Y.
 1e20 06000055 07000001 06689301 69930164  ...U.....h..i..d
 1e30 e6020000 08050251 01000001 660058fd  .......Q....f.X.
 1e40 020000ae 060000b0 06000003 92200264  ............. .d
 1e50 18000001 97180000 59bf0600 00550700  ........Y....U..
 1e60 00010668 93016993 0164e602 000008f2  ...h..i..d......
 1e70 01510100 00016665 706f6c00 08f20134  .Q....fepol....4
 1e80 01000006 64930165 9301000e 02250300  ....d..e.....%..
 1e90 00582f03 0000b006 0000b206 00000392  .X/.............
 1ea0 2002b718 000001c9 18000059 bf060000   ..........Y....
 1eb0 c9180000 01066893 01699301 00289718  ......h..i...(..
 1ec0 0000584f 030000b2 060000b8 06000003  ..XO............
 1ed0 922002e8 18000001 f7180000 51bf0600  . ..........Q...
 1ee0 00c91800 0001ce10 00000037 c5080000  ...........7....
 1ef0 b8060000 dc060000 03922002 01481900  .......... ..H..
 1f00 0038dd08 0000f410 000061d3 08000006  .8........a.....
 1f10 03ca0180 009f4bd6 06000001 700f0000  ......K.....p...
 1f20 4a066893 01699301 0503ca01 80004a06  J.h..i........J.
 1f30 66930167 930103f3 01680000 60610800  f..g.....h..`a..
 1f40 00dc0600 005e0700 00481100 0001ba19  .....^...H......
 1f50 00003879 080000dd 11000038 82080000  ..8y.......8....
 1f60 27120000 398d0800 00028c01 3a980800  '...9.......:...
 1f70 00481200 00616f08 00000603 ca018000  .H...ao.........
 1f80 9f3d0a07 00003207 0000a419 00003aa4  .=....2.......:.
 1f90 0800006d 12000000 5c400700 00f71800  ...m....\@......
 1fa0 004a0668 93016993 01028000 00006651  .J.h..i.......fQ
 1fb0 0300000a 1801015e 07000062 07000003  .......^...b....
 1fc0 92200201 da190000 67620700 00006827  . ......gb....h'
 1fd0 08000001 010168d2 06000001 010169a8  ......h.......i.
 1fe0 07000001 014a0a00 00580b00 00a31200  .....J...X......
 1ff0 00010b1c 00006a52 0a00007e 0a000006  ......jR...~....
 2000 4a01591a 00006bec 1200006b 01130000  J.Y...k....k....
 2010 6c710a00 00520a00 007e0a00 00064a01  lq...R...~....J.
 2020 577f0a00 006d4d0a 0000520a 0000720a  W....mM...R...r.
 2030 00000631 575b0a00 006d0b1c 0000520a  ...1W[...m....R.
 2040 00005a0a 00000b3f 6e000000 006dc20b  ..Z....?n....m..
 2050 00007e0a 0000580b 00000d2a 38ce0b00  ..~...X....*8...
 2060 00151300 0038d90b 00002913 00006d44  .....8....)...mD
 2070 0b00007e 0a000058 0b00000d 0757520b  ...~...X.....WR.
 2080 0000385c 0b00003e 13000038 660b0000  ..8\...>...8f...
 2090 52130000 38710b00 00661300 00387b0b  R...8q...f...8{.
 20a0 00007a13 00003885 0b00008e 13000038  ..z...8........8
 20b0 8f0b0000 a2130000 38990b00 00b61300  ........8.......
 20c0 0038a30b 0000ca13 000038ad 0b0000de  .8........8.....
 20d0 13000038 b70b0000 f2130000 452b0b00  ...8........E+..
 20e0 007e0a00 00860a00 00024512 1b000057  .~........E....W
 20f0 390b0000 6d0b1c00 007e0a00 00860a00  9...m....~......
 2100 0007406e 00006d8f 0a000092 0a000058  ..@n..m........X
 2110 0b000002 47579d0a 000038a7 0a000006  ....GW....8.....
 2120 14000038 b20a0000 1a140000 38bc0a00  ...8........8...
 2130 002e1400 0038c60a 00004314 000038d1  .....8....C...8.
 2140 0a000057 14000038 db0a0000 6b140000  ...W...8....k...
 2150 38e50a00 007f1400 0038ef0a 00009314  8........8......
 2160 000038f9 0a0000a7 14000038 030b0000  ..8........8....
 2170 bb140000 380d0b00 00cf1400 0038170b  ....8........8..
 2180 0000e314 00003e92 0a000058 0b00003a  ......>....X...:
 2190 210b0000 f7140000 47e60a00 00e50b00  !.......G.......
 21a0 0047f60a 0000e50b 00004704 0b0000e5  .G........G.....
 21b0 0b000047 100b0000 e50b0000 47180b00  ...G........G...
 21c0 00e50b00 0049280b 0000e70c 0000e41b  .....I(.........
 21d0 00004a01 66013000 49320b00 00e70c00  ..J.f.0.I2......
 21e0 00f71b00 004a0166 0130005c 400b0000  .....J.f.0.\@...
 21f0 e70c0000 4a016601 30000000 0000006f  ....J.f.0......o
 2200 73030000 03700154 08000003 2d016207  s....p.T....-.b.
 2210 0000f607 00008415 00000146 1c000043  ...........F...C
 2220 6d000332 e9050000 01160000 43660003  m..2........Cf..
 2230 335c0100 00741600 0000713d 0300000d  3\...t....q=....
 2240 10010171 bd020000 0c1c0101 717e0600  ...q........q~..
 2250 0003f101 0172dc03 00000341 01e90500  .....r.....A....
 2260 0001871c 0000326d 000343e9 0500002d  ......2m..C....-
 2270 51040000 03445101 00000071 cf050000  Q....DQ....q....
 2280 0d1a0101 361b0800 00010101 aa1c0000  ....6...........
 2290 302dfd02 00000d1e e9050000 00007301  0-............s.
 22a0 d6020000 0c21013a 00000001 580b0000  .....!.:....X...
 22b0 e80c0000 03922002 01641f00 0074581c  ...... ..d...tX.
 22c0 0000580b 0000de0b 00000c23 45461c00  ..X........#EF..
 22d0 00de0b00 001e0c00 000c2b63 1d000045  ..........+c...E
 22e0 611c0000 f80b0000 0e0c0000 0d171b1d  a...............
 22f0 00003ef8 0b00000e 0c00003a 721c0000  ..>........:r...
 2300 b9160000 3a7b1c00 00d71600 00000049  ....:{.........I
 2310 ea0b0000 1c0f0000 3b1d0000 4a0c6693  ........;...J.f.
 2320 01679301 68930169 9301030a e803005c  .g..h..i.......\
 2330 f80b0000 15150000 4a066893 01699301  ........J.h..i..
 2340 0503ca01 80004a01 6601404a 01640132  ......J.f.@J.d.2
 2350 4a016201 30000062 871c0000 1e0c0000  J.b.0..b........
 2360 30000000 0c2e5e1f 00007548 00000039  0.....^...uH...9
 2370 9d1c0000 0c5c9301 5d93015e 93015f93  .....\..]..^.._.
 2380 0162fc14 00001e0c 00006000 00000d20  .b........`.... 
 2390 e01d0000 570a1500 0062e414 00001e0c  ....W....b......
 23a0 00007800 000007b7 c21d0000 38f11400  ..x.........8...
 23b0 00ea1600 00005c7c 0c000031 1400004a  ......\|...1...J
 23c0 06689301 69930105 03ca0180 004a0166  .h..i........J.f
 23d0 01310000 45611c00 005c0c00 00720c00  .1..Ea...\...r..
 23e0 000d1e10 1e00003e 5c0c0000 720c0000  .......>\...r...
 23f0 3a721c00 00001700 003a7b1c 00001e17  :r.......:{.....
 2400 00000000 45e70700 00880c00 00900c00  ....E...........
 2410 000d2246 1e000057 f5070000 57ff0700  .."F...W....W...
 2420 005c900c 0000f718 00004a06 68930169  .\........J.h..i
 2430 93010503 32018000 000045b5 07000090  ....2.....E.....
 2440 0c00009e 0c00000d 23941e00 0057c307  ........#....W..
 2450 000038d6 07000031 17000038 cd070000  ..8....1...8....
 2460 45170000 5c9e0c00 00481900 004a0c66  E...\....H...J.f
 2470 93016793 01689301 69930105 0cc0c62d  ..g..h..i......-
 2480 004a0164 013a0000 45e70700 00a40c00  .J.d.:..E.......
 2490 00ac0c00 000d26ca 1e000057 f5070000  ......&....W....
 24a0 57ff0700 005cac0c 0000f718 00004a06  W....\........J.
 24b0 68930169 93010503 3a018000 000045b5  h..i....:.....E.
 24c0 070000ac 0c0000d2 0c00000d 27041f00  ............'...
 24d0 0057c307 000038d6 0700005d 17000038  .W....8....]...8
 24e0 cd070000 71170000 5cd20c00 00481900  ....q...\....H..
 24f0 004a0164 013a0000 45e70700 00d20c00  .J.d.:..E.......
 2500 00da0c00 000d283a 1f000057 f5070000  ......(:...W....
 2510 57ff0700 005cda0c 0000f718 00004a06  W....\........J.
 2520 68930169 93010503 41018000 00004988  h..i....A.....I.
 2530 0c000089 1400004d 1f00004a 01680130  .......M...J.h.0
 2540 005ca40c 00008914 00004a01 68013100  .\........J.h.1.
 2550 000067e6 0c000000 76350600 00058601  ..g.....v5......
 2560 01017701 f6070000 058f0101 f6070000  ..w.............
 2570 4a0a0000 a3170000 01332000 00783320  J........3 ..x3 
 2580 00000609 00000a09 000005a1 01ae1f00  ................
 2590 00796163 6b00058f 01510100 006e1800  .yack....Q...n..
 25a0 00007a64 1f00008c 09000096 09000005  ..zd............
 25b0 f4017833 2000000c 0a000014 0a000005  ..x3 ...........
 25c0 1d02e31f 00007961 636b0005 8f015101  ......yack....Q.
 25d0 00008218 00000078 33200000 140a0000  .......x3 ......
 25e0 1a0a0000 05230208 20000079 61636b00  .....#.. ..yack.
 25f0 058f0151 01000096 18000000 7bba0900  ...Q........{...
 2600 00013022 2000004a 06689301 69930105  ..0" ..J.h..i...
 2610 03690180 00007cd4 09000001 3047280a  .i....|.....0G(.
 2620 0000d50f 00000076 ca080000 05610101  .......v.....a..
 2630 017d0c03 00000623 51010000 03050346  .}.....#Q......F
 2640 01800024 51010000 5f200000 257e0500  ...$Q..._ ..%~..
 2650 001f0042 47080000 05354f20 00000503  ...BG....5O ....
 2660 47018000 42650400 00053742 0a000005  G...Be....7B....
 2670 03670180 00426406 00000536 420a0000  .g...Bd....6B...
 2680 05036801 80004249 07000005 394f2000  ..h...BI....9O .
 2690 00050369 01800042 08030000 053a420a  ...i...B.....:B.
 26a0 00000503 89018000 42d80700 00053c42  ........B.....<B
 26b0 0a000005 038a0180 00421002 00000529  .........B.....)
 26c0 420a0000 05038b01 800042e7 05000005  B.........B.....
 26d0 2c420a00 0005038c 01800042 c9020000  ,B.........B....
 26e0 052b420a 00000503 8d018000 42c20400  .+B.........B...
 26f0 0005314f 20000005 038e0180 00427402  ..1O ........Bt.
 2700 00000533 420a0000 0503ae01 800042f7  ...3B.........B.
 2710 06000005 32420a00 000503af 01800042  ....2B.........B
 2720 e1040000 052a420a 00000503 b0018000  .....*B.........
 2730 42bc0800 000d0ae9 05000005 03b10180  B...............
 2740 00423003 00000d0c e9050000 05030001  .B0.............
 2750 8000423f 02000003 285c0100 000503b5  ..B?....(\......
 2760 01800042 d5030000 03278721 00000503  ...B.....'.!....
 2770 b6018000 0f040723 06000035 80210000  .......#...5.!..
 2780 42250400 00032687 21000005 03ba0180  B%....&.!.......
 2790 00246b0f 0000ad21 0000257e 05000013  .$k....!..%~....
 27a0 00426f08 000013c4 be210000 05036800  .Bo......!....h.
 27b0 0000289d 21000024 d3210000 d3210000  ..(.!..$.!...!..
 27c0 257e0500 00040028 0e070000 42d40500  %~.....(....B...
 27d0 001386e9 21000005 037c0000 0028c321  ....!....|...(.!
 27e0 00004207 04000013 7eff2100 00050386  ..B.....~.!.....
 27f0 00000028 c3210000 42ab0300 00139615  ...(.!..B.......
 2800 22000005 03900000 00289d21 00004258  "........(.!..BX
 2810 02000013 ad2b2200 000503a4 00000028  .....+"........(
 2820 9d210000 7e9d0800 00064a01 fb050000  .!..~.....J.....
 2830 0503be01 800026a7 08000001 4d6c6364  ......&.....Mlcd
 2840 000d0742 22000005 03ca0180 0000aa00  ...B"...........
 2850 00000200 000d0000 0401420e 0000420d  ..........B...B.
 2860 0000460d 00002e2e 2f2e2e2f 2e2e2f2e  ..F...../../../.
 2870 2e2f6763 632f6c69 62676363 2f636f6e  ./gcc/libgcc/con
 2880 6669672f 6176722f 6c696231 66756e63  fig/avr/lib1func
 2890 732e5300 2f557365 72732f6a 656e6b69  s.S./Users/jenki
 28a0 6e732f6a 656e6b69 6e732f77 6f726b73  ns/jenkins/works
 28b0 70616365 2f617672 2d676363 2d737461  pace/avr-gcc-sta
 28c0 67696e67 2f6c6162 656c2f6d 61632d6d  ging/label/mac-m
 28d0 696e692f 6763632d 6275696c 642f6176  ini/gcc-build/av
 28e0 722f6176 72352f6c 69626763 6300474e  r/avr5/libgcc.GN
 28f0 55204153 20322e32 36000180 aa000000  U AS 2.26.......
 2900 0200140d 00000401 a40e0000 e80c0000  ................
 2910 2c0d0000 2e2e2f2e 2e2f2e2e 2f2e2e2f  ,...../../../../
 2920 6763632f 6c696267 63632f63 6f6e6669  gcc/libgcc/confi
 2930 672f6176 722f6c69 62316675 6e63732e  g/avr/lib1funcs.
 2940 53002f55 73657273 2f6a656e 6b696e73  S./Users/jenkins
 2950 2f6a656e 6b696e73 2f776f72 6b737061  /jenkins/workspa
 2960 63652f61 76722d67 63632d73 74616769  ce/avr-gcc-stagi
 2970 6e672f6c 6162656c 2f6d6163 2d6d696e  ng/label/mac-min
 2980 692f6763 632d6275 696c642f 6176722f  i/gcc-build/avr/
 2990 61767235 2f6c6962 67636300 474e5520  avr5/libgcc.GNU 
 29a0 41532032 2e323600 0180aa00 00000200  AS 2.26.........
 29b0 280d0000 0401c60f 0000c600 0000dc00  (...............
 29c0 00002e2e 2f2e2e2f 2e2e2f2e 2e2f6763  ..../../../../gc
 29d0 632f6c69 62676363 2f636f6e 6669672f  c/libgcc/config/
 29e0 6176722f 6c696231 66756e63 732e5300  avr/lib1funcs.S.
 29f0 2f557365 72732f6a 656e6b69 6e732f6a  /Users/jenkins/j
 2a00 656e6b69 6e732f77 6f726b73 70616365  enkins/workspace
 2a10 2f617672 2d676363 2d737461 67696e67  /avr-gcc-staging
 2a20 2f6c6162 656c2f6d 61632d6d 696e692f  /label/mac-mini/
 2a30 6763632d 6275696c 642f6176 722f6176  gcc-build/avr/av
 2a40 72352f6c 69626763 6300474e 55204153  r5/libgcc.GNU AS
 2a50 20322e32 36000180 aa000000 02003c0d   2.26.........<.
 2a60 00000401 5e100000 dc000000 ec000000  ....^...........
 2a70 2e2e2f2e 2e2f2e2e 2f2e2e2f 6763632f  ../../../../gcc/
 2a80 6c696267 63632f63 6f6e6669 672f6176  libgcc/config/av
 2a90 722f6c69 62316675 6e63732e 53002f55  r/lib1funcs.S./U
 2aa0 73657273 2f6a656e 6b696e73 2f6a656e  sers/jenkins/jen
 2ab0 6b696e73 2f776f72 6b737061 63652f61  kins/workspace/a
 2ac0 76722d67 63632d73 74616769 6e672f6c  vr-gcc-staging/l
 2ad0 6162656c 2f6d6163 2d6d696e 692f6763  abel/mac-mini/gc
 2ae0 632d6275 696c642f 6176722f 61767235  c-build/avr/avr5
 2af0 2f6c6962 67636300 474e5520 41532032  /libgcc.GNU AS 2
 2b00 2e323600 0180aa00 00000200 500d0000  .26.........P...
 2b10 0401e410 0000ec00 00000201 00002e2e  ................
 2b20 2f2e2e2f 2e2e2f2e 2e2f6763 632f6c69  /../../../gcc/li
 2b30 62676363 2f636f6e 6669672f 6176722f  bgcc/config/avr/
 2b40 6c696231 66756e63 732e5300 2f557365  lib1funcs.S./Use
 2b50 72732f6a 656e6b69 6e732f6a 656e6b69  rs/jenkins/jenki
 2b60 6e732f77 6f726b73 70616365 2f617672  ns/workspace/avr
 2b70 2d676363 2d737461 67696e67 2f6c6162  -gcc-staging/lab
 2b80 656c2f6d 61632d6d 696e692f 6763632d  el/mac-mini/gcc-
 2b90 6275696c 642f6176 722f6176 72352f6c  build/avr/avr5/l
 2ba0 69626763 6300474e 55204153 20322e32  ibgcc.GNU AS 2.2
 2bb0 36000180 aa000000 0200640d 00000401  6.........d.....
 2bc0 76110000 2c0d0000 380d0000 2e2e2f2e  v...,...8...../.
 2bd0 2e2f2e2e 2f2e2e2f 6763632f 6c696267  ./../../gcc/libg
 2be0 63632f63 6f6e6669 672f6176 722f6c69  cc/config/avr/li
 2bf0 62316675 6e63732e 53002f55 73657273  b1funcs.S./Users
 2c00 2f6a656e 6b696e73 2f6a656e 6b696e73  /jenkins/jenkins
 2c10 2f776f72 6b737061 63652f61 76722d67  /workspace/avr-g
 2c20 63632d73 74616769 6e672f6c 6162656c  cc-staging/label
 2c30 2f6d6163 2d6d696e 692f6763 632d6275  /mac-mini/gcc-bu
 2c40 696c642f 6176722f 61767235 2f6c6962  ild/avr/avr5/lib
 2c50 67636300 474e5520 41532032 2e323600  gcc.GNU AS 2.26.
 2c60 0180                                 ..              
Contents of section .debug_abbrev:
 0000 01110125 0e100600 00022400 030e0b0b  ...%......$.....
 0010 3e0b0000 03240003 0e0b0b3e 0b000004  >....$.....>....
 0020 01014913 00000521 0049132f 05000006  ..I....!.I./....
 0030 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0040 07340003 0e3a0b3b 0b49133f 0c020a00  .4...:.;.I.?....
 0050 00083400 030e3a0b 3b0b4913 3f0c020a  ..4...:.;.I.?...
 0060 00000934 00030e3a 0b3b0b49 133f0c02  ...4...:.;.I.?..
 0070 0a00000a 3400030e 3a0b3b0b 49133f0c  ....4...:.;.I.?.
 0080 020a0000 0b340003 0e3a0b3b 0b49133f  .....4...:.;.I.?
 0090 0c020a00 000c3400 030e3a0b 3b0b4913  ......4...:.;.I.
 00a0 3f0c020a 00000d34 00030e3a 0b3b0b49  ?......4...:.;.I
 00b0 133f0c02 0a00000e 3400030e 3a0b3b0b  .?......4...:.;.
 00c0 49133f0c 020a0000 0f340003 0e3a0b3b  I.?......4...:.;
 00d0 0b49133f 0c020a00 00103400 030e3a0b  .I.?......4...:.
 00e0 3b0b4913 3f0c020a 00001134 00030e3a  ;.I.?......4...:
 00f0 0b3b0b49 133f0c02 0a000012 3400030e  .;.I.?......4...
 0100 3a0b3b0b 49133f0c 020a0000 13340003  :.;.I.?......4..
 0110 0e3a0b3b 0b49133f 0c020a00 00143400  .:.;.I.?......4.
 0120 030e3a0b 3b0b4913 3f0c020a 00001534  ..:.;.I.?......4
 0130 00030e3a 0b3b0b49 133f0c02 0a000016  ...:.;.I.?......
 0140 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0150 17340003 0e3a0b3b 0b49133f 0c020a00  .4...:.;.I.?....
 0160 00183400 030e3a0b 3b0b4913 3f0c020a  ..4...:.;.I.?...
 0170 00001934 00030e3a 0b3b0b49 133f0c02  ...4...:.;.I.?..
 0180 0a00001a 3400030e 3a0b3b0b 49133f0c  ....4...:.;.I.?.
 0190 020a0000 1b340003 0e3a0b3b 0b49133f  .....4...:.;.I.?
 01a0 0c020a00 001c3400 030e3a0b 3b0b4913  ......4...:.;.I.
 01b0 3f0c020a 00001d34 00030e3a 0b3b0b49  ?......4...:.;.I
 01c0 133f0c02 0a00001e 3400030e 3a0b3b0b  .?......4...:.;.
 01d0 49133f0c 020a0000 1f340003 0e3a0b3b  I.?......4...:.;
 01e0 0b49133f 0c020a00 00203400 030e3a0b  .I.?..... 4...:.
 01f0 3b0b4913 3f0c020a 00002134 00030e3a  ;.I.?.....!4...:
 0200 0b3b0b49 133f0c02 0a000022 3400030e  .;.I.?....."4...
 0210 3a0b3b0b 49133f0c 020a0000 23340003  :.;.I.?.....#4..
 0220 0e3a0b3b 0b49133f 0c020a00 00243400  .:.;.I.?.....$4.
 0230 030e3a0b 3b0b4913 3f0c020a 00002534  ..:.;.I.?.....%4
 0240 00030e3a 0b3b0b49 133f0c02 0a000026  ...:.;.I.?.....&
 0250 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0260 27340003 0e3a0b3b 0b49133f 0c020a00  '4...:.;.I.?....
 0270 00283400 030e3a0b 3b0b4913 3f0c020a  .(4...:.;.I.?...
 0280 00002934 00030e3a 0b3b0b49 133f0c02  ..)4...:.;.I.?..
 0290 0a00002a 3400030e 3a0b3b0b 49133f0c  ...*4...:.;.I.?.
 02a0 020a0000 2b340003 0e3a0b3b 0b49133f  ....+4...:.;.I.?
 02b0 0c020a00 002c3400 030e3a0b 3b0b4913  .....,4...:.;.I.
 02c0 3f0c020a 00002d34 00030e3a 0b3b0b49  ?.....-4...:.;.I
 02d0 133f0c02 0a00002e 3400030e 3a0b3b0b  .?......4...:.;.
 02e0 49133f0c 020a0000 2f340003 0e3a0b3b  I.?...../4...:.;
 02f0 0b49133f 0c020a00 00303400 030e3a0b  .I.?.....04...:.
 0300 3b0b4913 3f0c020a 00003134 00030e3a  ;.I.?.....14...:
 0310 0b3b0b49 133f0c02 0a000032 3400030e  .;.I.?.....24...
 0320 3a0b3b0b 49133f0c 020a0000 33340003  :.;.I.?.....34..
 0330 0e3a0b3b 0b49133f 0c020a00 00343400  .:.;.I.?.....44.
 0340 030e3a0b 3b0b4913 3f0c020a 00003534  ..:.;.I.?.....54
 0350 00030e3a 0b3b0b49 133f0c02 0a000036  ...:.;.I.?.....6
 0360 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0370 37340003 0e3a0b3b 0b49133f 0c020a00  74...:.;.I.?....
 0380 00383400 030e3a0b 3b0b4913 3f0c020a  .84...:.;.I.?...
 0390 00003934 00030e3a 0b3b0b49 133f0c02  ..94...:.;.I.?..
 03a0 0a00003a 3400030e 3a0b3b0b 49133f0c  ...:4...:.;.I.?.
 03b0 020a0000 3b340003 0e3a0b3b 0b49133f  ....;4...:.;.I.?
 03c0 0c020a00 003c3400 030e3a0b 3b0b4913  .....<4...:.;.I.
 03d0 3f0c020a 00003d34 00030e3a 0b3b0b49  ?.....=4...:.;.I
 03e0 133f0c02 0a00003e 3400030e 3a0b3b0b  .?.....>4...:.;.
 03f0 49133f0c 020a0000 3f340003 0e3a0b3b  I.?.....?4...:.;
 0400 0b49133f 0c020a00 00403400 030e3a0b  .I.?.....@4...:.
 0410 3b0b4913 3f0c020a 00004134 00030e3a  ;.I.?.....A4...:
 0420 0b3b0b49 133f0c02 0a000042 3400030e  .;.I.?.....B4...
 0430 3a0b3b0b 49133f0c 020a0000 43340003  :.;.I.?.....C4..
 0440 0e3a0b3b 0b49133f 0c020a00 00443400  .:.;.I.?.....D4.
 0450 030e3a0b 3b0b4913 3f0c020a 00004534  ..:.;.I.?.....E4
 0460 00030e3a 0b3b0b49 133f0c02 0a000046  ...:.;.I.?.....F
 0470 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0480 47340003 0e3a0b3b 0b49133f 0c020a00  G4...:.;.I.?....
 0490 00483400 030e3a0b 3b0b4913 3f0c020a  .H4...:.;.I.?...
 04a0 00004934 00030e3a 0b3b0b49 133f0c02  ..I4...:.;.I.?..
 04b0 0a00004a 3400030e 3a0b3b0b 49133f0c  ...J4...:.;.I.?.
 04c0 020a0000 4b340003 0e3a0b3b 0b49133f  ....K4...:.;.I.?
 04d0 0c020a00 004c3400 030e3a0b 3b0b4913  .....L4...:.;.I.
 04e0 3f0c020a 00004d34 00030e3a 0b3b0b49  ?.....M4...:.;.I
 04f0 133f0c02 0a00004e 3400030e 3a0b3b0b  .?.....N4...:.;.
 0500 49133f0c 020a0000 4f340003 0e3a0b3b  I.?.....O4...:.;
 0510 0b49133f 0c020a00 00503400 030e3a0b  .I.?.....P4...:.
 0520 3b0b4913 3f0c020a 00005134 00030e3a  ;.I.?.....Q4...:
 0530 0b3b0b49 133f0c02 0a000052 3400030e  .;.I.?.....R4...
 0540 3a0b3b0b 49133f0c 020a0000 53340003  :.;.I.?.....S4..
 0550 0e3a0b3b 0b49133f 0c020a00 00543400  .:.;.I.?.....T4.
 0560 030e3a0b 3b0b4913 3f0c020a 00005534  ..:.;.I.?.....U4
 0570 00030e3a 0b3b0b49 133f0c02 0a000056  ...:.;.I.?.....V
 0580 3400030e 3a0b3b0b 49133f0c 020a0000  4...:.;.I.?.....
 0590 57340003 0e3a0b3b 0b49133f 0c020a00  W4...:.;.I.?....
 05a0 00000111 01250e13 0b030e55 06110152  .....%.....U...R
 05b0 01100600 00020f00 0b0b030e 49130000  ............I...
 05c0 03150149 13011300 00041800 00000524  ...I...........$
 05d0 000b0b3e 0b030800 00061301 030e0b0b  ...>............
 05e0 3a0b3b0b 1d130113 0000070d 00030e49  :.;............I
 05f0 13380a34 0c000008 0d00030e 3a0b3b0b  .8.4........:.;.
 0600 4913380a 320b0000 092e0103 0e3a0b3b  I.8.2........:.;
 0610 0b270c49 133c0c64 13011300 000a0500  .'.I.<.d........
 0620 4913340c 00000b05 00491300 000c2e01  I.4......I......
 0630 030e3a0b 3b0b270c 4913320b 3c0c6413  ..:.;.'.I.2.<.d.
 0640 01130000 0d2e0103 0e3a0b3b 0b270c49  .........:.;.'.I
 0650 134c0b4d 0a1d133c 0c641300 000e0f00  .L.M...<.d......
 0660 0b0b4913 00000f24 000b0b3e 0b030e00  ..I....$...>....
 0670 00100401 030e0b0b 49133a0b 3b0b0113  ........I.:.;...
 0680 00001128 00030e1c 0b000012 1600030e  ...(............
 0690 3a0b3b0b 49130000 13130103 080b0b3a  :.;.I..........:
 06a0 0b3b0b1d 13011300 00141c00 4913380a  .;..........I.8.
 06b0 320b0000 150d0003 0e3a0b3b 05491338  2........:.;.I.8
 06c0 0a320b00 00162e01 030e3a0b 3b0b270c  .2........:.;.'.
 06d0 3c0c6413 01130000 172e0103 0e3a0b3b  <.d..........:.;
 06e0 05270c3c 0c641301 13000018 2e01030e  .'.<.d..........
 06f0 3a0b3b05 270c4913 4c0b4d0a 1d133c0c  :.;.'.I.L.M...<.
 0700 64130113 0000192e 01030e3a 0b3b0527  d..........:.;.'
 0710 0c320b3c 0c641301 1300001a 2e01030e  .2.<.d..........
 0720 3a0b3b0b 270c4c0b 4d0a1d13 3c0c6413  :.;.'.L.M...<.d.
 0730 01130000 1b2e0103 0e3a0b3b 05270c4c  .........:.;.'.L
 0740 0b4d0a1d 133c0c64 13011300 001c2e01  .M...<.d........
 0750 030e3a0b 3b05270c 4c0b4d0a 1d133c0c  ..:.;.'.L.M...<.
 0760 64130000 1d130103 0e3c0c01 1300001e  d........<......
 0770 2e01030e 3a0b3b0b 270c4913 4c0b4d0a  ....:.;.'.I.L.M.
 0780 1d133c0c 64130113 00001f2e 013f0c03  ..<.d........?..
 0790 0e3a0b3b 0b87400e 270c3c0c 64130000  .:.;..@.'.<.d...
 07a0 202e0103 0e270c4c 0b4d0a1d 13340c3c   ....'.L.M...4.<
 07b0 0c641301 13000021 2e01030e 3a0b3b0b  .d.....!....:.;.
 07c0 270c320b 3c0c6413 01130000 222e0103  '.2.<.d....."...
 07d0 0e3a0b3b 0b270c4c 0b4d0a1d 133c0c64  .:.;.'.L.M...<.d
 07e0 13000023 13000308 3c0c0000 24010149  ...#....<...$..I
 07f0 13011300 00252100 49132f0b 00002613  .....%!.I./...&.
 0800 00030e3c 0c000027 2e01030e 3a0b3b0b  ...<...'....:.;.
 0810 270c3c0c 64130000 28260049 13000029  '.<.d...(&.I...)
 0820 2e014713 200b6413 01130000 2a050003  ..G. .d.....*...
 0830 0e491334 0c00002b 2e014713 3a0b3b0b  .I.4...+..G.:.;.
 0840 200b6413 01130000 2c050003 0e3a0b3b   .d.....,....:.;
 0850 0b491300 002d3400 030e3a0b 3b0b4913  .I...-4...:.;.I.
 0860 00002e05 0003083a 0b3b0b49 1300002f  .......:.;.I.../
 0870 0500030e 3a0b3b05 49130000 300b0100  ....:.;.I...0...
 0880 00313400 03083a0b 3b054913 00003234  .14...:.;.I...24
 0890 0003083a 0b3b0b49 13000033 2e01030e  ...:.;.I...3....
 08a0 3a0b3b0b 270c200b 01130000 340b0101  :.;.'. .....4...
 08b0 13000035 35004913 0000362e 01030e27  ...55.I...6....'
 08c0 0c340c20 0b011300 00372e01 31131101  .4. .....7..1...
 08d0 1201400a 97420c01 13000038 05003113  ..@..B.....8..1.
 08e0 02060000 39340031 13020a00 003a3400  ....94.1.....:4.
 08f0 31130206 00003b34 00311300 003c0500  1.....;4.1...<..
 0900 31131c0b 00003d0b 01110112 01011300  1.....=.........
 0910 003e0b01 11011201 00003f2e 01030e3a  .>........?....:
 0920 0b3b0b27 0c110112 01400a97 420c0113  .;.'.....@..B...
 0930 00004005 0003083a 0b3b0b49 13020600  ..@....:.;.I....
 0940 00410500 03083a0b 3b0b4913 020a0000  .A....:.;.I.....
 0950 42340003 0e3a0b3b 0b491302 0a000043  B4...:.;.I.....C
 0960 34000308 3a0b3b0b 49130206 00004434  4...:.;.I.....D4
 0970 00030e3a 0b3b0b49 13020600 00451d01  ...:.;.I.....E..
 0980 31131101 1201580b 590b0113 0000462e  1.....X.Y.....F.
 0990 01311311 01120140 06641397 420c0113  .1.....@.d..B...
 09a0 00004789 82010011 01311300 00481d01  ..G......1...H..
 09b0 31135201 5506580b 59050000 49898201  1.R.U.X.Y...I...
 09c0 01110131 13011300 004a8a82 0100020a  ...1.....J......
 09d0 91420a00 004b8982 01011101 95420c31  .B...K.......B.1
 09e0 1300004c 2e01030e 3a0b3b0b 270c4913  ...L....:.;.'.I.
 09f0 11011201 400a9742 0c011300 004d3400  ....@..B.....M4.
 0a00 03083a0b 3b0b4913 020a0000 4e2e0003  ..:.;.I.....N...
 0a10 0e3a0b3b 0b200b00 004f2e01 030e3a0b  .:.;. ...O....:.
 0a20 3b0b270c 11011201 40069742 0c011300  ;.'.....@..B....
 0a30 00502e01 47131101 12014006 64139742  .P..G.....@.d..B
 0a40 0c011300 00510500 030e4913 340c0206  .....Q....I.4...
 0a50 00005205 00030e3a 0b3b0b49 13020600  ..R....:.;.I....
 0a60 00538982 01011101 0000542e 00030e3a  .S........T....:
 0a70 0b3b0527 0c110112 01400a97 420c0000  .;.'.....@..B...
 0a80 552e0103 0e270c49 13340c20 0b011300  U....'.I.4. ....
 0a90 00562e01 030e3a0b 3b05270c 4913200b  .V....:.;.'.I. .
 0aa0 01130000 57050031 13000058 2e014713  ....W..1...X..G.
 0ab0 11011201 400a6413 97420c01 13000059  ....@.d..B.....Y
 0ac0 0500030e 4913340c 020a0000 5a340003  ....I.4.....Z4..
 0ad0 0e3a0b3b 0549131c 0d00005b 3400030e  .:.;.I.....[4...
 0ae0 3a0b3b0b 49131c0d 00005c89 82010111  :.;.I.....\.....
 0af0 01311300 005d8982 01001101 95420c31  .1...].......B.1
 0b00 1300005e 89820101 11019542 0c00005f  ...^.......B..._
 0b10 0500030e 3a0b3b05 49130206 0000602e  ....:.;.I.....`.
 0b20 01311311 01120140 0697420c 01130000  .1.....@..B.....
 0b30 61050031 13020a00 00621d01 31135201  a..1.....b..1.R.
 0b40 5506580b 590b0113 00006389 82010111  U.X.Y.....c.....
 0b50 01011300 00640500 030e3a0b 3b054913  .....d....:.;.I.
 0b60 020a0000 65050003 083a0b3b 05491302  ....e....:.;.I..
 0b70 0a000066 2e01030e 3a0b3b0b 270c8701  ...f....:.;.'...
 0b80 0c110112 01400a97 420c0113 00006789  .....@..B.....g.
 0b90 82010011 01000068 2e00030e 270c340c  .......h....'.4.
 0ba0 200b0000 692e0103 0e270c34 0c110112   ...i....'.4....
 0bb0 01400697 420c0113 00006a1d 01110112  .@..B.....j.....
 0bc0 01580b59 05011300 006b3400 02060000  .X.Y.....k4.....
 0bd0 6c1d0131 13110112 01580b59 0500006d  l..1.....X.Y...m
 0be0 1d013113 11011201 580b590b 00006e34  ..1.....X.Y...n4
 0bf0 0000006f 2e004713 200b0000 702e013f  ...o..G. ...p..?
 0c00 0c030e3a 0b3b0b27 0c110112 01400697  ...:.;.'.....@..
 0c10 420c0113 0000712e 00030e3a 0b3b0b27  B.....q....:.;.'
 0c20 0c200b00 00722e01 030e3a0b 3b0b270c  . ...r....:.;.'.
 0c30 4913200b 01130000 732e013f 0c030e3a  I. .....s..?...:
 0c40 0b3b0b27 0c491387 010c1101 1201400a  .;.'.I........@.
 0c50 97420c01 13000074 1d003113 11011201  .B.....t..1.....
 0c60 580b590b 0000750b 01550600 00762e00  X.Y...u..U...v..
 0c70 030e3a0b 3b05270c 200b0000 772e013f  ..:.;.'. ...w..?
 0c80 0c030e3a 0b3b0527 0c110112 01400697  ...:.;.'.....@..
 0c90 420c0113 0000781d 01311311 01120158  B.....x..1.....X
 0ca0 0b590501 13000079 34000308 3a0b3b05  .Y.....y4...:.;.
 0cb0 49130206 00007a1d 00311311 01120158  I.....z..1.....X
 0cc0 0b590500 007b8982 01011101 93420a01  .Y...{.......B..
 0cd0 1300007c 89820100 11019342 0a00007d  ...|.......B...}
 0ce0 3400030e 3a0b3b0b 4913320b 020a0000  4...:.;.I.2.....
 0cf0 7e340003 0e3a0b3b 05491302 0a000000  ~4...:.;.I......
 0d00 01110010 06110112 0103081b 08250813  .............%..
 0d10 05000000 01110010 06110112 0103081b  ................
 0d20 08250813 05000000 01110010 06110112  .%..............
 0d30 0103081b 08250813 05000000 01110010  .....%..........
 0d40 06110112 0103081b 08250813 05000000  .........%......
 0d50 01110010 06110112 0103081b 08250813  .............%..
 0d60 05000000 01110010 06110112 0103081b  ................
 0d70 08250813 05000000                    .%......        
Contents of section .debug_line:
 0000 16000000 02001000 00000201 fb0e0a00  ................
 0010 01010101 00000001 0000240e 00000200  ..........$.....
 0020 2e060000 0201fb0e 0a000101 01010000  ................
 0030 00012f70 72697661 74652f76 61722f66  ../private/var/f
 0040 6f6c6465 72732f76 392f665f 5f703966  olders/v9/f__p9f
 0050 7473336d 39377a30 38307233 7171765f  ts3m97z080r3qqv_
 0060 71303030 3030676e 2f542f41 70705472  q00000gn/T/AppTr
 0070 616e736c 6f636174 696f6e2f 34463435  anslocation/4F45
 0080 46313536 2d333745 422d3438 34302d38  F156-37EB-4840-8
 0090 3343432d 42413943 46453031 39433533  3CC-BA9CFE019C53
 00a0 2f642f41 72647569 6e6f2031 2e382e39  /d/Arduino 1.8.9
 00b0 2e617070 2f436f6e 74656e74 732f4a61  .app/Contents/Ja
 00c0 76612f68 61726477 6172652f 61726475  va/hardware/ardu
 00d0 696e6f2f 6176722f 636f7265 732f6172  ino/avr/cores/ar
 00e0 6475696e 6f002f55 73657273 2f6a656e  duino./Users/jen
 00f0 73627265 6974656e 73746569 6e2f446f  sbreitenstein/Do
 0100 63756d65 6e74732f 41726475 696e6f2f  cuments/Arduino/
 0110 6c696272 61726965 732f4e65 774c6971  libraries/NewLiq
 0120 75696443 72797374 616c5f6c 6962002f  uidCrystal_lib./
 0130 70726976 6174652f 7661722f 666f6c64  private/var/fold
 0140 6572732f 76392f66 5f5f7039 66747333  ers/v9/f__p9fts3
 0150 6d39377a 30383072 33717176 5f713030  m97z080r3qqv_q00
 0160 30303067 6e2f542f 41707054 72616e73  000gn/T/AppTrans
 0170 6c6f6361 74696f6e 2f344634 35463135  location/4F45F15
 0180 362d3337 45422d34 3834302d 38334343  6-37EB-4840-83CC
 0190 2d424139 43464530 31394335 332f642f  -BA9CFE019C53/d/
 01a0 41726475 696e6f20 312e382e 392e6170  Arduino 1.8.9.ap
 01b0 702f436f 6e74656e 74732f4a 6176612f  p/Contents/Java/
 01c0 68617264 77617265 2f617264 75696e6f  hardware/arduino
 01d0 2f617672 2f6c6962 72617269 65732f57  /avr/libraries/W
 01e0 6972652f 7372632f 7574696c 69747900  ire/src/utility.
 01f0 2f707269 76617465 2f766172 2f666f6c  /private/var/fol
 0200 64657273 2f76392f 665f5f70 39667473  ders/v9/f__p9fts
 0210 336d3937 7a303830 72337171 765f7130  3m97z080r3qqv_q0
 0220 30303030 676e2f54 2f417070 5472616e  0000gn/T/AppTran
 0230 736c6f63 6174696f 6e2f3446 34354631  slocation/4F45F1
 0240 35362d33 3745422d 34383430 2d383343  56-37EB-4840-83C
 0250 432d4241 39434645 30313943 35332f64  C-BA9CFE019C53/d
 0260 2f417264 75696e6f 20312e38 2e392e61  /Arduino 1.8.9.a
 0270 70702f43 6f6e7465 6e74732f 4a617661  pp/Contents/Java
 0280 2f686172 64776172 652f6172 6475696e  /hardware/arduin
 0290 6f2f6176 722f6c69 62726172 6965732f  o/avr/libraries/
 02a0 57697265 2f737263 002f5f73 68617265  Wire/src./_share
 02b0 645f2f64 65762f64 65762e70 726f6a65  d_/dev/dev.proje
 02c0 6374732f 544f432f 4d494449 2d464f4f  cts/TOC/MIDI-FOO
 02d0 542d434f 4e54524f 4c4c4552 2e505542  T-CONTROLLER.PUB
 02e0 4c49432e 4749542f 61726475 696e6f2f  LIC.GIT/arduino/
 02f0 4a425f43 50555f55 73616765 5f426173  JB_CPU_Usage_Bas
 0300 6963002f 70726976 6174652f 7661722f  ic./private/var/
 0310 666f6c64 6572732f 76392f66 5f5f7039  folders/v9/f__p9
 0320 66747333 6d39377a 30383072 33717176  fts3m97z080r3qqv
 0330 5f713030 30303067 6e2f542f 41707054  _q00000gn/T/AppT
 0340 72616e73 6c6f6361 74696f6e 2f344634  ranslocation/4F4
 0350 35463135 362d3337 45422d34 3834302d  5F156-37EB-4840-
 0360 38334343 2d424139 43464530 31394335  83CC-BA9CFE019C5
 0370 332f642f 41726475 696e6f20 312e382e  3/d/Arduino 1.8.
 0380 392e6170 702f436f 6e74656e 74732f4a  9.app/Contents/J
 0390 6176612f 68617264 77617265 2f746f6f  ava/hardware/too
 03a0 6c732f61 76722f61 76722f69 6e636c75  ls/avr/avr/inclu
 03b0 6465002f 70726976 6174652f 7661722f  de./private/var/
 03c0 666f6c64 6572732f 76392f66 5f5f7039  folders/v9/f__p9
 03d0 66747333 6d39377a 30383072 33717176  fts3m97z080r3qqv
 03e0 5f713030 30303067 6e2f542f 41707054  _q00000gn/T/AppT
 03f0 72616e73 6c6f6361 74696f6e 2f344634  ranslocation/4F4
 0400 35463135 362d3337 45422d34 3834302d  5F156-37EB-4840-
 0410 38334343 2d424139 43464530 31394335  83CC-BA9CFE019C5
 0420 332f642f 41726475 696e6f20 312e382e  3/d/Arduino 1.8.
 0430 392e6170 702f436f 6e74656e 74732f4a  9.app/Contents/J
 0440 6176612f 68617264 77617265 2f746f6f  ava/hardware/too
 0450 6c732f61 76722f6c 69622f67 63632f61  ls/avr/lib/gcc/a
 0460 76722f35 2e342e30 2f696e63 6c756465  vr/5.4.0/include
 0470 002f7072 69766174 652f7661 722f666f  ./private/var/fo
 0480 6c646572 732f7639 2f665f5f 70396674  lders/v9/f__p9ft
 0490 73336d39 377a3038 30723371 71765f71  s3m97z080r3qqv_q
 04a0 30303030 30676e2f 542f4170 70547261  00000gn/T/AppTra
 04b0 6e736c6f 63617469 6f6e2f34 46343546  nslocation/4F45F
 04c0 3135362d 33374542 2d343834 302d3833  156-37EB-4840-83
 04d0 43432d42 41394346 45303139 4335332f  CC-BA9CFE019C53/
 04e0 642f4172 6475696e 6f20312e 382e392e  d/Arduino 1.8.9.
 04f0 6170702f 436f6e74 656e7473 2f4a6176  app/Contents/Jav
 0500 612f6861 72647761 72652f61 72647569  a/hardware/ardui
 0510 6e6f2f61 76722f76 61726961 6e74732f  no/avr/variants/
 0520 65696768 74616e61 6c6f6769 6e707574  eightanaloginput
 0530 732f2e2e 2f737461 6e646172 64000077  s/../standard..w
 0540 6972696e 675f6469 67697461 6c2e6300  iring_digital.c.
 0550 0100004c 69717569 64437279 7374616c  ...LiquidCrystal
 0560 2e637070 00020000 77697269 6e672e63  .cpp....wiring.c
 0570 00010000 5072696e 742e6370 70000100  ....Print.cpp...
 0580 00747769 2e630003 00005769 72652e63  .twi.c....Wire.c
 0590 70700004 00004c43 442e6370 70000200  pp....LCD.cpp...
 05a0 004c4344 2e680002 00005072 696e742e  .LCD.h....Print.
 05b0 68000100 00616269 2e637070 00010000  h....abi.cpp....
 05c0 53747265 616d2e68 00010000 6d61696e  Stream.h....main
 05d0 2e637070 00010000 4a425f43 50555f55  .cpp....JB_CPU_U
 05e0 73616765 5f426173 69632e69 6e6f0005  sage_Basic.ino..
 05f0 00004c69 71756964 43727973 74616c2e  ..LiquidCrystal.
 0600 68000200 00737464 696e742e 68000600  h....stdint.h...
 0610 00737464 6465662e 68000700 00576972  .stddef.h....Wir
 0620 652e6800 04000041 72647569 6e6f2e68  e.h....Arduino.h
 0630 00010000 70696e73 5f617264 75696e6f  ....pins_arduino
 0640 2e680008 0000686f 6f6b732e 63000100  .h....hooks.c...
 0650 00000005 020e0100 00031c01 03020900  ................
 0660 00010301 090a0001 03030908 00010303  ................
 0670 09040001 03010910 0001030f 090a0001  ................
 0680 03010902 00010301 09020001 03010906  ................
 0690 000103d2 00090400 01030109 00000103  ................
 06a0 01090a00 01030109 08000103 03090800  ................
 06b0 01030409 06000103 b87f0904 00010315  ................
 06c0 090e0001 036b0906 00010306 090c0001  .....k..........
 06d0 037d0908 00010303 09060001 030b0906  .}..............
 06e0 00010304 09040001 03030904 00010303  ................
 06f0 09080001 032f090a 00010302 090e0001  ...../..........
 0700 03010902 00010302 09020001 03010904  ................
 0710 00010302 09080001 03030906 00010402  ................
 0720 03a30109 04000103 00092200 01030409  ..........".....
 0730 04000103 7e090400 01030209 06000103  ....~...........
 0740 75091e00 01030209 0a000103 0c090600  u...............
 0750 01037409 14000104 03038f7e 09040001  ..t........~....
 0760 03020900 00010302 09020001 03010902  ................
 0770 00010302 09100001 03080902 00010301  ................
 0780 09080001 03060906 00010302 09020001  ................
 0790 03010922 00010303 09020001 03010914  ..."............
 07a0 00010302 09080001 0302090a 00010301  ................
 07b0 091a0001 0301090a 0001037e 090c0001  ...........~....
 07c0 0305090c 00010404 03ae7f09 12000103  ................
 07d0 01091600 01030109 04000103 01090600  ................
 07e0 01030409 20000104 0503c802 09140001  .... ...........
 07f0 03020900 00010304 09060001 03050908  ................
 0800 000103b2 7f090600 01030409 00000103  ................
 0810 05091200 01030509 0e000103 01090400  ................
 0820 01030209 16000103 74090e00 01030509  ........t.......
 0830 04000103 0a090200 01040603 4d090200  ............M...
 0840 01037509 02000103 08090000 01036809  ..u...........h.
 0850 06000103 0a090000 01036e09 06000103  ..........n.....
 0860 01090000 01030109 06000103 6c090800  ............l...
 0870 01030909 08000103 03090600 01035b09  ..............[.
 0880 08000103 10090c00 01030309 0a000104  ................
 0890 02036909 0c000103 03090200 01031f09  ..i.............
 08a0 0a000103 01090a00 01030209 06000103  ................
 08b0 04090400 01034109 08000103 01091000  ......A.........
 08c0 01030109 06000103 01090200 01030109  ................
 08d0 04000103 01090e00 01037f09 0a000103  ................
 08e0 5b090200 01030209 0e000103 04090e00  [...............
 08f0 01030209 06000103 03090600 01030209  ................
 0900 04000103 02090600 01030409 04000103  ................
 0910 06091600 01030309 06000103 7d090800  ............}...
 0920 01040703 dc010904 00010301 09000001  ................
 0930 03020910 00010372 09060001 03010900  .......r........
 0940 000103ce 7e091000 01030209 14000103  ....~...........
 0950 01091800 01030209 18000103 02090800  ................
 0960 01030509 04000103 02090600 01037e09  ..............~.
 0970 06000103 02090800 01030409 04000103  ................
 0980 03090800 01037d09 10000103 8a7f0904  ......}.........
 0990 00010301 090a0001 03020904 00010302  ................
 09a0 09060001 03010902 00010304 09020001  ................
 09b0 03020908 00010308 09060001 0304090c  ................
 09c0 00010307 09060001 040303ef 00091200  ................
 09d0 01040703 957f0908 00010403 03eb0009  ................
 09e0 12000104 0703997f 090a0001 040303e7  ................
 09f0 00091200 01040703 9d7f0906 0001030a  ................
 0a00 09140001 040303d9 00090800 01040703  ................
 0a10 ab7f0908 00010403 03d50009 0a000104  ................
 0a20 0703af7f 090a0001 040303d1 00090a00  ................
 0a30 01040703 b57f0906 00010403 03cb0009  ................
 0a40 0a000104 0703b97f 09080001 033e0904  .............>..
 0a50 00010355 09080001 04030334 09080001  ...U.......4....
 0a60 04070340 09080001 03020904 000103a8  ...@............
 0a70 01090800 0103dc7e 090e0001 03a40109  .......~........
 0a80 08000104 0803b101 09020001 036d0902  .............m..
 0a90 00010409 03e87c09 02000103 65090200  ......|.....e...
 0aa0 01030009 00000103 75090600 01030109  ........u.......
 0ab0 00000103 01090400 01030109 1a000104  ................
 0ac0 04039401 09060001 03050920 00010303  ........... ....
 0ad0 09020001 0303090c 00010301 09120001  ................
 0ae0 03020904 0001037c 09120001 03070908  .......|........
 0af0 00010301 09060001 040a03bb 7e091e00  ............~...
 0b00 01030309 00000104 03031409 04000103  ................
 0b10 03091600 01030109 10000103 03090400  ................
 0b20 01030109 04000103 7e090400 01030309  ........~.......
 0b30 08000103 01090400 01030309 06000103  ................
 0b40 01090400 01030109 10000103 01092600  ..............&.
 0b50 01040503 d1020916 00010301 09220001  ............."..
 0b60 0327094e 00010359 09060001 03050970  .'.N...Y.......p
 0b70 00010308 09060001 0302090c 00010345  ...............E
 0b80 09180001 03cf0009 04000103 0b090600  ................
 0b90 01030309 18000103 08090a00 01030109  ................
 0ba0 18000103 03090800 01030409 06000103  ................
 0bb0 0f090400 01030209 06000103 06090600  ................
 0bc0 01030209 0a000103 9e7f091a 00010303  ................
 0bd0 09060001 03ea0009 04000103 01090800  ................
 0be0 01030309 0c000103 02091000 01030c09  ................
 0bf0 06000103 02090600 01030209 04000103  ................
 0c00 03090400 01030209 06000103 01090800  ................
 0c10 01030109 06000103 05090400 01030209  ................
 0c20 18000103 cd7e090e 0001037e 09080001  .....~.....~....
 0c30 03c00109 06000103 07090600 01030109  ................
 0c40 04000103 03090400 01092200 00010104  ..........".....
 0c50 09000502 520a0000 032d0104 0b031109  ....R....-......
 0c60 08000104 06037209 18000104 09037d09  ......r.......}.
 0c70 0c000104 02031709 08000103 b501090c  ................
 0c80 00010301 09060001 03010906 00010302  ................
 0c90 09060001 03010906 00010301 09060001  ................
 0ca0 03010906 00010301 09060001 03010906  ................
 0cb0 00010301 09060001 03010906 00010307  ................
 0cc0 090e0001 037e090a 0001030c 090a0001  .....~..........
 0cd0 037e0906 00010305 09060001 03030908  .~..............
 0ce0 00010302 09080001 03030904 00010307  ................
 0cf0 09080001 03030906 00010301 090a0001  ................
 0d00 0302090a 00010302 09080001 03040906  ................
 0d10 00010301 09060001 040c03ed 7d091200  ............}...
 0d20 01040303 d3010900 00010306 09020001  ................
 0d30 03010906 0001030d 09060001 03010906  ................
 0d40 0001030d 09060001 030b090a 00010303  ................
 0d50 09040001 0302090a 0001030a 090a0001  ................
 0d60 0307090a 00010309 090a0001 0323090a  .............#..
 0d70 00010301 090a0001 0301090a 00010317  ................
 0d80 090a0001 0309090a 0001040d 038d7d09  ..............}.
 0d90 04000103 02090c00 01040303 2f090e00  ............/...
 0da0 01030409 02000103 01090200 01030109  ................
 0db0 10000104 0d034d09 02000104 0303d301  ......M.........
 0dc0 09100001 040c03c5 7e090400 01040d03  ........~.......
 0dd0 6d090400 01040303 28093600 01030409  m.......(.6.....
 0de0 02000103 01090200 01030109 10000104  ................
 0df0 0703ec00 09020001 04030334 090a0001  ...........4....
 0e00 040d03b7 7e090600 01040403 1f090600  ....~...........
 0e10 01032a09 08000104 0d03bb7f 090e0001  ..*.............
 0e20 0404031b 09060001 032a0908 00010356  .........*.....V
 0e30 09260001 040c036f 09080001 090e0000  .&.....o........
 0e40 01015e00 00000200 41000000 0201fb0e  ..^.....A.......
 0e50 0a000101 01010000 00012e2e 2f2e2e2f  ............/../
 0e60 2e2e2f2e 2e2f6763 632f6c69 62676363  ../../gcc/libgcc
 0e70 2f636f6e 6669672f 61767200 006c6962  /config/avr..lib
 0e80 3166756e 63732e53 00010000 00000502  1funcs.S........
 0e90 420d0000 03e61101 03020902 00010902  B...............
 0ea0 00000101 1e010000 02004100 00000201  ..........A.....
 0eb0 fb0e0a00 01010101 00000001 2e2e2f2e  ............../.
 0ec0 2e2f2e2e 2f2e2e2f 6763632f 6c696267  ./../../gcc/libg
 0ed0 63632f63 6f6e6669 672f6176 7200006c  cc/config/avr..l
 0ee0 69623166 756e6373 2e530001 00000000  ib1funcs.S......
 0ef0 0502e80c 000003e6 0c010301 09020001  ................
 0f00 03010902 00010301 09020001 03010902  ................
 0f10 00010302 09020001 03020902 00010301  ................
 0f20 09020001 03010902 00010301 09020001  ................
 0f30 03010902 00010301 09020001 03010902  ................
 0f40 00010301 09020001 03010902 00010301  ................
 0f50 09020001 03010902 00010301 09020001  ................
 0f60 03010902 00010302 09020001 03010902  ................
 0f70 00010301 09020001 03010902 00010301  ................
 0f80 09020001 03010902 00010302 09020001  ................
 0f90 03010902 00010301 09020001 03010902  ................
 0fa0 00010302 09020001 03020902 00010302  ................
 0fb0 09020001 03020902 00010302 09020001  ................
 0fc0 09020000 01019400 00000200 41000000  ............A...
 0fd0 0201fb0e 0a000101 01010000 00012e2e  ................
 0fe0 2f2e2e2f 2e2e2f2e 2e2f6763 632f6c69  /../../../gcc/li
 0ff0 62676363 2f636f6e 6669672f 61767200  bgcc/config/avr.
 1000 006c6962 3166756e 63732e53 00010000  .lib1funcs.S....
 1010 00000502 c6000000 03e91201 03010902  ................
 1020 00010301 09020001 03010902 00010301  ................
 1030 09020001 03010902 00010303 09020001  ................
 1040 03050902 00010302 09020001 03010902  ................
 1050 00010301 09020001 09020000 01018200  ................
 1060 00000200 41000000 0201fb0e 0a000101  ....A...........
 1070 01010000 00012e2e 2f2e2e2f 2e2e2f2e  ......../../../.
 1080 2e2f6763 632f6c69 62676363 2f636f6e  ./gcc/libgcc/con
 1090 6669672f 61767200 006c6962 3166756e  fig/avr..lib1fun
 10a0 63732e53 00010000 00000502 dc000000  cs.S............
 10b0 03891301 03010902 00010301 09020001  ................
 10c0 03010902 00010302 09020001 03020902  ................
 10d0 00010301 09020001 03010902 00010902  ................
 10e0 00000101 8e000000 02004100 00000201  ..........A.....
 10f0 fb0e0a00 01010101 00000001 2e2e2f2e  ............../.
 1100 2e2f2e2e 2f2e2e2f 6763632f 6c696267  ./../../gcc/libg
 1110 63632f63 6f6e6669 672f6176 7200006c  cc/config/avr..l
 1120 69623166 756e6373 2e530001 00000000  ib1funcs.S......
 1130 0502ec00 000003a2 13010301 09020001  ................
 1140 03010902 00010304 09020001 03020902  ................
 1150 00010306 09020001 03010902 00010302  ................
 1160 09040001 03010902 00010305 09020001  ................
 1170 09020000 01017600 00000200 41000000  ......v.....A...
 1180 0201fb0e 0a000101 01010000 00012e2e  ................
 1190 2f2e2e2f 2e2e2f2e 2e2f6763 632f6c69  /../../../gcc/li
 11a0 62676363 2f636f6e 6669672f 61767200  bgcc/config/avr.
 11b0 006c6962 3166756e 63732e53 00010000  .lib1funcs.S....
 11c0 00000502 2c0d0000 03f81101 03010902  ....,...........
 11d0 0001031f 09020001 03010902 00010301  ................
 11e0 09020001 03010902 00010902 00000101  ................
Contents of section .debug_frame:
 0000 10000000 ffffffff 0100027f 240c2002  ............$. .
 0010 a4010000 0c000000 00000000 0e010000  ................
 0020 3e000000 0c000000 00000000 4c010000  >...........L...
 0030 9a000000 40000000 00000000 e6010000  ....@...........
 0040 76000000 410e038a 02410e04 8b03410e  v...A....A....A.
 0050 058c0441 0e068d05 410e078e 06410e08  ...A....A....A..
 0060 8f07410e 09900841 0e0a9109 410e0b9c  ..A....A....A...
 0070 0a410e0c 9d0b0000 0c000000 00000000  .A..............
 0080 5c020000 4a000000 34000000 00000000  \...J...4.......
 0090 a6020000 74000000 410e0388 02410e04  ....t...A....A..
 00a0 8903410e 058a0441 0e068b05 410e078c  ..A....A....A...
 00b0 06410e08 8d07410e 098e0841 0e0a8f09  .A....A....A....
 00c0 34000000 00000000 1a030000 54000000  4...........T...
 00d0 410e038c 02410e04 8d03410e 058e0441  A....A....A....A
 00e0 0e068f05 410e0790 06410e08 9107410e  ....A....A....A.
 00f0 099c0841 0e0a9d09 0c000000 00000000  ...A............
 0100 6e030000 14000000 0c000000 00000000  n...............
 0110 82030000 50000000 0c000000 00000000  ....P...........
 0120 d2030000 02000000 0c000000 00000000  ................
 0130 d4030000 06000000 0c000000 00000000  ................
 0140 da030000 06000000 0c000000 00000000  ................
 0150 e0030000 0e000000 18000000 00000000  ................
 0160 ee030000 16000000 410e039c 02410e04  ........A....A..
 0170 9d030000 1c000000 00000000 04040000  ................
 0180 22000000 410e039c 02410e04 9d03410e  "...A....A....A.
 0190 05420d1c 0c000000 00000000 26040000  .B..........&...
 01a0 28000000 28000000 00000000 4e040000  (...(.......N...
 01b0 36000000 410e038e 02410e04 8f03410e  6...A....A....A.
 01c0 05910441 0e069c05 410e079d 06000000  ...A....A.......
 01d0 20000000 00000000 84040000 5e000000   ...........^...
 01e0 410e0390 02410e04 9103410e 059c0441  A....A....A....A
 01f0 0e069d05 0c000000 00000000 e2040000  ................
 0200 16000000 0c000000 00000000 f8040000  ................
 0210 10000000 1c000000 00000000 08050000  ................
 0220 84000000 410e039c 02410e04 9d03420d  ....A....A....B.
 0230 1c410e0c 20000000 00000000 8c050000  .A.. ...........
 0240 20010000 410e0390 02410e04 9103410e   ...A....A....A.
 0250 059c0441 0e069d05 0c000000 00000000  ...A............
 0260 ac060000 02000000 0c000000 00000000  ................
 0270 ae060000 02000000 0c000000 00000000  ................
 0280 b0060000 02000000 0c000000 00000000  ................
 0290 b2060000 06000000 0c000000 00000000  ................
 02a0 b8060000 24000000 3c000000 00000000  ....$...<.......
 02b0 dc060000 82000000 410e0388 02410e04  ........A....A..
 02c0 8903410e 058a0441 0e068b05 410e0790  ..A....A....A...
 02d0 06410e08 9107410e 099c0841 0e0a9d09  .A....A....A....
 02e0 420d1c41 0e2b0000 0c000000 00000000  B..A.+..........
 02f0 5e070000 04000000 20000000 00000000  ^....... .......
 0300 4a0a0000 0e010000 410e0390 02410e04  J.......A....A..
 0310 9103410e 059c0441 0e069d05 34000000  ..A....A....4...
 0320 00000000 62070000 94000000 410e0381  ....b.......A...
 0330 02410e04 8003440e 05920441 0e069305  .A....D....A....
 0340 410e0798 06410e08 9907410e 099a0841  A....A....A....A
 0350 0e0a9b09 0c000000 00000000 580b0000  ............X...
 0360 90010000 54000000 00000000 f6070000  ....T...........
 0370 54020000 410e0381 02410e04 8003440e  T...A....A....D.
 0380 05920441 0e069305 410e0794 06410e08  ...A....A....A..
 0390 9507410e 09960841 0e0a9709 410e0b98  ..A....A....A...
 03a0 0a410e0c 990b410e 0d9a0c41 0e0e9b0d  .A....A....A....
 03b0 410e0f9e 0e410e10 9f0f0000           A....A......    
Contents of section .debug_str:
 0000 6176722d 6c696263 20322e30 2e300075  avr-libc 2.0.0.u
 0010 696e7438 5f740075 696e7431 365f7400  int8_t.uint16_t.
 0020 5f5f6565 70726f6d 00554452 30005543  __eeprom.UDR0.UC
 0030 53523041 00554353 52304200 55435352  SR0A.UCSR0B.UCSR
 0040 30430055 42525230 00545741 4d520054  0C.UBRR0.TWAMR.T
 0050 57425200 54574352 00545753 52005457  WBR.TWCR.TWSR.TW
 0060 44520054 57415200 54494d53 4b310054  DR.TWAR.TIMSK1.T
 0070 49465231 00544343 52314100 54434352  IFR1.TCCR1A.TCCR
 0080 31420054 43435231 43005443 4e543100  1B.TCCR1C.TCNT1.
 0090 4f435231 41004f43 52314200 49435231  OCR1A.OCR1B.ICR1
 00a0 00475443 43520054 494d534b 32005449  .GTCCR.TIMSK2.TI
 00b0 46523200 54434352 32410054 43435232  FR2.TCCR2A.TCCR2
 00c0 42005443 4e543200 4f435232 42004f43  B.TCNT2.OCR2B.OC
 00d0 52324100 41535352 00475443 43520041  R2A.ASSR.GTCCR.A
 00e0 444d5558 00414443 00414443 53524100  DMUX.ADC.ADCSRA.
 00f0 41444353 52420044 49445230 00414353  ADCSRB.DIDR0.ACS
 0100 52004449 44523100 504f5254 42004444  R.DIDR1.PORTB.DD
 0110 52420050 494e4200 504f5254 43004444  RB.PINB.PORTC.DD
 0120 52430050 494e4300 504f5254 44004444  RC.PINC.PORTD.DD
 0130 52440050 494e4400 4f435230 42004f43  RD.PIND.OCR0B.OC
 0140 52304100 54434e54 30005443 43523042  R0A.TCNT0.TCCR0B
 0150 00544343 52304100 54494d53 4b300054  .TCCR0A.TIMSK0.T
 0160 49465230 00475443 43520045 49435241  IFR0.GTCCR.EICRA
 0170 0045494d 534b0045 49465200 50434943  .EIMSK.EIFR.PCIC
 0180 52005043 4d534b32 0050434d 534b3100  R.PCMSK2.PCMSK1.
 0190 50434d53 4b300050 43494652 00535044  PCMSK0.PCIFR.SPD
 01a0 52005350 53520053 50435200 57445443  R.SPSR.SPCR.WDTC
 01b0 53520050 5252004f 53434341 4c00434c  SR.PRR.OSCCAL.CL
 01c0 4b505200 53524547 00535000 53504d43  KPR.SREG.SP.SPMC
 01d0 5352004d 43554352 004d4355 53520053  SR.MCUCR.MCUSR.S
 01e0 4d435200 4750494f 52320047 50494f52  MCR.GPIOR2.GPIOR
 01f0 31004750 494f5230 00454541 52004545  1.GPIOR0.EEAR.EE
 0200 44520045 45435200 6e756d42 69747300  DR.EECR.numBits.
 0210 7477695f 73746174 65005f64 6973706c  twi_state._displ
 0220 61796d6f 64650077 72697465 00656e61  aymode.write.ena
 0230 626c6500 666c7573 68007365 6e640074  ble.flush.send.t
 0240 696d6572 305f6672 61637400 77726974  imer0_fract.writ
 0250 655f6572 726f7200 64696769 74616c5f  e_error.digital_
 0260 70696e5f 746f5f62 69745f6d 61736b5f  pin_to_bit_mask_
 0270 50474d00 7477695f 6d617374 65724275  PGM.twi_masterBu
 0280 66666572 4c656e67 7468005f 64617461  fferLength._data
 0290 5f70696e 73007369 7a655f74 0073697a  _pins.size_t.siz
 02a0 65747970 6500504f 53495449 5645005f  etype.POSITIVE._
 02b0 5f656d70 74790062 6567696e 00696e69  _empty.begin.ini
 02c0 74566172 69616e74 00747769 5f73656e  tVariant.twi_sen
 02d0 6453746f 70006d61 696e0064 61746100  dStop.main.data.
 02e0 64656c61 79007661 6c756500 5f646973  delay.value._dis
 02f0 706c6179 66756e63 74696f6e 00656e64  playfunction.end
 0300 54696d65 5f6d7300 7477695f 72784275  Time_ms.twi_rxBu
 0310 66666572 496e6465 78007569 6e74385f  fferIndex.uint8_
 0320 74005f5a 4e355072 696e7443 32457600  t._ZN5PrintC2Ev.
 0330 5f6c6f6f 70436f75 6e746572 00736574  _loopCounter.set
 0340 75700071 75616e74 69747900 626f6f6c  up.quantity.bool
 0350 005f5f63 78615f70 7572655f 76697274  .__cxa_pure_virt
 0360 75616c00 5f5f6164 64723136 006c656e  ual.__addr16.len
 0370 67746800 7475726e 4f666650 574d0072  gth.turnOffPWM.r
 0380 65616400 7477695f 7472616e 736d6974  ead.twi_transmit
 0390 2e706172 742e3200 77726974 654e6269  .part.2.writeNbi
 03a0 74730070 696e4d6f 64650064 69676974  ts.pinMode.digit
 03b0 616c5f70 696e5f74 6f5f706f 72745f50  al_pin_to_port_P
 03c0 474d005f 5f626173 655f6374 6f722000  GM.__base_ctor .
 03d0 7065656b 0074696d 6572305f 6d696c6c  peek.timer0_mill
 03e0 69730061 7661696c 61626c65 466f7257  is.availableForW
 03f0 72697465 00636c65 61720066 6f757262  rite.clear.fourb
 0400 69746d6f 64650070 6f72745f 746f5f6d  itmode.port_to_m
 0410 6f64655f 50474d00 3c617274 69666963  ode_PGM.<artific
 0420 69616c3e 0074696d 6572305f 6f766572  ial>.timer0_over
 0430 666c6f77 5f636f75 6e740072 6f775f6f  flow_count.row_o
 0440 66667365 74734c61 72676500 62797465  ffsetsLarge.byte
 0450 006f6c64 53524547 00707269 6e744e75  .oldSREG.printNu
 0460 6d626572 00747769 5f747842 75666665  mber.twi_txBuffe
 0470 724c656e 67746800 5f636f6c 73005f5a  rLength._cols._Z
 0480 4e31334c 69717569 64437279 7374616c  N13LiquidCrystal
 0490 3473656e 64456868 2e706172 742e3100  4sendEhh.part.1.
 04a0 5f646973 706c6179 636f6e74 726f6c00  _displaycontrol.
 04b0 61766169 6c61626c 65006469 73706c61  available.displa
 04c0 79007477 695f6d61 73746572 42756666  y.twi_masterBuff
 04d0 65720075 6e736967 6e656420 63686172  er.unsigned char
 04e0 00747769 5f736c61 7277005f 5f696e69  .twi_slarw.__ini
 04f0 7469616c 697a655f 7000474e 55204749  tialize_p.GNU GI
 0500 4d504c45 20352e34 2e30202d 6d6e2d66  MPLE 5.4.0 -mn-f
 0510 6c617368 3d31202d 6d6d6375 3d617672  lash=1 -mmcu=avr
 0520 35202d6d 6e2d666c 6173683d 31202d6d  5 -mn-flash=1 -m
 0530 6e6f2d73 6b69702d 62756720 2d6d6d63  no-skip-bug -mmc
 0540 753d6176 7235202d 67202d4f 73202d4f  u=avr5 -g -Os -O
 0550 73202d66 6d617468 2d657272 6e6f202d  s -fmath-errno -
 0560 66736967 6e65642d 7a65726f 73202d66  fsigned-zeros -f
 0570 74726170 70696e67 2d6d6174 68202d66  trapping-math -f
 0580 6e6f2d74 72617076 202d666e 6f2d6f70  no-trapv -fno-op
 0590 656e6d70 202d666e 6f2d6f70 656e6163  enmp -fno-openac
 05a0 63202d66 6e6f2d65 78636570 74696f6e  c -fno-exception
 05b0 73202d66 7573652d 6c696e6b 65722d70  s -fuse-linker-p
 05c0 6c756769 6e202d66 6c747261 6e73006c  lugin -fltrans.l
 05d0 6f6f7000 706f7274 5f746f5f 6f757470  oop.port_to_outp
 05e0 75745f50 474d0074 77695f69 6e526570  ut_PGM.twi_inRep
 05f0 53746172 74007072 696e7400 75696e74  Start.print.uint
 0600 33325f74 0075696e 7431365f 74005f76  32_t.uint16_t._v
 0610 7074722e 5072696e 74005f5f 72657375  ptr.Print.__resu
 0620 6c74006c 6f6e6720 756e7369 676e6564  lt.long unsigned
 0630 20696e74 00747769 5f72656c 65617365   int.twi_release
 0640 42757300 73746172 74005374 7265616d  Bus.start.Stream
 0650 0074696d 65720073 65744261 636b6c69  .timer.setBackli
 0660 67687400 7477695f 74784275 66666572  ght.twi_txBuffer
 0670 496e6465 78005f72 775f7069 6e00696e  Index._rw_pin.in
 0680 69740074 77695f74 72616e73 6d697400  it.twi_transmit.
 0690 70756c73 65456e61 626c6500 7477695f  pulseEnable.twi_
 06a0 73746f70 00627566 66657200 5f72735f  stop.buffer._rs_
 06b0 70696e00 5f5f7072 696f7269 74790074  pin.__priority.t
 06c0 68697300 5f626163 6b6c6967 68745069  his._backlightPi
 06d0 6e005f47 4c4f4241 4c5f5f73 75625f49  n._GLOBAL__sub_I
 06e0 5f5f5a4e 3754776f 57697265 38727842  __ZN7TwoWire8rxB
 06f0 75666665 72450074 77695f6d 61737465  ufferE.twi_maste
 0700 72427566 66657249 6e646578 005f5f73  rBufferIndex.__s
 0710 74617469 635f696e 69746961 6c697a61  tatic_initializa
 0720 74696f6e 5f616e64 5f646573 74727563  tion_and_destruc
 0730 74696f6e 5f300064 69676974 616c5772  tion_0.digitalWr
 0740 69746500 706f7274 00747769 5f727842  ite.port.twi_rxB
 0750 75666665 72007475 726e4f66 6650574d  uffer.turnOffPWM
 0760 2e706172 742e3000 5f5f7674 626c5f70  .part.0.__vtbl_p
 0770 74725f74 79706500 4e454741 54495645  tr_type.NEGATIVE
 0780 00736574 43757273 6f72005f 74696d65  .setCursor._time
 0790 6f757400 5f656e61 626c655f 70696e00  out._enable_pin.
 07a0 646f7473 697a6500 5f474c4f 42414c5f  dotsize._GLOBAL_
 07b0 5f495f36 35353335 5f305f4a 425f4350  _I_65535_0_JB_CP
 07c0 555f5573 6167655f 42617369 632e696e  U_Usage_Basic.in
 07d0 6f2e6370 702e6f00 7477695f 6572726f  o.cpp.o.twi_erro
 07e0 72005f6e 756d6c69 6e657300 6261636b  r._numlines.back
 07f0 6c696768 74005f5f 76656374 6f725f32  light.__vector_2
 0800 3400745f 6261636b 6c696768 74506f6c  4.t_backlightPol
 0810 005f706f 6c617269 7479006c 6f6f702e  ._polarity.loop.
 0820 70617274 2e30005f 474c4f42 414c5f5f  part.0._GLOBAL__
 0830 7375625f 495f6c63 64005f73 74617274  sub_I_lcd._start
 0840 4d696c6c 69730074 77695f74 78427566  Millis.twi_txBuf
 0850 66657200 5f5f7665 63746f72 5f313600  fer.__vector_16.
 0860 726f775f 6f666673 65747344 65660064  row_offsetsDef.d
 0870 69676974 616c5f70 696e5f74 6f5f7469  igital_pin_to_ti
 0880 6d65725f 50474d00 64656c61 794d6963  mer_PGM.delayMic
 0890 726f7365 636f6e64 73005477 6f576972  roseconds.TwoWir
 08a0 65006261 7365004c 69717569 64437279  e.base.LiquidCry
 08b0 7374616c 006d6963 726f7300 5f737461  stal.micros._sta
 08c0 72745469 6d655f6d 73007477 695f7265  rtTime_ms.twi_re
 08d0 706c7900 73657442 61636b6c 69676874  ply.setBacklight
 08e0 50696e00 636f6d6d 616e6400           Pin.command.    
Contents of section .debug_loc:
 0000 0e010000 20010000 01006820 0100004c  .... .....h ...L
 0010 01000004 00f30168 9f000000 00000000  .......h........
 0020 00200100 002a0100 00010068 00000000  . ...*.....h....
 0030 00000000 34010000 4a010000 06006a93  ....4...J.....j.
 0040 016b9301 00000000 00000000 10010000  .k..............
 0050 16010000 09008800 03a40000 00229f16  ............."..
 0060 0100001a 01000006 006e9301 6f93011a  .........n..o...
 0070 01000020 01000009 00880003 a4000000  ... ............
 0080 229f2001 00002c01 00000f00 8e0003a4  ". ...,.........
 0090 00000022 03900000 001c9f00 00000000  ..."............
 00a0 00000018 0100001e 01000009 00880003  ................
 00b0 90000000 229f1e01 00002c01 00000600  ....".....,.....
 00c0 6e93016f 93010000 00000000 00003001  n..o..........0.
 00d0 00003401 00000600 6e93016f 93010000  ..4.....n..o....
 00e0 00000000 00003a01 00003e01 00000600  ......:...>.....
 00f0 6e93016f 93010000 00000000 00004001  n..o..........@.
 0100 00004a01 00000100 68000000 00000000  ..J.....h.......
 0110 004c0100 00800100 00010068 80010000  .L.........h....
 0120 84010000 0400f301 689f8401 00009401  ........h.......
 0130 00000100 68940100 00980100 000400f3  ....h...........
 0140 01689f98 0100009c 01000001 00689c01  .h...........h..
 0150 0000a401 00000400 f301689f a4010000  ..........h.....
 0160 a6010000 010068a6 010000ac 01000004  ......h.........
 0170 00f30168 9fac0100 00b00100 00010068  ...h...........h
 0180 b0010000 b4010000 0400f301 689fb401  ............h...
 0190 0000b801 00000100 68b80100 00e60100  ........h.......
 01a0 000400f3 01689f00 00000000 0000005e  .....h.........^
 01b0 010000d8 01000001 0063d801 0000da01  .........c......
 01c0 00000400 8300209f dc010000 e0010000  ...... .........
 01d0 01006300 00000000 00000066 010000c4  ..c........f....
 01e0 01000001 006e0000 00000000 0000cc01  .....n..........
 01f0 0000e401 00000600 6a93016b 93010000  ........j..k....
 0200 00000000 0000ce01 0000e401 00000100  ................
 0210 69000000 00000000 004e0100 00540100  i........N...T..
 0220 00090088 00036800 0000229f 54010000  ......h...".T...
 0230 58010000 06006e93 016f9301 58010000  X.....n..o..X...
 0240 80010000 09008800 03680000 00229f84  .........h..."..
 0250 01000094 01000009 00880003 68000000  ............h...
 0260 229f9801 00009c01 00000900 88000368  "..............h
 0270 00000022 9fa40100 00a60100 00090088  ..."............
 0280 00036800 0000229f ac010000 b0010000  ..h...".........
 0290 09008800 03680000 00229fb4 010000b8  .....h..."......
 02a0 01000009 00880003 68000000 229f0000  ........h..."...
 02b0 00000000 00005601 00005c01 00000900  ......V...\.....
 02c0 880003a4 00000022 9f5c0100 00600100  .......".\...`..
 02d0 0006006e 93016f93 01600100 00800100  ...n..o..`......
 02e0 00090088 0003a400 0000229f 84010000  ..........".....
 02f0 94010000 09008800 03a40000 00229f98  ............."..
 0300 0100009c 01000009 00880003 a4000000  ................
 0310 229fa401 0000a601 00000900 880003a4  "...............
 0320 00000022 9fac0100 00b00100 00090088  ..."............
 0330 0003a400 0000229f b4010000 b8010000  ......".........
 0340 09008800 03a40000 00229f00 00000000  ........."......
 0350 0000005e 01000064 01000009 00880003  ...^...d........
 0360 90000000 229f6401 00006601 00000600  ....".d...f.....
 0370 6e93016f 93016601 00008001 00000900  n..o..f.........
 0380 88000390 00000022 9f840100 00940100  ......."........
 0390 00090088 00039000 0000229f 98010000  ..........".....
 03a0 9c010000 09008800 03900000 00229fa4  ............."..
 03b0 010000a6 01000009 00880003 90000000  ................
 03c0 229fac01 0000b001 00000900 88000390  "...............
 03d0 00000022 9fb40100 00b80100 00090088  ..."............
 03e0 00039000 0000229f 00000000 00000000  ......".........
 03f0 70010000 be010000 01006200 00000000  p.........b.....
 0400 000000c8 010000cc 01000006 006e9301  .............n..
 0410 6f930100 00000000 000000e6 010000e8  o...............
 0420 01000003 00922002 e8010000 ea010000  ...... .........
 0430 03009220 03ea0100 00ec0100 00030092  ... ............
 0440 2004ec01 0000ee01 00000300 922005ee   ............ ..
 0450 010000f0 01000003 00922006 f0010000  .......... .....
 0460 f2010000 03009220 07f20100 00f40100  ....... ........
 0470 00030092 2008f401 0000f601 00000300  .... ...........
 0480 922009f6 010000f8 01000003 0092200a  . ............ .
 0490 f8010000 fa010000 03009220 0bfa0100  ........... ....
 04a0 005c0200 00030092 200c0000 00000000  .\...... .......
 04b0 0000e601 00000402 00000600 68930169  ............h..i
 04c0 93010402 00004c02 00000600 60930161  ......L.....`..a
 04d0 93014c02 00005b02 00000600 6e93016f  ..L...[.....n..o
 04e0 93015b02 00005c02 00000400 f301689f  ..[...\.......h.
 04f0 00000000 00000000 e6010000 10020000  ................
 0500 01006610 02000050 02000001 005e5002  ..f....P.....^P.
 0510 00005c02 00000400 f301669f 00000000  ..\.......f.....
 0520 00000000 e6010000 10020000 01006410  ..............d.
 0530 02000054 02000001 005c5402 00005c02  ...T.....\T...\.
 0540 00000400 f301649f 00000000 00000000  ......d.........
 0550 10020000 30020000 01006c30 02000032  ....0.....l0...2
 0560 02000003 008c019f 32020000 48020000  ........2...H...
 0570 01006c00 00000000 00000034 0200004c  ..l........4...L
 0580 02000006 00609301 6193014c 0200005b  .....`..a..L...[
 0590 02000006 006e9301 6f93015b 0200005c  .....n..o..[...\
 05a0 02000004 00f30168 9f000000 00000000  .......h........
 05b0 00700200 008a0200 000c0068 93016993  .p.........h..i.
 05c0 016a9301 6b930100 00000000 0000005e  .j..k..........^
 05d0 0200008a 02000001 00638a02 0000a602  .........c......
 05e0 00000200 085f0000 00000000 0000a602  ....._..........
 05f0 0000a802 00000300 922002a8 020000aa  ......... ......
 0600 02000003 00922003 aa020000 ac020000  ...... .........
 0610 03009220 04ac0200 00ae0200 00030092  ... ............
 0620 2005ae02 0000b002 00000300 922006b0   ............ ..
 0630 020000b2 02000003 00922007 b2020000  .......... .....
 0640 b4020000 03009220 08b40200 00b60200  ....... ........
 0650 00030092 2009b602 00001a03 00000300  .... ...........
 0660 92200a00 00000000 000000a6 020000bd  . ..............
 0670 0200000c 00669301 67930168 93016993  .....f..g..h..i.
 0680 01bd0200 00100300 000c005c 93015d93  ...........\..].
 0690 015e9301 5f930100 00000000 000000c2  .^.._...........
 06a0 020000f0 0200000c 00589301 5993015a  .........X..Y..Z
 06b0 93015b93 01f00200 00fc0200 00040078  ..[............x
 06c0 e8079ffc 02000018 0300000c 00589301  .............X..
 06d0 5993015a 93015b93 01000000 00000000  Y..Z..[.........
 06e0 001a0300 001c0300 00030092 20021c03  ............ ...
 06f0 00001e03 00000300 9220031e 03000020  ......... ..... 
 0700 03000003 00922004 20030000 22030000  ...... . ..."...
 0710 03009220 05220300 00240300 00030092  ... ."...$......
 0720 20062403 00002603 00000300 92200726   .$...&...... .&
 0730 03000028 03000003 00922008 28030000  ...(...... .(...
 0740 2a030000 03009220 092a0300 006e0300  *...... .*...n..
 0750 00030092 200a0000 00000000 00001a03  .... ...........
 0760 00003403 00000600 68930169 93013403  ..4.....h..i..4.
 0770 00006c03 00000600 5c93015d 93016c03  ..l.....\..]..l.
 0780 00006e03 00000400 f301689f 00000000  ..n.......h.....
 0790 00000000 1a030000 34030000 06006693  ........4.....f.
 07a0 01679301 34030000 3a030000 0700f301  .g..4...:.......
 07b0 668c0022 9f3a0300 00560300 000900f3  f..".:...V......
 07c0 01668c00 2223019f 56030000 58030000  .f.."#..V...X...
 07d0 07008c00 f3016622 9f580300 005a0300  ......f".X...Z..
 07e0 000900f3 01668c00 2223019f 00000000  .....f.."#......
 07f0 00000000 1a030000 34030000 06006493  ........4.....d.
 0800 01659301 34030000 56030000 07008c00  .e..4...V.......
 0810 207e0022 9f560300 00580300 0006007e   ~.".V...X.....~
 0820 008c001c 9f580300 005a0300 0007008c  .....X...Z......
 0830 00207e00 229f5a03 00006003 00000800  . ~.".Z...`.....
 0840 8c0020f3 0164229f 00000000 00000000  .. ..d".........
 0850 2e030000 34030000 0200309f 34030000  ....4.....0.4...
 0860 60030000 06006c93 016d9301 00000000  `.....l..m......
 0870 00000000 82030000 a2030000 06006893  ..............h.
 0880 01699301 a2030000 ca030000 0400f301  .i..............
 0890 689fca03 0000cc03 00000600 68930169  h...........h..i
 08a0 9301cc03 0000ce03 00000400 f301689f  ..............h.
 08b0 ce030000 d0030000 06006893 01699301  ..........h..i..
 08c0 d0030000 d2030000 0400f301 689f0000  ............h...
 08d0 00000000 00008203 0000c203 00000100  ................
 08e0 66c20300 00ca0300 000400f3 01669fca  f............f..
 08f0 030000d2 03000001 00660000 00000000  .........f......
 0900 0000a203 0000b803 00000100 68b80300  ............h...
 0910 00ba0300 00030088 019fba03 0000c003  ................
 0920 00000100 68000000 00000000 00d40300  ....h...........
 0930 00d80300 00060068 93016993 01d80300  .......h..i.....
 0940 00da0300 000400f3 01689f00 00000000  .........h......
 0950 000000da 030000de 03000006 00689301  .............h..
 0960 699301de 030000e0 03000004 00f30168  i..............h
 0970 9f000000 00000000 00e00300 00e40300  ................
 0980 00060068 93016993 01e40300 00ee0300  ...h..i.........
 0990 000400f3 01689f00 00000000 000000ee  .....h..........
 09a0 030000f0 03000003 00922002 f0030000  .......... .....
 09b0 f2030000 03009220 03f20300 00040400  ....... ........
 09c0 00030092 20040000 00000000 0000ee03  .... ...........
 09d0 0000f403 00000600 68930169 9301f403  ........h..i....
 09e0 00000404 00000400 f301689f 00000000  ..........h.....
 09f0 00000000 ee030000 f8030000 06006693  ..............f.
 0a00 01679301 f8030000 fb030000 06006893  .g............h.
 0a10 01699301 fb030000 04040000 0400f301  .i..............
 0a20 669f0000 00000000 0000ee03 0000fb03  f...............
 0a30 00000600 64930165 9301fb03 00000204  ....d..e........
 0a40 00000600 6c93016d 93010204 00000404  ....l..m........
 0a50 00000600 68930169 93010000 00000000  ....h..i........
 0a60 00000404 00000604 00000300 92200206  ............. ..
 0a70 04000008 04000003 00922003 08040000  .......... .....
 0a80 0a040000 03009220 040a0400 000e0400  ....... ........
 0a90 00030092 20050e04 00002604 00000200  .... .....&.....
 0aa0 8c050000 00000000 00000404 00001404  ................
 0ab0 00000600 68930169 93011404 00002604  ....h..i......&.
 0ac0 00000400 f301689f 00000000 00000000  ......h.........
 0ad0 04040000 12040000 01006612 04000024  ..........f....$
 0ae0 04000002 008c0124 04000026 04000003  .......$...&....
 0af0 0092207e 00000000 00000000 26040000  .. ~........&...
 0b00 2a040000 06006893 01699301 2a040000  *.....h..i..*...
 0b10 4b040000 06006e93 016f9301 4b040000  K.....n..o..K...
 0b20 4c040000 0400f301 689f4c04 00004e04  L.......h.L...N.
 0b30 00000600 6e93016f 93010000 00000000  ....n..o........
 0b40 00002604 00004404 00000100 66440400  ..&...D.....fD..
 0b50 00460400 000400f3 01669f46 04000048  .F.......f.F...H
 0b60 04000001 00664804 00004c04 00000400  .....fH...L.....
 0b70 f301669f 4c040000 4e040000 01006600  ..f.L...N.....f.
 0b80 00000000 0000004e 04000050 04000003  .......N...P....
 0b90 00922002 50040000 52040000 03009220  .. .P...R...... 
 0ba0 03520400 00540400 00030092 20045404  .R...T...... .T.
 0bb0 00005604 00000300 92200556 04000058  ..V...... .V...X
 0bc0 04000003 00922006 58040000 84040000  ...... .X.......
 0bd0 03009220 07000000 00000000 004e0400  ... .........N..
 0be0 00600400 00060068 93016993 01600400  .`.....h..i..`..
 0bf0 007c0400 0006006c 93016d93 017c0400  .|.....l..m..|..
 0c00 00830400 00060068 93016993 01830400  .......h..i.....
 0c10 00840400 000400f3 01689f00 00000000  .........h......
 0c20 0000004e 04000063 04000001 00666304  ...N...c.....fc.
 0c30 00007e04 00000100 617e0400 00830400  ..~.....a~......
 0c40 00020088 16830400 00840400 000400f3  ................
 0c50 01669f00 00000000 0000004e 04000063  .f.........N...c
 0c60 04000006 00649301 65930163 04000082  .....d..e..c....
 0c70 04000006 005e9301 5f930182 04000083  .....^.._.......
 0c80 04000002 00880983 04000084 04000004  ................
 0c90 00f30164 9f000000 00000000 00840400  ...d............
 0ca0 00860400 00030092 20028604 00008804  ........ .......
 0cb0 00000300 92200388 0400008a 04000003  ..... ..........
 0cc0 00922004 8a040000 8c040000 03009220  .. ............ 
 0cd0 058c0400 00e20400 00030092 20060000  ............ ...
 0ce0 00000000 00008404 00009c04 00000600  ................
 0cf0 68930169 93019c04 0000da04 00000600  h..i............
 0d00 6c93016d 9301da04 0000e104 00000600  l..m............
 0d10 68930169 9301e104 0000e204 00000400  h..i............
 0d20 f301689f 00000000 00000000 84040000  ..h.............
 0d30 94040000 01006694 040000dc 04000001  ......f.........
 0d40 0061dc04 0000e104 00000100 66e10400  .a..........f...
 0d50 00e20400 000400f3 01669f00 00000000  .........f......
 0d60 00000084 0400009f 04000001 00649f04  .............d..
 0d70 0000de04 00000100 60de0400 00e20400  ........`.......
 0d80 000400f3 01649f00 00000000 000000ba  .....d..........
 0d90 040000d0 04000001 00610000 00000000  .........a......
 0da0 0000ba04 0000d004 00000600 6c93016d  ............l..m
 0db0 93010000 00000000 0000e204 0000f104  ................
 0dc0 00000600 68930169 9301f104 0000f804  ....h..i........
 0dd0 00000400 f301689f 00000000 00000000  ......h.........
 0de0 e2040000 f1040000 010066f1 040000f8  ..........f.....
 0df0 04000004 00f30166 9f000000 00000000  .......f........
 0e00 00f80400 00070500 00060068 93016993  ...........h..i.
 0e10 01070500 00080500 000400f3 01689f00  .............h..
 0e20 00000000 000000f8 04000007 05000001  ................
 0e30 00660705 00000805 00000400 f301669f  .f............f.
 0e40 00000000 00000000 08050000 0a050000  ................
 0e50 03009220 020a0500 000c0500 00030092  ... ............
 0e60 20030c05 00001005 00000300 92200410   ............ ..
 0e70 05000012 05000002 008c0412 0500008c  ................
 0e80 05000002 008c0c00 00000000 00000008  ................
 0e90 05000056 05000001 00685605 00005805  ...V.....hV...X.
 0ea0 00000400 f301689f 58050000 78050000  ......h.X...x...
 0eb0 01006800 00000000 0000008c 0500008e  ..h.............
 0ec0 05000003 00922002 8e050000 90050000  ...... .........
 0ed0 03009220 03900500 00920500 00030092  ... ............
 0ee0 20049205 00009405 00000300 92200594   ............ ..
 0ef0 050000ac 06000003 00922006 00000000  .......... .....
 0f00 00000000 8c050000 9c050000 06006893  ..............h.
 0f10 01699301 9c050000 a6060000 06006c93  .i............l.
 0f20 016d9301 a6060000 ab060000 06006893  .m............h.
 0f30 01699301 ab060000 ac060000 0400f301  .i..............
 0f40 689f0000 00000000 00008c05 0000ba05  h...............
 0f50 00000100 66ba0500 00bd0500 0002008c  ....f...........
 0f60 08bd0500 00ac0600 000400f3 01669f00  .............f..
 0f70 00000000 0000008c 050000bd 05000001  ................
 0f80 0064bd05 0000ac06 00000400 f301649f  .d............d.
 0f90 00000000 00000000 8c050000 bd050000  ................
 0fa0 010062bd 050000ac 06000004 00f30162  ..b............b
 0fb0 9f000000 00000000 00d60500 00de0500  ................
 0fc0 0004000a 4b469f00 00000000 000000f0  ....KF..........
 0fd0 050000fa 05000004 000a5302 9f000000  ..........S.....
 0fe0 00000000 000c0600 00120600 0004000a  ................
 0ff0 53029f00 00000000 0000002e 06000036  S..............6
 1000 06000004 000a4b46 9f000000 00000000  ......KF........
 1010 00400600 004a0600 0004000a 53029f00  .@...J......S...
 1020 00000000 00000054 0600005a 06000004  .......T...Z....
 1030 000a5302 9f000000 00000000 00640600  ..S..........d..
 1040 006c0600 00030008 eb9f0000 00000000  .l..............
 1050 00007006 00007806 00000600 6c93016d  ..p...x.....l..m
 1060 93010000 00000000 00007806 00008806  ..........x.....
 1070 00000600 6c93016d 93010000 00000000  ....l..m........
 1080 00008006 00008806 00000400 0a3b1f9f  .............;..
 1090 00000000 00000000 94060000 a6060000  ................
 10a0 06006c93 016d9301 a6060000 ab060000  ..l..m..........
 10b0 06006893 01699301 ab060000 ac060000  ..h..i..........
 10c0 0400f301 689f0000 00000000 0000b206  ....h...........
 10d0 0000b606 00000600 68930169 9301b606  ........h..i....
 10e0 0000b806 00000400 f301689f 00000000  ..........h.....
 10f0 00000000 b8060000 d2060000 06006893  ..............h.
 1100 01699301 d2060000 d5060000 06006693  .i............f.
 1110 01679301 d5060000 d6060000 0400f301  .g..............
 1120 689fd606 0000da06 00000600 68930169  h...........h..i
 1130 9301da06 0000dc06 00000400 f301689f  ..............h.
 1140 00000000 00000000 dc060000 de060000  ................
 1150 03009220 02de0600 00e00600 00030092  ... ............
 1160 2003e006 0000e206 00000300 922004e2   ............ ..
 1170 060000e4 06000003 00922005 e4060000  .......... .....
 1180 e6060000 03009220 06e60600 00e80600  ....... ........
 1190 00030092 2007e806 0000ea06 00000300  .... ...........
 11a0 922008ea 060000ec 06000003 00922009  . ............ .
 11b0 ec060000 f0060000 03009220 0af00600  ........... ....
 11c0 00f20600 0002008c 0af20600 005e0700  .............^..
 11d0 0002008c 2b000000 00000000 00dc0600  ....+...........
 11e0 00120700 000c0066 93016793 01689301  .......f..g..h..
 11f0 69930112 0700001a 0700000c 00669301  i............f..
 1200 67930168 93016993 01200700 003f0700  g..h..i.. ...?..
 1210 000c0062 93016393 01649301 65930100  ...b..c..d..e...
 1220 00000000 000000dc 06000004 07000001  ................
 1230 00640407 00001207 00000400 f301649f  .d............d.
 1240 00000000 00000000 fc060000 12070000  ................
 1250 03009176 9f120700 00540700 00060060  ...v.....T.....`
 1260 93016193 01000000 00000000 001c0700  ..a.............
 1270 001e0700 00010066 1e070000 2a070000  .......f....*...
 1280 01006e2a 0700002c 07000003 008e509f  ..n*...,......P.
 1290 2c070000 2e070000 01006e00 00000000  ,.........n.....
 12a0 0000004a 0a00004c 0a000003 00922002  ...J...L...... .
 12b0 4c0a0000 4e0a0000 03009220 034e0a00  L...N...... .N..
 12c0 00500a00 00030092 2004500a 0000520a  .P...... .P...R.
 12d0 00000300 92200552 0a000058 0b000003  ..... .R...X....
 12e0 00922006 00000000 00000000 520a0000  .. .........R...
 12f0 7e0a0000 030009ff 9f000000 00000000  ~...............
 1300 00520a00 007e0a00 00020031 9f000000  .R...~.....1....
 1310 00000000 007e0a00 004e0b00 00020031  .....~...N.....1
 1320 9f000000 00000000 007e0a00 004e0b00  .........~...N..
 1330 00030009 ff9f0000 00000000 00007e0a  ..............~.
 1340 00004e0b 00000200 3e9f0000 00000000  ..N.....>.......
 1350 00007e0a 00004e0b 00000200 3c9f0000  ..~...N.....<...
 1360 00000000 00007e0a 00004e0b 00000200  ......~...N.....
 1370 349f0000 00000000 00007e0a 00004e0b  4.........~...N.
 1380 00000200 359f0000 00000000 00007e0a  ....5.........~.
 1390 00004e0b 00000200 369f0000 00000000  ..N.....6.......
 13a0 00007e0a 00004e0b 00000200 379f0000  ..~...N.....7...
 13b0 00000000 00007e0a 00004e0b 00000200  ......~...N.....
 13c0 389f0000 00000000 00007e0a 00004e0b  8.........~...N.
 13d0 00000200 399f0000 00000000 00007e0a  ....9.........~.
 13e0 00004e0b 00000200 3a9f0000 00000000  ..N.....:.......
 13f0 00007e0a 00004e0b 00000200 3b9f0000  ..~...N.....;...
 1400 00000000 0000920a 00004e0b 00000200  ..........N.....
 1410 309f0000 00000000 0000920a 00004e0b  0.............N.
 1420 00000200 3e9f0000 00000000 0000920a  ....>...........
 1430 00004e0b 00000300 09ff9f00 00000000  ..N.............
 1440 00000092 0a00004e 0b000002 003c9f00  .......N.....<..
 1450 00000000 00000092 0a00004e 0b000002  ...........N....
 1460 00349f00 00000000 00000092 0a00004e  .4.............N
 1470 0b000002 00359f00 00000000 00000092  .....5..........
 1480 0a00004e 0b000002 00369f00 00000000  ...N.....6......
 1490 00000092 0a00004e 0b000002 00379f00  .......N.....7..
 14a0 00000000 00000092 0a00004e 0b000002  ...........N....
 14b0 00389f00 00000000 00000092 0a00004e  .8.............N
 14c0 0b000002 00399f00 00000000 00000092  .....9..........
 14d0 0a00004e 0b000002 003a9f00 00000000  ...N.....:......
 14e0 00000092 0a00004e 0b000002 003b9f00  .......N.....;..
 14f0 00000000 000000d4 0a0000dc 0a000002  ................
 1500 00309fdc 0a0000e2 0a000009 00800003  .0..............
 1510 d8018000 1c9fe20a 0000e60a 00000a00  ................
 1520 03d80180 00208000 229fe60a 0000f00a  ..... ..".......
 1530 00000900 800003d8 0180001c 9ff00a00  ................
 1540 00f20a00 000b008c 0003dc01 80001c23  ...............#
 1550 049ff20a 0000f60a 00000b00 8c0003dc  ................
 1560 0180001c 23039ff6 0a00004e 0b00000b  ....#......N....
 1570 008c0003 dc018000 1c23049f 00000000  .........#......
 1580 00000000 62070000 64070000 03009220  ....b...d...... 
 1590 02640700 00660700 00030092 20036607  .d...f...... .f.
 15a0 00006e07 00000300 9220046e 07000070  ..n...... .n...p
 15b0 07000003 00922005 70070000 72070000  ...... .p...r...
 15c0 03009220 06720700 00740700 00030092  ... .r...t......
 15d0 20077407 00007607 00000300 92200876   .t...v...... .v
 15e0 07000078 07000003 00922009 78070000  ...x...... .x...
 15f0 f6070000 03009220 0a000000 00000000  ....... ........
 1600 00880700 008c0700 000c0068 93016993  ...........h..i.
 1610 016a9301 6b93018c 0700009a 07000003  .j..k...........
 1620 0088019f 9a070000 9c070000 0c006893  ..............h.
 1630 01699301 6a93016b 93019c07 0000a607  .i..j..k........
 1640 00000300 88019fa6 070000ca 0700000c  ................
 1650 00689301 6993016a 93016b93 01ca0700  .h..i..j..k.....
 1660 00e00700 00050003 b6018000 00000000  ................
 1670 00000000 8c070000 90070000 01006390  ..............c.
 1680 0700009e 07000001 00629e07 0000a007  .........b......
 1690 00000300 83039fa0 070000ec 07000001  ................
 16a0 0062ec07 0000f007 00000500 03b50180  .b..............
 16b0 00000000 00000000 000c0c00 000e0c00  ................
 16c0 000c0068 93016993 016a9301 6b930100  ...h..i..j..k...
 16d0 00000000 000000fa 0b00000e 0c000001  ................
 16e0 00620000 00000000 00007c0c 0000820c  .b........|.....
 16f0 00000400 0a3b1f9f 00000000 00000000  .....;..........
 1700 700c0000 720c0000 0c005c93 015d9301  p...r.....\..]..
 1710 5e93015f 93010000 00000000 00005e0c  ^.._..........^.
 1720 0000720c 00000100 68000000 00000000  ..r.....h.......
 1730 00900c00 009e0c00 0002003a 9f000000  ...........:....
 1740 00000000 00900c00 009e0c00 0006000c  ................
 1750 c0c62d00 9f000000 00000000 00ac0c00  ..-.............
 1760 00d20c00 0002003a 9f000000 00000000  .......:........
 1770 00ac0c00 00c80c00 000a007c 0003b101  ...........|....
 1780 8000061c 9fc80c00 00d10c00 000c0062  ...............b
 1790 93016393 01649301 65930100 00000000  ..c..d..e.......
 17a0 000000f6 070000f8 07000003 00922002  .............. .
 17b0 f8070000 fa070000 03009220 03fa0700  ........... ....
 17c0 00020800 00030092 20040208 00000408  ........ .......
 17d0 00000300 92200504 08000006 08000003  ..... ..........
 17e0 00922006 06080000 08080000 03009220  .. ............ 
 17f0 07080800 000a0800 00030092 20080a08  ............ ...
 1800 00000c08 00000300 9220090c 0800000e  ......... ......
 1810 08000003 0092200a 0e080000 10080000  ...... .........
 1820 03009220 0b100800 00120800 00030092  ... ............
 1830 200c1208 00001408 00000300 92200d14   ............ ..
 1840 08000016 08000003 0092200e 16080000  .......... .....
 1850 18080000 03009220 0f180800 004a0a00  ....... .....J..
 1860 00030092 20100000 00000000 00000609  .... ...........
 1870 00000a09 00000200 319f0000 00000000  ........1.......
 1880 00000c0a 00000e0a 00000200 309f0000  ............0...
 1890 00000000 0000140a 0000160a 00000200  ................
 18a0 319f0000 00000000 0000               1.........      
Contents of section .debug_ranges:
 0000 34020000 44020000 58020000 5c020000  4...D...X...\...
 0010 00000000 00000000 94060000 a2060000  ................
 0020 aa060000 ac060000 00000000 00000000  ................
 0030 1e0c0000 220c0000 260c0000 da0c0000  ...."...&.......
 0040 00000000 00000000 1e0c0000 220c0000  ............"...
 0050 5c0c0000 da0c0000 00000000 00000000  \...............
 0060 1e0c0000 220c0000 720c0000 820c0000  ...."...r.......
 0070 00000000 00000000 1e0c0000 220c0000  ............"...
 0080 7c0c0000 820c0000 00000000 00000000  |...............
 0090 0e010000 4a0a0000 4a0a0000 580b0000  ....J...J...X...
 00a0 580b0000 e80c0000 00000000 00000000  X...............

Disassembly of section .data:

00800100 <__data_start>:
  800100:	c0 c6       	rjmp	.+3456   	; 0x800e82 <__bss_end+0xca1>
  800102:	2d 00       	.word	0x002d	; ????
  800104:	00 40       	sbci	r16, 0x00	; 0
  800106:	14 54       	subi	r17, 0x44	; 68
  800108:	00 40       	sbci	r16, 0x00	; 0
  80010a:	10 50       	subi	r17, 0x00	; 0

0080010c <_ZTV7TwoWire>:
  80010c:	00 00       	nop
  80010e:	00 00       	nop
  800110:	02 02       	muls	r16, r18
  800112:	f7 01       	movw	r30, r14
  800114:	59 03       	fmul	r21, r17
  800116:	e9 01       	movw	r28, r18
  800118:	f0 01       	movw	r30, r0
  80011a:	ed 01       	movw	r28, r26
  80011c:	ea 01       	movw	r28, r20

0080011e <_ZTV13LiquidCrystal>:
  80011e:	00 00       	nop
  800120:	00 00       	nop
  800122:	71 02       	muls	r23, r17
  800124:	8d 01       	movw	r16, r26
  800126:	59 03       	fmul	r21, r17
  800128:	58 03       	fmul	r21, r16
  80012a:	c6 02       	muls	r28, r22
  80012c:	27 02       	muls	r18, r23
  80012e:	13 02       	muls	r17, r19
  800130:	42 02       	muls	r20, r18
  800132:	4c 6f       	ori	r20, 0xFC	; 252
  800134:	6f 70       	andi	r22, 0x0F	; 15
  800136:	73 3a       	cpi	r23, 0xA3	; 163
  800138:	20 00       	.word	0x0020	; ????
  80013a:	54 69       	ori	r21, 0x94	; 148
  80013c:	6d 65       	ori	r22, 0x5D	; 93
  80013e:	3a 20       	and	r3, r10
  800140:	00 5b       	subi	r16, 0xB0	; 176
  800142:	6d 73       	andi	r22, 0x3D	; 61
  800144:	5d 00       	.word	0x005d	; ????

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5d 00 	jmp	0xba	; 0xba <__ctors_end>
   4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
   8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
   c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  10:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  14:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  18:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  1c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  20:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  24:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  28:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  2c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  30:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  34:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  38:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  3c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  40:	0c 94 b1 03 	jmp	0x762	; 0x762 <__vector_16>
  44:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  48:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  4c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  50:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  54:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  58:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  5c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  60:	0c 94 fb 03 	jmp	0x7f6	; 0x7f6 <__vector_24>
  64:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 08       	sbc	r0, r0
  6c:	00 02       	muls	r16, r16
  6e:	01 00       	.word	0x0001	; ????
  70:	00 03       	mulsu	r16, r16
  72:	04 07       	cpc	r16, r20
	...

0000007c <port_to_output_PGM>:
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	25 00       	.word	0x0025	; ????
  82:	28 00       	.word	0x0028	; ????
  84:	2b 00       	.word	0x002b	; ????

00000086 <port_to_mode_PGM>:
  86:	00 00       	nop
  88:	00 00       	nop
  8a:	24 00       	.word	0x0024	; ????
  8c:	27 00       	.word	0x0027	; ????
  8e:	2a 00       	.word	0x002a	; ????

00000090 <digital_pin_to_port_PGM>:
  90:	04 04       	cpc	r0, r4
  92:	04 04       	cpc	r0, r4
  94:	04 04       	cpc	r0, r4
  96:	04 04       	cpc	r0, r4
  98:	02 02       	muls	r16, r18
  9a:	02 02       	muls	r16, r18
  9c:	02 02       	muls	r16, r18
  9e:	03 03       	mulsu	r16, r19
  a0:	03 03       	mulsu	r16, r19
  a2:	03 03       	mulsu	r16, r19

000000a4 <digital_pin_to_bit_mask_PGM>:
  a4:	01 02       	muls	r16, r17
  a6:	04 08       	sbc	r0, r4
  a8:	10 20       	and	r1, r0
  aa:	40 80       	ld	r4, Z
  ac:	01 02       	muls	r16, r17
  ae:	04 08       	sbc	r0, r4
  b0:	10 20       	and	r1, r0
  b2:	01 02       	muls	r16, r17
  b4:	04 08       	sbc	r0, r4
  b6:	10 20       	and	r1, r0

000000b8 <__ctors_start>:
  b8:	25 05       	cpc	r18, r5

000000ba <__ctors_end>:
  ba:	11 24       	eor	r1, r1
  bc:	1f be       	out	0x3f, r1	; 63
  be:	cf ef       	ldi	r28, 0xFF	; 255
  c0:	d8 e0       	ldi	r29, 0x08	; 8
  c2:	de bf       	out	0x3e, r29	; 62
  c4:	cd bf       	out	0x3d, r28	; 61

000000c6 <__do_copy_data>:
  c6:	11 e0       	ldi	r17, 0x01	; 1
  c8:	a0 e0       	ldi	r26, 0x00	; 0
  ca:	b1 e0       	ldi	r27, 0x01	; 1
  cc:	e6 e4       	ldi	r30, 0x46	; 70
  ce:	fd e0       	ldi	r31, 0x0D	; 13
  d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x10>
  d2:	05 90       	lpm	r0, Z+
  d4:	0d 92       	st	X+, r0
  d6:	a6 34       	cpi	r26, 0x46	; 70
  d8:	b1 07       	cpc	r27, r17
  da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0xc>

000000dc <__do_clear_bss>:
  dc:	21 e0       	ldi	r18, 0x01	; 1
  de:	a6 e4       	ldi	r26, 0x46	; 70
  e0:	b1 e0       	ldi	r27, 0x01	; 1
  e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
  e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
  e6:	a1 3e       	cpi	r26, 0xE1	; 225
  e8:	b2 07       	cpc	r27, r18
  ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>

000000ec <__do_global_ctors>:
  ec:	10 e0       	ldi	r17, 0x00	; 0
  ee:	cd e5       	ldi	r28, 0x5D	; 93
  f0:	d0 e0       	ldi	r29, 0x00	; 0
  f2:	04 c0       	rjmp	.+8      	; 0xfc <__do_global_ctors+0x10>
  f4:	21 97       	sbiw	r28, 0x01	; 1
  f6:	fe 01       	movw	r30, r28
  f8:	0e 94 96 06 	call	0xd2c	; 0xd2c <__tablejump2__>
  fc:	cc 35       	cpi	r28, 0x5C	; 92
  fe:	d1 07       	cpc	r29, r17
 100:	c9 f7       	brne	.-14     	; 0xf4 <__do_global_ctors+0x8>
 102:	0e 94 ac 05 	call	0xb58	; 0xb58 <main>
 106:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <_exit>

0000010a <__bad_interrupt>:
 10a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010e <pinMode.constprop.41>:
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	fc 01       	movw	r30, r24
 112:	ec 55       	subi	r30, 0x5C	; 92
 114:	ff 4f       	sbci	r31, 0xFF	; 255
 116:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 118:	fc 01       	movw	r30, r24
 11a:	e0 57       	subi	r30, 0x70	; 112
 11c:	ff 4f       	sbci	r31, 0xFF	; 255
 11e:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 120:	88 23       	and	r24, r24
 122:	99 f0       	breq	.+38     	; 0x14a <pinMode.constprop.41+0x3c>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	88 0f       	add	r24, r24
 128:	99 1f       	adc	r25, r25
 12a:	fc 01       	movw	r30, r24
 12c:	ea 57       	subi	r30, 0x7A	; 122
 12e:	ff 4f       	sbci	r31, 0xFF	; 255
 130:	a5 91       	lpm	r26, Z+
 132:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
 134:	fc 01       	movw	r30, r24
 136:	e4 58       	subi	r30, 0x84	; 132
 138:	ff 4f       	sbci	r31, 0xFF	; 255
 13a:	85 91       	lpm	r24, Z+
 13c:	94 91       	lpm	r25, Z
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 13e:	8f b7       	in	r24, 0x3f	; 63
                cli();
 140:	f8 94       	cli
		*reg |= bit;
 142:	ec 91       	ld	r30, X
 144:	e2 2b       	or	r30, r18
 146:	ec 93       	st	X, r30
		SREG = oldSREG;
 148:	8f bf       	out	0x3f, r24	; 63
 14a:	08 95       	ret

0000014c <digitalWrite>:
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	fc 01       	movw	r30, r24
 150:	e8 59       	subi	r30, 0x98	; 152
 152:	ff 4f       	sbci	r31, 0xFF	; 255
 154:	24 91       	lpm	r18, Z
	uint8_t bit = digitalPinToBitMask(pin);
 156:	fc 01       	movw	r30, r24
 158:	ec 55       	subi	r30, 0x5C	; 92
 15a:	ff 4f       	sbci	r31, 0xFF	; 255
 15c:	34 91       	lpm	r19, Z
	uint8_t port = digitalPinToPort(pin);
 15e:	fc 01       	movw	r30, r24
 160:	e0 57       	subi	r30, 0x70	; 112
 162:	ff 4f       	sbci	r31, 0xFF	; 255
 164:	e4 91       	lpm	r30, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 166:	ee 23       	and	r30, r30
 168:	09 f4       	brne	.+2      	; 0x16c <digitalWrite+0x20>
 16a:	3c c0       	rjmp	.+120    	; 0x1e4 <digitalWrite+0x98>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 16c:	22 23       	and	r18, r18
 16e:	39 f1       	breq	.+78     	; 0x1be <digitalWrite+0x72>
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 170:	23 30       	cpi	r18, 0x03	; 3
 172:	91 f0       	breq	.+36     	; 0x198 <digitalWrite+0x4c>
 174:	38 f4       	brcc	.+14     	; 0x184 <digitalWrite+0x38>
 176:	21 30       	cpi	r18, 0x01	; 1
 178:	a9 f0       	breq	.+42     	; 0x1a4 <digitalWrite+0x58>
 17a:	22 30       	cpi	r18, 0x02	; 2
 17c:	01 f5       	brne	.+64     	; 0x1be <digitalWrite+0x72>
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17e:	84 b5       	in	r24, 0x24	; 36
 180:	8f 7d       	andi	r24, 0xDF	; 223
 182:	12 c0       	rjmp	.+36     	; 0x1a8 <digitalWrite+0x5c>
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 184:	27 30       	cpi	r18, 0x07	; 7
 186:	91 f0       	breq	.+36     	; 0x1ac <digitalWrite+0x60>
 188:	28 30       	cpi	r18, 0x08	; 8
 18a:	a1 f0       	breq	.+40     	; 0x1b4 <digitalWrite+0x68>
 18c:	24 30       	cpi	r18, 0x04	; 4
 18e:	b9 f4       	brne	.+46     	; 0x1be <digitalWrite+0x72>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 190:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 194:	8f 7d       	andi	r24, 0xDF	; 223
 196:	03 c0       	rjmp	.+6      	; 0x19e <digitalWrite+0x52>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 198:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 19c:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 19e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 1a2:	0d c0       	rjmp	.+26     	; 0x1be <digitalWrite+0x72>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 1a4:	84 b5       	in	r24, 0x24	; 36
 1a6:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 1a8:	84 bd       	out	0x24, r24	; 36
 1aa:	09 c0       	rjmp	.+18     	; 0x1be <digitalWrite+0x72>
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 1ac:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 1b0:	8f 77       	andi	r24, 0x7F	; 127
 1b2:	03 c0       	rjmp	.+6      	; 0x1ba <digitalWrite+0x6e>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 1b4:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 1b8:	8f 7d       	andi	r24, 0xDF	; 223
 1ba:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 1be:	f0 e0       	ldi	r31, 0x00	; 0
 1c0:	ee 0f       	add	r30, r30
 1c2:	ff 1f       	adc	r31, r31
 1c4:	e4 58       	subi	r30, 0x84	; 132
 1c6:	ff 4f       	sbci	r31, 0xFF	; 255
 1c8:	a5 91       	lpm	r26, Z+
 1ca:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 1cc:	9f b7       	in	r25, 0x3f	; 63
	cli();
 1ce:	f8 94       	cli

	if (val == LOW) {
 1d0:	61 11       	cpse	r22, r1
 1d2:	04 c0       	rjmp	.+8      	; 0x1dc <digitalWrite+0x90>
		*out &= ~bit;
 1d4:	8c 91       	ld	r24, X
 1d6:	30 95       	com	r19
 1d8:	38 23       	and	r19, r24
 1da:	02 c0       	rjmp	.+4      	; 0x1e0 <digitalWrite+0x94>
	} else {
		*out |= bit;
 1dc:	ec 91       	ld	r30, X
 1de:	3e 2b       	or	r19, r30
 1e0:	3c 93       	st	X, r19
	}

	SREG = oldSREG;
 1e2:	9f bf       	out	0x3f, r25	; 63
 1e4:	08 95       	ret

000001e6 <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20>:
   digitalWrite(_enable_pin, LOW);
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
 1e6:	af 92       	push	r10
 1e8:	bf 92       	push	r11
 1ea:	cf 92       	push	r12
 1ec:	df 92       	push	r13
 1ee:	ef 92       	push	r14
 1f0:	ff 92       	push	r15
 1f2:	0f 93       	push	r16
 1f4:	1f 93       	push	r17
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	8c 01       	movw	r16, r24
 1fc:	5c 01       	movw	r10, r24
 1fe:	8e e0       	ldi	r24, 0x0E	; 14
 200:	a8 0e       	add	r10, r24
 202:	b1 1c       	adc	r11, r1
 204:	c4 2e       	mov	r12, r20
 206:	d1 2c       	mov	r13, r1
 208:	c0 e0       	ldi	r28, 0x00	; 0
 20a:	d0 e0       	ldi	r29, 0x00	; 0
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 20c:	e6 2e       	mov	r14, r22
 20e:	f1 2c       	mov	r15, r1

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
 210:	cc 15       	cp	r28, r12
 212:	dd 05       	cpc	r29, r13
 214:	79 f0       	breq	.+30     	; 0x234 <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20+0x4e>
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 216:	b7 01       	movw	r22, r14
 218:	0c 2e       	mov	r0, r28
 21a:	02 c0       	rjmp	.+4      	; 0x220 <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20+0x3a>
 21c:	75 95       	asr	r23
 21e:	67 95       	ror	r22
 220:	0a 94       	dec	r0
 222:	e2 f7       	brpl	.-8      	; 0x21c <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20+0x36>
 224:	61 70       	andi	r22, 0x01	; 1
 226:	f5 01       	movw	r30, r10
 228:	81 91       	ld	r24, Z+
 22a:	5f 01       	movw	r10, r30
 22c:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
 230:	21 96       	adiw	r28, 0x01	; 1
 232:	ee cf       	rjmp	.-36     	; 0x210 <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20+0x2a>
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
 234:	61 e0       	ldi	r22, 0x01	; 1
 236:	f8 01       	movw	r30, r16
 238:	85 85       	ldd	r24, Z+13	; 0x0d
 23a:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 23e:	60 e0       	ldi	r22, 0x00	; 0
 240:	f8 01       	movw	r30, r16
 242:	85 85       	ldd	r24, Z+13	; 0x0d
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
 244:	df 91       	pop	r29
 246:	cf 91       	pop	r28
 248:	1f 91       	pop	r17
 24a:	0f 91       	pop	r16
 24c:	ff 90       	pop	r15
 24e:	ef 90       	pop	r14
 250:	df 90       	pop	r13
 252:	cf 90       	pop	r12
 254:	bf 90       	pop	r11
 256:	af 90       	pop	r10
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 258:	0c 94 a6 00 	jmp	0x14c	; 0x14c <digitalWrite>

0000025c <micros>:
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
 25c:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
 25e:	f8 94       	cli
	m = timer0_overflow_count;
 260:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <timer0_overflow_count>
 264:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <timer0_overflow_count+0x1>
 268:	a0 91 bc 01 	lds	r26, 0x01BC	; 0x8001bc <timer0_overflow_count+0x2>
 26c:	b0 91 bd 01 	lds	r27, 0x01BD	; 0x8001bd <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
 270:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
 272:	a8 9b       	sbis	0x15, 0	; 21
 274:	05 c0       	rjmp	.+10     	; 0x280 <micros+0x24>
 276:	2f 3f       	cpi	r18, 0xFF	; 255
 278:	19 f0       	breq	.+6      	; 0x280 <micros+0x24>
		m++;
 27a:	01 96       	adiw	r24, 0x01	; 1
 27c:	a1 1d       	adc	r26, r1
 27e:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
 280:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
 282:	ba 2f       	mov	r27, r26
 284:	a9 2f       	mov	r26, r25
 286:	98 2f       	mov	r25, r24
 288:	88 27       	eor	r24, r24
 28a:	82 0f       	add	r24, r18
 28c:	91 1d       	adc	r25, r1
 28e:	a1 1d       	adc	r26, r1
 290:	b1 1d       	adc	r27, r1
 292:	bc 01       	movw	r22, r24
 294:	cd 01       	movw	r24, r26
 296:	42 e0       	ldi	r20, 0x02	; 2
 298:	66 0f       	add	r22, r22
 29a:	77 1f       	adc	r23, r23
 29c:	88 1f       	adc	r24, r24
 29e:	99 1f       	adc	r25, r25
 2a0:	4a 95       	dec	r20
 2a2:	d1 f7       	brne	.-12     	; 0x298 <micros+0x3c>
}
 2a4:	08 95       	ret

000002a6 <delay>:

void delay(unsigned long ms)
{
 2a6:	8f 92       	push	r8
 2a8:	9f 92       	push	r9
 2aa:	af 92       	push	r10
 2ac:	bf 92       	push	r11
 2ae:	cf 92       	push	r12
 2b0:	df 92       	push	r13
 2b2:	ef 92       	push	r14
 2b4:	ff 92       	push	r15
 2b6:	6b 01       	movw	r12, r22
 2b8:	7c 01       	movw	r14, r24
	uint32_t start = micros();
 2ba:	0e 94 2e 01 	call	0x25c	; 0x25c <micros>
 2be:	4b 01       	movw	r8, r22
 2c0:	5c 01       	movw	r10, r24

	while (ms > 0) {
 2c2:	c1 14       	cp	r12, r1
 2c4:	d1 04       	cpc	r13, r1
 2c6:	e1 04       	cpc	r14, r1
 2c8:	f1 04       	cpc	r15, r1
 2ca:	f1 f0       	breq	.+60     	; 0x308 <delay+0x62>
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2cc:	0e 94 2e 01 	call	0x25c	; 0x25c <micros>
 2d0:	dc 01       	movw	r26, r24
 2d2:	cb 01       	movw	r24, r22
 2d4:	88 19       	sub	r24, r8
 2d6:	99 09       	sbc	r25, r9
 2d8:	aa 09       	sbc	r26, r10
 2da:	bb 09       	sbc	r27, r11
 2dc:	88 3e       	cpi	r24, 0xE8	; 232
 2de:	93 40       	sbci	r25, 0x03	; 3
 2e0:	a1 05       	cpc	r26, r1
 2e2:	b1 05       	cpc	r27, r1
 2e4:	70 f3       	brcs	.-36     	; 0x2c2 <delay+0x1c>
			ms--;
 2e6:	21 e0       	ldi	r18, 0x01	; 1
 2e8:	c2 1a       	sub	r12, r18
 2ea:	d1 08       	sbc	r13, r1
 2ec:	e1 08       	sbc	r14, r1
 2ee:	f1 08       	sbc	r15, r1
			start += 1000;
 2f0:	88 ee       	ldi	r24, 0xE8	; 232
 2f2:	88 0e       	add	r8, r24
 2f4:	83 e0       	ldi	r24, 0x03	; 3
 2f6:	98 1e       	adc	r9, r24
 2f8:	a1 1c       	adc	r10, r1
 2fa:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2fc:	c1 14       	cp	r12, r1
 2fe:	d1 04       	cpc	r13, r1
 300:	e1 04       	cpc	r14, r1
 302:	f1 04       	cpc	r15, r1
 304:	19 f7       	brne	.-58     	; 0x2cc <delay+0x26>
 306:	dd cf       	rjmp	.-70     	; 0x2c2 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
 308:	ff 90       	pop	r15
 30a:	ef 90       	pop	r14
 30c:	df 90       	pop	r13
 30e:	cf 90       	pop	r12
 310:	bf 90       	pop	r11
 312:	af 90       	pop	r10
 314:	9f 90       	pop	r9
 316:	8f 90       	pop	r8
 318:	08 95       	ret

0000031a <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 31a:	cf 92       	push	r12
 31c:	df 92       	push	r13
 31e:	ef 92       	push	r14
 320:	ff 92       	push	r15
 322:	0f 93       	push	r16
 324:	1f 93       	push	r17
 326:	cf 93       	push	r28
 328:	df 93       	push	r29
 32a:	6c 01       	movw	r12, r24
 32c:	7a 01       	movw	r14, r20
 32e:	8b 01       	movw	r16, r22
  size_t n = 0;
 330:	c0 e0       	ldi	r28, 0x00	; 0
 332:	d0 e0       	ldi	r29, 0x00	; 0
  while (size--) {
 334:	ce 15       	cp	r28, r14
 336:	df 05       	cpc	r29, r15
 338:	81 f0       	breq	.+32     	; 0x35a <_ZN5Print5writeEPKhj+0x40>
    if (write(*buffer++)) n++;
 33a:	d8 01       	movw	r26, r16
 33c:	6d 91       	ld	r22, X+
 33e:	8d 01       	movw	r16, r26
 340:	d6 01       	movw	r26, r12
 342:	ed 91       	ld	r30, X+
 344:	fc 91       	ld	r31, X
 346:	01 90       	ld	r0, Z+
 348:	f0 81       	ld	r31, Z
 34a:	e0 2d       	mov	r30, r0
 34c:	c6 01       	movw	r24, r12
 34e:	09 95       	icall
 350:	89 2b       	or	r24, r25
 352:	11 f0       	breq	.+4      	; 0x358 <_ZN5Print5writeEPKhj+0x3e>
 354:	21 96       	adiw	r28, 0x01	; 1
 356:	ee cf       	rjmp	.-36     	; 0x334 <_ZN5Print5writeEPKhj+0x1a>
 358:	7e 01       	movw	r14, r28
    else break;
  }
  return n;
}
 35a:	c7 01       	movw	r24, r14
 35c:	df 91       	pop	r29
 35e:	cf 91       	pop	r28
 360:	1f 91       	pop	r17
 362:	0f 91       	pop	r16
 364:	ff 90       	pop	r15
 366:	ef 90       	pop	r14
 368:	df 90       	pop	r13
 36a:	cf 90       	pop	r12
 36c:	08 95       	ret

0000036e <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 36e:	85 ed       	ldi	r24, 0xD5	; 213
 370:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
 374:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 378:	84 fd       	sbrc	r24, 4
 37a:	fc cf       	rjmp	.-8      	; 0x374 <twi_stop+0x6>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
 37c:	10 92 8b 01 	sts	0x018B, r1	; 0x80018b <twi_state>
 380:	08 95       	ret

00000382 <twi_transmit>:
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
 382:	40 91 67 01 	lds	r20, 0x0167	; 0x800167 <twi_txBufferLength>
 386:	26 2f       	mov	r18, r22
 388:	30 e0       	ldi	r19, 0x00	; 0
 38a:	24 0f       	add	r18, r20
 38c:	31 1d       	adc	r19, r1
 38e:	21 32       	cpi	r18, 0x21	; 33
 390:	31 05       	cpc	r19, r1
 392:	dc f4       	brge	.+54     	; 0x3ca <twi_transmit+0x48>
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
 394:	20 91 8b 01 	lds	r18, 0x018B	; 0x80018b <twi_state>
 398:	24 30       	cpi	r18, 0x04	; 4
 39a:	c9 f4       	brne	.+50     	; 0x3ce <twi_transmit+0x4c>
 39c:	fc 01       	movw	r30, r24
 39e:	80 e0       	ldi	r24, 0x00	; 0
 3a0:	90 e0       	ldi	r25, 0x00	; 0
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
 3a2:	86 17       	cp	r24, r22
 3a4:	58 f4       	brcc	.+22     	; 0x3bc <twi_transmit+0x3a>
    twi_txBuffer[twi_txBufferLength+i] = data[i];
 3a6:	30 91 67 01 	lds	r19, 0x0167	; 0x800167 <twi_txBufferLength>
 3aa:	21 91       	ld	r18, Z+
 3ac:	dc 01       	movw	r26, r24
 3ae:	a9 5b       	subi	r26, 0xB9	; 185
 3b0:	be 4f       	sbci	r27, 0xFE	; 254
 3b2:	a3 0f       	add	r26, r19
 3b4:	b1 1d       	adc	r27, r1
 3b6:	2c 93       	st	X, r18
 3b8:	01 96       	adiw	r24, 0x01	; 1
 3ba:	f3 cf       	rjmp	.-26     	; 0x3a2 <twi_transmit+0x20>
  }
  twi_txBufferLength += length;
 3bc:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <twi_txBufferLength>
 3c0:	68 0f       	add	r22, r24
 3c2:	60 93 67 01 	sts	0x0167, r22	; 0x800167 <twi_txBufferLength>
 3c6:	80 e0       	ldi	r24, 0x00	; 0
 3c8:	08 95       	ret
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
 3ca:	81 e0       	ldi	r24, 0x01	; 1
 3cc:	08 95       	ret
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
 3ce:	82 e0       	ldi	r24, 0x02	; 2
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
 3d0:	08 95       	ret

000003d2 <_ZN7TwoWire5flushEv>:

  return value;
}

void TwoWire::flush(void)
{
 3d2:	08 95       	ret

000003d4 <_ZN7TwoWire4peekEv>:
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
 3d4:	8f ef       	ldi	r24, 0xFF	; 255
 3d6:	9f ef       	ldi	r25, 0xFF	; 255
 3d8:	08 95       	ret

000003da <_ZN7TwoWire4readEv>:
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
 3da:	8f ef       	ldi	r24, 0xFF	; 255
 3dc:	9f ef       	ldi	r25, 0xFF	; 255
 3de:	08 95       	ret

000003e0 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
 3e0:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <__data_end>
 3e4:	90 e0       	ldi	r25, 0x00	; 0
}
 3e6:	91 95       	neg	r25
 3e8:	81 95       	neg	r24
 3ea:	91 09       	sbc	r25, r1
 3ec:	08 95       	ret

000003ee <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
 3f2:	cb 01       	movw	r24, r22
 3f4:	ea 01       	movw	r28, r20
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
 3f6:	64 2f       	mov	r22, r20
 3f8:	0e 94 c1 01 	call	0x382	; 0x382 <twi_transmit>
  }
  return quantity;
}
 3fc:	ce 01       	movw	r24, r28
 3fe:	df 91       	pop	r29
 400:	cf 91       	pop	r28
 402:	08 95       	ret

00000404 <_ZN7TwoWire5writeEh>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
 404:	cf 93       	push	r28
 406:	df 93       	push	r29
 408:	1f 92       	push	r1
 40a:	cd b7       	in	r28, 0x3d	; 61
 40c:	de b7       	in	r29, 0x3e	; 62
 40e:	69 83       	std	Y+1, r22	; 0x01
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
 410:	61 e0       	ldi	r22, 0x01	; 1
 412:	ce 01       	movw	r24, r28
 414:	01 96       	adiw	r24, 0x01	; 1
 416:	0e 94 c1 01 	call	0x382	; 0x382 <twi_transmit>
  }
  return 1;
}
 41a:	81 e0       	ldi	r24, 0x01	; 1
 41c:	90 e0       	ldi	r25, 0x00	; 0
 41e:	0f 90       	pop	r0
 420:	df 91       	pop	r29
 422:	cf 91       	pop	r28
 424:	08 95       	ret

00000426 <_ZN13LiquidCrystal12setBacklightEh>:
#endif

//
// setBackligh
void LiquidCrystal::setBacklight ( uint8_t value )
{
 426:	fc 01       	movw	r30, r24
   // Check if there is a pin assigned to the backlight
   // ---------------------------------------------------
   if ( _backlightPin != LCD_NOBACKLIGHT )
 428:	86 89       	ldd	r24, Z+22	; 0x16
 42a:	8f 3f       	cpi	r24, 0xFF	; 255
 42c:	79 f0       	breq	.+30     	; 0x44c <_ZN13LiquidCrystal12setBacklightEh+0x26>
 42e:	21 85       	ldd	r18, Z+9	; 0x09
 430:	32 85       	ldd	r19, Z+10	; 0x0a
         }
      }
      // Not a PWM pin, set the backlight pin for POSI or NEG
      // polarity
      // --------------------------------------------------------
      else if (((value > 0) && (_polarity == POSITIVE)) ||
 432:	66 23       	and	r22, r22
 434:	19 f0       	breq	.+6      	; 0x43c <_ZN13LiquidCrystal12setBacklightEh+0x16>
 436:	23 2b       	or	r18, r19
 438:	31 f4       	brne	.+12     	; 0x446 <_ZN13LiquidCrystal12setBacklightEh+0x20>
 43a:	03 c0       	rjmp	.+6      	; 0x442 <_ZN13LiquidCrystal12setBacklightEh+0x1c>
               ((value == 0) && (_polarity == NEGATIVE)))
 43c:	21 30       	cpi	r18, 0x01	; 1
 43e:	31 05       	cpc	r19, r1
 440:	11 f4       	brne	.+4      	; 0x446 <_ZN13LiquidCrystal12setBacklightEh+0x20>
      {
         digitalWrite( _backlightPin, HIGH);
 442:	61 e0       	ldi	r22, 0x01	; 1
 444:	01 c0       	rjmp	.+2      	; 0x448 <_ZN13LiquidCrystal12setBacklightEh+0x22>
      }
      else
      {
         digitalWrite( _backlightPin, LOW);
 446:	60 e0       	ldi	r22, 0x00	; 0
 448:	0c 94 a6 00 	jmp	0x14c	; 0x14c <digitalWrite>
 44c:	08 95       	ret

0000044e <_ZN13LiquidCrystal15setBacklightPinEh14t_backlightPol>:
}

//
// setBacklightPin
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
 44e:	ef 92       	push	r14
 450:	ff 92       	push	r15
 452:	1f 93       	push	r17
 454:	cf 93       	push	r28
 456:	df 93       	push	r29
 458:	ec 01       	movw	r28, r24
 45a:	16 2f       	mov	r17, r22
 45c:	7a 01       	movw	r14, r20
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
 45e:	86 2f       	mov	r24, r22
 460:	0e 94 87 00 	call	0x10e	; 0x10e <pinMode.constprop.41>
   _backlightPin = pin;
 464:	1e 8b       	std	Y+22, r17	; 0x16
   _polarity = pol;
 466:	fa 86       	std	Y+10, r15	; 0x0a
 468:	e9 86       	std	Y+9, r14	; 0x09
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
 46a:	e8 81       	ld	r30, Y
 46c:	f9 81       	ldd	r31, Y+1	; 0x01
 46e:	04 84       	ldd	r0, Z+12	; 0x0c
 470:	f5 85       	ldd	r31, Z+13	; 0x0d
 472:	e0 2d       	mov	r30, r0
 474:	60 e0       	ldi	r22, 0x00	; 0
 476:	ce 01       	movw	r24, r28
}
 478:	df 91       	pop	r29
 47a:	cf 91       	pop	r28
 47c:	1f 91       	pop	r17
 47e:	ff 90       	pop	r15
 480:	ef 90       	pop	r14
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
   _backlightPin = pin;
   _polarity = pol;
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
 482:	09 94       	ijmp

00000484 <_ZN13LiquidCrystal4sendEhh>:

/************ low level data pushing commands **********/
//
// send
void LiquidCrystal::send(uint8_t value, uint8_t mode) 
{
 484:	0f 93       	push	r16
 486:	1f 93       	push	r17
 488:	cf 93       	push	r28
 48a:	df 93       	push	r29
 48c:	ec 01       	movw	r28, r24
 48e:	16 2f       	mov	r17, r22
 490:	04 2f       	mov	r16, r20
   // Only interested in COMMAND or DATA
   digitalWrite( _rs_pin, ( mode == LCD_DATA ) );
 492:	61 e0       	ldi	r22, 0x01	; 1
 494:	41 30       	cpi	r20, 0x01	; 1
 496:	09 f0       	breq	.+2      	; 0x49a <_ZN13LiquidCrystal4sendEhh+0x16>
 498:	60 e0       	ldi	r22, 0x00	; 0
 49a:	8b 85       	ldd	r24, Y+11	; 0x0b
 49c:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
   
   // if there is a RW pin indicated, set it low to Write
   // ---------------------------------------------------
   if (_rw_pin != 255) 
 4a0:	8c 85       	ldd	r24, Y+12	; 0x0c
 4a2:	8f 3f       	cpi	r24, 0xFF	; 255
 4a4:	19 f0       	breq	.+6      	; 0x4ac <_ZN13LiquidCrystal4sendEhh+0x28>
   { 
      digitalWrite(_rw_pin, LOW);
 4a6:	60 e0       	ldi	r22, 0x00	; 0
 4a8:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
   }
   
   if ( mode != FOUR_BITS )
 4ac:	02 30       	cpi	r16, 0x02	; 2
 4ae:	81 f0       	breq	.+32     	; 0x4d0 <_ZN13LiquidCrystal4sendEhh+0x4c>
   {   
      if ( (_displayfunction & LCD_8BITMODE ) )
 4b0:	8c 81       	ldd	r24, Y+4	; 0x04
 4b2:	84 ff       	sbrs	r24, 4
 4b4:	02 c0       	rjmp	.+4      	; 0x4ba <_ZN13LiquidCrystal4sendEhh+0x36>
      {
         writeNbits(value, 8); 
 4b6:	48 e0       	ldi	r20, 0x08	; 8
 4b8:	0c c0       	rjmp	.+24     	; 0x4d2 <_ZN13LiquidCrystal4sendEhh+0x4e>
      } 
      else 
      {
         writeNbits ( value >> 4, 4 );
 4ba:	61 2f       	mov	r22, r17
 4bc:	70 e0       	ldi	r23, 0x00	; 0
 4be:	84 e0       	ldi	r24, 0x04	; 4
 4c0:	75 95       	asr	r23
 4c2:	67 95       	ror	r22
 4c4:	8a 95       	dec	r24
 4c6:	e1 f7       	brne	.-8      	; 0x4c0 <_ZN13LiquidCrystal4sendEhh+0x3c>
 4c8:	44 e0       	ldi	r20, 0x04	; 4
 4ca:	ce 01       	movw	r24, r28
 4cc:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20>
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
 4d0:	44 e0       	ldi	r20, 0x04	; 4
 4d2:	61 2f       	mov	r22, r17
 4d4:	ce 01       	movw	r24, r28
   }
   waitUsec ( EXEC_TIME ); // wait for the command to execute by the LCD
}
 4d6:	df 91       	pop	r29
 4d8:	cf 91       	pop	r28
 4da:	1f 91       	pop	r17
 4dc:	0f 91       	pop	r16
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
 4de:	0c 94 f3 00 	jmp	0x1e6	; 0x1e6 <_ZN13LiquidCrystal10writeNbitsEhh.constprop.20>

000004e2 <_ZN3LCD5writeEh>:
   send(value, LCD_DATA);
}
#else
size_t LCD::write(uint8_t value) 
{
   send(value, LCD_DATA);
 4e2:	dc 01       	movw	r26, r24
 4e4:	ed 91       	ld	r30, X+
 4e6:	fc 91       	ld	r31, X
 4e8:	06 84       	ldd	r0, Z+14	; 0x0e
 4ea:	f7 85       	ldd	r31, Z+15	; 0x0f
 4ec:	e0 2d       	mov	r30, r0
 4ee:	41 e0       	ldi	r20, 0x01	; 1
 4f0:	09 95       	icall
   return 1;             // assume OK
}
 4f2:	81 e0       	ldi	r24, 0x01	; 1
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	08 95       	ret

000004f8 <_ZN3LCD7commandEh>:

// General LCD commands - generic methods used by the rest of the commands
// ---------------------------------------------------------------------------
void LCD::command(uint8_t value) 
{
   send(value, COMMAND);
 4f8:	dc 01       	movw	r26, r24
 4fa:	ed 91       	ld	r30, X+
 4fc:	fc 91       	ld	r31, X
 4fe:	06 84       	ldd	r0, Z+14	; 0x0e
 500:	f7 85       	ldd	r31, Z+15	; 0x0f
 502:	e0 2d       	mov	r30, r0
 504:	40 e0       	ldi	r20, 0x00	; 0
 506:	09 94       	ijmp

00000508 <_ZN3LCD9setCursorEhh.constprop.36>:
{
   command(LCD_RETURNHOME);             // set cursor position to zero
   delayMicroseconds(HOME_CLEAR_EXEC);  // This command is time consuming
}

void LCD::setCursor(uint8_t col, uint8_t row)
 508:	cf 93       	push	r28
 50a:	df 93       	push	r29
 50c:	cd b7       	in	r28, 0x3d	; 61
 50e:	de b7       	in	r29, 0x3e	; 62
 510:	28 97       	sbiw	r28, 0x08	; 8
 512:	0f b6       	in	r0, 0x3f	; 63
 514:	f8 94       	cli
 516:	de bf       	out	0x3e, r29	; 62
 518:	0f be       	out	0x3f, r0	; 63
 51a:	cd bf       	out	0x3d, r28	; 61
{
   const byte row_offsetsDef[]   = { 0x00, 0x40, 0x14, 0x54 }; // For regular LCDs
 51c:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__data_start+0x4>
 520:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__data_start+0x5>
 524:	60 91 06 01 	lds	r22, 0x0106	; 0x800106 <__data_start+0x6>
 528:	70 91 07 01 	lds	r23, 0x0107	; 0x800107 <__data_start+0x7>
 52c:	4d 83       	std	Y+5, r20	; 0x05
 52e:	5e 83       	std	Y+6, r21	; 0x06
 530:	6f 83       	std	Y+7, r22	; 0x07
 532:	78 87       	std	Y+8, r23	; 0x08
   const byte row_offsetsLarge[] = { 0x00, 0x40, 0x10, 0x50 }; // For 16x4 LCDs
 534:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <__data_start+0x8>
 538:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <__data_start+0x9>
 53c:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <__data_start+0xa>
 540:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <__data_start+0xb>
 544:	49 83       	std	Y+1, r20	; 0x01
 546:	5a 83       	std	Y+2, r21	; 0x02
 548:	6b 83       	std	Y+3, r22	; 0x03
 54a:	7c 83       	std	Y+4, r23	; 0x04
   
   if ( row >= _numlines ) 
 54c:	20 91 d1 01 	lds	r18, 0x01D1	; 0x8001d1 <lcd+0x7>
 550:	82 17       	cp	r24, r18
 552:	10 f0       	brcs	.+4      	; 0x558 <_ZN3LCD9setCursorEhh.constprop.36+0x50>
   {
      row = _numlines-1;    // rows start at 0
 554:	8f ef       	ldi	r24, 0xFF	; 255
 556:	82 0f       	add	r24, r18
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
 558:	30 91 d2 01 	lds	r19, 0x01D2	; 0x8001d2 <lcd+0x8>
 55c:	90 e0       	ldi	r25, 0x00	; 0
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
 55e:	fe 01       	movw	r30, r28
 560:	e8 0f       	add	r30, r24
 562:	f9 1f       	adc	r31, r25
      row = _numlines-1;    // rows start at 0
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
 564:	30 31       	cpi	r19, 0x10	; 16
 566:	21 f4       	brne	.+8      	; 0x570 <_ZN3LCD9setCursorEhh.constprop.36+0x68>
 568:	24 30       	cpi	r18, 0x04	; 4
 56a:	11 f4       	brne	.+4      	; 0x570 <_ZN3LCD9setCursorEhh.constprop.36+0x68>
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
 56c:	61 81       	ldd	r22, Z+1	; 0x01
 56e:	01 c0       	rjmp	.+2      	; 0x572 <_ZN3LCD9setCursorEhh.constprop.36+0x6a>
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
 570:	65 81       	ldd	r22, Z+5	; 0x05
 572:	60 68       	ori	r22, 0x80	; 128
 574:	8a ec       	ldi	r24, 0xCA	; 202
 576:	91 e0       	ldi	r25, 0x01	; 1
   }
   
}
 578:	28 96       	adiw	r28, 0x08	; 8
 57a:	0f b6       	in	r0, 0x3f	; 63
 57c:	f8 94       	cli
 57e:	de bf       	out	0x3e, r29	; 62
 580:	0f be       	out	0x3f, r0	; 63
 582:	cd bf       	out	0x3d, r28	; 61
 584:	df 91       	pop	r29
 586:	cf 91       	pop	r28
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
 588:	0c 94 7c 02 	jmp	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>

0000058c <_ZN3LCD5beginEhhh>:
// can't assume that its in that state when a application starts (and the
// LiquidCrystal constructor is called).
// A call to begin() will reinitialize the LCD.
//
void LCD::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) 
{
 58c:	0f 93       	push	r16
 58e:	1f 93       	push	r17
 590:	cf 93       	push	r28
 592:	df 93       	push	r29
 594:	ec 01       	movw	r28, r24
   if (lines > 1) 
 596:	42 30       	cpi	r20, 0x02	; 2
 598:	18 f0       	brcs	.+6      	; 0x5a0 <_ZN3LCD5beginEhhh+0x14>
   {
      _displayfunction |= LCD_2LINE;
 59a:	8c 81       	ldd	r24, Y+4	; 0x04
 59c:	88 60       	ori	r24, 0x08	; 8
 59e:	8c 83       	std	Y+4, r24	; 0x04
   }
   _numlines = lines;
 5a0:	4f 83       	std	Y+7, r20	; 0x07
   _cols = cols;
 5a2:	68 87       	std	Y+8, r22	; 0x08
   
   // for some 1 line displays you can select a 10 pixel high font
   // ------------------------------------------------------------
   if ((dotsize != LCD_5x8DOTS) && (lines == 1)) 
 5a4:	22 23       	and	r18, r18
 5a6:	29 f0       	breq	.+10     	; 0x5b2 <_ZN3LCD5beginEhhh+0x26>
 5a8:	41 30       	cpi	r20, 0x01	; 1
 5aa:	19 f4       	brne	.+6      	; 0x5b2 <_ZN3LCD5beginEhhh+0x26>
   {
      _displayfunction |= LCD_5x10DOTS;
 5ac:	8c 81       	ldd	r24, Y+4	; 0x04
 5ae:	84 60       	ori	r24, 0x04	; 4
 5b0:	8c 83       	std	Y+4, r24	; 0x04
   // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
   // according to datasheet, we need at least 40ms after power rises above 2.7V
   // before sending commands. Arduino can turn on way before 4.5V so we'll wait 
   // 50
   // ---------------------------------------------------------------------------
   delay (100); // 100ms delay
 5b2:	64 e6       	ldi	r22, 0x64	; 100
 5b4:	70 e0       	ldi	r23, 0x00	; 0
 5b6:	80 e0       	ldi	r24, 0x00	; 0
 5b8:	90 e0       	ldi	r25, 0x00	; 0
 5ba:	0e 94 53 01 	call	0x2a6	; 0x2a6 <delay>
   
   //put the LCD into 4 bit or 8 bit mode
   // -------------------------------------
   if (! (_displayfunction & LCD_8BITMODE)) 
 5be:	6c 81       	ldd	r22, Y+4	; 0x04
 5c0:	64 fd       	sbrc	r22, 4
 5c2:	31 c0       	rjmp	.+98     	; 0x626 <_ZN3LCD5beginEhhh+0x9a>
      // this is according to the hitachi HD44780 datasheet
      // figure 24, pg 46
      
      // we start in 8bit mode, try to set 4 bit mode
      // Special case of "Function Set"
      send(0x03, FOUR_BITS);
 5c4:	e8 81       	ld	r30, Y
 5c6:	f9 81       	ldd	r31, Y+1	; 0x01
 5c8:	06 84       	ldd	r0, Z+14	; 0x0e
 5ca:	f7 85       	ldd	r31, Z+15	; 0x0f
 5cc:	e0 2d       	mov	r30, r0
 5ce:	42 e0       	ldi	r20, 0x02	; 2
 5d0:	63 e0       	ldi	r22, 0x03	; 3
 5d2:	ce 01       	movw	r24, r28
 5d4:	09 95       	icall
	

#endif

	// busy wait
	__asm__ __volatile__ (
 5d6:	8b e4       	ldi	r24, 0x4B	; 75
 5d8:	96 e4       	ldi	r25, 0x46	; 70
 5da:	01 97       	sbiw	r24, 0x01	; 1
 5dc:	f1 f7       	brne	.-4      	; 0x5da <_ZN3LCD5beginEhhh+0x4e>
      delayMicroseconds(4500); // wait min 4.1ms
      
      // second try
      send ( 0x03, FOUR_BITS );
 5de:	e8 81       	ld	r30, Y
 5e0:	f9 81       	ldd	r31, Y+1	; 0x01
 5e2:	06 84       	ldd	r0, Z+14	; 0x0e
 5e4:	f7 85       	ldd	r31, Z+15	; 0x0f
 5e6:	e0 2d       	mov	r30, r0
 5e8:	42 e0       	ldi	r20, 0x02	; 2
 5ea:	63 e0       	ldi	r22, 0x03	; 3
 5ec:	ce 01       	movw	r24, r28
 5ee:	09 95       	icall
 5f0:	03 e5       	ldi	r16, 0x53	; 83
 5f2:	12 e0       	ldi	r17, 0x02	; 2
 5f4:	c8 01       	movw	r24, r16
 5f6:	01 97       	sbiw	r24, 0x01	; 1
 5f8:	f1 f7       	brne	.-4      	; 0x5f6 <_ZN3LCD5beginEhhh+0x6a>
      delayMicroseconds(150); // wait min 100us
      
      // third go!
      send( 0x03, FOUR_BITS );
 5fa:	e8 81       	ld	r30, Y
 5fc:	f9 81       	ldd	r31, Y+1	; 0x01
 5fe:	06 84       	ldd	r0, Z+14	; 0x0e
 600:	f7 85       	ldd	r31, Z+15	; 0x0f
 602:	e0 2d       	mov	r30, r0
 604:	42 e0       	ldi	r20, 0x02	; 2
 606:	63 e0       	ldi	r22, 0x03	; 3
 608:	ce 01       	movw	r24, r28
 60a:	09 95       	icall
 60c:	c8 01       	movw	r24, r16
 60e:	01 97       	sbiw	r24, 0x01	; 1
 610:	f1 f7       	brne	.-4      	; 0x60e <_ZN3LCD5beginEhhh+0x82>
      delayMicroseconds(150); // wait min of 100us
      
      // finally, set to 4-bit interface
      send ( 0x02, FOUR_BITS );
 612:	e8 81       	ld	r30, Y
 614:	f9 81       	ldd	r31, Y+1	; 0x01
 616:	06 84       	ldd	r0, Z+14	; 0x0e
 618:	f7 85       	ldd	r31, Z+15	; 0x0f
 61a:	e0 2d       	mov	r30, r0
 61c:	42 e0       	ldi	r20, 0x02	; 2
 61e:	62 e0       	ldi	r22, 0x02	; 2
 620:	ce 01       	movw	r24, r28
 622:	09 95       	icall
 624:	17 c0       	rjmp	.+46     	; 0x654 <_ZN3LCD5beginEhhh+0xc8>
   {
      // this is according to the hitachi HD44780 datasheet
      // page 45 figure 23
      
      // Send function set command sequence
      command(LCD_FUNCTIONSET | _displayfunction);
 626:	60 62       	ori	r22, 0x20	; 32
 628:	ce 01       	movw	r24, r28
 62a:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>
 62e:	8b e4       	ldi	r24, 0x4B	; 75
 630:	96 e4       	ldi	r25, 0x46	; 70
 632:	01 97       	sbiw	r24, 0x01	; 1
 634:	f1 f7       	brne	.-4      	; 0x632 <_ZN3LCD5beginEhhh+0xa6>
      delayMicroseconds(4500);  // wait more than 4.1ms
      
      // second try
      command(LCD_FUNCTIONSET | _displayfunction);
 636:	6c 81       	ldd	r22, Y+4	; 0x04
 638:	60 62       	ori	r22, 0x20	; 32
 63a:	ce 01       	movw	r24, r28
 63c:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>
 640:	03 e5       	ldi	r16, 0x53	; 83
 642:	12 e0       	ldi	r17, 0x02	; 2
 644:	c8 01       	movw	r24, r16
 646:	01 97       	sbiw	r24, 0x01	; 1
 648:	f1 f7       	brne	.-4      	; 0x646 <_ZN3LCD5beginEhhh+0xba>
      delayMicroseconds(150);
      
      // third go
      command(LCD_FUNCTIONSET | _displayfunction);
 64a:	6c 81       	ldd	r22, Y+4	; 0x04
 64c:	60 62       	ori	r22, 0x20	; 32
 64e:	ce 01       	movw	r24, r28
 650:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>
 654:	c8 01       	movw	r24, r16
 656:	01 97       	sbiw	r24, 0x01	; 1
 658:	f1 f7       	brne	.-4      	; 0x656 <_ZN3LCD5beginEhhh+0xca>
      delayMicroseconds(150);

   }
   
   // finally, set # lines, font size, etc.
   command(LCD_FUNCTIONSET | _displayfunction);
 65a:	6c 81       	ldd	r22, Y+4	; 0x04
 65c:	60 62       	ori	r22, 0x20	; 32
 65e:	ce 01       	movw	r24, r28
 660:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>
 664:	8b ee       	ldi	r24, 0xEB	; 235
 666:	90 e0       	ldi	r25, 0x00	; 0
 668:	01 97       	sbiw	r24, 0x01	; 1
 66a:	f1 f7       	brne	.-4      	; 0x668 <_ZN3LCD5beginEhhh+0xdc>
   delayMicroseconds ( 60 );  // wait more
   
   // turn the display on with no cursor or blinking default
   _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
 66c:	84 e0       	ldi	r24, 0x04	; 4
 66e:	8d 83       	std	Y+5, r24	; 0x05
}

void LCD::display() 
{
   _displaycontrol |= LCD_DISPLAYON;
   command(LCD_DISPLAYCONTROL | _displaycontrol);
 670:	6c e0       	ldi	r22, 0x0C	; 12
 672:	ce 01       	movw	r24, r28
 674:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
 678:	61 e0       	ldi	r22, 0x01	; 1
 67a:	ce 01       	movw	r24, r28
 67c:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>
 680:	8b e3       	ldi	r24, 0x3B	; 59
 682:	9f e1       	ldi	r25, 0x1F	; 31
 684:	01 97       	sbiw	r24, 0x01	; 1
 686:	f1 f7       	brne	.-4      	; 0x684 <_ZN3LCD5beginEhhh+0xf8>
   
   // clear the LCD
   clear();
   
   // Initialize to default text direction (for romance languages)
   _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
 688:	82 e0       	ldi	r24, 0x02	; 2
 68a:	8e 83       	std	Y+6, r24	; 0x06
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);
 68c:	66 e0       	ldi	r22, 0x06	; 6
 68e:	ce 01       	movw	r24, r28
 690:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
 694:	e8 81       	ld	r30, Y
 696:	f9 81       	ldd	r31, Y+1	; 0x01
 698:	04 84       	ldd	r0, Z+12	; 0x0c
 69a:	f5 85       	ldd	r31, Z+13	; 0x0d
 69c:	e0 2d       	mov	r30, r0
 69e:	6f ef       	ldi	r22, 0xFF	; 255
 6a0:	ce 01       	movw	r24, r28
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);

   backlight();

}
 6a2:	df 91       	pop	r29
 6a4:	cf 91       	pop	r28
 6a6:	1f 91       	pop	r17
 6a8:	0f 91       	pop	r16

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
 6aa:	09 94       	ijmp

000006ac <_ZN3LCD12setBacklightEh>:
    
    @param      0..255 - the value is very dependent on the LCD. However, 
    BACKLIGHT_OFF will be interpreted as off and BACKLIGHT_ON will drive the
    backlight on.
    */
   virtual void setBacklight ( uint8_t value ) { };
 6ac:	08 95       	ret

000006ae <_ZN3LCD15setBacklightPinEh14t_backlightPol>:
    empty function call is provided that does nothing.
    
    @param      value: pin associated to backlight control.
    @param      pol: backlight polarity control (POSITIVE, NEGATIVE)
    */
   virtual void setBacklightPin ( uint8_t value, t_backlightPol pol ) { };
 6ae:	08 95       	ret

000006b0 <_ZN5Print5flushEv>:
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 6b0:	08 95       	ret

000006b2 <_ZN5Print17availableForWriteEv>:
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 6b2:	80 e0       	ldi	r24, 0x00	; 0
 6b4:	90 e0       	ldi	r25, 0x00	; 0
 6b6:	08 95       	ret

000006b8 <_ZN5Print5writeEPKc.constprop.35>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 6b8:	00 97       	sbiw	r24, 0x00	; 0
 6ba:	69 f0       	breq	.+26     	; 0x6d6 <_ZN5Print5writeEPKc.constprop.35+0x1e>
      return write((const uint8_t *)str, strlen(str));
 6bc:	fc 01       	movw	r30, r24
 6be:	01 90       	ld	r0, Z+
 6c0:	00 20       	and	r0, r0
 6c2:	e9 f7       	brne	.-6      	; 0x6be <_ZN5Print5writeEPKc.constprop.35+0x6>
 6c4:	31 97       	sbiw	r30, 0x01	; 1
 6c6:	af 01       	movw	r20, r30
 6c8:	48 1b       	sub	r20, r24
 6ca:	59 0b       	sbc	r21, r25
 6cc:	bc 01       	movw	r22, r24
 6ce:	8a ec       	ldi	r24, 0xCA	; 202
 6d0:	91 e0       	ldi	r25, 0x01	; 1
 6d2:	0c 94 8d 01 	jmp	0x31a	; 0x31a <_ZN5Print5writeEPKhj>
    }
 6d6:	80 e0       	ldi	r24, 0x00	; 0
 6d8:	90 e0       	ldi	r25, 0x00	; 0
 6da:	08 95       	ret

000006dc <_ZN5Print11printNumberEmh.constprop.33>:
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 6dc:	8f 92       	push	r8
 6de:	9f 92       	push	r9
 6e0:	af 92       	push	r10
 6e2:	bf 92       	push	r11
 6e4:	0f 93       	push	r16
 6e6:	1f 93       	push	r17
 6e8:	cf 93       	push	r28
 6ea:	df 93       	push	r29
 6ec:	cd b7       	in	r28, 0x3d	; 61
 6ee:	de b7       	in	r29, 0x3e	; 62
 6f0:	a1 97       	sbiw	r28, 0x21	; 33
 6f2:	0f b6       	in	r0, 0x3f	; 63
 6f4:	f8 94       	cli
 6f6:	de bf       	out	0x3e, r29	; 62
 6f8:	0f be       	out	0x3f, r0	; 63
 6fa:	cd bf       	out	0x3d, r28	; 61
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 6fc:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 6fe:	42 30       	cpi	r20, 0x02	; 2
 700:	08 f4       	brcc	.+2      	; 0x704 <_ZN5Print11printNumberEmh.constprop.33+0x28>
 702:	4a e0       	ldi	r20, 0x0A	; 10
 704:	8e 01       	movw	r16, r28
 706:	0f 5d       	subi	r16, 0xDF	; 223
 708:	1f 4f       	sbci	r17, 0xFF	; 255

  do {
    char c = n % base;
 70a:	84 2e       	mov	r8, r20
 70c:	91 2c       	mov	r9, r1
 70e:	a1 2c       	mov	r10, r1
 710:	b1 2c       	mov	r11, r1
 712:	a5 01       	movw	r20, r10
 714:	94 01       	movw	r18, r8
 716:	0e 94 74 06 	call	0xce8	; 0xce8 <__udivmodsi4>
 71a:	e6 2f       	mov	r30, r22
    n /= base;
 71c:	b9 01       	movw	r22, r18
 71e:	ca 01       	movw	r24, r20

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 720:	01 50       	subi	r16, 0x01	; 1
 722:	11 09       	sbc	r17, r1
 724:	ea 30       	cpi	r30, 0x0A	; 10
 726:	14 f4       	brge	.+4      	; 0x72c <_ZN5Print11printNumberEmh.constprop.33+0x50>
 728:	e0 5d       	subi	r30, 0xD0	; 208
 72a:	01 c0       	rjmp	.+2      	; 0x72e <_ZN5Print11printNumberEmh.constprop.33+0x52>
 72c:	e9 5c       	subi	r30, 0xC9	; 201
 72e:	d8 01       	movw	r26, r16
 730:	ec 93       	st	X, r30
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 732:	23 2b       	or	r18, r19
 734:	24 2b       	or	r18, r20
 736:	25 2b       	or	r18, r21
 738:	61 f7       	brne	.-40     	; 0x712 <_ZN5Print11printNumberEmh.constprop.33+0x36>
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 73a:	c8 01       	movw	r24, r16
 73c:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <_ZN5Print5writeEPKc.constprop.35>
}
 740:	a1 96       	adiw	r28, 0x21	; 33
 742:	0f b6       	in	r0, 0x3f	; 63
 744:	f8 94       	cli
 746:	de bf       	out	0x3e, r29	; 62
 748:	0f be       	out	0x3f, r0	; 63
 74a:	cd bf       	out	0x3d, r28	; 61
 74c:	df 91       	pop	r29
 74e:	cf 91       	pop	r28
 750:	1f 91       	pop	r17
 752:	0f 91       	pop	r16
 754:	bf 90       	pop	r11
 756:	af 90       	pop	r10
 758:	9f 90       	pop	r9
 75a:	8f 90       	pop	r8
 75c:	08 95       	ret

0000075e <__cxa_pure_virtual>:
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
  // We might want to write some diagnostics to uart in this case
  //std::terminate();
  abort();
 75e:	0e 94 9c 06 	call	0xd38	; 0xd38 <abort>

00000762 <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 762:	1f 92       	push	r1
 764:	0f 92       	push	r0
 766:	0f b6       	in	r0, 0x3f	; 63
 768:	0f 92       	push	r0
 76a:	11 24       	eor	r1, r1
 76c:	2f 93       	push	r18
 76e:	3f 93       	push	r19
 770:	8f 93       	push	r24
 772:	9f 93       	push	r25
 774:	af 93       	push	r26
 776:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 778:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <timer0_millis>
 77c:	90 91 b7 01 	lds	r25, 0x01B7	; 0x8001b7 <timer0_millis+0x1>
 780:	a0 91 b8 01 	lds	r26, 0x01B8	; 0x8001b8 <timer0_millis+0x2>
 784:	b0 91 b9 01 	lds	r27, 0x01B9	; 0x8001b9 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
 788:	30 91 b5 01 	lds	r19, 0x01B5	; 0x8001b5 <timer0_fract>

	m += MILLIS_INC;
	f += FRACT_INC;
 78c:	23 e0       	ldi	r18, 0x03	; 3
 78e:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 790:	2d 37       	cpi	r18, 0x7D	; 125
 792:	20 f4       	brcc	.+8      	; 0x79c <__vector_16+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 794:	01 96       	adiw	r24, 0x01	; 1
 796:	a1 1d       	adc	r26, r1
 798:	b1 1d       	adc	r27, r1
 79a:	05 c0       	rjmp	.+10     	; 0x7a6 <__vector_16+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 79c:	26 e8       	ldi	r18, 0x86	; 134
 79e:	23 0f       	add	r18, r19
		m += 1;
 7a0:	02 96       	adiw	r24, 0x02	; 2
 7a2:	a1 1d       	adc	r26, r1
 7a4:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
 7a6:	20 93 b5 01 	sts	0x01B5, r18	; 0x8001b5 <timer0_fract>
	timer0_millis = m;
 7aa:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <timer0_millis>
 7ae:	90 93 b7 01 	sts	0x01B7, r25	; 0x8001b7 <timer0_millis+0x1>
 7b2:	a0 93 b8 01 	sts	0x01B8, r26	; 0x8001b8 <timer0_millis+0x2>
 7b6:	b0 93 b9 01 	sts	0x01B9, r27	; 0x8001b9 <timer0_millis+0x3>
	timer0_overflow_count++;
 7ba:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <timer0_overflow_count>
 7be:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <timer0_overflow_count+0x1>
 7c2:	a0 91 bc 01 	lds	r26, 0x01BC	; 0x8001bc <timer0_overflow_count+0x2>
 7c6:	b0 91 bd 01 	lds	r27, 0x01BD	; 0x8001bd <timer0_overflow_count+0x3>
 7ca:	01 96       	adiw	r24, 0x01	; 1
 7cc:	a1 1d       	adc	r26, r1
 7ce:	b1 1d       	adc	r27, r1
 7d0:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <timer0_overflow_count>
 7d4:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <timer0_overflow_count+0x1>
 7d8:	a0 93 bc 01 	sts	0x01BC, r26	; 0x8001bc <timer0_overflow_count+0x2>
 7dc:	b0 93 bd 01 	sts	0x01BD, r27	; 0x8001bd <timer0_overflow_count+0x3>
}
 7e0:	bf 91       	pop	r27
 7e2:	af 91       	pop	r26
 7e4:	9f 91       	pop	r25
 7e6:	8f 91       	pop	r24
 7e8:	3f 91       	pop	r19
 7ea:	2f 91       	pop	r18
 7ec:	0f 90       	pop	r0
 7ee:	0f be       	out	0x3f, r0	; 63
 7f0:	0f 90       	pop	r0
 7f2:	1f 90       	pop	r1
 7f4:	18 95       	reti

000007f6 <__vector_24>:
  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
 7f6:	1f 92       	push	r1
 7f8:	0f 92       	push	r0
 7fa:	0f b6       	in	r0, 0x3f	; 63
 7fc:	0f 92       	push	r0
 7fe:	11 24       	eor	r1, r1
 800:	2f 93       	push	r18
 802:	3f 93       	push	r19
 804:	4f 93       	push	r20
 806:	5f 93       	push	r21
 808:	6f 93       	push	r22
 80a:	7f 93       	push	r23
 80c:	8f 93       	push	r24
 80e:	9f 93       	push	r25
 810:	af 93       	push	r26
 812:	bf 93       	push	r27
 814:	ef 93       	push	r30
 816:	ff 93       	push	r31
  switch(TW_STATUS){
 818:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 81c:	88 7f       	andi	r24, 0xF8	; 248
 81e:	80 36       	cpi	r24, 0x60	; 96
 820:	09 f4       	brne	.+2      	; 0x824 <__vector_24+0x2e>
 822:	9c c0       	rjmp	.+312    	; 0x95c <__stack+0x5d>
 824:	68 f5       	brcc	.+90     	; 0x880 <__vector_24+0x8a>
 826:	88 32       	cpi	r24, 0x28	; 40
 828:	09 f4       	brne	.+2      	; 0x82c <__vector_24+0x36>
 82a:	5b c0       	rjmp	.+182    	; 0x8e2 <__vector_24+0xec>
 82c:	90 f4       	brcc	.+36     	; 0x852 <__vector_24+0x5c>
 82e:	80 31       	cpi	r24, 0x10	; 16
 830:	09 f4       	brne	.+2      	; 0x834 <__vector_24+0x3e>
 832:	54 c0       	rjmp	.+168    	; 0x8dc <__vector_24+0xe6>
 834:	38 f4       	brcc	.+14     	; 0x844 <__vector_24+0x4e>
 836:	88 23       	and	r24, r24
 838:	09 f4       	brne	.+2      	; 0x83c <__vector_24+0x46>
 83a:	f2 c0       	rjmp	.+484    	; 0xa20 <__stack+0x121>
 83c:	88 30       	cpi	r24, 0x08	; 8
 83e:	09 f4       	brne	.+2      	; 0x842 <__vector_24+0x4c>
 840:	4d c0       	rjmp	.+154    	; 0x8dc <__vector_24+0xe6>
 842:	f2 c0       	rjmp	.+484    	; 0xa28 <__stack+0x129>
 844:	88 31       	cpi	r24, 0x18	; 24
 846:	09 f4       	brne	.+2      	; 0x84a <__vector_24+0x54>
 848:	4c c0       	rjmp	.+152    	; 0x8e2 <__vector_24+0xec>
 84a:	80 32       	cpi	r24, 0x20	; 32
 84c:	09 f4       	brne	.+2      	; 0x850 <__vector_24+0x5a>
 84e:	5d c0       	rjmp	.+186    	; 0x90a <__stack+0xb>
 850:	eb c0       	rjmp	.+470    	; 0xa28 <__stack+0x129>
 852:	80 34       	cpi	r24, 0x40	; 64
 854:	09 f4       	brne	.+2      	; 0x858 <__vector_24+0x62>
 856:	68 c0       	rjmp	.+208    	; 0x928 <__stack+0x29>
 858:	48 f4       	brcc	.+18     	; 0x86c <__vector_24+0x76>
 85a:	80 33       	cpi	r24, 0x30	; 48
 85c:	09 f4       	brne	.+2      	; 0x860 <__vector_24+0x6a>
 85e:	55 c0       	rjmp	.+170    	; 0x90a <__stack+0xb>
 860:	88 33       	cpi	r24, 0x38	; 56
 862:	09 f0       	breq	.+2      	; 0x866 <__vector_24+0x70>
 864:	e1 c0       	rjmp	.+450    	; 0xa28 <__stack+0x129>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
 866:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <twi_error>
 86a:	d4 c0       	rjmp	.+424    	; 0xa14 <__stack+0x115>
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 86c:	80 35       	cpi	r24, 0x50	; 80
 86e:	09 f4       	brne	.+2      	; 0x872 <__vector_24+0x7c>
 870:	4f c0       	rjmp	.+158    	; 0x910 <__stack+0x11>
 872:	88 35       	cpi	r24, 0x58	; 88
 874:	09 f4       	brne	.+2      	; 0x878 <__vector_24+0x82>
 876:	5d c0       	rjmp	.+186    	; 0x932 <__stack+0x33>
 878:	88 34       	cpi	r24, 0x48	; 72
 87a:	09 f0       	breq	.+2      	; 0x87e <__vector_24+0x88>
 87c:	d5 c0       	rjmp	.+426    	; 0xa28 <__stack+0x129>
 87e:	d2 c0       	rjmp	.+420    	; 0xa24 <__stack+0x125>
 880:	88 39       	cpi	r24, 0x98	; 152
 882:	09 f4       	brne	.+2      	; 0x886 <__vector_24+0x90>
 884:	c3 c0       	rjmp	.+390    	; 0xa0c <__stack+0x10d>
 886:	a8 f4       	brcc	.+42     	; 0x8b2 <__vector_24+0xbc>
 888:	88 37       	cpi	r24, 0x78	; 120
 88a:	09 f4       	brne	.+2      	; 0x88e <__vector_24+0x98>
 88c:	67 c0       	rjmp	.+206    	; 0x95c <__stack+0x5d>
 88e:	38 f4       	brcc	.+14     	; 0x89e <__vector_24+0xa8>
 890:	88 36       	cpi	r24, 0x68	; 104
 892:	09 f4       	brne	.+2      	; 0x896 <__vector_24+0xa0>
 894:	63 c0       	rjmp	.+198    	; 0x95c <__stack+0x5d>
 896:	80 37       	cpi	r24, 0x70	; 112
 898:	09 f4       	brne	.+2      	; 0x89c <__vector_24+0xa6>
 89a:	60 c0       	rjmp	.+192    	; 0x95c <__stack+0x5d>
 89c:	c5 c0       	rjmp	.+394    	; 0xa28 <__stack+0x129>
 89e:	88 38       	cpi	r24, 0x88	; 136
 8a0:	09 f4       	brne	.+2      	; 0x8a4 <__vector_24+0xae>
 8a2:	b4 c0       	rjmp	.+360    	; 0xa0c <__stack+0x10d>
 8a4:	80 39       	cpi	r24, 0x90	; 144
 8a6:	09 f4       	brne	.+2      	; 0x8aa <__vector_24+0xb4>
 8a8:	5f c0       	rjmp	.+190    	; 0x968 <__stack+0x69>
 8aa:	80 38       	cpi	r24, 0x80	; 128
 8ac:	09 f0       	breq	.+2      	; 0x8b0 <__vector_24+0xba>
 8ae:	bc c0       	rjmp	.+376    	; 0xa28 <__stack+0x129>
 8b0:	5b c0       	rjmp	.+182    	; 0x968 <__stack+0x69>
 8b2:	80 3b       	cpi	r24, 0xB0	; 176
 8b4:	09 f4       	brne	.+2      	; 0x8b8 <__vector_24+0xc2>
 8b6:	84 c0       	rjmp	.+264    	; 0x9c0 <__stack+0xc1>
 8b8:	38 f4       	brcc	.+14     	; 0x8c8 <__vector_24+0xd2>
 8ba:	80 3a       	cpi	r24, 0xA0	; 160
 8bc:	09 f4       	brne	.+2      	; 0x8c0 <__vector_24+0xca>
 8be:	66 c0       	rjmp	.+204    	; 0x98c <__stack+0x8d>
 8c0:	88 3a       	cpi	r24, 0xA8	; 168
 8c2:	09 f4       	brne	.+2      	; 0x8c6 <__vector_24+0xd0>
 8c4:	7d c0       	rjmp	.+250    	; 0x9c0 <__stack+0xc1>
 8c6:	b0 c0       	rjmp	.+352    	; 0xa28 <__stack+0x129>
 8c8:	80 3c       	cpi	r24, 0xC0	; 192
 8ca:	09 f4       	brne	.+2      	; 0x8ce <__vector_24+0xd8>
 8cc:	a3 c0       	rjmp	.+326    	; 0xa14 <__stack+0x115>
 8ce:	88 3c       	cpi	r24, 0xC8	; 200
 8d0:	09 f4       	brne	.+2      	; 0x8d4 <__vector_24+0xde>
 8d2:	a0 c0       	rjmp	.+320    	; 0xa14 <__stack+0x115>
 8d4:	88 3b       	cpi	r24, 0xB8	; 184
 8d6:	09 f4       	brne	.+2      	; 0x8da <__vector_24+0xe4>
 8d8:	86 c0       	rjmp	.+268    	; 0x9e6 <__stack+0xe7>
 8da:	a6 c0       	rjmp	.+332    	; 0xa28 <__stack+0x129>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
 8dc:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <twi_slarw>
 8e0:	10 c0       	rjmp	.+32     	; 0x902 <__stack+0x3>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
 8e2:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <twi_masterBufferIndex>
 8e6:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <twi_masterBufferLength>
 8ea:	98 17       	cp	r25, r24
 8ec:	70 f5       	brcc	.+92     	; 0x94a <__stack+0x4b>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
 8ee:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <twi_masterBufferIndex>
 8f2:	81 e0       	ldi	r24, 0x01	; 1
 8f4:	8e 0f       	add	r24, r30
 8f6:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <twi_masterBufferIndex>
 8fa:	f0 e0       	ldi	r31, 0x00	; 0
 8fc:	e2 57       	subi	r30, 0x72	; 114
 8fe:	fe 4f       	sbci	r31, 0xFE	; 254
 900:	80 81       	ld	r24, Z
 902:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 906:	85 ec       	ldi	r24, 0xC5	; 197
 908:	82 c0       	rjmp	.+260    	; 0xa0e <__stack+0x10f>
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
 90a:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <twi_error>
 90e:	8a c0       	rjmp	.+276    	; 0xa24 <__stack+0x125>
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 910:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <twi_masterBufferIndex>
 914:	81 e0       	ldi	r24, 0x01	; 1
 916:	8e 0f       	add	r24, r30
 918:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <twi_masterBufferIndex>
 91c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 920:	f0 e0       	ldi	r31, 0x00	; 0
 922:	e2 57       	subi	r30, 0x72	; 114
 924:	fe 4f       	sbci	r31, 0xFE	; 254
 926:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
 928:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <twi_masterBufferIndex>
 92c:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <twi_masterBufferLength>
 930:	6a c0       	rjmp	.+212    	; 0xa06 <__stack+0x107>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 932:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <twi_masterBufferIndex>
 936:	81 e0       	ldi	r24, 0x01	; 1
 938:	8e 0f       	add	r24, r30
 93a:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <twi_masterBufferIndex>
 93e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 942:	f0 e0       	ldi	r31, 0x00	; 0
 944:	e2 57       	subi	r30, 0x72	; 114
 946:	fe 4f       	sbci	r31, 0xFE	; 254
 948:	80 83       	st	Z, r24
	if (twi_sendStop)
 94a:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <twi_sendStop>
 94e:	81 11       	cpse	r24, r1
 950:	69 c0       	rjmp	.+210    	; 0xa24 <__stack+0x125>
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
 952:	81 e0       	ldi	r24, 0x01	; 1
 954:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <twi_inRepStart>
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
 958:	84 ea       	ldi	r24, 0xA4	; 164
 95a:	5d c0       	rjmp	.+186    	; 0xa16 <__stack+0x117>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
 95c:	83 e0       	ldi	r24, 0x03	; 3
 95e:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <twi_state>
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
 962:	10 92 89 01 	sts	0x0189, r1	; 0x800189 <twi_rxBufferIndex>
 966:	cf cf       	rjmp	.-98     	; 0x906 <__stack+0x7>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 968:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <twi_rxBufferIndex>
 96c:	80 32       	cpi	r24, 0x20	; 32
 96e:	08 f0       	brcs	.+2      	; 0x972 <__stack+0x73>
 970:	4d c0       	rjmp	.+154    	; 0xa0c <__stack+0x10d>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
 972:	e0 91 89 01 	lds	r30, 0x0189	; 0x800189 <twi_rxBufferIndex>
 976:	81 e0       	ldi	r24, 0x01	; 1
 978:	8e 0f       	add	r24, r30
 97a:	80 93 89 01 	sts	0x0189, r24	; 0x800189 <twi_rxBufferIndex>
 97e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 982:	f0 e0       	ldi	r31, 0x00	; 0
 984:	e7 59       	subi	r30, 0x97	; 151
 986:	fe 4f       	sbci	r31, 0xFE	; 254
 988:	80 83       	st	Z, r24
 98a:	bd cf       	rjmp	.-134    	; 0x906 <__stack+0x7>
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
 98c:	85 ec       	ldi	r24, 0xC5	; 197
 98e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

  // update twi state
  twi_state = TWI_READY;
 992:	10 92 8b 01 	sts	0x018B, r1	; 0x80018b <twi_state>
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 996:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <twi_rxBufferIndex>
 99a:	80 32       	cpi	r24, 0x20	; 32
 99c:	30 f4       	brcc	.+12     	; 0x9aa <__stack+0xab>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
 99e:	e0 91 89 01 	lds	r30, 0x0189	; 0x800189 <twi_rxBufferIndex>
 9a2:	f0 e0       	ldi	r31, 0x00	; 0
 9a4:	e7 59       	subi	r30, 0x97	; 151
 9a6:	fe 4f       	sbci	r31, 0xFE	; 254
 9a8:	10 82       	st	Z, r1
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
 9aa:	60 91 89 01 	lds	r22, 0x0189	; 0x800189 <twi_rxBufferIndex>
 9ae:	70 e0       	ldi	r23, 0x00	; 0
 9b0:	89 e6       	ldi	r24, 0x69	; 105
 9b2:	91 e0       	ldi	r25, 0x01	; 1
 9b4:	e0 e0       	ldi	r30, 0x00	; 0
 9b6:	f0 e0       	ldi	r31, 0x00	; 0
 9b8:	09 95       	icall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
 9ba:	10 92 89 01 	sts	0x0189, r1	; 0x800189 <twi_rxBufferIndex>
 9be:	34 c0       	rjmp	.+104    	; 0xa28 <__stack+0x129>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
 9c0:	84 e0       	ldi	r24, 0x04	; 4
 9c2:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <twi_state>
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
 9c6:	10 92 68 01 	sts	0x0168, r1	; 0x800168 <twi_txBufferIndex>
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
 9ca:	10 92 67 01 	sts	0x0167, r1	; 0x800167 <twi_txBufferLength>
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
 9ce:	e0 e0       	ldi	r30, 0x00	; 0
 9d0:	f0 e0       	ldi	r31, 0x00	; 0
 9d2:	09 95       	icall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
 9d4:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <twi_txBufferLength>
 9d8:	81 11       	cpse	r24, r1
 9da:	05 c0       	rjmp	.+10     	; 0x9e6 <__stack+0xe7>
        twi_txBufferLength = 1;
 9dc:	81 e0       	ldi	r24, 0x01	; 1
 9de:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <twi_txBufferLength>
        twi_txBuffer[0] = 0x00;
 9e2:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <twi_txBuffer>
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
 9e6:	e0 91 68 01 	lds	r30, 0x0168	; 0x800168 <twi_txBufferIndex>
 9ea:	81 e0       	ldi	r24, 0x01	; 1
 9ec:	8e 0f       	add	r24, r30
 9ee:	80 93 68 01 	sts	0x0168, r24	; 0x800168 <twi_txBufferIndex>
 9f2:	f0 e0       	ldi	r31, 0x00	; 0
 9f4:	e9 5b       	subi	r30, 0xB9	; 185
 9f6:	fe 4f       	sbci	r31, 0xFE	; 254
 9f8:	80 81       	ld	r24, Z
 9fa:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
 9fe:	90 91 68 01 	lds	r25, 0x0168	; 0x800168 <twi_txBufferIndex>
 a02:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <twi_txBufferLength>
 a06:	98 17       	cp	r25, r24
 a08:	08 f4       	brcc	.+2      	; 0xa0c <__stack+0x10d>
 a0a:	7d cf       	rjmp	.-262    	; 0x906 <__stack+0x7>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 a0c:	85 e8       	ldi	r24, 0x85	; 133
 a0e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 a12:	0a c0       	rjmp	.+20     	; 0xa28 <__stack+0x129>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 a14:	85 ec       	ldi	r24, 0xC5	; 197
 a16:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
 a1a:	10 92 8b 01 	sts	0x018B, r1	; 0x80018b <twi_state>
 a1e:	04 c0       	rjmp	.+8      	; 0xa28 <__stack+0x129>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
 a20:	10 92 8a 01 	sts	0x018A, r1	; 0x80018a <twi_error>
      twi_stop();
 a24:	0e 94 b7 01 	call	0x36e	; 0x36e <twi_stop>
      break;
  }
}
 a28:	ff 91       	pop	r31
 a2a:	ef 91       	pop	r30
 a2c:	bf 91       	pop	r27
 a2e:	af 91       	pop	r26
 a30:	9f 91       	pop	r25
 a32:	8f 91       	pop	r24
 a34:	7f 91       	pop	r23
 a36:	6f 91       	pop	r22
 a38:	5f 91       	pop	r21
 a3a:	4f 91       	pop	r20
 a3c:	3f 91       	pop	r19
 a3e:	2f 91       	pop	r18
 a40:	0f 90       	pop	r0
 a42:	0f be       	out	0x3f, r0	; 63
 a44:	0f 90       	pop	r0
 a46:	1f 90       	pop	r1
 a48:	18 95       	reti

00000a4a <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580>:
 a4a:	0f 93       	push	r16
 a4c:	1f 93       	push	r17
 a4e:	cf 93       	push	r28
 a50:	df 93       	push	r29
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 a52:	10 92 c1 01 	sts	0x01C1, r1	; 0x8001c1 <Wire+0x3>
 a56:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <Wire+0x2>
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
 a5a:	88 ee       	ldi	r24, 0xE8	; 232
 a5c:	93 e0       	ldi	r25, 0x03	; 3
 a5e:	a0 e0       	ldi	r26, 0x00	; 0
 a60:	b0 e0       	ldi	r27, 0x00	; 0
 a62:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <Wire+0x4>
 a66:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <Wire+0x5>
 a6a:	a0 93 c4 01 	sts	0x01C4, r26	; 0x8001c4 <Wire+0x6>
 a6e:	b0 93 c5 01 	sts	0x01C5, r27	; 0x8001c5 <Wire+0x7>
void (*TwoWire::user_onRequest)(void);
void (*TwoWire::user_onReceive)(int);

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire()
 a72:	80 e1       	ldi	r24, 0x10	; 16
 a74:	91 e0       	ldi	r25, 0x01	; 1
 a76:	90 93 bf 01 	sts	0x01BF, r25	; 0x8001bf <Wire+0x1>
 a7a:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <Wire>
 a7e:	10 92 cd 01 	sts	0x01CD, r1	; 0x8001cd <lcd+0x3>
 a82:	10 92 cc 01 	sts	0x01CC, r1	; 0x8001cc <lcd+0x2>
// CONSTRUCTORS
// ---------------------------------------------------------------------------

LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
                             uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
                             uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
 a86:	82 e2       	ldi	r24, 0x22	; 34
 a88:	91 e0       	ldi	r25, 0x01	; 1
 a8a:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <lcd+0x1>
 a8e:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <lcd>
   uint8_t i;
   
   // Initialize the IO pins
   // -----------------------
   
   _rs_pin = rs;
 a92:	8e e0       	ldi	r24, 0x0E	; 14
 a94:	80 93 d5 01 	sts	0x01D5, r24	; 0x8001d5 <lcd+0xb>
   _rw_pin = rw;
 a98:	8f ef       	ldi	r24, 0xFF	; 255
 a9a:	80 93 d6 01 	sts	0x01D6, r24	; 0x8001d6 <lcd+0xc>
   _enable_pin = enable;
 a9e:	8c e0       	ldi	r24, 0x0C	; 12
 aa0:	80 93 d7 01 	sts	0x01D7, r24	; 0x8001d7 <lcd+0xd>
   
   _data_pins[0] = d0;
 aa4:	84 e0       	ldi	r24, 0x04	; 4
 aa6:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <lcd+0xe>
   _data_pins[1] = d1;
 aaa:	85 e0       	ldi	r24, 0x05	; 5
 aac:	80 93 d9 01 	sts	0x01D9, r24	; 0x8001d9 <lcd+0xf>
   _data_pins[2] = d2;
 ab0:	86 e0       	ldi	r24, 0x06	; 6
 ab2:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <lcd+0x10>
   _data_pins[3] = d3; 
 ab6:	87 e0       	ldi	r24, 0x07	; 7
 ab8:	80 93 db 01 	sts	0x01DB, r24	; 0x8001db <lcd+0x11>
   _data_pins[4] = d4;
 abc:	88 e0       	ldi	r24, 0x08	; 8
 abe:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <lcd+0x12>
   _data_pins[5] = d5;
 ac2:	89 e0       	ldi	r24, 0x09	; 9
 ac4:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <lcd+0x13>
   _data_pins[6] = d6;
 ac8:	8a e0       	ldi	r24, 0x0A	; 10
 aca:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <lcd+0x14>
   _data_pins[7] = d7;
 ace:	8b e0       	ldi	r24, 0x0B	; 11
 ad0:	80 93 df 01 	sts	0x01DF, r24	; 0x8001df <lcd+0x15>
 ad4:	08 ed       	ldi	r16, 0xD8	; 216
 ad6:	11 e0       	ldi	r17, 0x01	; 1
 ad8:	cc ed       	ldi	r28, 0xDC	; 220
 ada:	d1 e0       	ldi	r29, 0x01	; 1
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
   {
      pinMode ( _data_pins[i], OUTPUT );
 adc:	f8 01       	movw	r30, r16
 ade:	81 91       	ld	r24, Z+
 ae0:	8f 01       	movw	r16, r30
 ae2:	0e 94 87 00 	call	0x10e	; 0x10e <pinMode.constprop.41>
   _data_pins[7] = d7;
   
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
 ae6:	c0 17       	cp	r28, r16
 ae8:	d1 07       	cpc	r29, r17
 aea:	c1 f7       	brne	.-16     	; 0xadc <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x92>
 aec:	00 ee       	ldi	r16, 0xE0	; 224
 aee:	11 e0       	ldi	r17, 0x01	; 1
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
      {
         pinMode ( _data_pins[i], OUTPUT );
 af0:	89 91       	ld	r24, Y+
 af2:	0e 94 87 00 	call	0x10e	; 0x10e <pinMode.constprop.41>
   // Initialize the rest of the ports if it is an 8bit controlled LCD
   // ----------------------------------------------------------------
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
 af6:	0c 17       	cp	r16, r28
 af8:	1d 07       	cpc	r17, r29
 afa:	d1 f7       	brne	.-12     	; 0xaf0 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0xa6>
      {
         pinMode ( _data_pins[i], OUTPUT );
      }
   }
   pinMode(_rs_pin, OUTPUT);
 afc:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <lcd+0xb>
 b00:	0e 94 87 00 	call	0x10e	; 0x10e <pinMode.constprop.41>
   
   // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
   if (_rw_pin != 255) 
 b04:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <lcd+0xc>
 b08:	8f 3f       	cpi	r24, 0xFF	; 255
 b0a:	11 f0       	breq	.+4      	; 0xb10 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0xc6>
   { 
      pinMode(_rw_pin, OUTPUT);
 b0c:	0e 94 87 00 	call	0x10e	; 0x10e <pinMode.constprop.41>
   }
   
   pinMode(_enable_pin, OUTPUT);
 b10:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <lcd+0xd>
 b14:	0e 94 87 00 	call	0x10e	; 0x10e <pinMode.constprop.41>
   // Initialise displaymode functions to defaults: LCD_1LINE and LCD_5x8DOTS
   // -------------------------------------------------------------------------
   if (fourbitmode)
      _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
   else 
      _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
 b18:	80 e1       	ldi	r24, 0x10	; 16
 b1a:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <lcd+0x4>
   
   // Now we pull both RS and R/W low to begin commands
   digitalWrite(_rs_pin, LOW);
 b1e:	60 e0       	ldi	r22, 0x00	; 0
 b20:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <lcd+0xb>
 b24:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
   digitalWrite(_enable_pin, LOW);
 b28:	60 e0       	ldi	r22, 0x00	; 0
 b2a:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <lcd+0xd>
 b2e:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
   
   if (_rw_pin != 255) 
 b32:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <lcd+0xc>
 b36:	8f 3f       	cpi	r24, 0xFF	; 255
 b38:	19 f0       	breq	.+6      	; 0xb40 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0xf6>
   { 
      digitalWrite(_rw_pin, LOW);
 b3a:	60 e0       	ldi	r22, 0x00	; 0
 b3c:	0e 94 a6 00 	call	0x14c	; 0x14c <digitalWrite>
   }
   
   // Initialise the backlight pin no nothing
   _backlightPin = LCD_NOBACKLIGHT;
 b40:	8f ef       	ldi	r24, 0xFF	; 255
 b42:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <lcd+0x16>
   _polarity = POSITIVE;
 b46:	10 92 d4 01 	sts	0x01D4, r1	; 0x8001d4 <lcd+0xa>
 b4a:	10 92 d3 01 	sts	0x01D3, r1	; 0x8001d3 <lcd+0x9>
 b4e:	df 91       	pop	r29
 b50:	cf 91       	pop	r28
 b52:	1f 91       	pop	r17
 b54:	0f 91       	pop	r16
 b56:	08 95       	ret

00000b58 <main>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 b58:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 b5a:	84 b5       	in	r24, 0x24	; 36
 b5c:	82 60       	ori	r24, 0x02	; 2
 b5e:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 b60:	84 b5       	in	r24, 0x24	; 36
 b62:	81 60       	ori	r24, 0x01	; 1
 b64:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 b66:	85 b5       	in	r24, 0x25	; 37
 b68:	82 60       	ori	r24, 0x02	; 2
 b6a:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 b6c:	85 b5       	in	r24, 0x25	; 37
 b6e:	81 60       	ori	r24, 0x01	; 1
 b70:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 b72:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
 b76:	81 60       	ori	r24, 0x01	; 1
 b78:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 b7c:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 b80:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 b84:	82 60       	ori	r24, 0x02	; 2
 b86:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 b8a:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 b8e:	81 60       	ori	r24, 0x01	; 1
 b90:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 b94:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 b98:	81 60       	ori	r24, 0x01	; 1
 b9a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 b9e:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 ba2:	84 60       	ori	r24, 0x04	; 4
 ba4:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 ba8:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 bac:	81 60       	ori	r24, 0x01	; 1
 bae:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 bb2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 bb6:	84 60       	ori	r24, 0x04	; 4
 bb8:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS1);
 bbc:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 bc0:	82 60       	ori	r24, 0x02	; 2
 bc2:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbi(ADCSRA, ADPS0);
 bc6:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 bca:	81 60       	ori	r24, 0x01	; 1
 bcc:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 bd0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 bd4:	80 68       	ori	r24, 0x80	; 128
 bd6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 bda:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
// ----------

void setup()
{
  // some displays need time to initialize
  delay(1000);
 bde:	68 ee       	ldi	r22, 0xE8	; 232
 be0:	73 e0       	ldi	r23, 0x03	; 3
 be2:	80 e0       	ldi	r24, 0x00	; 0
 be4:	90 e0       	ldi	r25, 0x00	; 0
 be6:	0e 94 53 01 	call	0x2a6	; 0x2a6 <delay>
  // initialize LCD and set up the number of columns and rows
  lcd.begin(16, 2);
 bea:	20 e0       	ldi	r18, 0x00	; 0
 bec:	42 e0       	ldi	r20, 0x02	; 2
 bee:	60 e1       	ldi	r22, 0x10	; 16
 bf0:	8a ec       	ldi	r24, 0xCA	; 202
 bf2:	91 e0       	ldi	r25, 0x01	; 1
 bf4:	0e 94 c6 02 	call	0x58c	; 0x58c <_ZN3LCD5beginEhhh>
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 bf8:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 bfa:	f8 94       	cli
	m = timer0_millis;
 bfc:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <timer0_millis>
 c00:	90 91 b7 01 	lds	r25, 0x01B7	; 0x8001b7 <timer0_millis+0x1>
 c04:	a0 91 b8 01 	lds	r26, 0x01B8	; 0x8001b8 <timer0_millis+0x2>
 c08:	b0 91 b9 01 	lds	r27, 0x01B9	; 0x8001b9 <timer0_millis+0x3>
	SREG = oldSREG;
 c0c:	2f bf       	out	0x3f, r18	; 63

  _startTime_ms = millis();
 c0e:	80 93 b1 01 	sts	0x01B1, r24	; 0x8001b1 <_startTime_ms>
 c12:	90 93 b2 01 	sts	0x01B2, r25	; 0x8001b2 <_startTime_ms+0x1>
 c16:	a0 93 b3 01 	sts	0x01B3, r26	; 0x8001b3 <_startTime_ms+0x2>
 c1a:	b0 93 b4 01 	sts	0x01B4, r27	; 0x8001b4 <_startTime_ms+0x3>
	

#endif

	// busy wait
	__asm__ __volatile__ (
 c1e:	cb e3       	ldi	r28, 0x3B	; 59
 c20:	df e1       	ldi	r29, 0x1F	; 31
	
	setup();
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 c22:	00 e0       	ldi	r16, 0x00	; 0
 c24:	10 e0       	ldi	r17, 0x00	; 0
}

void loop() 
{
  if (0 == _loopCounter--) {
 c26:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 c2a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 c2e:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <__data_start+0x2>
 c32:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <__data_start+0x3>
 c36:	ac 01       	movw	r20, r24
 c38:	bd 01       	movw	r22, r26
 c3a:	41 50       	subi	r20, 0x01	; 1
 c3c:	51 09       	sbc	r21, r1
 c3e:	61 09       	sbc	r22, r1
 c40:	71 09       	sbc	r23, r1
 c42:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
 c46:	50 93 01 01 	sts	0x0101, r21	; 0x800101 <__data_start+0x1>
 c4a:	60 93 02 01 	sts	0x0102, r22	; 0x800102 <__data_start+0x2>
 c4e:	70 93 03 01 	sts	0x0103, r23	; 0x800103 <__data_start+0x3>
 c52:	89 2b       	or	r24, r25
 c54:	8a 2b       	or	r24, r26
 c56:	8b 2b       	or	r24, r27
 c58:	09 f0       	breq	.+2      	; 0xc5c <main+0x104>
 c5a:	3f c0       	rjmp	.+126    	; 0xcda <main+0x182>
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 c5c:	8f b7       	in	r24, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 c5e:	f8 94       	cli
	m = timer0_millis;
 c60:	c0 90 b6 01 	lds	r12, 0x01B6	; 0x8001b6 <timer0_millis>
 c64:	d0 90 b7 01 	lds	r13, 0x01B7	; 0x8001b7 <timer0_millis+0x1>
 c68:	e0 90 b8 01 	lds	r14, 0x01B8	; 0x8001b8 <timer0_millis+0x2>
 c6c:	f0 90 b9 01 	lds	r15, 0x01B9	; 0x8001b9 <timer0_millis+0x3>
	SREG = oldSREG;
 c70:	8f bf       	out	0x3f, r24	; 63

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
 c72:	61 e0       	ldi	r22, 0x01	; 1
 c74:	8a ec       	ldi	r24, 0xCA	; 202
 c76:	91 e0       	ldi	r25, 0x01	; 1
 c78:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <_ZN3LCD7commandEh>
	

#endif

	// busy wait
	__asm__ __volatile__ (
 c7c:	ce 01       	movw	r24, r28
 c7e:	01 97       	sbiw	r24, 0x01	; 1
 c80:	f1 f7       	brne	.-4      	; 0xc7e <main+0x126>
    // 3000000 loops in 6225 [ms]
    unsigned long endTime_ms = millis();
  
    lcd.clear();
    lcd.setCursor(0, 0);
 c82:	80 e0       	ldi	r24, 0x00	; 0
 c84:	0e 94 84 02 	call	0x508	; 0x508 <_ZN3LCD9setCursorEhh.constprop.36>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 c88:	82 e3       	ldi	r24, 0x32	; 50
 c8a:	91 e0       	ldi	r25, 0x01	; 1
 c8c:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <_ZN5Print5writeEPKc.constprop.35>
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 c90:	4a e0       	ldi	r20, 0x0A	; 10
 c92:	60 ec       	ldi	r22, 0xC0	; 192
 c94:	76 ec       	ldi	r23, 0xC6	; 198
 c96:	8d e2       	ldi	r24, 0x2D	; 45
 c98:	90 e0       	ldi	r25, 0x00	; 0
 c9a:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_ZN5Print11printNumberEmh.constprop.33>
    lcd.print("Loops: ");
    lcd.print(C_LOOP_COUNT);
  
    lcd.setCursor(0, 1);
 c9e:	81 e0       	ldi	r24, 0x01	; 1
 ca0:	0e 94 84 02 	call	0x508	; 0x508 <_ZN3LCD9setCursorEhh.constprop.36>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 ca4:	8a e3       	ldi	r24, 0x3A	; 58
 ca6:	91 e0       	ldi	r25, 0x01	; 1
 ca8:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <_ZN5Print5writeEPKc.constprop.35>
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 cac:	80 91 b1 01 	lds	r24, 0x01B1	; 0x8001b1 <_startTime_ms>
 cb0:	90 91 b2 01 	lds	r25, 0x01B2	; 0x8001b2 <_startTime_ms+0x1>
 cb4:	a0 91 b3 01 	lds	r26, 0x01B3	; 0x8001b3 <_startTime_ms+0x2>
 cb8:	b0 91 b4 01 	lds	r27, 0x01B4	; 0x8001b4 <_startTime_ms+0x3>
 cbc:	a7 01       	movw	r20, r14
 cbe:	96 01       	movw	r18, r12
 cc0:	28 1b       	sub	r18, r24
 cc2:	39 0b       	sbc	r19, r25
 cc4:	4a 0b       	sbc	r20, r26
 cc6:	5b 0b       	sbc	r21, r27
 cc8:	ca 01       	movw	r24, r20
 cca:	b9 01       	movw	r22, r18
 ccc:	4a e0       	ldi	r20, 0x0A	; 10
 cce:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_ZN5Print11printNumberEmh.constprop.33>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 cd2:	81 e4       	ldi	r24, 0x41	; 65
 cd4:	91 e0       	ldi	r25, 0x01	; 1
 cd6:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <_ZN5Print5writeEPKc.constprop.35>
 cda:	01 15       	cp	r16, r1
 cdc:	11 05       	cpc	r17, r1
 cde:	09 f4       	brne	.+2      	; 0xce2 <main+0x18a>
 ce0:	a2 cf       	rjmp	.-188    	; 0xc26 <main+0xce>
 ce2:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 ce6:	9f cf       	rjmp	.-194    	; 0xc26 <main+0xce>

00000ce8 <__udivmodsi4>:
 ce8:	a1 e2       	ldi	r26, 0x21	; 33
 cea:	1a 2e       	mov	r1, r26
 cec:	aa 1b       	sub	r26, r26
 cee:	bb 1b       	sub	r27, r27
 cf0:	fd 01       	movw	r30, r26
 cf2:	0d c0       	rjmp	.+26     	; 0xd0e <__udivmodsi4_ep>

00000cf4 <__udivmodsi4_loop>:
 cf4:	aa 1f       	adc	r26, r26
 cf6:	bb 1f       	adc	r27, r27
 cf8:	ee 1f       	adc	r30, r30
 cfa:	ff 1f       	adc	r31, r31
 cfc:	a2 17       	cp	r26, r18
 cfe:	b3 07       	cpc	r27, r19
 d00:	e4 07       	cpc	r30, r20
 d02:	f5 07       	cpc	r31, r21
 d04:	20 f0       	brcs	.+8      	; 0xd0e <__udivmodsi4_ep>
 d06:	a2 1b       	sub	r26, r18
 d08:	b3 0b       	sbc	r27, r19
 d0a:	e4 0b       	sbc	r30, r20
 d0c:	f5 0b       	sbc	r31, r21

00000d0e <__udivmodsi4_ep>:
 d0e:	66 1f       	adc	r22, r22
 d10:	77 1f       	adc	r23, r23
 d12:	88 1f       	adc	r24, r24
 d14:	99 1f       	adc	r25, r25
 d16:	1a 94       	dec	r1
 d18:	69 f7       	brne	.-38     	; 0xcf4 <__udivmodsi4_loop>
 d1a:	60 95       	com	r22
 d1c:	70 95       	com	r23
 d1e:	80 95       	com	r24
 d20:	90 95       	com	r25
 d22:	9b 01       	movw	r18, r22
 d24:	ac 01       	movw	r20, r24
 d26:	bd 01       	movw	r22, r26
 d28:	cf 01       	movw	r24, r30
 d2a:	08 95       	ret

00000d2c <__tablejump2__>:
 d2c:	ee 0f       	add	r30, r30
 d2e:	ff 1f       	adc	r31, r31
 d30:	05 90       	lpm	r0, Z+
 d32:	f4 91       	lpm	r31, Z
 d34:	e0 2d       	mov	r30, r0
 d36:	09 94       	ijmp

00000d38 <abort>:
 d38:	81 e0       	ldi	r24, 0x01	; 1
 d3a:	90 e0       	ldi	r25, 0x00	; 0
 d3c:	f8 94       	cli
 d3e:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <_exit>

00000d42 <_exit>:
 d42:	f8 94       	cli

00000d44 <__stop_program>:
 d44:	ff cf       	rjmp	.-2      	; 0xd44 <__stop_program>

Disassembly of section .bss:

00800146 <__bss_start>:
	...

00800147 <twi_txBuffer>:
	...

00800167 <twi_txBufferLength>:
	...

00800168 <twi_txBufferIndex>:
	...

00800169 <twi_rxBuffer>:
	...

00800189 <twi_rxBufferIndex>:
	...

0080018a <twi_error>:
	...

0080018b <twi_state>:
	...

0080018c <twi_inRepStart>:
	...

0080018d <twi_sendStop>:
	...

0080018e <twi_masterBuffer>:
	...

008001ae <twi_masterBufferLength>:
	...

008001af <twi_masterBufferIndex>:
	...

008001b0 <twi_slarw>:
	...

008001b1 <_startTime_ms>:
  8001b1:	00 00       	nop
	...

008001b5 <timer0_fract>:
	...

008001b6 <timer0_millis>:
  8001b6:	00 00       	nop
	...

008001ba <timer0_overflow_count>:
  8001ba:	00 00       	nop
	...

008001be <Wire>:
	...

008001ca <lcd>:
	...

Disassembly of section .comment:

00000000 <_end-0x8001e1>:
   0:	47 43       	sbci	r20, 0x37	; 55
   2:	43 3a       	cpi	r20, 0xA3	; 163
   4:	20 28       	or	r2, r0
   6:	47 4e       	sbci	r20, 0xE7	; 231
   8:	55 29       	or	r21, r5
   a:	20 35       	cpi	r18, 0x50	; 80
   c:	2e 34       	cpi	r18, 0x4E	; 78
   e:	2e 30       	cpi	r18, 0x0E	; 14
	...

Disassembly of section .note.gnu.avr.deviceinfo:

00000000 <.note.gnu.avr.deviceinfo>:
   0:	04 00       	.word	0x0004	; ????
   2:	00 00       	nop
   4:	2d 00       	.word	0x002d	; ????
   6:	00 00       	nop
   8:	01 00       	.word	0x0001	; ????
   a:	00 00       	nop
   c:	41 56       	subi	r20, 0x61	; 97
   e:	52 00       	.word	0x0052	; ????
  10:	00 00       	nop
  12:	00 00       	nop
  14:	00 80       	ld	r0, Z
  16:	00 00       	nop
  18:	00 01       	movw	r0, r0
  1a:	00 00       	nop
  1c:	00 08       	sbc	r0, r0
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 04       	cpc	r0, r0
  26:	00 00       	nop
  28:	08 00       	.word	0x0008	; ????
  2a:	00 00       	nop
  2c:	01 00       	.word	0x0001	; ????
  2e:	00 00       	nop
  30:	00 61       	ori	r16, 0x10	; 16
  32:	74 6d       	ori	r23, 0xD4	; 212
  34:	65 67       	ori	r22, 0x75	; 117
  36:	61 33       	cpi	r22, 0x31	; 49
  38:	32 38       	cpi	r19, 0x82	; 130
  3a:	70 00       	.word	0x0070	; ????
  3c:	00 00       	nop
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	2c 00       	.word	0x002c	; ????
   2:	00 00       	nop
   4:	02 00       	.word	0x0002	; ????
   6:	f4 05       	cpc	r31, r4
   8:	00 00       	nop
   a:	04 00       	.word	0x0004	; ????
   c:	00 00       	nop
   e:	00 00       	nop
  10:	0e 01       	movw	r0, r28
  12:	00 00       	nop
  14:	3c 09       	sbc	r19, r12
  16:	00 00       	nop
  18:	4a 0a       	sbc	r4, r26
  1a:	00 00       	nop
  1c:	0e 01       	movw	r0, r28
  1e:	00 00       	nop
  20:	58 0b       	sbc	r21, r24
  22:	00 00       	nop
  24:	90 01       	movw	r18, r0
	...
  2e:	00 00       	nop
  30:	1c 00       	.word	0x001c	; ????
  32:	00 00       	nop
  34:	02 00       	.word	0x0002	; ????
  36:	4e 28       	or	r4, r14
  38:	00 00       	nop
  3a:	04 00       	.word	0x0004	; ????
  3c:	00 00       	nop
  3e:	00 00       	nop
  40:	42 0d       	add	r20, r2
  42:	00 00       	nop
  44:	04 00       	.word	0x0004	; ????
	...
  4e:	00 00       	nop
  50:	1c 00       	.word	0x001c	; ????
  52:	00 00       	nop
  54:	02 00       	.word	0x0002	; ????
  56:	fc 28       	or	r15, r12
  58:	00 00       	nop
  5a:	04 00       	.word	0x0004	; ????
  5c:	00 00       	nop
  5e:	00 00       	nop
  60:	e8 0c       	add	r14, r8
  62:	00 00       	nop
  64:	44 00       	.word	0x0044	; ????
	...
  6e:	00 00       	nop
  70:	1c 00       	.word	0x001c	; ????
  72:	00 00       	nop
  74:	02 00       	.word	0x0002	; ????
  76:	aa 29       	or	r26, r10
  78:	00 00       	nop
  7a:	04 00       	.word	0x0004	; ????
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	c6 00       	.word	0x00c6	; ????
  82:	00 00       	nop
  84:	16 00       	.word	0x0016	; ????
	...
  8e:	00 00       	nop
  90:	1c 00       	.word	0x001c	; ????
  92:	00 00       	nop
  94:	02 00       	.word	0x0002	; ????
  96:	58 2a       	or	r5, r24
  98:	00 00       	nop
  9a:	04 00       	.word	0x0004	; ????
  9c:	00 00       	nop
  9e:	00 00       	nop
  a0:	dc 00       	.word	0x00dc	; ????
  a2:	00 00       	nop
  a4:	10 00       	.word	0x0010	; ????
	...
  ae:	00 00       	nop
  b0:	1c 00       	.word	0x001c	; ????
  b2:	00 00       	nop
  b4:	02 00       	.word	0x0002	; ????
  b6:	06 2b       	or	r16, r22
  b8:	00 00       	nop
  ba:	04 00       	.word	0x0004	; ????
  bc:	00 00       	nop
  be:	00 00       	nop
  c0:	ec 00       	.word	0x00ec	; ????
  c2:	00 00       	nop
  c4:	16 00       	.word	0x0016	; ????
	...
  ce:	00 00       	nop
  d0:	1c 00       	.word	0x001c	; ????
  d2:	00 00       	nop
  d4:	02 00       	.word	0x0002	; ????
  d6:	b4 2b       	or	r27, r20
  d8:	00 00       	nop
  da:	04 00       	.word	0x0004	; ????
  dc:	00 00       	nop
  de:	00 00       	nop
  e0:	2c 0d       	add	r18, r12
  e2:	00 00       	nop
  e4:	0c 00       	.word	0x000c	; ????
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	f0 05       	cpc	r31, r0
       2:	00 00       	nop
       4:	02 00       	.word	0x0002	; ????
       6:	00 00       	nop
       8:	00 00       	nop
       a:	04 01       	movw	r0, r8
	...
      14:	02 0f       	add	r16, r18
      16:	00 00       	nop
      18:	00 01       	movw	r0, r0
      1a:	08 03       	fmul	r16, r16
      1c:	17 00       	.word	0x0017	; ????
      1e:	00 00       	nop
      20:	02 07       	cpc	r16, r18
      22:	04 14       	cp	r0, r4
      24:	00 00       	nop
      26:	00 05       	cpc	r16, r0
      28:	1b 00       	.word	0x001b	; ????
      2a:	00 00       	nop
      2c:	ff 03       	fmulsu	r23, r23
      2e:	00 06       	cpc	r0, r16
      30:	20 00       	.word	0x0020	; ????
      32:	00 00       	nop
      34:	00 00       	nop
      36:	22 00       	.word	0x0022	; ????
      38:	00 00       	nop
      3a:	01 05       	cpc	r16, r1
      3c:	03 00       	.word	0x0003	; ????
      3e:	00 81       	ld	r16, Z
      40:	00 07       	cpc	r16, r16
      42:	29 00       	.word	0x0029	; ????
      44:	00 00       	nop
      46:	00 00       	nop
      48:	14 00       	.word	0x0014	; ????
      4a:	00 00       	nop
      4c:	01 05       	cpc	r16, r1
      4e:	03 c6       	rjmp	.+3078   	; 0xc56 <main+0xfe>
      50:	00 80       	ld	r0, Z
      52:	00 08       	sbc	r0, r0
      54:	2e 00       	.word	0x002e	; ????
      56:	00 00       	nop
      58:	00 00       	nop
      5a:	14 00       	.word	0x0014	; ????
      5c:	00 00       	nop
      5e:	01 05       	cpc	r16, r1
      60:	03 c0       	rjmp	.+6      	; 0x68 <__trampolines_end>
      62:	00 80       	ld	r0, Z
      64:	00 09       	sbc	r16, r0
      66:	35 00       	.word	0x0035	; ????
      68:	00 00       	nop
      6a:	00 00       	nop
      6c:	14 00       	.word	0x0014	; ????
      6e:	00 00       	nop
      70:	01 05       	cpc	r16, r1
      72:	03 c1       	rjmp	.+518    	; 0x27a <micros+0x1e>
      74:	00 80       	ld	r0, Z
      76:	00 0a       	sbc	r0, r16
      78:	3c 00       	.word	0x003c	; ????
      7a:	00 00       	nop
      7c:	00 00       	nop
      7e:	14 00       	.word	0x0014	; ????
      80:	00 00       	nop
      82:	01 05       	cpc	r16, r1
      84:	03 c2       	rjmp	.+1030   	; 0x48c <_ZN13LiquidCrystal4sendEhh+0x8>
      86:	00 80       	ld	r0, Z
      88:	00 0b       	sbc	r16, r16
      8a:	43 00       	.word	0x0043	; ????
      8c:	00 00       	nop
      8e:	00 00       	nop
      90:	1b 00       	.word	0x001b	; ????
      92:	00 00       	nop
      94:	01 05       	cpc	r16, r1
      96:	03 c4       	rjmp	.+2054   	; 0x89e <__vector_24+0xa8>
      98:	00 80       	ld	r0, Z
      9a:	00 0c       	add	r0, r0
      9c:	49 00       	.word	0x0049	; ????
      9e:	00 00       	nop
      a0:	00 00       	nop
      a2:	14 00       	.word	0x0014	; ????
      a4:	00 00       	nop
      a6:	01 05       	cpc	r16, r1
      a8:	03 bd       	out	0x23, r16	; 35
      aa:	00 80       	ld	r0, Z
      ac:	00 0d       	add	r16, r0
      ae:	4f 00       	.word	0x004f	; ????
      b0:	00 00       	nop
      b2:	00 00       	nop
      b4:	14 00       	.word	0x0014	; ????
      b6:	00 00       	nop
      b8:	01 05       	cpc	r16, r1
      ba:	03 b8       	out	0x03, r0	; 3
      bc:	00 80       	ld	r0, Z
      be:	00 0e       	add	r0, r16
      c0:	54 00       	.word	0x0054	; ????
      c2:	00 00       	nop
      c4:	00 00       	nop
      c6:	14 00       	.word	0x0014	; ????
      c8:	00 00       	nop
      ca:	01 05       	cpc	r16, r1
      cc:	03 bc       	out	0x23, r0	; 35
      ce:	00 80       	ld	r0, Z
      d0:	00 0f       	add	r16, r16
      d2:	59 00       	.word	0x0059	; ????
      d4:	00 00       	nop
      d6:	00 00       	nop
      d8:	14 00       	.word	0x0014	; ????
      da:	00 00       	nop
      dc:	01 05       	cpc	r16, r1
      de:	03 b9       	out	0x03, r16	; 3
      e0:	00 80       	ld	r0, Z
      e2:	00 10       	cpse	r0, r0
      e4:	5e 00       	.word	0x005e	; ????
      e6:	00 00       	nop
      e8:	00 00       	nop
      ea:	14 00       	.word	0x0014	; ????
      ec:	00 00       	nop
      ee:	01 05       	cpc	r16, r1
      f0:	03 bb       	out	0x13, r16	; 19
      f2:	00 80       	ld	r0, Z
      f4:	00 11       	cpse	r16, r0
      f6:	63 00       	.word	0x0063	; ????
      f8:	00 00       	nop
      fa:	00 00       	nop
      fc:	14 00       	.word	0x0014	; ????
      fe:	00 00       	nop
     100:	01 05       	cpc	r16, r1
     102:	03 ba       	out	0x13, r0	; 19
     104:	00 80       	ld	r0, Z
     106:	00 12       	cpse	r0, r16
     108:	68 00       	.word	0x0068	; ????
     10a:	00 00       	nop
     10c:	00 00       	nop
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
     10e:	14 00       	.word	0x0014	; ????
     110:	00 00       	nop
     112:	01 05       	cpc	r16, r1
     114:	03 6f       	ori	r16, 0xF3	; 243
     116:	00 80       	ld	r0, Z
	uint8_t port = digitalPinToPort(pin);
     118:	00 13       	cpse	r16, r16
     11a:	6f 00       	.word	0x006f	; ????
     11c:	00 00       	nop
     11e:	00 00       	nop
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     120:	14 00       	.word	0x0014	; ????
     122:	00 00       	nop

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     124:	01 05       	cpc	r16, r1
     126:	03 36       	cpi	r16, 0x63	; 99
     128:	00 80       	ld	r0, Z
     12a:	00 14       	cp	r0, r0
     12c:	75 00       	.word	0x0075	; ????
     12e:	00 00       	nop
     130:	00 00       	nop
     132:	14 00       	.word	0x0014	; ????
	out = portOutputRegister(port);
     134:	00 00       	nop
     136:	01 05       	cpc	r16, r1
     138:	03 80       	ldd	r0, Z+3	; 0x03
     13a:	00 80       	ld	r0, Z
     13c:	00 15       	cp	r16, r0
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
     13e:	7c 00       	.word	0x007c	; ????
                cli();
     140:	00 00       	nop
		*reg |= bit;
     142:	00 00       	nop
     144:	14 00       	.word	0x0014	; ????
     146:	00 00       	nop
		SREG = oldSREG;
     148:	01 05       	cpc	r16, r1
     14a:	03 81       	ldd	r16, Z+3	; 0x03
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
     14c:	00 80       	ld	r0, Z
     14e:	00 16       	cp	r0, r16
     150:	83 00       	.word	0x0083	; ????
     152:	00 00       	nop
     154:	00 00       	nop
	uint8_t bit = digitalPinToBitMask(pin);
     156:	14 00       	.word	0x0014	; ????
     158:	00 00       	nop
     15a:	01 05       	cpc	r16, r1
     15c:	03 82       	std	Z+3, r0	; 0x03
	uint8_t port = digitalPinToPort(pin);
     15e:	00 80       	ld	r0, Z
     160:	00 17       	cp	r16, r16
     162:	8a 00       	.word	0x008a	; ????
     164:	00 00       	nop
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     166:	00 00       	nop
     168:	1b 00       	.word	0x001b	; ????
     16a:	00 00       	nop

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     16c:	01 05       	cpc	r16, r1
     16e:	03 84       	ldd	r0, Z+11	; 0x0b
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     170:	00 80       	ld	r0, Z
     172:	00 18       	sub	r0, r0
     174:	90 00       	.word	0x0090	; ????
     176:	00 00       	nop
     178:	00 00       	nop
     17a:	1b 00       	.word	0x001b	; ????
     17c:	00 00       	nop
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     17e:	01 05       	cpc	r16, r1
     180:	03 88       	ldd	r0, Z+19	; 0x13
     182:	00 80       	ld	r0, Z
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     184:	00 19       	sub	r16, r0
     186:	96 00       	.word	0x0096	; ????
     188:	00 00       	nop
     18a:	00 00       	nop
     18c:	1b 00       	.word	0x001b	; ????
     18e:	00 00       	nop
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     190:	01 05       	cpc	r16, r1
     192:	03 8a       	std	Z+19, r0	; 0x13
     194:	00 80       	ld	r0, Z
     196:	00 1a       	sub	r0, r16
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     198:	9c 00       	.word	0x009c	; ????
     19a:	00 00       	nop
     19c:	00 00       	nop
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     19e:	1b 00       	.word	0x001b	; ????
     1a0:	00 00       	nop
     1a2:	01 05       	cpc	r16, r1
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     1a4:	03 86       	std	Z+11, r0	; 0x0b
     1a6:	00 80       	ld	r0, Z
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     1a8:	00 1b       	sub	r16, r16
     1aa:	a1 00       	.word	0x00a1	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     1ac:	00 00       	nop
     1ae:	00 00       	nop
     1b0:	14 00       	.word	0x0014	; ????
     1b2:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     1b4:	01 05       	cpc	r16, r1
     1b6:	03 43       	sbci	r16, 0x33	; 51
     1b8:	00 80       	ld	r0, Z
     1ba:	00 1c       	adc	r0, r0
     1bc:	a7 00       	.word	0x00a7	; ????

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
     1be:	00 00       	nop
     1c0:	00 00       	nop
     1c2:	14 00       	.word	0x0014	; ????
     1c4:	00 00       	nop
     1c6:	01 05       	cpc	r16, r1
     1c8:	03 70       	andi	r16, 0x03	; 3
     1ca:	00 80       	ld	r0, Z

	uint8_t oldSREG = SREG;
     1cc:	00 1d       	adc	r16, r0
	cli();
     1ce:	ae 00       	.word	0x00ae	; ????

	if (val == LOW) {
     1d0:	00 00       	nop
     1d2:	00 00       	nop
		*out &= ~bit;
     1d4:	14 00       	.word	0x0014	; ????
     1d6:	00 00       	nop
     1d8:	01 05       	cpc	r16, r1
     1da:	03 37       	cpi	r16, 0x73	; 115
	} else {
		*out |= bit;
     1dc:	00 80       	ld	r0, Z
     1de:	00 1e       	adc	r0, r16
     1e0:	b4 00       	.word	0x00b4	; ????
	}

	SREG = oldSREG;
     1e2:	00 00       	nop
     1e4:	00 00       	nop
   digitalWrite(_enable_pin, LOW);
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
     1e6:	14 00       	.word	0x0014	; ????
     1e8:	00 00       	nop
     1ea:	01 05       	cpc	r16, r1
     1ec:	03 b0       	in	r0, 0x03	; 3
     1ee:	00 80       	ld	r0, Z
     1f0:	00 1f       	adc	r16, r16
     1f2:	bb 00       	.word	0x00bb	; ????
     1f4:	00 00       	nop
     1f6:	00 00       	nop
     1f8:	14 00       	.word	0x0014	; ????
     1fa:	00 00       	nop
     1fc:	01 05       	cpc	r16, r1
     1fe:	03 b1       	in	r16, 0x03	; 3
     200:	00 80       	ld	r0, Z
     202:	00 20       	and	r0, r0
     204:	c2 00       	.word	0x00c2	; ????
     206:	00 00       	nop
     208:	00 00       	nop
     20a:	14 00       	.word	0x0014	; ????
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
     20c:	00 00       	nop
     20e:	01 05       	cpc	r16, r1

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
     210:	03 b2       	in	r0, 0x13	; 19
     212:	00 80       	ld	r0, Z
     214:	00 21       	and	r16, r0
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
     216:	c8 00       	.word	0x00c8	; ????
     218:	00 00       	nop
     21a:	00 00       	nop
     21c:	14 00       	.word	0x0014	; ????
     21e:	00 00       	nop
     220:	01 05       	cpc	r16, r1
     222:	03 b4       	in	r0, 0x23	; 35
     224:	00 80       	ld	r0, Z
     226:	00 22       	and	r0, r16
     228:	ce 00       	.word	0x00ce	; ????
     22a:	00 00       	nop
     22c:	00 00       	nop
     22e:	14 00       	.word	0x0014	; ????
     230:	00 00       	nop
     232:	01 05       	cpc	r16, r1
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
     234:	03 b3       	in	r16, 0x13	; 19
     236:	00 80       	ld	r0, Z
     238:	00 23       	and	r16, r16
     23a:	d4 00       	.word	0x00d4	; ????
     23c:	00 00       	nop
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
     23e:	00 00       	nop
     240:	14 00       	.word	0x0014	; ????
     242:	00 00       	nop
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
     244:	01 05       	cpc	r16, r1
     246:	03 b6       	in	r0, 0x33	; 51
     248:	00 80       	ld	r0, Z
     24a:	00 24       	eor	r0, r0
     24c:	d9 00       	.word	0x00d9	; ????
     24e:	00 00       	nop
     250:	00 00       	nop
     252:	14 00       	.word	0x0014	; ????
     254:	00 00       	nop
     256:	01 05       	cpc	r16, r1
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
     258:	03 43       	sbci	r16, 0x33	; 51
     25a:	00 80       	ld	r0, Z
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     25c:	00 25       	eor	r16, r0
	
	cli();
     25e:	df 00       	.word	0x00df	; ????
	m = timer0_overflow_count;
     260:	00 00       	nop
     262:	00 00       	nop
     264:	14 00       	.word	0x0014	; ????
     266:	00 00       	nop
     268:	01 05       	cpc	r16, r1
     26a:	03 7c       	andi	r16, 0xC3	; 195
     26c:	00 80       	ld	r0, Z
     26e:	00 26       	eor	r0, r16
#if defined(TCNT0)
	t = TCNT0;
     270:	e5 00       	.word	0x00e5	; ????
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     272:	00 00       	nop
     274:	00 00       	nop
     276:	1b 00       	.word	0x001b	; ????
     278:	00 00       	nop
		m++;
     27a:	01 05       	cpc	r16, r1
     27c:	03 78       	andi	r16, 0x83	; 131
     27e:	00 80       	ld	r0, Z
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     280:	00 27       	eor	r16, r16
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     282:	e9 00       	.word	0x00e9	; ????
     284:	00 00       	nop
     286:	00 00       	nop
     288:	14 00       	.word	0x0014	; ????
     28a:	00 00       	nop
     28c:	01 05       	cpc	r16, r1
     28e:	03 7a       	andi	r16, 0xA3	; 163
     290:	00 80       	ld	r0, Z
     292:	00 28       	or	r0, r0
     294:	f0 00       	.word	0x00f0	; ????
     296:	00 00       	nop
     298:	00 00       	nop
     29a:	14 00       	.word	0x0014	; ????
     29c:	00 00       	nop
     29e:	01 05       	cpc	r16, r1
     2a0:	03 7b       	andi	r16, 0xB3	; 179
     2a2:	00 80       	ld	r0, Z
}
     2a4:	00 29       	or	r16, r0

void delay(unsigned long ms)
{
     2a6:	f7 00       	.word	0x00f7	; ????
     2a8:	00 00       	nop
     2aa:	00 00       	nop
     2ac:	14 00       	.word	0x0014	; ????
     2ae:	00 00       	nop
     2b0:	01 05       	cpc	r16, r1
     2b2:	03 7e       	andi	r16, 0xE3	; 227
     2b4:	00 80       	ld	r0, Z
     2b6:	00 2a       	or	r0, r16
     2b8:	fd 00       	.word	0x00fd	; ????
	uint32_t start = micros();
     2ba:	00 00       	nop
     2bc:	00 00       	nop
     2be:	14 00       	.word	0x0014	; ????
     2c0:	00 00       	nop

	while (ms > 0) {
     2c2:	01 05       	cpc	r16, r1
     2c4:	03 50       	subi	r16, 0x03	; 3
     2c6:	00 80       	ld	r0, Z
     2c8:	00 2b       	or	r16, r16
     2ca:	02 01       	movw	r0, r4
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     2cc:	00 00       	nop
     2ce:	00 00       	nop
     2d0:	14 00       	.word	0x0014	; ????
     2d2:	00 00       	nop
     2d4:	01 05       	cpc	r16, r1
     2d6:	03 7f       	andi	r16, 0xF3	; 243
     2d8:	00 80       	ld	r0, Z
     2da:	00 2c       	mov	r0, r0
     2dc:	08 01       	movw	r0, r16
     2de:	00 00       	nop
     2e0:	00 00       	nop
     2e2:	14 00       	.word	0x0014	; ????
     2e4:	00 00       	nop
			ms--;
     2e6:	01 05       	cpc	r16, r1
     2e8:	03 25       	eor	r16, r3
     2ea:	00 80       	ld	r0, Z
     2ec:	00 2d       	mov	r16, r0
     2ee:	0e 01       	movw	r0, r28
			start += 1000;
     2f0:	00 00       	nop
     2f2:	00 00       	nop
     2f4:	14 00       	.word	0x0014	; ????
     2f6:	00 00       	nop
     2f8:	01 05       	cpc	r16, r1
     2fa:	03 24       	eor	r0, r3
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     2fc:	00 80       	ld	r0, Z
     2fe:	00 2e       	mov	r0, r16
     300:	13 01       	movw	r2, r6
     302:	00 00       	nop
     304:	00 00       	nop
     306:	14 00       	.word	0x0014	; ????
			ms--;
			start += 1000;
		}
	}
}
     308:	00 00       	nop
     30a:	01 05       	cpc	r16, r1
     30c:	03 23       	and	r16, r19
     30e:	00 80       	ld	r0, Z
     310:	00 2f       	mov	r16, r16
     312:	18 01       	movw	r2, r16
     314:	00 00       	nop
     316:	00 00       	nop
     318:	14 00       	.word	0x0014	; ????

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     31a:	00 00       	nop
     31c:	01 05       	cpc	r16, r1
     31e:	03 28       	or	r0, r3
     320:	00 80       	ld	r0, Z
     322:	00 30       	cpi	r16, 0x00	; 0
     324:	1e 01       	movw	r2, r28
     326:	00 00       	nop
     328:	00 00       	nop
     32a:	14 00       	.word	0x0014	; ????
     32c:	00 00       	nop
     32e:	01 05       	cpc	r16, r1
  size_t n = 0;
     330:	03 27       	eor	r16, r19
     332:	00 80       	ld	r0, Z
  while (size--) {
     334:	00 31       	cpi	r16, 0x10	; 16
     336:	23 01       	movw	r4, r6
     338:	00 00       	nop
    if (write(*buffer++)) n++;
     33a:	00 00       	nop
     33c:	14 00       	.word	0x0014	; ????
     33e:	00 00       	nop
     340:	01 05       	cpc	r16, r1
     342:	03 26       	eor	r0, r19
     344:	00 80       	ld	r0, Z
     346:	00 32       	cpi	r16, 0x20	; 32
     348:	28 01       	movw	r4, r16
     34a:	00 00       	nop
     34c:	00 00       	nop
     34e:	14 00       	.word	0x0014	; ????
     350:	00 00       	nop
     352:	01 05       	cpc	r16, r1
     354:	03 2b       	or	r16, r19
     356:	00 80       	ld	r0, Z
     358:	00 33       	cpi	r16, 0x30	; 48
    else break;
  }
  return n;
}
     35a:	2e 01       	movw	r4, r28
     35c:	00 00       	nop
     35e:	00 00       	nop
     360:	14 00       	.word	0x0014	; ????
     362:	00 00       	nop
     364:	01 05       	cpc	r16, r1
     366:	03 2a       	or	r0, r19
     368:	00 80       	ld	r0, Z
     36a:	00 34       	cpi	r16, 0x40	; 64
     36c:	33 01       	movw	r6, r6
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
     36e:	00 00       	nop
     370:	00 00       	nop
     372:	14 00       	.word	0x0014	; ????

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
     374:	00 00       	nop
     376:	01 05       	cpc	r16, r1
     378:	03 29       	or	r16, r3
     37a:	00 80       	ld	r0, Z
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
     37c:	00 35       	cpi	r16, 0x50	; 80
     37e:	38 01       	movw	r6, r16
     380:	00 00       	nop
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
     382:	00 00       	nop
     384:	14 00       	.word	0x0014	; ????
     386:	00 00       	nop
     388:	01 05       	cpc	r16, r1
     38a:	03 48       	sbci	r16, 0x83	; 131
     38c:	00 80       	ld	r0, Z
     38e:	00 36       	cpi	r16, 0x60	; 96
     390:	3e 01       	movw	r6, r28
     392:	00 00       	nop
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
     394:	00 00       	nop
     396:	14 00       	.word	0x0014	; ????
     398:	00 00       	nop
     39a:	01 05       	cpc	r16, r1
     39c:	03 47       	sbci	r16, 0x73	; 115
     39e:	00 80       	ld	r0, Z
     3a0:	00 37       	cpi	r16, 0x70	; 112
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
     3a2:	44 01       	movw	r8, r8
     3a4:	00 00       	nop
    twi_txBuffer[twi_txBufferLength+i] = data[i];
     3a6:	00 00       	nop
     3a8:	14 00       	.word	0x0014	; ????
     3aa:	00 00       	nop
     3ac:	01 05       	cpc	r16, r1
     3ae:	03 46       	sbci	r16, 0x63	; 99
     3b0:	00 80       	ld	r0, Z
     3b2:	00 38       	cpi	r16, 0x80	; 128
     3b4:	4a 01       	movw	r8, r20
     3b6:	00 00       	nop
     3b8:	00 00       	nop
     3ba:	14 00       	.word	0x0014	; ????
  }
  twi_txBufferLength += length;
     3bc:	00 00       	nop
     3be:	01 05       	cpc	r16, r1
     3c0:	03 45       	sbci	r16, 0x53	; 83
     3c2:	00 80       	ld	r0, Z
     3c4:	00 39       	cpi	r16, 0x90	; 144
     3c6:	51 01       	movw	r10, r2
     3c8:	00 00       	nop
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
     3ca:	00 00       	nop
     3cc:	14 00       	.word	0x0014	; ????
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
     3ce:	00 00       	nop
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
     3d0:	01 05       	cpc	r16, r1

  return value;
}

void TwoWire::flush(void)
{
     3d2:	03 44       	sbci	r16, 0x43	; 67
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     3d4:	00 80       	ld	r0, Z
     3d6:	00 3a       	cpi	r16, 0xA0	; 160
     3d8:	58 01       	movw	r10, r16
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
     3da:	00 00       	nop
     3dc:	00 00       	nop
     3de:	14 00       	.word	0x0014	; ????
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
     3e0:	00 00       	nop
     3e2:	01 05       	cpc	r16, r1
     3e4:	03 6e       	ori	r16, 0xE3	; 227
}
     3e6:	00 80       	ld	r0, Z
     3e8:	00 3b       	cpi	r16, 0xB0	; 176
     3ea:	5f 01       	movw	r10, r30
     3ec:	00 00       	nop

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     3ee:	00 00       	nop
     3f0:	14 00       	.word	0x0014	; ????
     3f2:	00 00       	nop
     3f4:	01 05       	cpc	r16, r1
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
     3f6:	03 35       	cpi	r16, 0x53	; 83
     3f8:	00 80       	ld	r0, Z
     3fa:	00 3c       	cpi	r16, 0xC0	; 192
  }
  return quantity;
}
     3fc:	65 01       	movw	r12, r10
     3fe:	00 00       	nop
     400:	00 00       	nop
     402:	14 00       	.word	0x0014	; ????

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
     404:	00 00       	nop
     406:	01 05       	cpc	r16, r1
     408:	03 43       	sbci	r16, 0x33	; 51
     40a:	00 80       	ld	r0, Z
     40c:	00 3d       	cpi	r16, 0xD0	; 208
     40e:	6b 01       	movw	r12, r22
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
     410:	00 00       	nop
     412:	00 00       	nop
     414:	14 00       	.word	0x0014	; ????
     416:	00 00       	nop
     418:	01 05       	cpc	r16, r1
  }
  return 1;
}
     41a:	03 69       	ori	r16, 0x93	; 147
     41c:	00 80       	ld	r0, Z
     41e:	00 3e       	cpi	r16, 0xE0	; 224
     420:	71 01       	movw	r14, r2
     422:	00 00       	nop
     424:	00 00       	nop
#endif

//
// setBackligh
void LiquidCrystal::setBacklight ( uint8_t value )
{
     426:	14 00       	.word	0x0014	; ????
   // Check if there is a pin assigned to the backlight
   // ---------------------------------------------------
   if ( _backlightPin != LCD_NOBACKLIGHT )
     428:	00 00       	nop
     42a:	01 05       	cpc	r16, r1
     42c:	03 3d       	cpi	r16, 0xD3	; 211
     42e:	00 80       	ld	r0, Z
     430:	00 3f       	cpi	r16, 0xF0	; 240
         }
      }
      // Not a PWM pin, set the backlight pin for POSI or NEG
      // polarity
      // --------------------------------------------------------
      else if (((value > 0) && (_polarity == POSITIVE)) ||
     432:	77 01       	movw	r14, r14
     434:	00 00       	nop
     436:	00 00       	nop
     438:	14 00       	.word	0x0014	; ????
     43a:	00 00       	nop
               ((value == 0) && (_polarity == NEGATIVE)))
     43c:	01 05       	cpc	r16, r1
     43e:	03 3c       	cpi	r16, 0xC3	; 195
     440:	00 80       	ld	r0, Z
      {
         digitalWrite( _backlightPin, HIGH);
     442:	00 40       	sbci	r16, 0x00	; 0
     444:	7c 01       	movw	r14, r24
      }
      else
      {
         digitalWrite( _backlightPin, LOW);
     446:	00 00       	nop
     448:	00 00       	nop
     44a:	14 00       	.word	0x0014	; ????
     44c:	00 00       	nop
}

//
// setBacklightPin
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
     44e:	01 05       	cpc	r16, r1
     450:	03 68       	ori	r16, 0x83	; 131
     452:	00 80       	ld	r0, Z
     454:	00 41       	sbci	r16, 0x10	; 16
     456:	82 01       	movw	r16, r4
     458:	00 00       	nop
     45a:	00 00       	nop
     45c:	14 00       	.word	0x0014	; ????
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
     45e:	00 00       	nop
     460:	01 05       	cpc	r16, r1
     462:	03 6d       	ori	r16, 0xD3	; 211
   _backlightPin = pin;
     464:	00 80       	ld	r0, Z
   _polarity = pol;
     466:	00 42       	sbci	r16, 0x20	; 32
     468:	89 01       	movw	r16, r18
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
     46a:	00 00       	nop
     46c:	00 00       	nop
     46e:	14 00       	.word	0x0014	; ????
     470:	00 00       	nop
     472:	01 05       	cpc	r16, r1
     474:	03 6c       	ori	r16, 0xC3	; 195
     476:	00 80       	ld	r0, Z
}
     478:	00 43       	sbci	r16, 0x30	; 48
     47a:	90 01       	movw	r18, r0
     47c:	00 00       	nop
     47e:	00 00       	nop
     480:	14 00       	.word	0x0014	; ????
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
   _backlightPin = pin;
   _polarity = pol;
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
     482:	00 00       	nop

/************ low level data pushing commands **********/
//
// send
void LiquidCrystal::send(uint8_t value, uint8_t mode) 
{
     484:	01 05       	cpc	r16, r1
     486:	03 6b       	ori	r16, 0xB3	; 179
     488:	00 80       	ld	r0, Z
     48a:	00 44       	sbci	r16, 0x40	; 64
     48c:	97 01       	movw	r18, r14
     48e:	00 00       	nop
     490:	00 00       	nop
   // Only interested in COMMAND or DATA
   digitalWrite( _rs_pin, ( mode == LCD_DATA ) );
     492:	14 00       	.word	0x0014	; ????
     494:	00 00       	nop
     496:	01 05       	cpc	r16, r1
     498:	03 3b       	cpi	r16, 0xB3	; 179
     49a:	00 80       	ld	r0, Z
     49c:	00 45       	sbci	r16, 0x50	; 80
     49e:	9d 01       	movw	r18, r26
   
   // if there is a RW pin indicated, set it low to Write
   // ---------------------------------------------------
   if (_rw_pin != 255) 
     4a0:	00 00       	nop
     4a2:	00 00       	nop
     4a4:	14 00       	.word	0x0014	; ????
   { 
      digitalWrite(_rw_pin, LOW);
     4a6:	00 00       	nop
     4a8:	01 05       	cpc	r16, r1
     4aa:	03 4e       	sbci	r16, 0xE3	; 227
   }
   
   if ( mode != FOUR_BITS )
     4ac:	00 80       	ld	r0, Z
     4ae:	00 46       	sbci	r16, 0x60	; 96
   {   
      if ( (_displayfunction & LCD_8BITMODE ) )
     4b0:	a2 01       	movw	r20, r4
     4b2:	00 00       	nop
     4b4:	00 00       	nop
      {
         writeNbits(value, 8); 
     4b6:	14 00       	.word	0x0014	; ????
     4b8:	00 00       	nop
      } 
      else 
      {
         writeNbits ( value >> 4, 4 );
     4ba:	01 05       	cpc	r16, r1
     4bc:	03 4d       	sbci	r16, 0xD3	; 211
     4be:	00 80       	ld	r0, Z
     4c0:	00 47       	sbci	r16, 0x70	; 112
     4c2:	a7 01       	movw	r20, r14
     4c4:	00 00       	nop
     4c6:	00 00       	nop
     4c8:	14 00       	.word	0x0014	; ????
     4ca:	00 00       	nop
     4cc:	01 05       	cpc	r16, r1
     4ce:	03 4c       	sbci	r16, 0xC3	; 195
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
     4d0:	00 80       	ld	r0, Z
     4d2:	00 48       	sbci	r16, 0x80	; 128
     4d4:	ac 01       	movw	r20, r24
   }
   waitUsec ( EXEC_TIME ); // wait for the command to execute by the LCD
}
     4d6:	00 00       	nop
     4d8:	00 00       	nop
     4da:	14 00       	.word	0x0014	; ????
     4dc:	00 00       	nop
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
     4de:	01 05       	cpc	r16, r1
     4e0:	03 60       	ori	r16, 0x03	; 3
   send(value, LCD_DATA);
}
#else
size_t LCD::write(uint8_t value) 
{
   send(value, LCD_DATA);
     4e2:	00 80       	ld	r0, Z
     4e4:	00 49       	sbci	r16, 0x90	; 144
     4e6:	b3 01       	movw	r22, r6
     4e8:	00 00       	nop
     4ea:	00 00       	nop
     4ec:	14 00       	.word	0x0014	; ????
     4ee:	00 00       	nop
     4f0:	01 05       	cpc	r16, r1
   return 1;             // assume OK
}
     4f2:	03 64       	ori	r16, 0x43	; 67
     4f4:	00 80       	ld	r0, Z
     4f6:	00 4a       	sbci	r16, 0xA0	; 160

// General LCD commands - generic methods used by the rest of the commands
// ---------------------------------------------------------------------------
void LCD::command(uint8_t value) 
{
   send(value, COMMAND);
     4f8:	b7 01       	movw	r22, r14
     4fa:	00 00       	nop
     4fc:	00 00       	nop
     4fe:	14 00       	.word	0x0014	; ????
     500:	00 00       	nop
     502:	01 05       	cpc	r16, r1
     504:	03 66       	ori	r16, 0x63	; 99
     506:	00 80       	ld	r0, Z
{
   command(LCD_RETURNHOME);             // set cursor position to zero
   delayMicroseconds(HOME_CLEAR_EXEC);  // This command is time consuming
}

void LCD::setCursor(uint8_t col, uint8_t row)
     508:	00 4b       	sbci	r16, 0xB0	; 176
     50a:	be 01       	movw	r22, r28
     50c:	00 00       	nop
     50e:	00 00       	nop
     510:	14 00       	.word	0x0014	; ????
     512:	00 00       	nop
     514:	01 05       	cpc	r16, r1
     516:	03 61       	ori	r16, 0x13	; 19
     518:	00 80       	ld	r0, Z
     51a:	00 4c       	sbci	r16, 0xC0	; 192
{
   const byte row_offsetsDef[]   = { 0x00, 0x40, 0x14, 0x54 }; // For regular LCDs
     51c:	c4 01       	movw	r24, r8
     51e:	00 00       	nop
     520:	00 00       	nop
     522:	14 00       	.word	0x0014	; ????
     524:	00 00       	nop
     526:	01 05       	cpc	r16, r1
     528:	03 5f       	subi	r16, 0xF3	; 243
     52a:	00 80       	ld	r0, Z
     52c:	00 4d       	sbci	r16, 0xD0	; 208
     52e:	c9 01       	movw	r24, r18
     530:	00 00       	nop
     532:	00 00       	nop
   const byte row_offsetsLarge[] = { 0x00, 0x40, 0x10, 0x50 }; // For 16x4 LCDs
     534:	1b 00       	.word	0x001b	; ????
     536:	00 00       	nop
     538:	01 05       	cpc	r16, r1
     53a:	03 5d       	subi	r16, 0xD3	; 211
     53c:	00 80       	ld	r0, Z
     53e:	00 4e       	sbci	r16, 0xE0	; 224
     540:	cc 01       	movw	r24, r24
     542:	00 00       	nop
     544:	00 00       	nop
     546:	14 00       	.word	0x0014	; ????
     548:	00 00       	nop
     54a:	01 05       	cpc	r16, r1
   
   if ( row >= _numlines ) 
     54c:	03 57       	subi	r16, 0x73	; 115
     54e:	00 80       	ld	r0, Z
     550:	00 4f       	sbci	r16, 0xF0	; 240
     552:	d3 01       	movw	r26, r6
   {
      row = _numlines-1;    // rows start at 0
     554:	00 00       	nop
     556:	00 00       	nop
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
     558:	14 00       	.word	0x0014	; ????
     55a:	00 00       	nop
     55c:	01 05       	cpc	r16, r1
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
     55e:	03 55       	subi	r16, 0x53	; 83
     560:	00 80       	ld	r0, Z
     562:	00 50       	subi	r16, 0x00	; 0
      row = _numlines-1;    // rows start at 0
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
     564:	d9 01       	movw	r26, r18
     566:	00 00       	nop
     568:	00 00       	nop
     56a:	14 00       	.word	0x0014	; ????
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
     56c:	00 00       	nop
     56e:	01 05       	cpc	r16, r1
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
     570:	03 54       	subi	r16, 0x43	; 67
     572:	00 80       	ld	r0, Z
     574:	00 51       	subi	r16, 0x10	; 16
     576:	df 01       	movw	r26, r30
   }
   
}
     578:	00 00       	nop
     57a:	00 00       	nop
     57c:	14 00       	.word	0x0014	; ????
     57e:	00 00       	nop
     580:	01 05       	cpc	r16, r1
     582:	03 53       	subi	r16, 0x33	; 51
     584:	00 80       	ld	r0, Z
     586:	00 52       	subi	r16, 0x20	; 32
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
     588:	e4 01       	movw	r28, r8
     58a:	00 00       	nop
// can't assume that its in that state when a application starts (and the
// LiquidCrystal constructor is called).
// A call to begin() will reinitialize the LCD.
//
void LCD::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) 
{
     58c:	00 00       	nop
     58e:	14 00       	.word	0x0014	; ????
     590:	00 00       	nop
     592:	01 05       	cpc	r16, r1
     594:	03 4b       	sbci	r16, 0xB3	; 179
   if (lines > 1) 
     596:	00 80       	ld	r0, Z
     598:	00 53       	subi	r16, 0x30	; 48
   {
      _displayfunction |= LCD_2LINE;
     59a:	eb 01       	movw	r28, r22
     59c:	00 00       	nop
     59e:	00 00       	nop
   }
   _numlines = lines;
     5a0:	14 00       	.word	0x0014	; ????
   _cols = cols;
     5a2:	00 00       	nop
   
   // for some 1 line displays you can select a 10 pixel high font
   // ------------------------------------------------------------
   if ((dotsize != LCD_5x8DOTS) && (lines == 1)) 
     5a4:	01 05       	cpc	r16, r1
     5a6:	03 4a       	sbci	r16, 0xA3	; 163
     5a8:	00 80       	ld	r0, Z
     5aa:	00 54       	subi	r16, 0x40	; 64
   {
      _displayfunction |= LCD_5x10DOTS;
     5ac:	f2 01       	movw	r30, r4
     5ae:	00 00       	nop
     5b0:	00 00       	nop
   // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
   // according to datasheet, we need at least 40ms after power rises above 2.7V
   // before sending commands. Arduino can turn on way before 4.5V so we'll wait 
   // 50
   // ---------------------------------------------------------------------------
   delay (100); // 100ms delay
     5b2:	14 00       	.word	0x0014	; ????
     5b4:	00 00       	nop
     5b6:	01 05       	cpc	r16, r1
     5b8:	03 3e       	cpi	r16, 0xE3	; 227
     5ba:	00 80       	ld	r0, Z
     5bc:	00 55       	subi	r16, 0x50	; 80
   
   //put the LCD into 4 bit or 8 bit mode
   // -------------------------------------
   if (! (_displayfunction & LCD_8BITMODE)) 
     5be:	f9 01       	movw	r30, r18
     5c0:	00 00       	nop
     5c2:	00 00       	nop
      // this is according to the hitachi HD44780 datasheet
      // figure 24, pg 46
      
      // we start in 8bit mode, try to set 4 bit mode
      // Special case of "Function Set"
      send(0x03, FOUR_BITS);
     5c4:	1b 00       	.word	0x001b	; ????
     5c6:	00 00       	nop
     5c8:	01 05       	cpc	r16, r1
     5ca:	03 41       	sbci	r16, 0x13	; 19
     5cc:	00 80       	ld	r0, Z
     5ce:	00 56       	subi	r16, 0x60	; 96
     5d0:	fe 01       	movw	r30, r28
     5d2:	00 00       	nop
     5d4:	00 00       	nop
	

#endif

	// busy wait
	__asm__ __volatile__ (
     5d6:	14 00       	.word	0x0014	; ????
     5d8:	00 00       	nop
     5da:	01 05       	cpc	r16, r1
     5dc:	03 40       	sbci	r16, 0x03	; 3
      delayMicroseconds(4500); // wait min 4.1ms
      
      // second try
      send ( 0x03, FOUR_BITS );
     5de:	00 80       	ld	r0, Z
     5e0:	00 57       	subi	r16, 0x70	; 112
     5e2:	03 02       	muls	r16, r19
     5e4:	00 00       	nop
     5e6:	00 00       	nop
     5e8:	14 00       	.word	0x0014	; ????
     5ea:	00 00       	nop
     5ec:	01 05       	cpc	r16, r1
     5ee:	03 3f       	cpi	r16, 0xF3	; 243
     5f0:	00 80       	ld	r0, Z
     5f2:	00 00       	nop
     5f4:	56 22       	and	r5, r22
     5f6:	00 00       	nop
     5f8:	02 00       	.word	0x0002	; ????
      delayMicroseconds(150); // wait min 100us
      
      // third go!
      send( 0x03, FOUR_BITS );
     5fa:	a2 05       	cpc	r26, r2
     5fc:	00 00       	nop
     5fe:	04 01       	movw	r0, r8
     600:	fa 04       	cpc	r15, r10
     602:	00 00       	nop
     604:	02 18       	sub	r0, r2
     606:	04 00       	.word	0x0004	; ????
     608:	00 90 00 00 	lds	r0, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
	...
      delayMicroseconds(150); // wait min of 100us
      
      // finally, set to 4-bit interface
      send ( 0x02, FOUR_BITS );
     614:	00 1a       	sub	r0, r16
     616:	00 00       	nop
     618:	00 02       	muls	r16, r16
     61a:	02 68       	ori	r16, 0x82	; 130
     61c:	07 00       	.word	0x0007	; ????
     61e:	00 2f       	mov	r16, r16
     620:	00 00       	nop
     622:	00 03       	mulsu	r16, r16
     624:	3a 00       	.word	0x003a	; ????
   {
      // this is according to the hitachi HD44780 datasheet
      // page 45 figure 23
      
      // Send function set command sequence
      command(LCD_FUNCTIONSET | _displayfunction);
     626:	00 00       	nop
     628:	3a 00       	.word	0x003a	; ????
     62a:	00 00       	nop
     62c:	04 00       	.word	0x0004	; ????
     62e:	05 02       	muls	r16, r21
     630:	05 69       	ori	r16, 0x95	; 149
     632:	6e 74       	andi	r22, 0x4E	; 78
     634:	00 06       	cpc	r0, r16
      delayMicroseconds(4500);  // wait more than 4.1ms
      
      // second try
      command(LCD_FUNCTIONSET | _displayfunction);
     636:	14 06       	cpc	r1, r20
     638:	00 00       	nop
     63a:	04 09       	sbc	r16, r4
     63c:	25 41       	sbci	r18, 0x15	; 21
     63e:	00 00       	nop
     640:	00 27       	eor	r16, r16
     642:	01 00       	.word	0x0001	; ????
     644:	00 07       	cpc	r16, r16
     646:	0e 06       	cpc	r0, r30
     648:	00 00       	nop
      delayMicroseconds(150);
      
      // third go
      command(LCD_FUNCTIONSET | _displayfunction);
     64a:	27 01       	movw	r4, r14
     64c:	00 00       	nop
     64e:	02 23       	and	r16, r18
     650:	00 01       	movw	r0, r0
     652:	08 4c       	sbci	r16, 0xC8	; 200
     654:	02 00       	.word	0x0002	; ????
     656:	00 09       	sbc	r16, r0
     658:	28 3a       	cpi	r18, 0xA8	; 168
      delayMicroseconds(150);

   }
   
   // finally, set # lines, font size, etc.
   command(LCD_FUNCTIONSET | _displayfunction);
     65a:	00 00       	nop
     65c:	00 02       	muls	r16, r16
     65e:	23 02       	muls	r18, r19
     660:	03 09       	sbc	r16, r3
     662:	f6 05       	cpc	r31, r6
     664:	00 00       	nop
     666:	04 67       	ori	r16, 0x74	; 116
     668:	01 8b       	std	Z+17, r16	; 0x11
     66a:	05 00       	.word	0x0005	; ????
   delayMicroseconds ( 60 );  // wait more
   
   // turn the display on with no cursor or blinking default
   _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
     66c:	00 01       	movw	r0, r0
     66e:	82 00       	.word	0x0082	; ????
}

void LCD::display() 
{
   _displaycontrol |= LCD_DISPLAYON;
   command(LCD_DISPLAYCONTROL | _displaycontrol);
     670:	00 00       	nop
     672:	93 00       	.word	0x0093	; ????
     674:	00 00       	nop
     676:	0a af       	std	Y+58, r16	; 0x3a

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
     678:	07 00       	.word	0x0007	; ????
     67a:	00 01       	movw	r0, r0
     67c:	0b e9       	ldi	r16, 0x9B	; 155
     67e:	05 00       	.word	0x0005	; ????
     680:	00 0b       	sbc	r16, r16
     682:	3a 00       	.word	0x003a	; ????
     684:	00 00       	nop
     686:	00 09       	sbc	r16, r0
   
   // clear the LCD
   clear();
   
   // Initialize to default text direction (for romance languages)
   _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
     688:	f6 05       	cpc	r31, r6
     68a:	00 00       	nop
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);
     68c:	04 3e       	cpi	r16, 0xE4	; 228
     68e:	01 8b       	std	Z+17, r16	; 0x11
     690:	05 00       	.word	0x0005	; ????
     692:	00 01       	movw	r0, r0

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
     694:	a8 00       	.word	0x00a8	; ????
     696:	00 00       	nop
     698:	b4 00       	.word	0x00b4	; ????
     69a:	00 00       	nop
     69c:	0a af       	std	Y+58, r16	; 0x3a
     69e:	07 00       	.word	0x0007	; ????
     6a0:	00 01       	movw	r0, r0
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);

   backlight();

}
     6a2:	0b f0       	brvs	.+2      	; 0x6a6 <_ZN3LCD5beginEhhh+0x11a>
     6a4:	05 00       	.word	0x0005	; ????
     6a6:	00 00       	nop
     6a8:	0c 59       	subi	r16, 0x9C	; 156

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
     6aa:	04 00       	.word	0x0004	; ????
    
    @param      0..255 - the value is very dependent on the LCD. However, 
    BACKLIGHT_OFF will be interpreted as off and BACKLIGHT_ON will drive the
    backlight on.
    */
   virtual void setBacklight ( uint8_t value ) { };
     6ac:	00 04       	cpc	r0, r0
    empty function call is provided that does nothing.
    
    @param      value: pin associated to backlight control.
    @param      pol: backlight polarity control (POSITIVE, NEGATIVE)
    */
   virtual void setBacklightPin ( uint8_t value, t_backlightPol pol ) { };
     6ae:	cb 01       	movw	r24, r22
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     6b0:	8b 05       	cpc	r24, r11
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     6b2:	00 00       	nop
     6b4:	03 01       	movw	r0, r6
     6b6:	ca 00       	.word	0x00ca	; ????
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     6b8:	00 00       	nop
     6ba:	db 00       	.word	0x00db	; ????
      return write((const uint8_t *)str, strlen(str));
     6bc:	00 00       	nop
     6be:	0a af       	std	Y+58, r16	; 0x3a
     6c0:	07 00       	.word	0x0007	; ????
     6c2:	00 01       	movw	r0, r0
     6c4:	0b e9       	ldi	r16, 0x9B	; 155
     6c6:	05 00       	.word	0x0005	; ????
     6c8:	00 0b       	sbc	r16, r16
     6ca:	51 01       	movw	r10, r2
     6cc:	00 00       	nop
     6ce:	00 09       	sbc	r16, r0
     6d0:	27 02       	muls	r18, r23
     6d2:	00 00       	nop
     6d4:	09 34       	cpi	r16, 0x49	; 73
    }
     6d6:	01 8b       	std	Z+17, r16	; 0x11
     6d8:	05 00       	.word	0x0005	; ????
     6da:	00 01       	movw	r0, r0
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
     6dc:	f0 00       	.word	0x00f0	; ????
     6de:	00 00       	nop
     6e0:	fc 00       	.word	0x00fc	; ????
     6e2:	00 00       	nop
     6e4:	0a af       	std	Y+58, r16	; 0x3a
     6e6:	07 00       	.word	0x0007	; ????
     6e8:	00 01       	movw	r0, r0
     6ea:	0b f0       	brvs	.+2      	; 0x6ee <_ZN5Print11printNumberEmh.constprop.33+0x12>
     6ec:	05 00       	.word	0x0005	; ????
     6ee:	00 00       	nop
     6f0:	0d 27       	eor	r16, r29
     6f2:	02 00       	.word	0x0002	; ????
     6f4:	00 04       	cpc	r0, r0
     6f6:	22 01       	movw	r4, r4
     6f8:	8b 05       	cpc	r24, r11
     6fa:	00 00       	nop
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     6fc:	01 02       	muls	r16, r17

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     6fe:	10 01       	movw	r2, r0
     700:	41 00       	.word	0x0041	; ????
     702:	00 00       	nop
     704:	01 15       	cp	r16, r1
     706:	01 00       	.word	0x0001	; ????
     708:	00 0a       	sbc	r0, r16

  do {
    char c = n % base;
     70a:	af 07       	cpc	r26, r31
     70c:	00 00       	nop
     70e:	01 0b       	sbc	r16, r17
     710:	65 0f       	add	r22, r21
     712:	00 00       	nop
     714:	0b 8b       	std	Y+19, r16	; 0x13
     716:	05 00       	.word	0x0005	; ????
     718:	00 00       	nop
     71a:	00 0e       	add	r0, r16
    n /= base;
     71c:	02 25       	eor	r16, r2
     71e:	00 00       	nop

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     720:	00 0f       	add	r16, r16
     722:	02 07       	cpc	r16, r18
     724:	28 06       	cpc	r2, r24
     726:	00 00       	nop
     728:	10 02       	muls	r17, r16
     72a:	08 00       	.word	0x0008	; ????
     72c:	00 02       	muls	r16, r16
     72e:	2d 01       	movw	r4, r26
     730:	00 00       	nop
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
     732:	08 c5       	rjmp	.+2576   	; 0x1144 <__data_load_end+0x3b8>
     734:	51 01       	movw	r10, r2
     736:	00 00       	nop
     738:	11 a6       	std	Z+41, r1	; 0x29
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
     73a:	02 00       	.word	0x0002	; ????
     73c:	00 00       	nop
     73e:	11 78       	andi	r17, 0x81	; 129
}
     740:	07 00       	.word	0x0007	; ????
     742:	00 01       	movw	r0, r0
     744:	00 12       	cpse	r0, r16
     746:	1a 03       	fmul	r17, r18
     748:	00 00       	nop
     74a:	0f 7e       	andi	r16, 0xEF	; 239
     74c:	5c 01       	movw	r10, r24
     74e:	00 00       	nop
     750:	0f 01       	movw	r0, r30
     752:	08 d3       	rcall	.+1552   	; 0xd64 <__data_load_start+0x1e>
     754:	04 00       	.word	0x0004	; ????
     756:	00 13       	cpse	r16, r16
     758:	4c 43       	sbci	r20, 0x3C	; 60
     75a:	44 00       	.word	0x0044	; ????
     75c:	0b 08       	sbc	r0, r11
     75e:	c7 25       	eor	r28, r7
     760:	03 00       	.word	0x0003	; ????
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     762:	00 25       	eor	r16, r0
     764:	03 00       	.word	0x0003	; ????
     766:	00 14       	cp	r0, r0
     768:	25 03       	mulsu	r18, r21
     76a:	00 00       	nop
     76c:	02 23       	and	r16, r18
     76e:	00 01       	movw	r0, r0
     770:	15 ec       	ldi	r17, 0xC5	; 197
     772:	02 00       	.word	0x0002	; ????
     774:	00 08       	sbc	r0, r0
     776:	21 02       	muls	r18, r17
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     778:	51 01       	movw	r10, r2
     77a:	00 00       	nop
     77c:	02 23       	and	r16, r18
     77e:	04 02       	muls	r16, r20
     780:	15 a0       	ldd	r1, Z+37	; 0x25
     782:	04 00       	.word	0x0004	; ????
     784:	00 08       	sbc	r0, r0
     786:	23 02       	muls	r18, r19
	unsigned char f = timer0_fract;
     788:	51 01       	movw	r10, r2
     78a:	00 00       	nop

	m += MILLIS_INC;
	f += FRACT_INC;
     78c:	02 23       	and	r16, r18
     78e:	05 02       	muls	r16, r21
	if (f >= FRACT_MAX) {
     790:	15 1a       	sub	r1, r21
     792:	02 00       	.word	0x0002	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     794:	00 08       	sbc	r0, r0
     796:	25 02       	muls	r18, r21
     798:	51 01       	movw	r10, r2
     79a:	00 00       	nop
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     79c:	02 23       	and	r16, r18
     79e:	06 02       	muls	r16, r22
		m += 1;
     7a0:	15 e2       	ldi	r17, 0x25	; 37
     7a2:	07 00       	.word	0x0007	; ????
     7a4:	00 08       	sbc	r0, r0
	}

	timer0_fract = f;
     7a6:	26 02       	muls	r18, r22
     7a8:	51 01       	movw	r10, r2
	timer0_millis = m;
     7aa:	00 00       	nop
     7ac:	02 23       	and	r16, r18
     7ae:	07 02       	muls	r16, r23
     7b0:	15 78       	andi	r17, 0x85	; 133
     7b2:	04 00       	.word	0x0004	; ????
     7b4:	00 08       	sbc	r0, r0
     7b6:	27 02       	muls	r18, r23
     7b8:	51 01       	movw	r10, r2
	timer0_overflow_count++;
     7ba:	00 00       	nop
     7bc:	02 23       	and	r16, r18
     7be:	08 02       	muls	r16, r24
     7c0:	15 11       	cpse	r17, r5
     7c2:	08 00       	.word	0x0008	; ????
     7c4:	00 08       	sbc	r0, r0
     7c6:	28 02       	muls	r18, r24
     7c8:	34 01       	movw	r6, r8
     7ca:	00 00       	nop
     7cc:	02 23       	and	r16, r18
     7ce:	09 02       	muls	r16, r25
     7d0:	16 ba       	out	0x16, r1	; 22
     7d2:	04 00       	.word	0x0004	; ????
     7d4:	00 07       	cpc	r16, r16
     7d6:	de 01       	movw	r26, r28
     7d8:	01 ed       	ldi	r16, 0xD1	; 209
     7da:	01 00       	.word	0x0001	; ????
     7dc:	00 f4       	brcc	.+0      	; 0x7de <__vector_16+0x7c>
     7de:	01 00       	.word	0x0001	; ????
}
     7e0:	00 0a       	sbc	r0, r16
     7e2:	36 07       	cpc	r19, r22
     7e4:	00 00       	nop
     7e6:	01 00       	.word	0x0001	; ????
     7e8:	17 ec       	ldi	r17, 0xC7	; 199
     7ea:	07 00       	.word	0x0007	; ????
     7ec:	00 07       	cpc	r16, r16
     7ee:	52 01       	movw	r10, r4
     7f0:	01 01       	movw	r0, r2
     7f2:	06 02       	muls	r16, r22
     7f4:	00 00       	nop
  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
     7f6:	0d 02       	muls	r16, r29
     7f8:	00 00       	nop
     7fa:	0a 36       	cpi	r16, 0x6A	; 106
     7fc:	07 00       	.word	0x0007	; ????
     7fe:	00 01       	movw	r0, r0
     800:	00 16       	cp	r0, r16
     802:	81 07       	cpc	r24, r17
     804:	00 00       	nop
     806:	07 c0       	rjmp	.+14     	; 0x816 <__vector_24+0x20>
     808:	01 01       	movw	r0, r2
     80a:	1e 02       	muls	r17, r30
     80c:	00 00       	nop
     80e:	2f 02       	muls	r18, r31
     810:	00 00       	nop
     812:	0a 36       	cpi	r16, 0x6A	; 106
     814:	07 00       	.word	0x0007	; ????
     816:	00 01       	movw	r0, r0
  switch(TW_STATUS){
     818:	0b 51       	subi	r16, 0x1B	; 27
     81a:	01 00       	.word	0x0001	; ????
     81c:	00 0b       	sbc	r16, r16
     81e:	51 01       	movw	r10, r2
     820:	00 00       	nop
     822:	00 16       	cp	r0, r16
     824:	c3 03       	fmuls	r20, r19
     826:	00 00       	nop
     828:	07 40       	sbci	r16, 0x07	; 7
     82a:	01 01       	movw	r0, r2
     82c:	40 02       	muls	r20, r16
     82e:	00 00       	nop
     830:	47 02       	muls	r20, r23
     832:	00 00       	nop
     834:	0a 36       	cpi	r16, 0x6A	; 106
     836:	07 00       	.word	0x0007	; ????
     838:	00 01       	movw	r0, r0
     83a:	00 18       	sub	r0, r0
     83c:	27 02       	muls	r18, r23
     83e:	00 00       	nop
     840:	07 7b       	andi	r16, 0xB7	; 183
     842:	01 01       	movw	r0, r2
     844:	8b 05       	cpc	r24, r11
     846:	00 00       	nop
     848:	01 02       	muls	r16, r17
     84a:	10 00       	.word	0x0010	; ????
     84c:	63 01       	movw	r12, r6
     84e:	00 00       	nop
     850:	01 65       	ori	r16, 0x51	; 81
     852:	02 00       	.word	0x0002	; ????
     854:	00 71       	andi	r16, 0x10	; 16
     856:	02 00       	.word	0x0002	; ????
     858:	00 0a       	sbc	r0, r16
     85a:	36 07       	cpc	r19, r22
     85c:	00 00       	nop
     85e:	01 0b       	sbc	r16, r17
     860:	51 01       	movw	r10, r2
     862:	00 00       	nop
     864:	00 19       	sub	r16, r0
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
     866:	e4 08       	sbc	r14, r4
     868:	00 00       	nop
     86a:	07 70       	andi	r16, 0x07	; 7
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     86c:	01 01       	movw	r0, r2
     86e:	03 01       	movw	r0, r6
     870:	84 02       	muls	r24, r20
     872:	00 00       	nop
     874:	90 02       	muls	r25, r16
     876:	00 00       	nop
     878:	0a 36       	cpi	r16, 0x6A	; 106
     87a:	07 00       	.word	0x0007	; ????
     87c:	00 01       	movw	r0, r0
     87e:	0b 51       	subi	r16, 0x1B	; 27
     880:	01 00       	.word	0x0001	; ????
     882:	00 00       	nop
     884:	16 f5       	brtc	.+68     	; 0x8ca <__vector_24+0xd4>
     886:	03 00       	.word	0x0003	; ????
     888:	00 07       	cpc	r16, r16
     88a:	b4 01       	movw	r22, r8
     88c:	01 a1       	ldd	r16, Z+33	; 0x21
     88e:	02 00       	.word	0x0002	; ????
     890:	00 a8       	ldd	r0, Z+48	; 0x30
     892:	02 00       	.word	0x0002	; ????
     894:	00 0a       	sbc	r0, r16
     896:	36 07       	cpc	r19, r22
     898:	00 00       	nop
     89a:	01 00       	.word	0x0001	; ????
     89c:	1a b7       	in	r17, 0x3a	; 58
     89e:	02 00       	.word	0x0002	; ????
     8a0:	00 07       	cpc	r16, r16
     8a2:	5b 01       	movw	r10, r22
     8a4:	01 02       	muls	r16, r17
     8a6:	10 04       	cpc	r1, r0
     8a8:	63 01       	movw	r12, r6
     8aa:	00 00       	nop
     8ac:	01 c1       	rjmp	.+514    	; 0xab0 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x66>
     8ae:	02 00       	.word	0x0002	; ????
     8b0:	00 d7       	rcall	.+3584   	; 0x16b2 <__data_load_end+0x926>
     8b2:	02 00       	.word	0x0002	; ????
     8b4:	00 0a       	sbc	r0, r16
     8b6:	36 07       	cpc	r19, r22
     8b8:	00 00       	nop
     8ba:	01 0b       	sbc	r16, r17
     8bc:	51 01       	movw	r10, r2
     8be:	00 00       	nop
     8c0:	0b 51       	subi	r16, 0x1B	; 27
     8c2:	01 00       	.word	0x0001	; ????
     8c4:	00 0b       	sbc	r16, r16
     8c6:	51 01       	movw	r10, r2
     8c8:	00 00       	nop
     8ca:	00 1b       	sub	r16, r16
     8cc:	57 06       	cpc	r5, r23
     8ce:	00 00       	nop
     8d0:	08 05       	cpc	r16, r8
     8d2:	02 01       	movw	r0, r4
     8d4:	01 02       	muls	r16, r17
     8d6:	10 06       	cpc	r1, r16
     8d8:	63 01       	movw	r12, r6
     8da:	00 00       	nop
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
     8dc:	01 f1       	breq	.+64     	; 0x91e <__stack+0x1f>
     8de:	02 00       	.word	0x0002	; ????
     8e0:	00 fd       	sbrc	r16, 0

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
     8e2:	02 00       	.word	0x0002	; ????
     8e4:	00 0a       	sbc	r0, r16
     8e6:	36 07       	cpc	r19, r22
     8e8:	00 00       	nop
     8ea:	01 0b       	sbc	r16, r17
     8ec:	51 01       	movw	r10, r2
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
     8ee:	00 00       	nop
     8f0:	00 1c       	adc	r0, r0
     8f2:	d4 08       	sbc	r13, r4
     8f4:	00 00       	nop
     8f6:	08 f2       	brcs	.-126    	; 0x87a <__vector_24+0x84>
     8f8:	01 01       	movw	r0, r2
     8fa:	01 02       	muls	r16, r17
     8fc:	10 05       	cpc	r17, r0
     8fe:	63 01       	movw	r12, r6
     900:	00 00       	nop
     902:	01 13       	cpse	r16, r17
     904:	03 00       	.word	0x0003	; ????
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     906:	00 0a       	sbc	r0, r16
     908:	36 07       	cpc	r19, r22
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
     90a:	00 00       	nop
     90c:	01 0b       	sbc	r16, r17
     90e:	51 01       	movw	r10, r2
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     910:	00 00       	nop
     912:	0b 34       	cpi	r16, 0x4B	; 75
     914:	01 00       	.word	0x0001	; ????
     916:	00 00       	nop
     918:	00 1d       	adc	r16, r0
     91a:	14 06       	cpc	r1, r20
     91c:	00 00       	nop
     91e:	01 8d       	ldd	r16, Z+25	; 0x19
     920:	03 00       	.word	0x0003	; ????
     922:	00 1a       	sub	r0, r16
     924:	34 02       	muls	r19, r20
     926:	00 00       	nop
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
     928:	09 5a       	subi	r16, 0xA9	; 169
     92a:	01 01       	movw	r0, r2
     92c:	02 10       	cpse	r0, r2
     92e:	03 25       	eor	r16, r3
     930:	03 00       	.word	0x0003	; ????
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     932:	00 01       	movw	r0, r0
     934:	48 03       	fmul	r20, r16
     936:	00 00       	nop
     938:	4f 03       	fmul	r20, r23
     93a:	00 00       	nop
     93c:	0a 97       	sbiw	r24, 0x0a	; 10
     93e:	18 00       	.word	0x0018	; ????
     940:	00 01       	movw	r0, r0
     942:	00 1e       	adc	r0, r16
     944:	e3 03       	fmuls	r22, r19
     946:	00 00       	nop
     948:	09 3f       	cpi	r16, 0xF9	; 249
	if (twi_sendStop)
     94a:	01 3a       	cpi	r16, 0xA1	; 161
     94c:	00 00       	nop
     94e:	00 01       	movw	r0, r0
     950:	02 10       	cpse	r0, r2
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
     952:	02 25       	eor	r16, r2
     954:	03 00       	.word	0x0003	; ????
     956:	00 01       	movw	r0, r0
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
     958:	6c 03       	fmul	r22, r20
     95a:	00 00       	nop
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
     95c:	73 03       	mulsu	r23, r19
     95e:	00 00       	nop
     960:	0a 97       	sbiw	r24, 0x0a	; 10
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
     962:	18 00       	.word	0x0018	; ????
     964:	00 01       	movw	r0, r0
     966:	00 1f       	adc	r16, r16
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     968:	01 c3       	rjmp	.+1538   	; 0xf6c <__data_load_end+0x1e0>
     96a:	03 00       	.word	0x0003	; ????
     96c:	00 09       	sbc	r16, r0
     96e:	2e 22       	and	r2, r30
     970:	03 00       	.word	0x0003	; ????
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
     972:	00 01       	movw	r0, r0
     974:	01 85       	ldd	r16, Z+9	; 0x09
     976:	03 00       	.word	0x0003	; ????
     978:	00 0a       	sbc	r0, r16
     97a:	97 18       	sub	r9, r7
     97c:	00 00       	nop
     97e:	01 00       	.word	0x0001	; ????
     980:	00 06       	cpc	r0, r16
     982:	a7 08       	sbc	r10, r7
     984:	00 00       	nop
     986:	17 0e       	add	r1, r23
     988:	38 85       	ldd	r19, Y+8	; 0x08
     98a:	05 00       	.word	0x0005	; ????
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
     98c:	00 68       	ori	r16, 0x80	; 128
     98e:	05 00       	.word	0x0005	; ????
     990:	00 14       	cp	r0, r0

  // update twi state
  twi_state = TWI_READY;
     992:	68 05       	cpc	r22, r8
     994:	00 00       	nop
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     996:	02 23       	and	r16, r18
     998:	00 01       	movw	r0, r0
     99a:	08 ac       	ldd	r0, Y+56	; 0x38
     99c:	06 00       	.word	0x0006	; ????
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
     99e:	00 0e       	add	r0, r16
     9a0:	b5 51       	subi	r27, 0x15	; 21
     9a2:	01 00       	.word	0x0001	; ????
     9a4:	00 02       	muls	r16, r16
     9a6:	23 0b       	sbc	r18, r19
     9a8:	03 08       	sbc	r0, r3
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
     9aa:	76 06       	cpc	r7, r22
     9ac:	00 00       	nop
     9ae:	0e b6       	in	r0, 0x3e	; 62
     9b0:	51 01       	movw	r10, r2
     9b2:	00 00       	nop
     9b4:	02 23       	and	r16, r18
     9b6:	0c 03       	fmul	r16, r20
     9b8:	08 94       	sec
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
     9ba:	07 00       	.word	0x0007	; ????
     9bc:	00 0e       	add	r0, r16
     9be:	b7 51       	subi	r27, 0x17	; 23
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
     9c0:	01 00       	.word	0x0001	; ????
     9c2:	00 02       	muls	r16, r16
     9c4:	23 0d       	add	r18, r3
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
     9c6:	03 08       	sbc	r0, r3
     9c8:	8b 02       	muls	r24, r27
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
     9ca:	00 00       	nop
     9cc:	0e b8       	out	0x0e, r0	; 14
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
     9ce:	6e 05       	cpc	r22, r14
     9d0:	00 00       	nop
     9d2:	02 23       	and	r16, r18
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
     9d4:	0e 03       	fmul	r16, r22
     9d6:	08 c4       	rjmp	.+2064   	; 0x11e8 <__data_load_end+0x45c>
     9d8:	06 00       	.word	0x0006	; ????
     9da:	00 0e       	add	r0, r16
        twi_txBufferLength = 1;
     9dc:	b9 51       	subi	r27, 0x19	; 25
     9de:	01 00       	.word	0x0001	; ????
     9e0:	00 02       	muls	r16, r16
        twi_txBuffer[0] = 0x00;
     9e2:	23 16       	cp	r2, r19
     9e4:	03 20       	and	r0, r3
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
     9e6:	7e 04       	cpc	r7, r14
     9e8:	00 00       	nop
     9ea:	01 01       	movw	r0, r2
     9ec:	02 10       	cpse	r0, r2
     9ee:	07 8d       	ldd	r16, Z+31	; 0x1f
     9f0:	03 00       	.word	0x0003	; ????
     9f2:	00 01       	movw	r0, r0
     9f4:	01 09       	sbc	r16, r1
     9f6:	04 00       	.word	0x0004	; ????
     9f8:	00 15       	cp	r16, r0
     9fa:	04 00       	.word	0x0004	; ????
     9fc:	00 0a       	sbc	r0, r16
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
     9fe:	73 07       	cpc	r23, r19
     a00:	00 00       	nop
     a02:	01 0b       	sbc	r16, r17
     a04:	51 01       	movw	r10, r2
     a06:	00 00       	nop
     a08:	00 19       	sub	r16, r0
     a0a:	90 06       	cpc	r9, r16
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
     a0c:	00 00       	nop
     a0e:	02 3a       	cpi	r16, 0xA2	; 162
     a10:	01 01       	movw	r0, r2
     a12:	03 01       	movw	r0, r6
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     a14:	28 04       	cpc	r2, r8
     a16:	00 00       	nop
     a18:	2f 04       	cpc	r2, r15
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
     a1a:	00 00       	nop
     a1c:	0a 73       	andi	r16, 0x3A	; 58
     a1e:	07 00       	.word	0x0007	; ????

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
     a20:	00 01       	movw	r0, r0
     a22:	00 19       	sub	r16, r0
      twi_stop();
     a24:	98 03       	fmulsu	r17, r16
     a26:	00 00       	nop
      break;
  }
}
     a28:	02 45       	sbci	r16, 0x52	; 82
     a2a:	01 01       	movw	r0, r2
     a2c:	03 01       	movw	r0, r6
     a2e:	42 04       	cpc	r4, r2
     a30:	00 00       	nop
     a32:	53 04       	cpc	r5, r3
     a34:	00 00       	nop
     a36:	0a 73       	andi	r16, 0x3A	; 58
     a38:	07 00       	.word	0x0007	; ????
     a3a:	00 01       	movw	r0, r0
     a3c:	0b 51       	subi	r16, 0x1B	; 27
     a3e:	01 00       	.word	0x0001	; ????
     a40:	00 0b       	sbc	r16, r16
     a42:	51 01       	movw	r10, r2
     a44:	00 00       	nop
     a46:	00 21       	and	r16, r0
     a48:	7e 06       	cpc	r7, r30
     a4a:	00 00       	nop
     a4c:	02 f1       	brmi	.+64     	; 0xa8e <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x44>
     a4e:	01 03       	mulsu	r16, r17
     a50:	01 65       	ori	r16, 0x51	; 81
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     a52:	04 00       	.word	0x0004	; ????
     a54:	00 a8       	ldd	r0, Z+48	; 0x30
     a56:	04 00       	.word	0x0004	; ????
     a58:	00 0a       	sbc	r0, r16
     a5a:	73 07       	cpc	r23, r19
     a5c:	00 00       	nop
     a5e:	01 0b       	sbc	r16, r17
     a60:	51 01       	movw	r10, r2
     a62:	00 00       	nop
     a64:	0b 51       	subi	r16, 0x1B	; 27
     a66:	01 00       	.word	0x0001	; ????
     a68:	00 0b       	sbc	r16, r16
     a6a:	51 01       	movw	r10, r2
     a6c:	00 00       	nop
     a6e:	0b 51       	subi	r16, 0x1B	; 27
     a70:	01 00       	.word	0x0001	; ????
void (*TwoWire::user_onRequest)(void);
void (*TwoWire::user_onReceive)(int);

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire()
     a72:	00 0b       	sbc	r16, r16
     a74:	51 01       	movw	r10, r2
     a76:	00 00       	nop
     a78:	0b 51       	subi	r16, 0x1B	; 27
     a7a:	01 00       	.word	0x0001	; ????
     a7c:	00 0b       	sbc	r16, r16
     a7e:	51 01       	movw	r10, r2
     a80:	00 00       	nop
     a82:	0b 51       	subi	r16, 0x1B	; 27
     a84:	01 00       	.word	0x0001	; ????
// CONSTRUCTORS
// ---------------------------------------------------------------------------

LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
                             uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
                             uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
     a86:	00 0b       	sbc	r16, r16
     a88:	51 01       	movw	r10, r2
     a8a:	00 00       	nop
     a8c:	0b 51       	subi	r16, 0x1B	; 27
     a8e:	01 00       	.word	0x0001	; ????
     a90:	00 0b       	sbc	r16, r16
   uint8_t i;
   
   // Initialize the IO pins
   // -----------------------
   
   _rs_pin = rs;
     a92:	51 01       	movw	r10, r2
     a94:	00 00       	nop
     a96:	0b 51       	subi	r16, 0x1B	; 27
   _rw_pin = rw;
     a98:	01 00       	.word	0x0001	; ????
     a9a:	00 00       	nop
     a9c:	16 c3       	rjmp	.+1580   	; 0x10ca <__data_load_end+0x33e>
   _enable_pin = enable;
     a9e:	03 00       	.word	0x0003	; ????
     aa0:	00 02       	muls	r16, r16
     aa2:	43 01       	movw	r8, r6
   
   _data_pins[0] = d0;
     aa4:	01 b9       	out	0x01, r16	; 1
     aa6:	04 00       	.word	0x0004	; ????
     aa8:	00 f2       	brcs	.-128    	; 0xa2a <__stack+0x12b>
   _data_pins[1] = d1;
     aaa:	04 00       	.word	0x0004	; ????
     aac:	00 0a       	sbc	r0, r16
     aae:	73 07       	cpc	r23, r19
   _data_pins[2] = d2;
     ab0:	00 00       	nop
     ab2:	01 0b       	sbc	r16, r17
     ab4:	51 01       	movw	r10, r2
   _data_pins[3] = d3; 
     ab6:	00 00       	nop
     ab8:	0b 51       	subi	r16, 0x1B	; 27
     aba:	01 00       	.word	0x0001	; ????
   _data_pins[4] = d4;
     abc:	00 0b       	sbc	r16, r16
     abe:	51 01       	movw	r10, r2
     ac0:	00 00       	nop
   _data_pins[5] = d5;
     ac2:	0b 51       	subi	r16, 0x1B	; 27
     ac4:	01 00       	.word	0x0001	; ????
     ac6:	00 0b       	sbc	r16, r16
   _data_pins[6] = d6;
     ac8:	51 01       	movw	r10, r2
     aca:	00 00       	nop
     acc:	0b 51       	subi	r16, 0x1B	; 27
   _data_pins[7] = d7;
     ace:	01 00       	.word	0x0001	; ????
     ad0:	00 0b       	sbc	r16, r16
     ad2:	51 01       	movw	r10, r2
     ad4:	00 00       	nop
     ad6:	0b 51       	subi	r16, 0x1B	; 27
     ad8:	01 00       	.word	0x0001	; ????
     ada:	00 0b       	sbc	r16, r16
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
   {
      pinMode ( _data_pins[i], OUTPUT );
     adc:	51 01       	movw	r10, r2
     ade:	00 00       	nop
     ae0:	0b 51       	subi	r16, 0x1B	; 27
     ae2:	01 00       	.word	0x0001	; ????
     ae4:	00 00       	nop
   _data_pins[7] = d7;
   
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
     ae6:	1a 57       	subi	r17, 0x7A	; 122
     ae8:	06 00       	.word	0x0006	; ????
     aea:	00 02       	muls	r16, r16
     aec:	bd 01       	movw	r22, r26
     aee:	01 02       	muls	r16, r17
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
      {
         pinMode ( _data_pins[i], OUTPUT );
     af0:	10 06       	cpc	r1, r16
     af2:	8d 03       	fmulsu	r16, r21
     af4:	00 00       	nop
   // Initialize the rest of the ports if it is an 8bit controlled LCD
   // ----------------------------------------------------------------
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
     af6:	01 0b       	sbc	r16, r17
     af8:	05 00       	.word	0x0005	; ????
     afa:	00 17       	cp	r16, r16
      {
         pinMode ( _data_pins[i], OUTPUT );
      }
   }
   pinMode(_rs_pin, OUTPUT);
     afc:	05 00       	.word	0x0005	; ????
     afe:	00 0a       	sbc	r0, r16
     b00:	73 07       	cpc	r23, r19
     b02:	00 00       	nop
   
   // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
   if (_rw_pin != 255) 
     b04:	01 0b       	sbc	r16, r17
     b06:	51 01       	movw	r10, r2
     b08:	00 00       	nop
     b0a:	00 1a       	sub	r0, r16
   { 
      pinMode(_rw_pin, OUTPUT);
     b0c:	d4 08       	sbc	r13, r4
     b0e:	00 00       	nop
   }
   
   pinMode(_enable_pin, OUTPUT);
     b10:	02 a7       	std	Z+42, r16	; 0x2a
     b12:	01 01       	movw	r0, r2
     b14:	02 10       	cpse	r0, r2
     b16:	05 8d       	ldd	r16, Z+29	; 0x1d
   // Initialise displaymode functions to defaults: LCD_1LINE and LCD_5x8DOTS
   // -------------------------------------------------------------------------
   if (fourbitmode)
      _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
   else 
      _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
     b18:	03 00       	.word	0x0003	; ????
     b1a:	00 01       	movw	r0, r0
     b1c:	30 05       	cpc	r19, r0
   
   // Now we pull both RS and R/W low to begin commands
   digitalWrite(_rs_pin, LOW);
     b1e:	00 00       	nop
     b20:	41 05       	cpc	r20, r1
     b22:	00 00       	nop
     b24:	0a 73       	andi	r16, 0x3A	; 58
     b26:	07 00       	.word	0x0007	; ????
   digitalWrite(_enable_pin, LOW);
     b28:	00 01       	movw	r0, r0
     b2a:	0b 51       	subi	r16, 0x1B	; 27
     b2c:	01 00       	.word	0x0001	; ????
     b2e:	00 0b       	sbc	r16, r16
     b30:	34 01       	movw	r6, r8
   
   if (_rw_pin != 255) 
     b32:	00 00       	nop
     b34:	00 22       	and	r0, r16
     b36:	3a 02       	muls	r19, r26
     b38:	00 00       	nop
   { 
      digitalWrite(_rw_pin, LOW);
     b3a:	02 86       	std	Z+10, r0	; 0x0a
     b3c:	01 01       	movw	r0, r2
     b3e:	02 10       	cpse	r0, r2
   }
   
   // Initialise the backlight pin no nothing
   _backlightPin = LCD_NOBACKLIGHT;
     b40:	07 8d       	ldd	r16, Z+31	; 0x1f
     b42:	03 00       	.word	0x0003	; ????
     b44:	00 01       	movw	r0, r0
   _polarity = POSITIVE;
     b46:	56 05       	cpc	r21, r6
     b48:	00 00       	nop
     b4a:	0a 73       	andi	r16, 0x3A	; 58
     b4c:	07 00       	.word	0x0007	; ????
     b4e:	00 01       	movw	r0, r0
     b50:	0b 51       	subi	r16, 0x1B	; 27
     b52:	01 00       	.word	0x0001	; ????
     b54:	00 0b       	sbc	r16, r16
     b56:	51 01       	movw	r10, r2

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     b58:	00 00       	nop
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     b5a:	00 00       	nop
     b5c:	23 4c       	sbci	r18, 0xC3	; 195
     b5e:	43 44       	sbci	r20, 0x43	; 67
	sbi(TCCR0A, WGM00);
     b60:	00 01       	movw	r0, r0
     b62:	24 51       	subi	r18, 0x14	; 20
     b64:	01 00       	.word	0x0001	; ????
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     b66:	00 7e       	andi	r16, 0xE0	; 224
     b68:	05 00       	.word	0x0005	; ????
     b6a:	00 25       	eor	r16, r0
	sbi(TCCR0B, CS00);
     b6c:	7e 05       	cpc	r23, r14
     b6e:	00 00       	nop
     b70:	07 00       	.word	0x0007	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     b72:	0f 02       	muls	r16, r31
     b74:	07 9d       	mul	r16, r7
     b76:	02 00       	.word	0x0002	; ????
     b78:	00 26       	eor	r0, r16
     b7a:	14 06       	cpc	r1, r20
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     b7c:	00 00       	nop
     b7e:	01 12       	cpse	r0, r17

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     b80:	96 02       	muls	r25, r22
     b82:	00 00       	nop
     b84:	10 d8       	rcall	.-4064   	; 0xfffffba6 <__eeprom_end+0xff7efba6>
     b86:	2d 01       	movw	r4, r26
     b88:	00 00       	nop
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     b8a:	0f 01       	movw	r0, r30
     b8c:	06 dc       	rcall	.-2036   	; 0x39a <twi_transmit+0x18>
     b8e:	04 00       	.word	0x0004	; ????
     b90:	00 06       	cpc	r0, r16
     b92:	4a 06       	cpc	r4, r26
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     b94:	00 00       	nop
     b96:	0c 0b       	sbc	r16, r28
     b98:	31 25       	eor	r19, r1
     b9a:	03 00       	.word	0x0003	; ????
     b9c:	00 e9       	ldi	r16, 0x90	; 144

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     b9e:	05 00       	.word	0x0005	; ????
     ba0:	00 14       	cp	r0, r0
     ba2:	25 03       	mulsu	r18, r21
     ba4:	00 00       	nop
     ba6:	02 23       	and	r16, r18

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     ba8:	00 01       	movw	r0, r0
     baa:	08 8b       	std	Y+16, r16	; 0x10
     bac:	07 00       	.word	0x0007	; ????
     bae:	00 0b       	sbc	r16, r16
     bb0:	34 e9       	ldi	r19, 0x94	; 148
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     bb2:	05 00       	.word	0x0005	; ????
     bb4:	00 02       	muls	r16, r16
     bb6:	23 04       	cpc	r2, r3
     bb8:	02 08       	sbc	r0, r2
     bba:	3a 08       	sbc	r3, r10
		sbi(ADCSRA, ADPS1);
     bbc:	00 00       	nop
     bbe:	0b 35       	cpi	r16, 0x5B	; 91
     bc0:	e9 05       	cpc	r30, r9
     bc2:	00 00       	nop
     bc4:	02 23       	and	r16, r18
		sbi(ADCSRA, ADPS0);
     bc6:	08 02       	muls	r16, r24
     bc8:	27 c3       	rjmp	.+1614   	; 0x1218 <__data_load_end+0x48c>
     bca:	03 00       	.word	0x0003	; ????
     bcc:	00 0b       	sbc	r16, r16
     bce:	3f 01       	movw	r6, r30
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     bd0:	01 e1       	ldi	r16, 0x11	; 17
     bd2:	05 00       	.word	0x0005	; ????
     bd4:	00 0a       	sbc	r0, r16
     bd6:	47 0a       	sbc	r4, r23
     bd8:	00 00       	nop
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     bda:	01 00       	.word	0x0001	; ????
     bdc:	00 0f       	add	r16, r16
// ----------

void setup()
{
  // some displays need time to initialize
  delay(1000);
     bde:	04 07       	cpc	r16, r20
     be0:	23 06       	cpc	r2, r19
     be2:	00 00       	nop
     be4:	0e 02       	muls	r16, r30
     be6:	f6 05       	cpc	r31, r6
     be8:	00 00       	nop
  // initialize LCD and set up the number of columns and rows
  lcd.begin(16, 2);
     bea:	28 96       	adiw	r28, 0x08	; 8
     bec:	05 00       	.word	0x0005	; ????
     bee:	00 06       	cpc	r0, r16
     bf0:	9a 08       	sbc	r9, r10
     bf2:	00 00       	nop
     bf4:	0c 11       	cpse	r16, r12
     bf6:	21 25       	eor	r18, r1
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     bf8:	03 00       	.word	0x0003	; ????

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     bfa:	00 0e       	add	r0, r16
	m = timer0_millis;
     bfc:	07 00       	.word	0x0007	; ????
     bfe:	00 14       	cp	r0, r0
     c00:	9d 05       	cpc	r25, r13
     c02:	00 00       	nop
     c04:	02 23       	and	r16, r18
     c06:	00 01       	movw	r0, r0
     c08:	16 c3       	rjmp	.+1580   	; 0x1236 <__data_load_end+0x4aa>
     c0a:	03 00       	.word	0x0003	; ????
	SREG = oldSREG;
     c0c:	00 06       	cpc	r0, r16

  _startTime_ms = millis();
     c0e:	31 01       	movw	r6, r2
     c10:	01 25       	eor	r16, r1
     c12:	06 00       	.word	0x0006	; ????
     c14:	00 2c       	mov	r0, r0
     c16:	06 00       	.word	0x0006	; ????
     c18:	00 0a       	sbc	r0, r16
     c1a:	6b 0a       	sbc	r6, r27
     c1c:	00 00       	nop
	

#endif

	// busy wait
	__asm__ __volatile__ (
     c1e:	01 00       	.word	0x0001	; ????
     c20:	1b 34       	cpi	r17, 0x4B	; 75
     c22:	02 00       	.word	0x0002	; ????
     c24:	00 06       	cpc	r0, r16
}

void loop() 
{
  if (0 == _loopCounter--) {
     c26:	0f 01       	movw	r0, r30
     c28:	01 01       	movw	r0, r2
     c2a:	02 10       	cpse	r0, r2
     c2c:	03 fb       	bst	r16, 3
     c2e:	05 00       	.word	0x0005	; ????
     c30:	00 01       	movw	r0, r0
     c32:	46 06       	cpc	r4, r22
     c34:	00 00       	nop
     c36:	4d 06       	cpc	r4, r29
     c38:	00 00       	nop
     c3a:	0a 6b       	ori	r16, 0xBA	; 186
     c3c:	0a 00       	.word	0x000a	; ????
     c3e:	00 01       	movw	r0, r0
     c40:	00 18       	sub	r0, r0
     c42:	d0 03       	fmuls	r21, r16
     c44:	00 00       	nop
     c46:	06 04       	cpc	r0, r6
     c48:	01 01       	movw	r0, r2
     c4a:	3a 00       	.word	0x003a	; ????
     c4c:	00 00       	nop
     c4e:	01 02       	muls	r16, r17
     c50:	10 06       	cpc	r1, r16
     c52:	fb 05       	cpc	r31, r11
     c54:	00 00       	nop
     c56:	01 6b       	ori	r16, 0xB1	; 177
     c58:	06 00       	.word	0x0006	; ????
     c5a:	00 72       	andi	r16, 0x20	; 32
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     c5c:	06 00       	.word	0x0006	; ????

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     c5e:	00 0a       	sbc	r0, r16
	m = timer0_millis;
     c60:	6b 0a       	sbc	r6, r27
     c62:	00 00       	nop
     c64:	01 00       	.word	0x0001	; ????
     c66:	1e 7f       	andi	r17, 0xFE	; 254
     c68:	03 00       	.word	0x0003	; ????
     c6a:	00 06       	cpc	r0, r16
     c6c:	f4 01       	movw	r30, r8
     c6e:	3a 00       	.word	0x003a	; ????
	SREG = oldSREG;
     c70:	00 00       	nop

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
     c72:	01 02       	muls	r16, r17
     c74:	10 05       	cpc	r17, r0
     c76:	fb 05       	cpc	r31, r11
     c78:	00 00       	nop
     c7a:	01 8f       	std	Z+25, r16	; 0x19
	

#endif

	// busy wait
	__asm__ __volatile__ (
     c7c:	06 00       	.word	0x0006	; ????
     c7e:	00 96       	adiw	r24, 0x00	; 0
     c80:	06 00       	.word	0x0006	; ????
    // 3000000 loops in 6225 [ms]
    unsigned long endTime_ms = millis();
  
    lcd.clear();
    lcd.setCursor(0, 0);
     c82:	00 0a       	sbc	r0, r16
     c84:	6b 0a       	sbc	r6, r27
     c86:	00 00       	nop
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     c88:	01 00       	.word	0x0001	; ????
     c8a:	1e b0       	in	r1, 0x0e	; 14
     c8c:	04 00       	.word	0x0004	; ????
     c8e:	00 06       	cpc	r0, r16
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     c90:	ec 01       	movw	r28, r24
     c92:	3a 00       	.word	0x003a	; ????
     c94:	00 00       	nop
     c96:	01 02       	muls	r16, r17
     c98:	10 04       	cpc	r1, r0
     c9a:	fb 05       	cpc	r31, r11
     c9c:	00 00       	nop
    lcd.print("Loops: ");
    lcd.print(C_LOOP_COUNT);
  
    lcd.setCursor(0, 1);
     c9e:	01 b3       	in	r16, 0x11	; 17
     ca0:	06 00       	.word	0x0006	; ????
     ca2:	00 ba       	out	0x10, r0	; 16
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     ca4:	06 00       	.word	0x0006	; ????
     ca6:	00 0a       	sbc	r0, r16
     ca8:	6b 0a       	sbc	r6, r27
     caa:	00 00       	nop
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     cac:	01 00       	.word	0x0001	; ????
     cae:	1e 27       	eor	r17, r30
     cb0:	02 00       	.word	0x0002	; ????
     cb2:	00 06       	cpc	r0, r16
     cb4:	da 01       	movw	r26, r20
     cb6:	8b 05       	cpc	r24, r11
     cb8:	00 00       	nop
     cba:	01 02       	muls	r16, r17
     cbc:	10 01       	movw	r2, r0
     cbe:	fb 05       	cpc	r31, r11
     cc0:	00 00       	nop
     cc2:	01 d7       	rcall	.+3586   	; 0x1ac6 <__data_load_end+0xd3a>
     cc4:	06 00       	.word	0x0006	; ????
     cc6:	00 e8       	ldi	r16, 0x80	; 128
     cc8:	06 00       	.word	0x0006	; ????
     cca:	00 0a       	sbc	r0, r16
     ccc:	6b 0a       	sbc	r6, r27
     cce:	00 00       	nop
     cd0:	01 0b       	sbc	r16, r17
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     cd2:	65 0f       	add	r22, r21
     cd4:	00 00       	nop
     cd6:	0b 8b       	std	Y+19, r16	; 0x13
     cd8:	05 00       	.word	0x0005	; ????
     cda:	00 00       	nop
     cdc:	0d 27       	eor	r16, r29
     cde:	02 00       	.word	0x0002	; ????
     ce0:	00 06       	cpc	r0, r16
     ce2:	c1 01       	movw	r24, r2
     ce4:	8b 05       	cpc	r24, r11
     ce6:	00 00       	nop
     ce8:	01 02       	muls	r16, r17
     cea:	10 00       	.word	0x0010	; ????
     cec:	fb 05       	cpc	r31, r11
     cee:	00 00       	nop
     cf0:	01 01       	movw	r0, r2
     cf2:	07 00       	.word	0x0007	; ????
     cf4:	00 0a       	sbc	r0, r16
     cf6:	6b 0a       	sbc	r6, r27
     cf8:	00 00       	nop
     cfa:	01 0b       	sbc	r16, r17
     cfc:	51 01       	movw	r10, r2
     cfe:	00 00       	nop
     d00:	00 00       	nop
     d02:	12 05       	cpc	r17, r2
     d04:	06 00       	.word	0x0006	; ????
     d06:	00 0f       	add	r16, r16
     d08:	80 2d       	mov	r24, r0
     d0a:	01 00       	.word	0x0001	; ????
     d0c:	00 12       	cpse	r0, r16
     d0e:	4c 04       	cpc	r4, r12
     d10:	00 00       	nop
     d12:	12 7e       	andi	r17, 0xE2	; 226
     d14:	51 01       	movw	r10, r2
     d16:	00 00       	nop
     d18:	12 fc       	sbrc	r1, 2
     d1a:	05 00       	.word	0x0005	; ????
     d1c:	00 0f       	add	r16, r16
     d1e:	82 e9       	ldi	r24, 0x92	; 146
     d20:	05 00       	.word	0x0005	; ????
     d22:	00 0f       	add	r16, r16
     d24:	01 02       	muls	r16, r17
     d26:	4c 03       	fmul	r20, r20
     d28:	00 00       	nop
     d2a:	0e 02       	muls	r16, r30
     d2c:	63 01       	movw	r12, r6
     d2e:	00 00       	nop
     d30:	29 dc       	rcall	.-1966   	; 0x584 <_ZN3LCD9setCursorEhh.constprop.36+0x7c>
     d32:	01 00       	.word	0x0001	; ????
     d34:	00 01       	movw	r0, r0
     d36:	4a 07       	cpc	r20, r26
     d38:	00 00       	nop
     d3a:	55 07       	cpc	r21, r21
     d3c:	00 00       	nop
     d3e:	2a bf       	out	0x3a, r18	; 58
     d40:	06 00       	.word	0x0006	; ????
     d42:	00 55       	subi	r16, 0x50	; 80
     d44:	07 00       	.word	0x0007	; ????
     d46:	00 01       	movw	r0, r0
     d48:	00 28       	or	r0, r0
     d4a:	36 07       	cpc	r19, r22
     d4c:	00 00       	nop
     d4e:	29 f4       	brne	.+10     	; 0xd5a <__data_load_start+0x14>
     d50:	01 00       	.word	0x0001	; ????
     d52:	00 01       	movw	r0, r0
     d54:	68 07       	cpc	r22, r24
     d56:	00 00       	nop
     d58:	73 07       	cpc	r23, r19
     d5a:	00 00       	nop
     d5c:	2a bf       	out	0x3a, r18	; 58
     d5e:	06 00       	.word	0x0006	; ????
     d60:	00 55       	subi	r16, 0x50	; 80
     d62:	07 00       	.word	0x0007	; ????
     d64:	00 01       	movw	r0, r0
     d66:	00 0e       	add	r0, r16
     d68:	02 8d       	ldd	r16, Z+26	; 0x1a
     d6a:	03 00       	.word	0x0003	; ????
     d6c:	00 2b       	or	r16, r16
     d6e:	f1 03       	fmuls	r23, r17
     d70:	00 00       	nop
     d72:	02 86       	std	Z+10, r0	; 0x0a
     d74:	01 89       	ldd	r16, Z+17	; 0x11
     d76:	07 00       	.word	0x0007	; ????
     d78:	00 aa       	std	Z+48, r0	; 0x30
     d7a:	07 00       	.word	0x0007	; ????
     d7c:	00 2a       	or	r0, r16
     d7e:	bf 06       	cpc	r11, r31
     d80:	00 00       	nop
     d82:	aa 07       	cpc	r26, r26
     d84:	00 00       	nop
     d86:	01 2c       	mov	r0, r1
     d88:	e6 02       	muls	r30, r22
     d8a:	00 00       	nop
     d8c:	02 86       	std	Z+10, r0	; 0x0a
     d8e:	51 01       	movw	r10, r2
     d90:	00 00       	nop
     d92:	2d 02       	muls	r18, r29
     d94:	04 00       	.word	0x0004	; ????
     d96:	00 02       	muls	r16, r16
     d98:	86 51       	subi	r24, 0x16	; 22
     d9a:	01 00       	.word	0x0001	; ????
     d9c:	00 00       	nop
     d9e:	28 73       	andi	r18, 0x38	; 56
     da0:	07 00       	.word	0x0007	; ????
     da2:	00 0e       	add	r0, r16
     da4:	02 41       	sbci	r16, 0x12	; 18
     da6:	00 00       	nop
     da8:	00 29       	or	r16, r0
     daa:	6d 00       	.word	0x006d	; ????
     dac:	00 00       	nop
     dae:	01 c3       	rjmp	.+1538   	; 0x13b2 <__data_load_end+0x626>
     db0:	07 00       	.word	0x0007	; ????
     db2:	00 e2       	ldi	r16, 0x20	; 32
     db4:	07 00       	.word	0x0007	; ????
     db6:	00 2a       	or	r0, r16
     db8:	bf 06       	cpc	r11, r31
     dba:	00 00       	nop
     dbc:	e2 07       	cpc	r30, r18
     dbe:	00 00       	nop
     dc0:	01 2e       	mov	r0, r17
     dc2:	6e 00       	.word	0x006e	; ????
     dc4:	04 67       	ori	r16, 0x74	; 116
     dc6:	e9 05       	cpc	r30, r9
     dc8:	00 00       	nop
     dca:	2c a2       	std	Y+36, r2	; 0x24
     dcc:	08 00       	.word	0x0008	; ????
     dce:	00 04       	cpc	r0, r0
     dd0:	67 3a       	cpi	r22, 0xA7	; 167
     dd2:	00 00       	nop
     dd4:	00 00       	nop
     dd6:	28 af       	std	Y+56, r18	; 0x38
     dd8:	07 00       	.word	0x0007	; ????
     dda:	00 29       	or	r16, r0
     ddc:	93 00       	.word	0x0093	; ????
     dde:	00 00       	nop
     de0:	01 f5       	brne	.+64     	; 0xe22 <__data_load_end+0x96>
     de2:	07 00       	.word	0x0007	; ????
     de4:	00 0b       	sbc	r16, r16
     de6:	08 00       	.word	0x0008	; ????
     de8:	00 2a       	or	r0, r16
     dea:	bf 06       	cpc	r11, r31
     dec:	00 00       	nop
     dee:	e2 07       	cpc	r30, r18
     df0:	00 00       	nop
     df2:	01 2e       	mov	r0, r17
     df4:	73 74       	andi	r23, 0x43	; 67
     df6:	72 00       	.word	0x0072	; ????
     df8:	04 3e       	cpi	r16, 0xE4	; 228
     dfa:	f0 05       	cpc	r31, r0
     dfc:	00 00       	nop
     dfe:	00 29       	or	r16, r0
     e00:	15 04       	cpc	r1, r5
     e02:	00 00       	nop
     e04:	01 19       	sub	r16, r1
     e06:	08 00       	.word	0x0008	; ????
     e08:	00 24       	eor	r0, r0
     e0a:	08 00       	.word	0x0008	; ????
     e0c:	00 2a       	or	r0, r16
     e0e:	bf 06       	cpc	r11, r31
     e10:	00 00       	nop
     e12:	aa 07       	cpc	r26, r26
     e14:	00 00       	nop
     e16:	01 00       	.word	0x0001	; ????
     e18:	29 2f       	mov	r18, r25
     e1a:	04 00       	.word	0x0004	; ????
     e1c:	00 01       	movw	r0, r0
     e1e:	32 08       	sbc	r3, r2
     e20:	00 00       	nop
     e22:	61 08       	sbc	r6, r1
     e24:	00 00       	nop
     e26:	2a bf       	out	0x3a, r18	; 58
     e28:	06 00       	.word	0x0006	; ????
     e2a:	00 aa       	std	Z+48, r0	; 0x30
     e2c:	07 00       	.word	0x0007	; ????
     e2e:	00 01       	movw	r0, r0
     e30:	2f e6       	ldi	r18, 0x6F	; 111
     e32:	02 00       	.word	0x0002	; ????
     e34:	00 02       	muls	r16, r16
     e36:	45 01       	movw	r8, r10
     e38:	51 01       	movw	r10, r2
     e3a:	00 00       	nop
     e3c:	2f 08       	sbc	r2, r15
     e3e:	02 00       	.word	0x0002	; ????
     e40:	00 02       	muls	r16, r16
     e42:	45 01       	movw	r8, r10
     e44:	51 01       	movw	r10, r2
     e46:	00 00       	nop
     e48:	30 31       	cpi	r19, 0x10	; 16
     e4a:	69 00       	.word	0x0069	; ????
     e4c:	02 47       	sbci	r16, 0x72	; 114
     e4e:	01 51       	subi	r16, 0x11	; 17
     e50:	01 00       	.word	0x0001	; ????
     e52:	00 00       	nop
     e54:	00 29       	or	r16, r0
     e56:	b4 00       	.word	0x00b4	; ????
     e58:	00 00       	nop
     e5a:	01 6f       	ori	r16, 0xF1	; 241
     e5c:	08 00       	.word	0x0008	; ????
     e5e:	00 af       	std	Z+56, r16	; 0x38
     e60:	08 00       	.word	0x0008	; ????
     e62:	00 2a       	or	r0, r16
     e64:	bf 06       	cpc	r11, r31
     e66:	00 00       	nop
     e68:	e2 07       	cpc	r30, r18
     e6a:	00 00       	nop
     e6c:	01 2e       	mov	r0, r17
     e6e:	6e 00       	.word	0x006e	; ????
     e70:	04 cb       	rjmp	.-2552   	; 0x47a <_ZN13LiquidCrystal15setBacklightPinEh14t_backlightPol+0x2c>
     e72:	e9 05       	cpc	r30, r9
     e74:	00 00       	nop
     e76:	2c a2       	std	Y+36, r2	; 0x24
     e78:	08 00       	.word	0x0008	; ????
     e7a:	00 04       	cpc	r0, r0
     e7c:	cb 51       	subi	r28, 0x1B	; 27
     e7e:	01 00       	.word	0x0001	; ????
     e80:	00 32       	cpi	r16, 0x20	; 32
     e82:	62 75       	andi	r22, 0x52	; 82
     e84:	66 00       	.word	0x0066	; ????
     e86:	04 cd       	rjmp	.-1528   	; 0x890 <__vector_24+0x9a>
     e88:	af 08       	sbc	r10, r15
     e8a:	00 00       	nop
     e8c:	32 73       	andi	r19, 0x32	; 50
     e8e:	74 72       	andi	r23, 0x24	; 36
     e90:	00 04       	cpc	r0, r0
     e92:	ce bf       	out	0x3e, r28	; 62
     e94:	08 00       	.word	0x0008	; ????
     e96:	00 30       	cpi	r16, 0x00	; 0
     e98:	32 63       	ori	r19, 0x32	; 50
     e9a:	00 04       	cpc	r0, r0
     e9c:	d6 96       	adiw	r26, 0x36	; 54
     e9e:	05 00       	.word	0x0005	; ????
     ea0:	00 00       	nop
     ea2:	00 24       	eor	r0, r0
     ea4:	96 05       	cpc	r25, r6
     ea6:	00 00       	nop
     ea8:	bf 08       	sbc	r11, r15
     eaa:	00 00       	nop
     eac:	25 7e       	andi	r18, 0xE5	; 229
     eae:	05 00       	.word	0x0005	; ????
     eb0:	00 20       	and	r0, r0
     eb2:	00 0e       	add	r0, r16
     eb4:	02 96       	adiw	r24, 0x02	; 2
     eb6:	05 00       	.word	0x0005	; ????
     eb8:	00 29       	or	r16, r0
     eba:	db 00       	.word	0x00db	; ????
     ebc:	00 00       	nop
     ebe:	03 d3       	rcall	.+1542   	; 0x14c6 <__data_load_end+0x73a>
     ec0:	08 00       	.word	0x0008	; ????
     ec2:	00 e9       	ldi	r16, 0x90	; 144
     ec4:	08 00       	.word	0x0008	; ????
     ec6:	00 2a       	or	r0, r16
     ec8:	bf 06       	cpc	r11, r31
     eca:	00 00       	nop
     ecc:	e2 07       	cpc	r30, r18
     ece:	00 00       	nop
     ed0:	01 2e       	mov	r0, r17
     ed2:	73 74       	andi	r23, 0x43	; 67
     ed4:	72 00       	.word	0x0072	; ????
     ed6:	09 34       	cpi	r16, 0x49	; 73
     ed8:	f0 05       	cpc	r31, r0
     eda:	00 00       	nop
     edc:	00 29       	or	r16, r0
     ede:	0d 02       	muls	r16, r29
     ee0:	00 00       	nop
     ee2:	01 f7       	brne	.-64     	; 0xea4 <__data_load_end+0x118>
     ee4:	08 00       	.word	0x0008	; ????
     ee6:	00 2e       	mov	r0, r16
     ee8:	09 00       	.word	0x0009	; ????
     eea:	00 2a       	or	r0, r16
     eec:	bf 06       	cpc	r11, r31
     eee:	00 00       	nop
     ef0:	55 07       	cpc	r21, r21
     ef2:	00 00       	nop
     ef4:	01 2e       	mov	r0, r17
     ef6:	63 6f       	ori	r22, 0xF3	; 243
     ef8:	6c 00       	.word	0x006c	; ????
     efa:	07 c0       	rjmp	.+14     	; 0xf0a <__data_load_end+0x17e>
     efc:	51 01       	movw	r10, r2
     efe:	00 00       	nop
     f00:	2e 72       	andi	r18, 0x2E	; 46
     f02:	6f 77       	andi	r22, 0x7F	; 127
     f04:	00 07       	cpc	r16, r16
     f06:	c0 51       	subi	r28, 0x10	; 16
     f08:	01 00       	.word	0x0001	; ????
     f0a:	00 2d       	mov	r16, r0
     f0c:	60 08       	sbc	r6, r0
     f0e:	00 00       	nop
     f10:	07 c2       	rjmp	.+1038   	; 0x1320 <__data_load_end+0x594>
     f12:	43 09       	sbc	r20, r3
     f14:	00 00       	nop
     f16:	2d 3b       	cpi	r18, 0xBD	; 189
     f18:	04 00       	.word	0x0004	; ????
     f1a:	00 07       	cpc	r16, r16
     f1c:	c3 48       	sbci	r28, 0x83	; 131
     f1e:	09 00       	.word	0x0009	; ????
     f20:	00 00       	nop
     f22:	24 3e       	cpi	r18, 0xE4	; 228
     f24:	09 00       	.word	0x0009	; ????
     f26:	00 3e       	cpi	r16, 0xE0	; 224
     f28:	09 00       	.word	0x0009	; ????
     f2a:	00 25       	eor	r16, r0
     f2c:	7e 05       	cpc	r23, r14
     f2e:	00 00       	nop
     f30:	03 00       	.word	0x0003	; ????
     f32:	28 19       	sub	r18, r8
     f34:	07 00       	.word	0x0007	; ????
     f36:	00 28       	or	r0, r0
     f38:	2e 09       	sbc	r18, r14
     f3a:	00 00       	nop
     f3c:	28 2e       	mov	r2, r24
     f3e:	09 00       	.word	0x0009	; ????
     f40:	00 33       	cpi	r16, 0x30	; 48
     f42:	a3 03       	fmuls	r18, r19
     f44:	00 00       	nop
     f46:	01 1d       	adc	r16, r1
     f48:	01 01       	movw	r0, r2
     f4a:	3c 0a       	sbc	r3, r28
     f4c:	00 00       	nop
     f4e:	2e 70       	andi	r18, 0x0E	; 14
     f50:	69 6e       	ori	r22, 0xE9	; 233
     f52:	00 01       	movw	r0, r0
     f54:	1d 51       	subi	r17, 0x1D	; 29
     f56:	01 00       	.word	0x0001	; ????
     f58:	00 2c       	mov	r0, r0
     f5a:	02 04       	cpc	r0, r2
     f5c:	00 00       	nop
     f5e:	01 1d       	adc	r16, r1
     f60:	51 01       	movw	r10, r2
     f62:	00 00       	nop
     f64:	32 62       	ori	r19, 0x22	; 34
     f66:	69 74       	andi	r22, 0x49	; 73
     f68:	00 01       	movw	r0, r0
     f6a:	1f 51       	subi	r17, 0x1F	; 31
     f6c:	01 00       	.word	0x0001	; ????
     f6e:	00 2d       	mov	r16, r0
     f70:	44 07       	cpc	r20, r20
     f72:	00 00       	nop
     f74:	01 20       	and	r0, r1
     f76:	51 01       	movw	r10, r2
     f78:	00 00       	nop
     f7a:	32 72       	andi	r19, 0x22	; 34
     f7c:	65 67       	ori	r22, 0x75	; 117
     f7e:	00 01       	movw	r0, r0
     f80:	21 3c       	cpi	r18, 0xC1	; 193
     f82:	0a 00       	.word	0x000a	; ????
     f84:	00 32       	cpi	r16, 0x20	; 32
     f86:	6f 75       	andi	r22, 0x5F	; 95
     f88:	74 00       	.word	0x0074	; ????
     f8a:	01 21       	and	r16, r1
     f8c:	3c 0a       	sbc	r3, r28
     f8e:	00 00       	nop
     f90:	34 ad       	ldd	r19, Z+60	; 0x3c
     f92:	09 00       	.word	0x0009	; ????
     f94:	00 2d       	mov	r16, r0
     f96:	51 04       	cpc	r5, r1
     f98:	00 00       	nop
     f9a:	01 36       	cpi	r16, 0x61	; 97
     f9c:	51 01       	movw	r10, r2
     f9e:	00 00       	nop
     fa0:	00 34       	cpi	r16, 0x40	; 64
     fa2:	be 09       	sbc	r27, r14
     fa4:	00 00       	nop
     fa6:	2d 51       	subi	r18, 0x1D	; 29
     fa8:	04 00       	.word	0x0004	; ????
     faa:	00 01       	movw	r0, r0
     fac:	30 51       	subi	r19, 0x10	; 16
     fae:	01 00       	.word	0x0001	; ????
     fb0:	00 00       	nop
     fb2:	34 cf       	rjmp	.-408    	; 0xe1c <__data_load_end+0x90>
     fb4:	09 00       	.word	0x0009	; ????
     fb6:	00 2d       	mov	r16, r0
     fb8:	51 04       	cpc	r5, r1
     fba:	00 00       	nop
     fbc:	01 2a       	or	r0, r17
     fbe:	51 01       	movw	r10, r2
     fc0:	00 00       	nop
     fc2:	00 34       	cpi	r16, 0x40	; 64
     fc4:	eb 09       	sbc	r30, r11
     fc6:	00 00       	nop
     fc8:	2d 64       	ori	r18, 0x4D	; 77
     fca:	03 00       	.word	0x0003	; ????
     fcc:	00 01       	movw	r0, r0
     fce:	27 0e       	add	r2, r23
     fd0:	07 00       	.word	0x0007	; ????
     fd2:	00 2d       	mov	r16, r0
     fd4:	1a 06       	cpc	r1, r26
     fd6:	00 00       	nop
     fd8:	01 27       	eor	r16, r17
     fda:	0e 07       	cpc	r16, r30
     fdc:	00 00       	nop
     fde:	00 34       	cpi	r16, 0x40	; 64
     fe0:	07 0a       	sbc	r0, r23
     fe2:	00 00       	nop
     fe4:	2d 64       	ori	r18, 0x4D	; 77
     fe6:	03 00       	.word	0x0003	; ????
     fe8:	00 01       	movw	r0, r0
     fea:	26 0e       	add	r2, r22
     fec:	07 00       	.word	0x0007	; ????
     fee:	00 2d       	mov	r16, r0
     ff0:	1a 06       	cpc	r1, r26
     ff2:	00 00       	nop
     ff4:	01 26       	eor	r0, r17
     ff6:	0e 07       	cpc	r16, r30
     ff8:	00 00       	nop
     ffa:	00 34       	cpi	r16, 0x40	; 64
     ffc:	23 0a       	sbc	r2, r19
     ffe:	00 00       	nop
    1000:	2d 64       	ori	r18, 0x4D	; 77
    1002:	03 00       	.word	0x0003	; ????
    1004:	00 01       	movw	r0, r0
    1006:	20 0e       	add	r2, r16
    1008:	07 00       	.word	0x0007	; ????
    100a:	00 2d       	mov	r16, r0
    100c:	1a 06       	cpc	r1, r26
    100e:	00 00       	nop
    1010:	01 20       	and	r0, r1
    1012:	51 01       	movw	r10, r2
    1014:	00 00       	nop
    1016:	00 30       	cpi	r16, 0x00	; 0
    1018:	2d 64       	ori	r18, 0x4D	; 77
    101a:	03 00       	.word	0x0003	; ????
    101c:	00 01       	movw	r0, r0
    101e:	1f 0e       	add	r1, r31
    1020:	07 00       	.word	0x0007	; ????
    1022:	00 2d       	mov	r16, r0
    1024:	1a 06       	cpc	r1, r26
    1026:	00 00       	nop
    1028:	01 1f       	adc	r16, r17
    102a:	51 01       	movw	r10, r2
    102c:	00 00       	nop
    102e:	00 00       	nop
    1030:	0e 02       	muls	r16, r30
    1032:	42 0a       	sbc	r4, r18
    1034:	00 00       	nop
    1036:	35 51       	subi	r19, 0x15	; 21
    1038:	01 00       	.word	0x0001	; ????
    103a:	00 0e       	add	r0, r16
    103c:	02 9d       	mul	r16, r2
    103e:	05 00       	.word	0x0005	; ????
    1040:	00 29       	or	r16, r0
    1042:	d4 05       	cpc	r29, r4
    1044:	00 00       	nop
    1046:	03 5b       	subi	r16, 0xB3	; 179
    1048:	0a 00       	.word	0x000a	; ????
    104a:	00 66       	ori	r16, 0x60	; 96
    104c:	0a 00       	.word	0x000a	; ????
    104e:	00 2a       	or	r0, r16
    1050:	bf 06       	cpc	r11, r31
    1052:	00 00       	nop
    1054:	66 0a       	sbc	r6, r22
    1056:	00 00       	nop
    1058:	01 00       	.word	0x0001	; ????
    105a:	28 47       	sbci	r18, 0x78	; 120
    105c:	0a 00       	.word	0x000a	; ????
    105e:	00 0e       	add	r0, r16
    1060:	02 fb       	bst	r16, 2
    1062:	05 00       	.word	0x0005	; ????
    1064:	00 29       	or	r16, r0
    1066:	14 06       	cpc	r1, r20
    1068:	00 00       	nop
    106a:	01 7f       	andi	r16, 0xF1	; 241
    106c:	0a 00       	.word	0x000a	; ????
    106e:	00 8a       	std	Z+16, r0	; 0x10
    1070:	0a 00       	.word	0x000a	; ????
    1072:	00 2a       	or	r0, r16
    1074:	bf 06       	cpc	r11, r31
    1076:	00 00       	nop
    1078:	8a 0a       	sbc	r8, r26
    107a:	00 00       	nop
    107c:	01 00       	.word	0x0001	; ????
    107e:	28 6b       	ori	r18, 0xB8	; 184
    1080:	0a 00       	.word	0x000a	; ????
    1082:	00 29       	or	r16, r0
    1084:	53 04       	cpc	r5, r3
    1086:	00 00       	nop
    1088:	01 9d       	mul	r16, r1
    108a:	0a 00       	.word	0x000a	; ????
    108c:	00 2b       	or	r16, r16
    108e:	0b 00       	.word	0x000b	; ????
    1090:	00 2a       	or	r0, r16
    1092:	bf 06       	cpc	r11, r31
    1094:	00 00       	nop
    1096:	aa 07       	cpc	r26, r26
    1098:	00 00       	nop
    109a:	01 2c       	mov	r0, r1
    109c:	fb 03       	fmulsu	r23, r19
    109e:	00 00       	nop
    10a0:	02 f1       	brmi	.+64     	; 0x10e2 <__data_load_end+0x356>
    10a2:	51 01       	movw	r10, r2
    10a4:	00 00       	nop
    10a6:	2e 72       	andi	r18, 0x2E	; 46
    10a8:	73 00       	.word	0x0073	; ????
    10aa:	02 f1       	brmi	.+64     	; 0x10ec <__data_load_end+0x360>
    10ac:	51 01       	movw	r10, r2
    10ae:	00 00       	nop
    10b0:	2e 72       	andi	r18, 0x2E	; 46
    10b2:	77 00       	.word	0x0077	; ????
    10b4:	02 f1       	brmi	.+64     	; 0x10f6 <__data_load_end+0x36a>
    10b6:	51 01       	movw	r10, r2
    10b8:	00 00       	nop
    10ba:	2c 2d       	mov	r18, r12
    10bc:	02 00       	.word	0x0002	; ????
    10be:	00 02       	muls	r16, r16
    10c0:	f1 51       	subi	r31, 0x11	; 17
    10c2:	01 00       	.word	0x0001	; ????
    10c4:	00 2e       	mov	r0, r16
    10c6:	64 30       	cpi	r22, 0x04	; 4
    10c8:	00 02       	muls	r16, r16
    10ca:	f2 51       	subi	r31, 0x12	; 18
    10cc:	01 00       	.word	0x0001	; ????
    10ce:	00 2e       	mov	r0, r16
    10d0:	64 31       	cpi	r22, 0x14	; 20
    10d2:	00 02       	muls	r16, r16
    10d4:	f2 51       	subi	r31, 0x12	; 18
    10d6:	01 00       	.word	0x0001	; ????
    10d8:	00 2e       	mov	r0, r16
    10da:	64 32       	cpi	r22, 0x24	; 36
    10dc:	00 02       	muls	r16, r16
    10de:	f2 51       	subi	r31, 0x12	; 18
    10e0:	01 00       	.word	0x0001	; ????
    10e2:	00 2e       	mov	r0, r16
    10e4:	64 33       	cpi	r22, 0x34	; 52
    10e6:	00 02       	muls	r16, r16
    10e8:	f2 51       	subi	r31, 0x12	; 18
    10ea:	01 00       	.word	0x0001	; ????
    10ec:	00 2e       	mov	r0, r16
    10ee:	64 34       	cpi	r22, 0x44	; 68
    10f0:	00 02       	muls	r16, r16
    10f2:	f3 51       	subi	r31, 0x13	; 19
    10f4:	01 00       	.word	0x0001	; ????
    10f6:	00 2e       	mov	r0, r16
    10f8:	64 35       	cpi	r22, 0x54	; 84
    10fa:	00 02       	muls	r16, r16
    10fc:	f3 51       	subi	r31, 0x13	; 19
    10fe:	01 00       	.word	0x0001	; ????
    1100:	00 2e       	mov	r0, r16
    1102:	64 36       	cpi	r22, 0x64	; 100
    1104:	00 02       	muls	r16, r16
    1106:	f3 51       	subi	r31, 0x13	; 19
    1108:	01 00       	.word	0x0001	; ????
    110a:	00 2e       	mov	r0, r16
    110c:	64 37       	cpi	r22, 0x74	; 116
    110e:	00 02       	muls	r16, r16
    1110:	f3 51       	subi	r31, 0x13	; 19
    1112:	01 00       	.word	0x0001	; ????
    1114:	00 32       	cpi	r16, 0x20	; 32
    1116:	69 00       	.word	0x0069	; ????
    1118:	02 f5       	brpl	.+64     	; 0x115a <__data_load_end+0x3ce>
    111a:	51 01       	movw	r10, r2
    111c:	00 00       	nop
    111e:	00 29       	or	r16, r0
    1120:	2f 02       	muls	r18, r31
    1122:	00 00       	nop
    1124:	01 39       	cpi	r16, 0x91	; 145
    1126:	0b 00       	.word	0x000b	; ????
    1128:	00 44       	sbci	r16, 0x40	; 64
    112a:	0b 00       	.word	0x000b	; ????
    112c:	00 2a       	or	r0, r16
    112e:	bf 06       	cpc	r11, r31
    1130:	00 00       	nop
    1132:	55 07       	cpc	r21, r21
    1134:	00 00       	nop
    1136:	01 00       	.word	0x0001	; ????
    1138:	29 a8       	ldd	r2, Y+49	; 0x31
    113a:	04 00       	.word	0x0004	; ????
    113c:	00 01       	movw	r0, r0
    113e:	52 0b       	sbc	r21, r18
    1140:	00 00       	nop
    1142:	c2 0b       	sbc	r28, r18
    1144:	00 00       	nop
    1146:	2a bf       	out	0x3a, r18	; 58
    1148:	06 00       	.word	0x0006	; ????
    114a:	00 aa       	std	Z+48, r0	; 0x30
    114c:	07 00       	.word	0x0007	; ????
    114e:	00 01       	movw	r0, r0
    1150:	2e 72       	andi	r18, 0x2E	; 46
    1152:	73 00       	.word	0x0073	; ????
    1154:	02 43       	sbci	r16, 0x32	; 50
    1156:	51 01       	movw	r10, r2
    1158:	00 00       	nop
    115a:	2c 2d       	mov	r18, r12
    115c:	02 00       	.word	0x0002	; ????
    115e:	00 02       	muls	r16, r16
    1160:	43 51       	subi	r20, 0x13	; 19
    1162:	01 00       	.word	0x0001	; ????
    1164:	00 2e       	mov	r0, r16
    1166:	64 30       	cpi	r22, 0x04	; 4
    1168:	00 02       	muls	r16, r16
    116a:	44 51       	subi	r20, 0x14	; 20
    116c:	01 00       	.word	0x0001	; ????
    116e:	00 2e       	mov	r0, r16
    1170:	64 31       	cpi	r22, 0x14	; 20
    1172:	00 02       	muls	r16, r16
    1174:	44 51       	subi	r20, 0x14	; 20
    1176:	01 00       	.word	0x0001	; ????
    1178:	00 2e       	mov	r0, r16
    117a:	64 32       	cpi	r22, 0x24	; 36
    117c:	00 02       	muls	r16, r16
    117e:	44 51       	subi	r20, 0x14	; 20
    1180:	01 00       	.word	0x0001	; ????
    1182:	00 2e       	mov	r0, r16
    1184:	64 33       	cpi	r22, 0x34	; 52
    1186:	00 02       	muls	r16, r16
    1188:	44 51       	subi	r20, 0x14	; 20
    118a:	01 00       	.word	0x0001	; ????
    118c:	00 2e       	mov	r0, r16
    118e:	64 34       	cpi	r22, 0x44	; 68
    1190:	00 02       	muls	r16, r16
    1192:	45 51       	subi	r20, 0x15	; 21
    1194:	01 00       	.word	0x0001	; ????
    1196:	00 2e       	mov	r0, r16
    1198:	64 35       	cpi	r22, 0x54	; 84
    119a:	00 02       	muls	r16, r16
    119c:	45 51       	subi	r20, 0x15	; 21
    119e:	01 00       	.word	0x0001	; ????
    11a0:	00 2e       	mov	r0, r16
    11a2:	64 36       	cpi	r22, 0x64	; 100
    11a4:	00 02       	muls	r16, r16
    11a6:	45 51       	subi	r20, 0x15	; 21
    11a8:	01 00       	.word	0x0001	; ????
    11aa:	00 2e       	mov	r0, r16
    11ac:	64 37       	cpi	r22, 0x74	; 116
    11ae:	00 02       	muls	r16, r16
    11b0:	45 51       	subi	r20, 0x15	; 21
    11b2:	01 00       	.word	0x0001	; ????
    11b4:	00 00       	nop
    11b6:	36 0d       	add	r19, r6
    11b8:	07 00       	.word	0x0007	; ????
    11ba:	00 01       	movw	r0, r0
    11bc:	01 01       	movw	r0, r2
    11be:	e5 0b       	sbc	r30, r21
    11c0:	00 00       	nop
    11c2:	2c eb       	ldi	r18, 0xBC	; 188
    11c4:	04 00       	.word	0x0004	; ????
    11c6:	00 0d       	add	r16, r0
    11c8:	2a 3a       	cpi	r18, 0xAA	; 170
    11ca:	00 00       	nop
    11cc:	00 2c       	mov	r0, r0
    11ce:	b4 06       	cpc	r11, r20
    11d0:	00 00       	nop
    11d2:	0d 2a       	or	r0, r29
    11d4:	3a 00       	.word	0x003a	; ????
    11d6:	00 00       	nop
    11d8:	00 37       	cpi	r16, 0x70	; 112
    11da:	4d 09       	sbc	r20, r13
    11dc:	00 00       	nop
    11de:	0e 01       	movw	r0, r28
    11e0:	00 00       	nop
    11e2:	4c 01       	movw	r8, r24
    11e4:	00 00       	nop
    11e6:	03 92       	.word	0x9203	; ????
    11e8:	20 02       	muls	r18, r16
    11ea:	01 b6       	in	r0, 0x31	; 49
    11ec:	0c 00       	.word	0x000c	; ????
    11ee:	00 38       	cpi	r16, 0x80	; 128
    11f0:	5a 09       	sbc	r21, r10
    11f2:	00 00       	nop
    11f4:	00 00       	nop
    11f6:	00 00       	nop
    11f8:	39 70       	andi	r19, 0x09	; 9
    11fa:	09 00       	.word	0x0009	; ????
    11fc:	00 01       	movw	r0, r0
    11fe:	62 3a       	cpi	r22, 0xA2	; 162
    1200:	7b 09       	sbc	r23, r11
    1202:	00 00       	nop
    1204:	21 00       	.word	0x0021	; ????
    1206:	00 00       	nop
    1208:	3a 86       	std	Y+10, r3	; 0x0a
    120a:	09 00       	.word	0x0009	; ????
    120c:	00 34       	cpi	r16, 0x40	; 64
    120e:	00 00       	nop
    1210:	00 3b       	cpi	r16, 0xB0	; 176
    1212:	91 09       	sbc	r25, r1
    1214:	00 00       	nop
    1216:	3c 65       	ori	r19, 0x5C	; 92
    1218:	09 00       	.word	0x0009	; ????
    121a:	00 01       	movw	r0, r0
    121c:	3d 0e       	add	r3, r29
    121e:	01 00       	.word	0x0001	; ????
    1220:	00 18       	sub	r0, r0
    1222:	01 00       	.word	0x0001	; ????
    1224:	00 46       	sbci	r16, 0x60	; 96
    1226:	0c 00       	.word	0x000c	; ????
    1228:	00 3a       	cpi	r16, 0xA0	; 160
    122a:	24 0a       	sbc	r2, r20
    122c:	00 00       	nop
    122e:	4c 00       	.word	0x004c	; ????
    1230:	00 00       	nop
    1232:	39 2f       	mov	r19, r25
    1234:	0a 00       	.word	0x000a	; ????
    1236:	00 01       	movw	r0, r0
    1238:	62 00       	.word	0x0062	; ????
    123a:	3d 18       	sub	r3, r13
    123c:	01 00       	.word	0x0001	; ????
    123e:	00 20       	and	r0, r0
    1240:	01 00       	.word	0x0001	; ????
    1242:	00 66       	ori	r16, 0x60	; 96
    1244:	0c 00       	.word	0x000c	; ????
    1246:	00 3a       	cpi	r16, 0xA0	; 160
    1248:	0c 0a       	sbc	r0, r28
    124a:	00 00       	nop
    124c:	a3 00       	.word	0x00a3	; ????
    124e:	00 00       	nop
    1250:	3a 17       	cp	r19, r26
    1252:	0a 00       	.word	0x000a	; ????
    1254:	00 21       	and	r16, r0
    1256:	00 00       	nop
    1258:	00 00       	nop
    125a:	3d 24       	eor	r3, r13
    125c:	01 00       	.word	0x0001	; ????
    125e:	00 34       	cpi	r16, 0x40	; 64
    1260:	01 00       	.word	0x0001	; ????
    1262:	00 86       	std	Z+8, r0	; 0x08
    1264:	0c 00       	.word	0x000c	; ????
    1266:	00 3a       	cpi	r16, 0xA0	; 160
    1268:	f0 09       	sbc	r31, r0
    126a:	00 00       	nop
    126c:	ce 00       	.word	0x00ce	; ????
    126e:	00 00       	nop
    1270:	3a fb       	.word	0xfb3a	; ????
    1272:	09 00       	.word	0x0009	; ????
    1274:	00 34       	cpi	r16, 0x40	; 64
    1276:	00 00       	nop
    1278:	00 00       	nop
    127a:	3d 34       	cpi	r19, 0x4D	; 77
    127c:	01 00       	.word	0x0001	; ????
    127e:	00 3e       	cpi	r16, 0xE0	; 224
    1280:	01 00       	.word	0x0001	; ????
    1282:	00 a2       	std	Z+32, r0	; 0x20
    1284:	0c 00       	.word	0x000c	; ????
    1286:	00 3a       	cpi	r16, 0xA0	; 160
    1288:	d4 09       	sbc	r29, r4
    128a:	00 00       	nop
    128c:	e6 00       	.word	0x00e6	; ????
    128e:	00 00       	nop
    1290:	3b df       	rcall	.-394    	; 0x1108 <__data_load_end+0x37c>
    1292:	09 00       	.word	0x0009	; ????
    1294:	00 00       	nop
    1296:	3e 3e       	cpi	r19, 0xEE	; 238
    1298:	01 00       	.word	0x0001	; ????
    129a:	00 4c       	sbci	r16, 0xC0	; 192
    129c:	01 00       	.word	0x0001	; ????
    129e:	00 3a       	cpi	r16, 0xA0	; 160
    12a0:	a1 09       	sbc	r26, r1
    12a2:	00 00       	nop
    12a4:	fe 00       	.word	0x00fe	; ????
    12a6:	00 00       	nop
    12a8:	00 00       	nop
    12aa:	33 74       	andi	r19, 0x43	; 67
    12ac:	03 00       	.word	0x0003	; ????
    12ae:	00 01       	movw	r0, r0
    12b0:	4b 01       	movw	r8, r22
    12b2:	01 cf       	rjmp	.-510    	; 0x10b6 <__data_load_end+0x32a>
    12b4:	0c 00       	.word	0x000c	; ????
    12b6:	00 2c       	mov	r0, r0
    12b8:	51 06       	cpc	r5, r17
    12ba:	00 00       	nop
    12bc:	01 4b       	sbci	r16, 0xB1	; 177
    12be:	51 01       	movw	r10, r2
    12c0:	00 00       	nop
    12c2:	00 36       	cpi	r16, 0x60	; 96
    12c4:	56 07       	cpc	r21, r22
    12c6:	00 00       	nop
    12c8:	01 01       	movw	r0, r2
    12ca:	01 e7       	ldi	r16, 0x71	; 113
    12cc:	0c 00       	.word	0x000c	; ????
    12ce:	00 2d       	mov	r16, r0
    12d0:	51 06       	cpc	r5, r17
    12d2:	00 00       	nop
    12d4:	01 4b       	sbci	r16, 0xB1	; 177
    12d6:	51 01       	movw	r10, r2
    12d8:	00 00       	nop
    12da:	00 3f       	cpi	r16, 0xF0	; 240
    12dc:	37 07       	cpc	r19, r23
    12de:	00 00       	nop
    12e0:	01 8a       	std	Z+17, r0	; 0x11
    12e2:	01 4c       	sbci	r16, 0xC1	; 193
    12e4:	01 00       	.word	0x0001	; ????
    12e6:	00 e6       	ldi	r16, 0x60	; 96
    12e8:	01 00       	.word	0x0001	; ????
    12ea:	00 03       	mulsu	r16, r16
    12ec:	92 20       	and	r9, r2
    12ee:	02 01       	movw	r0, r4
    12f0:	3c 0e       	add	r3, r28
    12f2:	00 00       	nop
    12f4:	40 70       	andi	r20, 0x00	; 0
    12f6:	69 6e       	ori	r22, 0xE9	; 233
    12f8:	00 01       	movw	r0, r0
    12fa:	8a 51       	subi	r24, 0x1A	; 26
    12fc:	01 00       	.word	0x0001	; ????
    12fe:	00 11       	cpse	r16, r0
    1300:	01 00       	.word	0x0001	; ????
    1302:	00 41       	sbci	r16, 0x10	; 16
    1304:	76 61       	ori	r23, 0x16	; 22
    1306:	6c 00       	.word	0x006c	; ????
    1308:	01 8a       	std	Z+17, r0	; 0x11
    130a:	51 01       	movw	r10, r2
    130c:	00 00       	nop
    130e:	01 66       	ori	r16, 0x61	; 97
    1310:	42 51       	subi	r20, 0x12	; 18
    1312:	06 00       	.word	0x0006	; ????
    1314:	00 01       	movw	r0, r0
    1316:	8c 51       	subi	r24, 0x1C	; 28
    1318:	01 00       	.word	0x0001	; ????
    131a:	00 01       	movw	r0, r0
    131c:	62 43       	sbci	r22, 0x32	; 50
    131e:	62 69       	ori	r22, 0x92	; 146
    1320:	74 00       	.word	0x0074	; ????
    1322:	01 8d       	ldd	r16, Z+25	; 0x19
    1324:	51 01       	movw	r10, r2
    1326:	00 00       	nop
    1328:	af 01       	movw	r20, r30
    132a:	00 00       	nop
    132c:	44 44       	sbci	r20, 0x44	; 68
    132e:	07 00       	.word	0x0007	; ????
    1330:	00 01       	movw	r0, r0
    1332:	8e 51       	subi	r24, 0x1E	; 30
    1334:	01 00       	.word	0x0001	; ????
    1336:	00 db       	rcall	.-2560   	; 0x938 <__stack+0x39>
    1338:	01 00       	.word	0x0001	; ????
    133a:	00 43       	sbci	r16, 0x30	; 48
    133c:	6f 75       	andi	r22, 0x5F	; 95
    133e:	74 00       	.word	0x0074	; ????
    1340:	01 8f       	std	Z+25, r16	; 0x19
    1342:	3c 0a       	sbc	r3, r28
    1344:	00 00       	nop
    1346:	ee 01       	movw	r28, r28
    1348:	00 00       	nop
    134a:	44 51       	subi	r20, 0x14	; 20
    134c:	04 00       	.word	0x0004	; ????
    134e:	00 01       	movw	r0, r0
    1350:	99 51       	subi	r25, 0x19	; 25
    1352:	01 00       	.word	0x0001	; ????
    1354:	00 06       	cpc	r0, r16
    1356:	02 00       	.word	0x0002	; ????
    1358:	00 3d       	cpi	r16, 0xD0	; 208
    135a:	4c 01       	movw	r8, r24
    135c:	00 00       	nop
    135e:	56 01       	movw	r10, r12
    1360:	00 00       	nop
    1362:	8f 0d       	add	r24, r15
    1364:	00 00       	nop
    1366:	44 64       	ori	r20, 0x44	; 68
    1368:	03 00       	.word	0x0003	; ????
    136a:	00 01       	movw	r0, r0
    136c:	8c 0e       	add	r8, r28
    136e:	07 00       	.word	0x0007	; ????
    1370:	00 19       	sub	r16, r0
    1372:	02 00       	.word	0x0002	; ????
    1374:	00 42       	sbci	r16, 0x20	; 32
    1376:	1a 06       	cpc	r1, r26
    1378:	00 00       	nop
    137a:	01 8c       	ldd	r0, Z+25	; 0x19
    137c:	51 01       	movw	r10, r2
    137e:	00 00       	nop
    1380:	01 62       	ori	r16, 0x21	; 33
    1382:	00 3d       	cpi	r16, 0xD0	; 208
    1384:	56 01       	movw	r10, r12
    1386:	00 00       	nop
    1388:	5e 01       	movw	r10, r28
    138a:	00 00       	nop
    138c:	bb 0d       	add	r27, r11
    138e:	00 00       	nop
    1390:	44 64       	ori	r20, 0x44	; 68
    1392:	03 00       	.word	0x0003	; ????
    1394:	00 01       	movw	r0, r0
    1396:	8d 0e       	add	r8, r29
    1398:	07 00       	.word	0x0007	; ????
    139a:	00 b6       	in	r0, 0x30	; 48
    139c:	02 00       	.word	0x0002	; ????
    139e:	00 44       	sbci	r16, 0x40	; 64
    13a0:	1a 06       	cpc	r1, r26
    13a2:	00 00       	nop
    13a4:	01 8d       	ldd	r16, Z+25	; 0x19
    13a6:	51 01       	movw	r10, r2
    13a8:	00 00       	nop
    13aa:	af 01       	movw	r20, r30
    13ac:	00 00       	nop
    13ae:	00 3d       	cpi	r16, 0xD0	; 208
    13b0:	5e 01       	movw	r10, r28
    13b2:	00 00       	nop
    13b4:	66 01       	movw	r12, r12
    13b6:	00 00       	nop
    13b8:	e7 0d       	add	r30, r7
    13ba:	00 00       	nop
    13bc:	44 64       	ori	r20, 0x44	; 68
    13be:	03 00       	.word	0x0003	; ????
    13c0:	00 01       	movw	r0, r0
    13c2:	8e 0e       	add	r8, r30
    13c4:	07 00       	.word	0x0007	; ????
    13c6:	00 53       	subi	r16, 0x30	; 48
    13c8:	03 00       	.word	0x0003	; ????
    13ca:	00 44       	sbci	r16, 0x40	; 64
    13cc:	1a 06       	cpc	r1, r26
    13ce:	00 00       	nop
    13d0:	01 8e       	std	Z+25, r0	; 0x19
    13d2:	51 01       	movw	r10, r2
    13d4:	00 00       	nop
    13d6:	db 01       	movw	r26, r22
    13d8:	00 00       	nop
    13da:	00 45       	sbci	r16, 0x50	; 80
    13dc:	b6 0c       	add	r11, r6
    13de:	00 00       	nop
    13e0:	70 01       	movw	r14, r0
    13e2:	00 00       	nop
    13e4:	be 01       	movw	r22, r28
    13e6:	00 00       	nop
    13e8:	01 95       	neg	r16
    13ea:	13 0e       	add	r1, r19
    13ec:	00 00       	nop
    13ee:	38 c3       	rjmp	.+1648   	; 0x1a60 <__data_load_end+0xcd4>
    13f0:	0c 00       	.word	0x000c	; ????
    13f2:	00 f0       	brcs	.+0      	; 0x13f4 <__data_load_end+0x668>
    13f4:	03 00       	.word	0x0003	; ????
    13f6:	00 3e       	cpi	r16, 0xE0	; 224
    13f8:	a4 01       	movw	r20, r8
    13fa:	00 00       	nop
    13fc:	a8 01       	movw	r20, r16
    13fe:	00 00       	nop
    1400:	3b db       	rcall	.-2442   	; 0xa78 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x2e>
    1402:	0c 00       	.word	0x000c	; ????
    1404:	00 00       	nop
    1406:	00 3e       	cpi	r16, 0xE0	; 224
    1408:	be 01       	movw	r22, r28
    140a:	00 00       	nop
    140c:	cc 01       	movw	r24, r24
    140e:	00 00       	nop
    1410:	44 64       	ori	r20, 0x44	; 68
    1412:	03 00       	.word	0x0003	; ????
    1414:	00 01       	movw	r0, r0
    1416:	97 0e       	add	r9, r23
    1418:	07 00       	.word	0x0007	; ????
    141a:	00 03       	mulsu	r16, r16
    141c:	04 00       	.word	0x0004	; ????
    141e:	00 44       	sbci	r16, 0x40	; 64
    1420:	1a 06       	cpc	r1, r26
    1422:	00 00       	nop
    1424:	01 97       	sbiw	r24, 0x01	; 1
    1426:	0e 07       	cpc	r16, r30
    1428:	00 00       	nop
    142a:	ee 01       	movw	r28, r28
    142c:	00 00       	nop
    142e:	00 00       	nop
    1430:	46 24       	eor	r4, r6
    1432:	08 00       	.word	0x0008	; ????
    1434:	00 e6       	ldi	r16, 0x60	; 96
    1436:	01 00       	.word	0x0001	; ????
    1438:	00 5c       	subi	r16, 0xC0	; 192
    143a:	02 00       	.word	0x0002	; ????
    143c:	00 1b       	sub	r16, r16
    143e:	04 00       	.word	0x0004	; ????
    1440:	00 56       	subi	r16, 0x60	; 96
    1442:	0e 00       	.word	0x000e	; ????
    1444:	00 01       	movw	r0, r0
    1446:	cf 0e       	add	r12, r31
    1448:	00 00       	nop
    144a:	38 32       	cpi	r19, 0x28	; 40
    144c:	08 00       	.word	0x0008	; ????
    144e:	00 b2       	in	r0, 0x10	; 16
    1450:	04 00       	.word	0x0004	; ????
    1452:	00 38       	cpi	r16, 0x80	; 128
    1454:	3c 08       	sbc	r3, r12
    1456:	00 00       	nop
    1458:	f8 04       	cpc	r15, r8
    145a:	00 00       	nop
    145c:	38 48       	sbci	r19, 0x88	; 136
    145e:	08 00       	.word	0x0008	; ????
    1460:	00 24       	eor	r0, r0
    1462:	05 00       	.word	0x0005	; ????
    1464:	00 3d       	cpi	r16, 0xD0	; 208
    1466:	0c 02       	muls	r16, r28
    1468:	00 00       	nop
    146a:	34 02       	muls	r19, r20
    146c:	00 00       	nop
    146e:	91 0e       	add	r9, r17
    1470:	00 00       	nop
    1472:	3a 55       	subi	r19, 0x5A	; 90
    1474:	08 00       	.word	0x0008	; ????
    1476:	00 50       	subi	r16, 0x00	; 0
    1478:	05 00       	.word	0x0005	; ????
    147a:	00 47       	sbci	r16, 0x70	; 112
    147c:	30 02       	muls	r19, r16
    147e:	00 00       	nop
    1480:	e7 0c       	add	r14, r7
    1482:	00 00       	nop
    1484:	00 48       	sbci	r16, 0x80	; 128
    1486:	0b 08       	sbc	r0, r11
    1488:	00 00       	nop
    148a:	34 02       	muls	r19, r20
    148c:	00 00       	nop
    148e:	00 00       	nop
    1490:	00 00       	nop
    1492:	02 4b       	sbci	r16, 0xB2	; 178
    1494:	01 38       	cpi	r16, 0x81	; 129
    1496:	19 08       	sbc	r1, r9
    1498:	00 00       	nop
    149a:	7b 05       	cpc	r23, r11
    149c:	00 00       	nop
    149e:	49 3e       	cpi	r20, 0xE9	; 233
    14a0:	02 00       	.word	0x0002	; ????
    14a2:	00 e7       	ldi	r16, 0x70	; 112
    14a4:	0c 00       	.word	0x000c	; ????
    14a6:	00 bd       	out	0x20, r16	; 32
    14a8:	0e 00       	.word	0x000e	; ????
    14aa:	00 4a       	sbci	r16, 0xA0	; 160
    14ac:	01 66       	ori	r16, 0x61	; 97
    14ae:	01 31       	cpi	r16, 0x11	; 17
    14b0:	00 4b       	sbci	r16, 0xB0	; 176
    14b2:	5c 02       	muls	r21, r28
    14b4:	00 00       	nop
    14b6:	01 e7       	ldi	r16, 0x71	; 113
    14b8:	0c 00       	.word	0x000c	; ????
    14ba:	00 4a       	sbci	r16, 0xA0	; 160
    14bc:	01 66       	ori	r16, 0x61	; 97
    14be:	01 30       	cpi	r16, 0x01	; 1
    14c0:	00 00       	nop
    14c2:	00 4c       	sbci	r16, 0xC0	; 192
    14c4:	b5 08       	sbc	r11, r5
    14c6:	00 00       	nop
    14c8:	03 4f       	sbci	r16, 0xF3	; 243
    14ca:	01 e9       	ldi	r16, 0x91	; 145
    14cc:	05 00       	.word	0x0005	; ????
    14ce:	00 5c       	subi	r16, 0xC0	; 192
    14d0:	02 00       	.word	0x0002	; ????
    14d2:	00 a6       	std	Z+40, r0	; 0x28
    14d4:	02 00       	.word	0x0002	; ????
    14d6:	00 03       	mulsu	r16, r16
    14d8:	92 20       	and	r9, r2
    14da:	02 01       	movw	r0, r4
    14dc:	14 0f       	add	r17, r20
    14de:	00 00       	nop
    14e0:	43 6d       	ori	r20, 0xD3	; 211
    14e2:	00 03       	mulsu	r16, r16
    14e4:	50 e9       	ldi	r21, 0x90	; 144
    14e6:	05 00       	.word	0x0005	; ????
    14e8:	00 b1       	in	r16, 0x00	; 0
    14ea:	05 00       	.word	0x0005	; ????
    14ec:	00 44       	sbci	r16, 0x40	; 64
    14ee:	51 04       	cpc	r5, r1
    14f0:	00 00       	nop
    14f2:	03 51       	subi	r16, 0x13	; 19
    14f4:	51 01       	movw	r10, r2
    14f6:	00 00       	nop
    14f8:	cf 05       	cpc	r28, r15
    14fa:	00 00       	nop
    14fc:	4d 74       	andi	r20, 0x4D	; 77
    14fe:	00 03       	mulsu	r16, r16
    1500:	51 51       	subi	r21, 0x11	; 17
    1502:	01 00       	.word	0x0001	; ????
    1504:	00 01       	movw	r0, r0
    1506:	62 00       	.word	0x0062	; ????
    1508:	4e af       	std	Y+62, r20	; 0x3e
    150a:	02 00       	.word	0x0002	; ????
    150c:	00 14       	cp	r0, r0
    150e:	1c 01       	movw	r2, r24
    1510:	4f e0       	ldi	r20, 0x0F	; 15
    1512:	02 00       	.word	0x0002	; ????
    1514:	00 03       	mulsu	r16, r16
    1516:	6a 01       	movw	r12, r20
    1518:	a6 02       	muls	r26, r22
    151a:	00 00       	nop
    151c:	1a 03       	fmul	r17, r18
    151e:	00 00       	nop
    1520:	ee 05       	cpc	r30, r14
    1522:	00 00       	nop
    1524:	01 65       	ori	r16, 0x51	; 81
    1526:	0f 00       	.word	0x000f	; ????
    1528:	00 40       	sbci	r16, 0x00	; 0
    152a:	6d 73       	andi	r22, 0x3D	; 61
    152c:	00 03       	mulsu	r16, r16
    152e:	6a e9       	ldi	r22, 0x9A	; 154
    1530:	05 00       	.word	0x0005	; ????
    1532:	00 6b       	ori	r16, 0xB0	; 176
    1534:	06 00       	.word	0x0006	; ????
    1536:	00 44       	sbci	r16, 0x40	; 64
    1538:	44 06       	cpc	r4, r20
    153a:	00 00       	nop
    153c:	03 6c       	ori	r16, 0xC3	; 195
    153e:	24 07       	cpc	r18, r20
    1540:	00 00       	nop
    1542:	9f 06       	cpc	r9, r31
    1544:	00 00       	nop
    1546:	47 be       	out	0x37, r4	; 55
    1548:	02 00       	.word	0x0002	; ????
    154a:	00 cf       	rjmp	.-512    	; 0x134c <__data_load_end+0x5c0>
    154c:	0e 00       	.word	0x000e	; ????
    154e:	00 47       	sbci	r16, 0x70	; 112
    1550:	d0 02       	muls	r29, r16
    1552:	00 00       	nop
    1554:	cf 0e       	add	r12, r31
    1556:	00 00       	nop
    1558:	00 0e       	add	r0, r16
    155a:	02 6b       	ori	r16, 0xB2	; 178
    155c:	0f 00       	.word	0x000f	; ????
    155e:	00 28       	or	r0, r0
    1560:	51 01       	movw	r10, r2
    1562:	00 00       	nop
    1564:	50 fc       	sbrc	r5, 0
    1566:	00 00       	nop
    1568:	00 1a       	sub	r0, r16
    156a:	03 00       	.word	0x0003	; ????
    156c:	00 6e       	ori	r16, 0xE0	; 224
    156e:	03 00       	.word	0x0003	; ????
    1570:	00 e1       	ldi	r16, 0x10	; 16
    1572:	06 00       	.word	0x0006	; ????
    1574:	00 8a       	std	Z+16, r0	; 0x10
    1576:	0f 00       	.word	0x000f	; ????
    1578:	00 01       	movw	r0, r0
    157a:	d5 0f       	add	r29, r21
    157c:	00 00       	nop
    157e:	51 bf       	out	0x31, r21	; 49
    1580:	06 00       	.word	0x0006	; ????
    1582:	00 e2       	ldi	r16, 0x20	; 32
    1584:	07 00       	.word	0x0007	; ????
    1586:	00 01       	movw	r0, r0
    1588:	5e 07       	cpc	r21, r30
    158a:	00 00       	nop
    158c:	52 a5       	ldd	r21, Z+42	; 0x2a
    158e:	06 00       	.word	0x0006	; ????
    1590:	00 04       	cpc	r0, r0
    1592:	22 65       	ori	r18, 0x52	; 82
    1594:	0f 00       	.word	0x000f	; ????
    1596:	00 94       	com	r0
    1598:	07 00       	.word	0x0007	; ????
    159a:	00 52       	subi	r16, 0x20	; 32
    159c:	a3 07       	cpc	r26, r19
    159e:	00 00       	nop
    15a0:	04 22       	and	r0, r20
    15a2:	8b 05       	cpc	r24, r11
    15a4:	00 00       	nop
    15a6:	f4 07       	cpc	r31, r20
    15a8:	00 00       	nop
    15aa:	43 6e       	ori	r20, 0xE3	; 227
    15ac:	00 04       	cpc	r0, r0
    15ae:	24 8b       	std	Z+20, r18	; 0x14
    15b0:	05 00       	.word	0x0005	; ????
    15b2:	00 50       	subi	r16, 0x00	; 0
    15b4:	08 00       	.word	0x0008	; ????
    15b6:	00 53       	subi	r16, 0x30	; 48
    15b8:	50 03       	mulsu	r21, r16
    15ba:	00 00       	nop
    15bc:	4a 06       	cpc	r4, r26
    15be:	68 93       	.word	0x9368	; ????
    15c0:	01 69       	ori	r16, 0x91	; 145
    15c2:	93 01       	movw	r18, r6
    15c4:	02 7c       	andi	r16, 0xC2	; 194
    15c6:	00 00       	nop
    15c8:	00 54       	subi	r16, 0x40	; 64
    15ca:	9c 06       	cpc	r9, r28
    15cc:	00 00       	nop
    15ce:	05 71       	andi	r16, 0x15	; 21
    15d0:	01 01       	movw	r0, r2
    15d2:	6e 03       	fmul	r22, r22
    15d4:	00 00       	nop
    15d6:	82 03       	fmuls	r16, r18
    15d8:	00 00       	nop
    15da:	03 92       	.word	0x9203	; ????
    15dc:	20 02       	muls	r18, r16
    15de:	01 55       	subi	r16, 0x51	; 81
    15e0:	84 03       	fmuls	r16, r20
    15e2:	00 00       	nop
    15e4:	01 51       	subi	r16, 0x11	; 17
    15e6:	01 00       	.word	0x0001	; ????
    15e8:	00 01       	movw	r0, r0
    15ea:	01 1e       	adc	r0, r17
    15ec:	10 00       	.word	0x0010	; ????
    15ee:	00 2f       	mov	r16, r16
    15f0:	db 02       	muls	r29, r27
    15f2:	00 00       	nop
    15f4:	05 2e       	mov	r0, r21
    15f6:	01 65       	ori	r16, 0x51	; 81
    15f8:	0f 00       	.word	0x000f	; ????
    15fa:	00 2f       	mov	r16, r16
    15fc:	6d 03       	fmul	r22, r21
    15fe:	00 00       	nop
    1600:	05 2e       	mov	r0, r21
    1602:	01 51       	subi	r16, 0x11	; 17
    1604:	01 00       	.word	0x0001	; ????
    1606:	00 31       	cpi	r16, 0x10	; 16
    1608:	69 00       	.word	0x0069	; ????
    160a:	05 30       	cpi	r16, 0x05	; 5
    160c:	01 51       	subi	r16, 0x11	; 17
    160e:	01 00       	.word	0x0001	; ????
    1610:	00 00       	nop
    1612:	56 83       	std	Z+6, r21	; 0x06
    1614:	06 00       	.word	0x0006	; ????
    1616:	00 05       	cpc	r16, r0
    1618:	2e 01       	movw	r4, r28
    161a:	01 51       	subi	r16, 0x11	; 17
    161c:	01 00       	.word	0x0001	; ????
    161e:	00 01       	movw	r0, r0
    1620:	66 10       	cpse	r6, r6
    1622:	00 00       	nop
    1624:	2f db       	rcall	.-2466   	; 0xc84 <main+0x12c>
    1626:	02 00       	.word	0x0002	; ????
    1628:	00 05       	cpc	r16, r0
    162a:	2e 01       	movw	r4, r28
    162c:	65 0f       	add	r22, r21
    162e:	00 00       	nop
    1630:	2f 6d       	ori	r18, 0xDF	; 223
    1632:	03 00       	.word	0x0003	; ????
    1634:	00 05       	cpc	r16, r0
    1636:	2e 01       	movw	r4, r28
    1638:	51 01       	movw	r10, r2
    163a:	00 00       	nop
    163c:	31 69       	ori	r19, 0x91	; 145
    163e:	00 05       	cpc	r16, r0
    1640:	30 01       	movw	r6, r0
    1642:	51 01       	movw	r10, r2
    1644:	00 00       	nop
    1646:	30 57       	subi	r19, 0x70	; 112
    1648:	07 10       	cpse	r0, r7
    164a:	00 00       	nop
    164c:	57 fb       	bst	r21, 7
    164e:	0f 00       	.word	0x000f	; ????
    1650:	00 30       	cpi	r16, 0x00	; 0
    1652:	3b 13       	cpse	r19, r27
    1654:	10 00       	.word	0x0010	; ????
    1656:	00 00       	nop
    1658:	00 00       	nop
    165a:	37 1e       	adc	r3, r23
    165c:	10 00       	.word	0x0010	; ????
    165e:	00 82       	st	Z, r0
    1660:	03 00       	.word	0x0003	; ????
    1662:	00 d2       	rcall	.+1024   	; 0x1a64 <__data_load_end+0xcd8>
    1664:	03 00       	.word	0x0003	; ????
    1666:	00 03       	mulsu	r16, r16
    1668:	92 20       	and	r9, r2
    166a:	02 01       	movw	r0, r4
    166c:	bb 10       	cpse	r11, r11
    166e:	00 00       	nop
    1670:	38 30       	cpi	r19, 0x08	; 8
    1672:	10 00       	.word	0x0010	; ????
    1674:	00 74       	andi	r16, 0x40	; 64
    1676:	08 00       	.word	0x0008	; ????
    1678:	00 38       	cpi	r16, 0x80	; 128
    167a:	3c 10       	cpse	r3, r12
    167c:	00 00       	nop
    167e:	d6 08       	sbc	r13, r6
    1680:	00 00       	nop
    1682:	3b 48       	sbci	r19, 0x8B	; 139
    1684:	10 00       	.word	0x0010	; ????
    1686:	00 3e       	cpi	r16, 0xE0	; 224
    1688:	a2 03       	fmuls	r18, r18
    168a:	00 00       	nop
    168c:	ca 03       	fmulsu	r20, r18
    168e:	00 00       	nop
    1690:	57 07       	cpc	r21, r23
    1692:	10 00       	.word	0x0010	; ????
    1694:	00 57       	subi	r16, 0x70	; 112
    1696:	fb 0f       	add	r31, r27
    1698:	00 00       	nop
    169a:	3e a2       	std	Y+38, r3	; 0x26
    169c:	03 00       	.word	0x0003	; ????
    169e:	00 ca       	rjmp	.-3072   	; 0xaa0 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x56>
    16a0:	03 00       	.word	0x0003	; ????
    16a2:	00 3a       	cpi	r16, 0xA0	; 160
    16a4:	13 10       	cpse	r1, r3
    16a6:	00 00       	nop
    16a8:	02 09       	sbc	r16, r2
    16aa:	00 00       	nop
    16ac:	00 00       	nop
    16ae:	00 58       	subi	r16, 0x80	; 128
    16b0:	2c 06       	cpc	r2, r28
    16b2:	00 00       	nop
    16b4:	d2 03       	fmuls	r21, r18
    16b6:	00 00       	nop
    16b8:	d4 03       	fmuls	r21, r20
    16ba:	00 00       	nop
    16bc:	03 92       	.word	0x9203	; ????
    16be:	20 02       	muls	r18, r16
    16c0:	d5 10       	cpse	r13, r5
    16c2:	00 00       	nop
    16c4:	01 e7       	ldi	r16, 0x71	; 113
    16c6:	10 00       	.word	0x0010	; ????
    16c8:	00 59       	subi	r16, 0x90	; 144
    16ca:	bf 06       	cpc	r11, r31
    16cc:	00 00       	nop
    16ce:	8a 0a       	sbc	r8, r26
    16d0:	00 00       	nop
    16d2:	01 06       	cpc	r0, r17
    16d4:	68 93       	.word	0x9368	; ????
    16d6:	01 69       	ori	r16, 0x91	; 145
    16d8:	93 01       	movw	r18, r6
    16da:	00 58       	subi	r16, 0x80	; 128
    16dc:	4d 06       	cpc	r4, r29
    16de:	00 00       	nop
    16e0:	d4 03       	fmuls	r21, r20
    16e2:	00 00       	nop
    16e4:	da 03       	fmulsu	r21, r18
    16e6:	00 00       	nop
    16e8:	03 92       	.word	0x9203	; ????
    16ea:	20 02       	muls	r18, r16
    16ec:	01 11       	cpse	r16, r1
    16ee:	00 00       	nop
    16f0:	01 1d       	adc	r16, r1
    16f2:	11 00       	.word	0x0011	; ????
    16f4:	00 51       	subi	r16, 0x10	; 16
    16f6:	bf 06       	cpc	r11, r31
    16f8:	00 00       	nop
    16fa:	8a 0a       	sbc	r8, r26
    16fc:	00 00       	nop
    16fe:	01 2d       	mov	r16, r1
    1700:	09 00       	.word	0x0009	; ????
    1702:	00 5a       	subi	r16, 0xA0	; 160
    1704:	e6 02       	muls	r30, r22
    1706:	00 00       	nop
    1708:	06 06       	cpc	r0, r22
    170a:	01 3a       	cpi	r16, 0xA1	; 161
    170c:	00 00       	nop
    170e:	00 7f       	andi	r16, 0xF0	; 240
    1710:	00 58       	subi	r16, 0x80	; 128
    1712:	72 06       	cpc	r7, r18
    1714:	00 00       	nop
    1716:	da 03       	fmulsu	r21, r18
    1718:	00 00       	nop
    171a:	e0 03       	fmuls	r22, r16
    171c:	00 00       	nop
    171e:	03 92       	.word	0x9203	; ????
    1720:	20 02       	muls	r18, r16
    1722:	37 11       	cpse	r19, r7
    1724:	00 00       	nop
    1726:	01 52       	subi	r16, 0x21	; 33
    1728:	11 00       	.word	0x0011	; ????
    172a:	00 51       	subi	r16, 0x10	; 16
    172c:	bf 06       	cpc	r11, r31
    172e:	00 00       	nop
    1730:	8a 0a       	sbc	r8, r26
    1732:	00 00       	nop
    1734:	01 53       	subi	r16, 0x31	; 49
    1736:	09 00       	.word	0x0009	; ????
    1738:	00 5b       	subi	r16, 0xB0	; 176
    173a:	e6 02       	muls	r30, r22
    173c:	00 00       	nop
    173e:	06 f6       	brtc	.-128    	; 0x16c0 <__data_load_end+0x934>
    1740:	3a 00       	.word	0x003a	; ????
    1742:	00 00       	nop
    1744:	7f 00       	.word	0x007f	; ????
    1746:	58 96       	adiw	r26, 0x18	; 24
    1748:	06 00       	.word	0x0006	; ????
    174a:	00 e0       	ldi	r16, 0x00	; 0
    174c:	03 00       	.word	0x0003	; ????
    174e:	00 ee       	ldi	r16, 0xE0	; 224
    1750:	03 00       	.word	0x0003	; ????
    1752:	00 03       	mulsu	r16, r16
    1754:	92 20       	and	r9, r2
    1756:	02 6c       	ori	r16, 0xC2	; 194
    1758:	11 00       	.word	0x0011	; ????
    175a:	00 01       	movw	r0, r0
    175c:	7b 11       	cpse	r23, r11
    175e:	00 00       	nop
    1760:	51 bf       	out	0x31, r21	; 49
    1762:	06 00       	.word	0x0006	; ????
    1764:	00 8a       	std	Z+16, r0	; 0x10
    1766:	0a 00       	.word	0x000a	; ????
    1768:	00 01       	movw	r0, r0
    176a:	79 09       	sbc	r23, r9
    176c:	00 00       	nop
    176e:	00 50       	subi	r16, 0x00	; 0
    1770:	ba 06       	cpc	r11, r26
    1772:	00 00       	nop
    1774:	ee 03       	fmulsu	r22, r22
    1776:	00 00       	nop
    1778:	04 04       	cpc	r0, r4
    177a:	00 00       	nop
    177c:	9f 09       	sbc	r25, r15
    177e:	00 00       	nop
    1780:	95 11       	cpse	r25, r5
    1782:	00 00       	nop
    1784:	01 d8       	rcall	.-4094   	; 0x788 <__vector_16+0x26>
    1786:	11 00       	.word	0x0011	; ????
    1788:	00 51       	subi	r16, 0x10	; 16
    178a:	bf 06       	cpc	r11, r31
    178c:	00 00       	nop
    178e:	8a 0a       	sbc	r8, r26
    1790:	00 00       	nop
    1792:	01 ce       	rjmp	.-1022   	; 0x1396 <__data_load_end+0x60a>
    1794:	09 00       	.word	0x0009	; ????
    1796:	00 52       	subi	r16, 0x20	; 32
    1798:	db 02       	muls	r29, r27
    179a:	00 00       	nop
    179c:	06 da       	rcall	.-3060   	; 0xbaa <main+0x52>
    179e:	65 0f       	add	r22, r21
    17a0:	00 00       	nop
    17a2:	f4 09       	sbc	r31, r4
    17a4:	00 00       	nop
    17a6:	52 43       	sbci	r21, 0x32	; 50
    17a8:	03 00       	.word	0x0003	; ????
    17aa:	00 06       	cpc	r0, r16
    17ac:	da 8b       	std	Y+18, r29	; 0x12
    17ae:	05 00       	.word	0x0005	; ????
    17b0:	00 2a       	or	r0, r16
    17b2:	0a 00       	.word	0x000a	; ????
    17b4:	00 5c       	subi	r16, 0xC0	; 192
    17b6:	fc 03       	fmulsu	r23, r20
    17b8:	00 00       	nop
    17ba:	1e 10       	cpse	r1, r14
    17bc:	00 00       	nop
    17be:	4a 06       	cpc	r4, r26
    17c0:	68 93       	.word	0x9368	; ????
    17c2:	01 69       	ori	r16, 0x91	; 145
    17c4:	93 01       	movw	r18, r6
    17c6:	03 f3       	brvs	.-64     	; 0x1788 <__data_load_end+0x9fc>
    17c8:	01 66       	ori	r16, 0x61	; 97
    17ca:	00 00       	nop
    17cc:	50 e8       	ldi	r21, 0x80	; 128
    17ce:	06 00       	.word	0x0006	; ????
    17d0:	00 04       	cpc	r0, r0
    17d2:	04 00       	.word	0x0004	; ????
    17d4:	00 26       	eor	r0, r16
    17d6:	04 00       	.word	0x0004	; ????
    17d8:	00 62       	ori	r16, 0x20	; 32
    17da:	0a 00       	.word	0x000a	; ????
    17dc:	00 f2       	brcs	.-128    	; 0x175e <__data_load_end+0x9d2>
    17de:	11 00       	.word	0x0011	; ????
    17e0:	00 01       	movw	r0, r0
    17e2:	2a 12       	cpse	r2, r26
    17e4:	00 00       	nop
    17e6:	51 bf       	out	0x31, r21	; 49
    17e8:	06 00       	.word	0x0006	; ????
    17ea:	00 8a       	std	Z+16, r0	; 0x10
    17ec:	0a 00       	.word	0x000a	; ????
    17ee:	00 01       	movw	r0, r0
    17f0:	aa 0a       	sbc	r10, r26
    17f2:	00 00       	nop
    17f4:	52 db       	rcall	.-2396   	; 0xe9a <__data_load_end+0x10e>
    17f6:	02 00       	.word	0x0002	; ????
    17f8:	00 06       	cpc	r0, r16
    17fa:	c1 51       	subi	r28, 0x11	; 17
    17fc:	01 00       	.word	0x0001	; ????
    17fe:	00 d0       	rcall	.+0      	; 0x1800 <__data_load_end+0xa74>
    1800:	0a 00       	.word	0x000a	; ????
    1802:	00 5c       	subi	r16, 0xC0	; 192
    1804:	1a 04       	cpc	r1, r10
    1806:	00 00       	nop
    1808:	1e 10       	cpse	r1, r14
    180a:	00 00       	nop
    180c:	4a 06       	cpc	r4, r26
    180e:	68 93       	.word	0x9368	; ????
    1810:	01 69       	ori	r16, 0x91	; 145
    1812:	93 01       	movw	r18, r6
    1814:	02 8c       	ldd	r0, Z+26	; 0x1a
    1816:	01 4a       	sbci	r16, 0xA1	; 161
    1818:	01 66       	ori	r16, 0x61	; 97
    181a:	01 31       	cpi	r16, 0x11	; 17
    181c:	00 00       	nop
    181e:	58 f2       	brcs	.-106    	; 0x17b6 <__data_load_end+0xa2a>
    1820:	04 00       	.word	0x0004	; ????
    1822:	00 26       	eor	r0, r16
    1824:	04 00       	.word	0x0004	; ????
    1826:	00 4e       	sbci	r16, 0xE0	; 224
    1828:	04 00       	.word	0x0004	; ????
    182a:	00 03       	mulsu	r16, r16
    182c:	92 20       	and	r9, r2
    182e:	02 44       	sbci	r16, 0x42	; 66
    1830:	12 00       	.word	0x0012	; ????
    1832:	00 01       	movw	r0, r0
    1834:	6c 12       	cpse	r6, r28
    1836:	00 00       	nop
    1838:	51 bf       	out	0x31, r21	; 49
    183a:	06 00       	.word	0x0006	; ????
    183c:	00 aa       	std	Z+48, r0	; 0x30
    183e:	07 00       	.word	0x0007	; ????
    1840:	00 01       	movw	r0, r0
    1842:	fc 0a       	sbc	r15, r28
    1844:	00 00       	nop
    1846:	52 e6       	ldi	r21, 0x62	; 98
    1848:	02 00       	.word	0x0002	; ????
    184a:	00 02       	muls	r16, r16
    184c:	bd 51       	subi	r27, 0x1D	; 29
    184e:	01 00       	.word	0x0001	; ????
    1850:	00 42       	sbci	r16, 0x20	; 32
    1852:	0b 00       	.word	0x000b	; ????
    1854:	00 5d       	subi	r16, 0xD0	; 208
    1856:	4c 04       	cpc	r4, r12
    1858:	00 00       	nop
    185a:	01 e7       	ldi	r16, 0x71	; 113
    185c:	0c 00       	.word	0x000c	; ????
    185e:	00 00       	nop
    1860:	50 17       	cp	r21, r16
    1862:	05 00       	.word	0x0005	; ????
    1864:	00 4e       	sbci	r16, 0xE0	; 224
    1866:	04 00       	.word	0x0004	; ????
    1868:	00 84       	ldd	r0, Z+8	; 0x08
    186a:	04 00       	.word	0x0004	; ????
    186c:	00 87       	std	Z+8, r16	; 0x08
    186e:	0b 00       	.word	0x000b	; ????
    1870:	00 86       	std	Z+8, r0	; 0x08
    1872:	12 00       	.word	0x0012	; ????
    1874:	00 01       	movw	r0, r0
    1876:	df 12       	cpse	r13, r31
    1878:	00 00       	nop
    187a:	51 bf       	out	0x31, r21	; 49
    187c:	06 00       	.word	0x0006	; ????
    187e:	00 aa       	std	Z+48, r0	; 0x30
    1880:	07 00       	.word	0x0007	; ????
    1882:	00 01       	movw	r0, r0
    1884:	dd 0b       	sbc	r29, r29
    1886:	00 00       	nop
    1888:	40 70       	andi	r20, 0x00	; 0
    188a:	69 6e       	ori	r22, 0xE9	; 233
    188c:	00 02       	muls	r16, r16
    188e:	a7 51       	subi	r26, 0x17	; 23
    1890:	01 00       	.word	0x0001	; ????
    1892:	00 23       	and	r16, r16
    1894:	0c 00       	.word	0x000c	; ????
    1896:	00 40       	sbci	r16, 0x00	; 0
    1898:	70 6f       	ori	r23, 0xF0	; 240
    189a:	6c 00       	.word	0x006c	; ????
    189c:	02 a7       	std	Z+42, r16	; 0x2a
    189e:	34 01       	movw	r6, r8
    18a0:	00 00       	nop
    18a2:	5b 0c       	add	r5, r11
    18a4:	00 00       	nop
    18a6:	49 64       	ori	r20, 0x49	; 73
    18a8:	04 00       	.word	0x0004	; ????
    18aa:	00 e5       	ldi	r16, 0x50	; 80
    18ac:	0b 00       	.word	0x000b	; ????
    18ae:	00 c6       	rjmp	.+3072   	; 0x24b0 <__data_load_end+0x1724>
    18b0:	12 00       	.word	0x0012	; ????
    18b2:	00 4a       	sbci	r16, 0xA0	; 160
    18b4:	01 68       	ori	r16, 0x81	; 129
    18b6:	02 81       	ldd	r16, Z+2	; 0x02
    18b8:	00 00       	nop
    18ba:	5e 84       	ldd	r5, Y+14	; 0x0e
    18bc:	04 00       	.word	0x0004	; ????
    18be:	00 01       	movw	r0, r0
    18c0:	4a 06       	cpc	r4, r26
    18c2:	68 93       	.word	0x9368	; ????
    18c4:	01 69       	ori	r16, 0x91	; 145
    18c6:	93 01       	movw	r18, r6
    18c8:	03 f3       	brvs	.-64     	; 0x188a <__data_load_end+0xafe>
    18ca:	01 68       	ori	r16, 0x81	; 129
    18cc:	4a 01       	movw	r8, r20
    18ce:	66 01       	movw	r12, r12
    18d0:	30 00       	.word	0x0030	; ????
    18d2:	00 29       	or	r16, r0
    18d4:	41 05       	cpc	r20, r1
    18d6:	00 00       	nop
    18d8:	01 ed       	ldi	r16, 0xD1	; 209
    18da:	12 00       	.word	0x0012	; ????
    18dc:	00 21       	and	r16, r0
    18de:	13 00       	.word	0x0013	; ????
    18e0:	00 2a       	or	r0, r16
    18e2:	bf 06       	cpc	r11, r31
    18e4:	00 00       	nop
    18e6:	aa 07       	cpc	r26, r26
    18e8:	00 00       	nop
    18ea:	01 2c       	mov	r0, r1
    18ec:	e6 02       	muls	r30, r22
    18ee:	00 00       	nop
    18f0:	02 86       	std	Z+10, r0	; 0x0a
    18f2:	51 01       	movw	r10, r2
    18f4:	00 00       	nop
    18f6:	2c 02       	muls	r18, r28
    18f8:	04 00       	.word	0x0004	; ????
    18fa:	00 02       	muls	r16, r16
    18fc:	86 51       	subi	r24, 0x16	; 22
    18fe:	01 00       	.word	0x0001	; ????
    1900:	00 30       	cpi	r16, 0x00	; 0
    1902:	57 93       	lat	Z, r21
    1904:	07 00       	.word	0x0007	; ????
    1906:	00 57       	subi	r16, 0x70	; 112
    1908:	89 07       	cpc	r24, r25
    190a:	00 00       	nop
    190c:	30 3b       	cpi	r19, 0xB0	; 176
    190e:	9e 07       	cpc	r25, r30
    1910:	00 00       	nop
    1912:	00 00       	nop
    1914:	00 46       	sbci	r16, 0x60	; 96
    1916:	df 12       	cpse	r13, r31
    1918:	00 00       	nop
    191a:	84 04       	cpc	r8, r4
    191c:	00 00       	nop
    191e:	e2 04       	cpc	r14, r2
    1920:	00 00       	nop
    1922:	9d 0c       	add	r9, r13
    1924:	00 00       	nop
    1926:	3b 13       	cpse	r19, r27
    1928:	00 00       	nop
    192a:	01 da       	rcall	.-3070   	; 0xd2e <__tablejump2__+0x2>
    192c:	13 00       	.word	0x0013	; ????
    192e:	00 38       	cpi	r16, 0x80	; 128
    1930:	ed 12       	cpse	r14, r29
    1932:	00 00       	nop
    1934:	e6 0c       	add	r14, r6
    1936:	00 00       	nop
    1938:	38 f7       	brcc	.-50     	; 0x1908 <__data_load_end+0xb7c>
    193a:	12 00       	.word	0x0012	; ????
    193c:	00 2c       	mov	r0, r0
    193e:	0d 00       	.word	0x000d	; ????
    1940:	00 38       	cpi	r16, 0x80	; 128
    1942:	02 13       	cpse	r16, r18
    1944:	00 00       	nop
    1946:	63 0d       	add	r22, r3
    1948:	00 00       	nop
    194a:	3d ba       	out	0x1d, r3	; 29
    194c:	04 00       	.word	0x0004	; ????
    194e:	00 d0       	rcall	.+0      	; 0x1950 <__data_load_end+0xbc4>
    1950:	04 00       	.word	0x0004	; ????
    1952:	00 9f       	mul	r16, r16
    1954:	13 00       	.word	0x0013	; ????
    1956:	00 38       	cpi	r16, 0x80	; 128
    1958:	93 07       	cpc	r25, r19
    195a:	00 00       	nop
    195c:	8f 0d       	add	r24, r15
    195e:	00 00       	nop
    1960:	38 89       	ldd	r19, Y+16	; 0x10
    1962:	07 00       	.word	0x0007	; ????
    1964:	00 a2       	std	Z+32, r0	; 0x20
    1966:	0d 00       	.word	0x000d	; ????
    1968:	00 3e       	cpi	r16, 0xE0	; 224
    196a:	ba 04       	cpc	r11, r10
    196c:	00 00       	nop
    196e:	d0 04       	cpc	r13, r0
    1970:	00 00       	nop
    1972:	3b 9e       	mul	r3, r27
    1974:	07 00       	.word	0x0007	; ????
    1976:	00 5c       	subi	r16, 0xC0	; 192
    1978:	d0 04       	cpc	r13, r0
    197a:	00 00       	nop
    197c:	3c 0e       	add	r3, r28
    197e:	00 00       	nop
    1980:	4a 06       	cpc	r4, r26
    1982:	68 93       	.word	0x9368	; ????
    1984:	01 69       	ori	r16, 0x91	; 145
    1986:	93 01       	movw	r18, r6
    1988:	02 8c       	ldd	r0, Z+26	; 0x1a
    198a:	00 4a       	sbci	r16, 0xA0	; 160
    198c:	01 64       	ori	r16, 0x41	; 65
    198e:	01 34       	cpi	r16, 0x41	; 65
    1990:	00 00       	nop
    1992:	00 47       	sbci	r16, 0x70	; 112
    1994:	a0 04       	cpc	r10, r0
    1996:	00 00       	nop
    1998:	e7 0c       	add	r14, r7
    199a:	00 00       	nop
    199c:	49 ac       	ldd	r4, Y+57	; 0x39
    199e:	04 00       	.word	0x0004	; ????
    19a0:	00 e7       	ldi	r16, 0x70	; 112
    19a2:	0c 00       	.word	0x000c	; ????
    19a4:	00 bb       	out	0x10, r16	; 16
    19a6:	13 00       	.word	0x0013	; ????
    19a8:	00 4a       	sbci	r16, 0xA0	; 160
    19aa:	01 66       	ori	r16, 0x61	; 97
    19ac:	01 30       	cpi	r16, 0x01	; 1
    19ae:	00 4b       	sbci	r16, 0xB0	; 176
    19b0:	e2 04       	cpc	r14, r2
    19b2:	00 00       	nop
    19b4:	01 3c       	cpi	r16, 0xC1	; 193
    19b6:	0e 00       	.word	0x000e	; ????
    19b8:	00 4a       	sbci	r16, 0xA0	; 160
    19ba:	06 68       	ori	r16, 0x86	; 134
    19bc:	93 01       	movw	r18, r6
    19be:	69 93       	st	Y+, r22
    19c0:	01 03       	mulsu	r16, r17
    19c2:	f3 01       	movw	r30, r6
    19c4:	68 4a       	sbci	r22, 0xA8	; 168
    19c6:	01 66       	ori	r16, 0x61	; 97
    19c8:	03 f3       	brvs	.-64     	; 0x198a <__data_load_end+0xbfe>
    19ca:	01 66       	ori	r16, 0x61	; 97
    19cc:	00 00       	nop
    19ce:	58 47       	sbci	r21, 0x78	; 120
    19d0:	02 00       	.word	0x0002	; ????
    19d2:	00 e2       	ldi	r16, 0x20	; 32
    19d4:	04 00       	.word	0x0004	; ????
    19d6:	00 f8       	bld	r0, 0
    19d8:	04 00       	.word	0x0004	; ????
    19da:	00 03       	mulsu	r16, r16
    19dc:	92 20       	and	r9, r2
    19de:	02 f4       	brpl	.+0      	; 0x19e0 <__data_load_end+0xc54>
    19e0:	13 00       	.word	0x0013	; ????
    19e2:	00 01       	movw	r0, r0
    19e4:	31 14       	cp	r3, r1
    19e6:	00 00       	nop
    19e8:	51 bf       	out	0x31, r21	; 49
    19ea:	06 00       	.word	0x0006	; ????
    19ec:	00 55       	subi	r16, 0x50	; 80
    19ee:	07 00       	.word	0x0007	; ????
    19f0:	00 01       	movw	r0, r0
    19f2:	ba 0d       	add	r27, r10
    19f4:	00 00       	nop
    19f6:	5f e6       	ldi	r21, 0x6F	; 111
    19f8:	02 00       	.word	0x0002	; ????
    19fa:	00 07       	cpc	r16, r16
    19fc:	7b 01       	movw	r14, r22
    19fe:	51 01       	movw	r10, r2
    1a00:	00 00       	nop
    1a02:	e0 0d       	add	r30, r0
    1a04:	00 00       	nop
    1a06:	53 f2       	brvs	.-108    	; 0x199c <__data_load_end+0xc10>
    1a08:	04 00       	.word	0x0004	; ????
    1a0a:	00 4a       	sbci	r16, 0xA0	; 160
    1a0c:	06 68       	ori	r16, 0x86	; 134
    1a0e:	93 01       	movw	r18, r6
    1a10:	69 93       	st	Y+, r22
    1a12:	01 03       	mulsu	r16, r17
    1a14:	f3 01       	movw	r30, r6
    1a16:	68 4a       	sbci	r22, 0xA8	; 168
    1a18:	01 66       	ori	r16, 0x61	; 97
    1a1a:	03 f3       	brvs	.-64     	; 0x19dc <__data_load_end+0xc50>
    1a1c:	01 66       	ori	r16, 0x61	; 97
    1a1e:	4a 01       	movw	r8, r20
    1a20:	64 01       	movw	r12, r8
    1a22:	31 00       	.word	0x0031	; ????
    1a24:	00 58       	subi	r16, 0x80	; 128
    1a26:	71 02       	muls	r23, r17
    1a28:	00 00       	nop
    1a2a:	f8 04       	cpc	r15, r8
    1a2c:	00 00       	nop
    1a2e:	08 05       	cpc	r16, r8
    1a30:	00 00       	nop
    1a32:	03 92       	.word	0x9203	; ????
    1a34:	20 02       	muls	r18, r16
    1a36:	4b 14       	cp	r4, r11
    1a38:	00 00       	nop
    1a3a:	01 89       	ldd	r16, Z+17	; 0x11
    1a3c:	14 00       	.word	0x0014	; ????
    1a3e:	00 51       	subi	r16, 0x10	; 16
    1a40:	bf 06       	cpc	r11, r31
    1a42:	00 00       	nop
    1a44:	55 07       	cpc	r21, r21
    1a46:	00 00       	nop
    1a48:	01 01       	movw	r0, r2
    1a4a:	0e 00       	.word	0x000e	; ????
    1a4c:	00 5f       	subi	r16, 0xF0	; 240
    1a4e:	e6 02       	muls	r30, r22
    1a50:	00 00       	nop
    1a52:	07 70       	andi	r16, 0x07	; 7
    1a54:	01 51       	subi	r16, 0x11	; 17
    1a56:	01 00       	.word	0x0001	; ????
    1a58:	00 27       	eor	r16, r16
    1a5a:	0e 00       	.word	0x000e	; ????
    1a5c:	00 5e       	subi	r16, 0xE0	; 224
    1a5e:	08 05       	cpc	r16, r8
    1a60:	00 00       	nop
    1a62:	01 4a       	sbci	r16, 0xA1	; 161
    1a64:	06 68       	ori	r16, 0x86	; 134
    1a66:	93 01       	movw	r18, r6
    1a68:	69 93       	st	Y+, r22
    1a6a:	01 03       	mulsu	r16, r17
    1a6c:	f3 01       	movw	r30, r6
    1a6e:	68 4a       	sbci	r22, 0xA8	; 168
    1a70:	01 66       	ori	r16, 0x61	; 97
    1a72:	03 f3       	brvs	.-64     	; 0x1a34 <__data_load_end+0xca8>
    1a74:	01 66       	ori	r16, 0x61	; 97
    1a76:	4a 01       	movw	r8, r20
    1a78:	64 01       	movw	r12, r8
    1a7a:	30 00       	.word	0x0030	; ????
    1a7c:	00 60       	ori	r16, 0x00	; 0
    1a7e:	e9 08       	sbc	r14, r9
    1a80:	00 00       	nop
    1a82:	08 05       	cpc	r16, r8
    1a84:	00 00       	nop
    1a86:	8c 05       	cpc	r24, r12
    1a88:	00 00       	nop
    1a8a:	48 0e       	add	r4, r24
    1a8c:	00 00       	nop
    1a8e:	01 e4       	ldi	r16, 0x41	; 65
    1a90:	14 00       	.word	0x0014	; ????
    1a92:	00 38       	cpi	r16, 0x80	; 128
    1a94:	0c 09       	sbc	r16, r12
    1a96:	00 00       	nop
    1a98:	8f 0e       	add	r8, r31
    1a9a:	00 00       	nop
    1a9c:	39 17       	cp	r19, r25
    1a9e:	09 00       	.word	0x0009	; ????
    1aa0:	00 02       	muls	r16, r16
    1aa2:	8c 05       	cpc	r24, r12
    1aa4:	39 22       	and	r3, r25
    1aa6:	09 00       	.word	0x0009	; ????
    1aa8:	00 02       	muls	r16, r16
    1aaa:	8c 01       	movw	r16, r24
    1aac:	3c 01       	movw	r6, r24
    1aae:	09 00       	.word	0x0009	; ????
    1ab0:	00 00       	nop
    1ab2:	61 f7       	brne	.-40     	; 0x1a8c <__data_load_end+0xd00>
    1ab4:	08 00       	.word	0x0008	; ????
    1ab6:	00 06       	cpc	r0, r16
    1ab8:	03 ca       	rjmp	.-3066   	; 0xec0 <__data_load_end+0x134>
    1aba:	01 80       	ldd	r0, Z+1	; 0x01
    1abc:	00 9f       	mul	r16, r16
    1abe:	4b 8c       	ldd	r4, Y+27	; 0x1b
    1ac0:	05 00       	.word	0x0005	; ????
    1ac2:	00 01       	movw	r0, r0
    1ac4:	31 14       	cp	r3, r1
    1ac6:	00 00       	nop
    1ac8:	4a 06       	cpc	r4, r26
    1aca:	68 93       	.word	0x9368	; ????
    1acc:	01 69       	ori	r16, 0x91	; 145
    1ace:	93 01       	movw	r18, r6
    1ad0:	05 03       	mulsu	r16, r21
    1ad2:	ca 01       	movw	r24, r20
    1ad4:	80 00       	.word	0x0080	; ????
    1ad6:	00 00       	nop
    1ad8:	33 88       	ldd	r3, Z+19	; 0x13
    1ada:	08 00       	.word	0x0008	; ????
    1adc:	00 03       	mulsu	r16, r16
    1ade:	78 01       	movw	r14, r16
    1ae0:	01 fc       	sbrc	r0, 1
    1ae2:	14 00       	.word	0x0014	; ????
    1ae4:	00 2e       	mov	r0, r16
    1ae6:	75 73       	andi	r23, 0x35	; 53
    1ae8:	00 03       	mulsu	r16, r16
    1aea:	78 2d       	mov	r23, r8
    1aec:	01 00       	.word	0x0001	; ????
    1aee:	00 00       	nop
    1af0:	29 90       	ld	r2, Y+
    1af2:	02 00       	.word	0x0002	; ????
    1af4:	00 01       	movw	r0, r0
    1af6:	0a 15       	cp	r16, r10
    1af8:	00 00       	nop
    1afa:	15 15       	cp	r17, r5
    1afc:	00 00       	nop
    1afe:	2a bf       	out	0x3a, r18	; 58
    1b00:	06 00       	.word	0x0006	; ????
    1b02:	00 55       	subi	r16, 0x50	; 80
    1b04:	07 00       	.word	0x0007	; ????
    1b06:	00 01       	movw	r0, r0
    1b08:	00 50       	subi	r16, 0x00	; 0
    1b0a:	a8 02       	muls	r26, r24
    1b0c:	00 00       	nop
    1b0e:	8c 05       	cpc	r24, r12
    1b10:	00 00       	nop
    1b12:	ac 06       	cpc	r10, r28
    1b14:	00 00       	nop
    1b16:	bb 0e       	add	r11, r27
    1b18:	00 00       	nop
    1b1a:	2f 15       	cp	r18, r15
    1b1c:	00 00       	nop
    1b1e:	01 10       	cpse	r0, r1
    1b20:	18 00       	.word	0x0018	; ????
    1b22:	00 51       	subi	r16, 0x10	; 16
    1b24:	bf 06       	cpc	r11, r31
    1b26:	00 00       	nop
    1b28:	55 07       	cpc	r21, r21
    1b2a:	00 00       	nop
    1b2c:	01 04       	cpc	r0, r1
    1b2e:	0f 00       	.word	0x000f	; ????
    1b30:	00 52       	subi	r16, 0x20	; 32
    1b32:	79 04       	cpc	r7, r9
    1b34:	00 00       	nop
    1b36:	07 5b       	subi	r16, 0xB7	; 183
    1b38:	51 01       	movw	r10, r2
    1b3a:	00 00       	nop
    1b3c:	4a 0f       	add	r20, r26
    1b3e:	00 00       	nop
    1b40:	52 e6       	ldi	r21, 0x62	; 98
    1b42:	07 00       	.word	0x0007	; ????
    1b44:	00 07       	cpc	r16, r16
    1b46:	5b 51       	subi	r21, 0x1B	; 27
    1b48:	01 00       	.word	0x0001	; ????
    1b4a:	00 77       	andi	r16, 0x70	; 112
    1b4c:	0f 00       	.word	0x000f	; ????
    1b4e:	00 52       	subi	r16, 0x20	; 32
    1b50:	a0 07       	cpc	r26, r16
    1b52:	00 00       	nop
    1b54:	07 5b       	subi	r16, 0xB7	; 183
    1b56:	51 01       	movw	r10, r2
    1b58:	00 00       	nop
    1b5a:	98 0f       	add	r25, r24
    1b5c:	00 00       	nop
    1b5e:	45 e4       	ldi	r20, 0x45	; 69
    1b60:	14 00       	.word	0x0014	; ????
    1b62:	00 d6       	rcall	.+3072   	; 0x2764 <__data_load_end+0x19d8>
    1b64:	05 00       	.word	0x0005	; ????
    1b66:	00 de       	rcall	.-1024   	; 0x1768 <__data_load_end+0x9dc>
    1b68:	05 00       	.word	0x0005	; ????
    1b6a:	00 07       	cpc	r16, r16
    1b6c:	7c 87       	std	Y+12, r23	; 0x0c
    1b6e:	15 00       	.word	0x0015	; ????
    1b70:	00 38       	cpi	r16, 0x80	; 128
    1b72:	f1 14       	cp	r15, r1
    1b74:	00 00       	nop
    1b76:	b9 0f       	add	r27, r25
    1b78:	00 00       	nop
    1b7a:	00 45       	sbci	r16, 0x50	; 80
    1b7c:	e4 14       	cp	r14, r4
    1b7e:	00 00       	nop
    1b80:	f0 05       	cpc	r31, r0
    1b82:	00 00       	nop
    1b84:	fa 05       	cpc	r31, r10
    1b86:	00 00       	nop
    1b88:	07 80       	ldd	r0, Z+7	; 0x07
    1b8a:	a4 15       	cp	r26, r4
    1b8c:	00 00       	nop
    1b8e:	38 f1       	brcs	.+78     	; 0x1bde <__data_load_end+0xe52>
    1b90:	14 00       	.word	0x0014	; ????
    1b92:	00 cf       	rjmp	.-512    	; 0x1994 <__data_load_end+0xc08>
    1b94:	0f 00       	.word	0x000f	; ????
    1b96:	00 00       	nop
    1b98:	45 e4       	ldi	r20, 0x45	; 69
    1b9a:	14 00       	.word	0x0014	; ????
    1b9c:	00 0c       	add	r0, r0
    1b9e:	06 00       	.word	0x0006	; ????
    1ba0:	00 12       	cpse	r0, r16
    1ba2:	06 00       	.word	0x0006	; ????
    1ba4:	00 07       	cpc	r16, r16
    1ba6:	84 c1       	rjmp	.+776    	; 0x1eb0 <__data_load_end+0x1124>
    1ba8:	15 00       	.word	0x0015	; ????
    1baa:	00 38       	cpi	r16, 0x80	; 128
    1bac:	f1 14       	cp	r15, r1
    1bae:	00 00       	nop
    1bb0:	e5 0f       	add	r30, r21
    1bb2:	00 00       	nop
    1bb4:	00 45       	sbci	r16, 0x50	; 80
    1bb6:	e4 14       	cp	r14, r4
    1bb8:	00 00       	nop
    1bba:	2e 06       	cpc	r2, r30
    1bbc:	00 00       	nop
    1bbe:	36 06       	cpc	r3, r22
    1bc0:	00 00       	nop
    1bc2:	07 92       	lat	Z, r0
    1bc4:	de 15       	cp	r29, r14
    1bc6:	00 00       	nop
    1bc8:	38 f1       	brcs	.+78     	; 0x1c18 <__data_load_end+0xe8c>
    1bca:	14 00       	.word	0x0014	; ????
    1bcc:	00 fb       	bst	r16, 0
    1bce:	0f 00       	.word	0x000f	; ????
    1bd0:	00 00       	nop
    1bd2:	45 e4       	ldi	r20, 0x45	; 69
    1bd4:	14 00       	.word	0x0014	; ????
    1bd6:	00 40       	sbci	r16, 0x00	; 0
    1bd8:	06 00       	.word	0x0006	; ????
    1bda:	00 4a       	sbci	r16, 0xA0	; 160
    1bdc:	06 00       	.word	0x0006	; ????
    1bde:	00 07       	cpc	r16, r16
    1be0:	96 fb       	bst	r25, 6
    1be2:	15 00       	.word	0x0015	; ????
    1be4:	00 38       	cpi	r16, 0x80	; 128
    1be6:	f1 14       	cp	r15, r1
    1be8:	00 00       	nop
    1bea:	11 10       	cpse	r1, r1
    1bec:	00 00       	nop
    1bee:	00 45       	sbci	r16, 0x50	; 80
    1bf0:	e4 14       	cp	r14, r4
    1bf2:	00 00       	nop
    1bf4:	54 06       	cpc	r5, r20
    1bf6:	00 00       	nop
    1bf8:	5a 06       	cpc	r5, r26
    1bfa:	00 00       	nop
    1bfc:	07 9a       	sbi	0x00, 7	; 0
    1bfe:	18 16       	cp	r1, r24
    1c00:	00 00       	nop
    1c02:	38 f1       	brcs	.+78     	; 0x1c52 <__data_load_end+0xec6>
    1c04:	14 00       	.word	0x0014	; ????
    1c06:	00 27       	eor	r16, r16
    1c08:	10 00       	.word	0x0010	; ????
    1c0a:	00 00       	nop
    1c0c:	45 e4       	ldi	r20, 0x45	; 69
    1c0e:	14 00       	.word	0x0014	; ????
    1c10:	00 64       	ori	r16, 0x40	; 64
    1c12:	06 00       	.word	0x0006	; ????
    1c14:	00 6c       	ori	r16, 0xC0	; 192
    1c16:	06 00       	.word	0x0006	; ????
    1c18:	00 07       	cpc	r16, r16
    1c1a:	a0 35       	cpi	r26, 0x50	; 80
    1c1c:	16 00       	.word	0x0016	; ????
    1c1e:	00 38       	cpi	r16, 0x80	; 128
    1c20:	f1 14       	cp	r15, r1
    1c22:	00 00       	nop
    1c24:	3d 10       	cpse	r3, r13
    1c26:	00 00       	nop
    1c28:	00 45       	sbci	r16, 0x50	; 80
    1c2a:	3c 07       	cpc	r19, r28
    1c2c:	00 00       	nop
    1c2e:	70 06       	cpc	r7, r16
    1c30:	00 00       	nop
    1c32:	78 06       	cpc	r7, r24
    1c34:	00 00       	nop
    1c36:	07 a4       	ldd	r0, Z+47	; 0x2f
    1c38:	6c 16       	cp	r6, r28
    1c3a:	00 00       	nop
    1c3c:	38 4a       	sbci	r19, 0xA8	; 168
    1c3e:	07 00       	.word	0x0007	; ????
    1c40:	00 52       	subi	r16, 0x20	; 32
    1c42:	10 00       	.word	0x0010	; ????
    1c44:	00 5c       	subi	r16, 0xC0	; 192
    1c46:	78 06       	cpc	r7, r24
    1c48:	00 00       	nop
    1c4a:	31 14       	cp	r3, r1
    1c4c:	00 00       	nop
    1c4e:	4a 06       	cpc	r4, r26
    1c50:	68 93       	.word	0x9368	; ????
    1c52:	01 69       	ori	r16, 0x91	; 145
    1c54:	93 01       	movw	r18, r6
    1c56:	02 8c       	ldd	r0, Z+26	; 0x1a
    1c58:	00 4a       	sbci	r16, 0xA0	; 160
    1c5a:	01 66       	ori	r16, 0x61	; 97
    1c5c:	01 3c       	cpi	r16, 0xC1	; 193
    1c5e:	00 00       	nop
    1c60:	45 fc       	sbrc	r4, 5
    1c62:	14 00       	.word	0x0014	; ????
    1c64:	00 78       	andi	r16, 0x80	; 128
    1c66:	06 00       	.word	0x0006	; ????
    1c68:	00 88       	ldd	r0, Z+16	; 0x10
    1c6a:	06 00       	.word	0x0006	; ????
    1c6c:	00 07       	cpc	r16, r16
    1c6e:	a7 c0       	rjmp	.+334    	; 0x1dbe <__data_load_end+0x1032>
    1c70:	16 00       	.word	0x0016	; ????
    1c72:	00 38       	cpi	r16, 0x80	; 128
    1c74:	0a 15       	cp	r16, r10
    1c76:	00 00       	nop
    1c78:	6a 10       	cpse	r6, r10
    1c7a:	00 00       	nop
    1c7c:	45 e4       	ldi	r20, 0x45	; 69
    1c7e:	14 00       	.word	0x0014	; ????
    1c80:	00 80       	ld	r0, Z
    1c82:	06 00       	.word	0x0006	; ????
    1c84:	00 88       	ldd	r0, Z+16	; 0x10
    1c86:	06 00       	.word	0x0006	; ????
    1c88:	00 07       	cpc	r16, r16
    1c8a:	b7 a5       	ldd	r27, Z+47	; 0x2f
    1c8c:	16 00       	.word	0x0016	; ????
    1c8e:	00 38       	cpi	r16, 0x80	; 128
    1c90:	f1 14       	cp	r15, r1
    1c92:	00 00       	nop
    1c94:	82 10       	cpse	r8, r2
    1c96:	00 00       	nop
    1c98:	00 5c       	subi	r16, 0xC0	; 192
    1c9a:	80 06       	cpc	r8, r16
    1c9c:	00 00       	nop
    1c9e:	31 14       	cp	r3, r1
    1ca0:	00 00       	nop
    1ca2:	4a 06       	cpc	r4, r26
    1ca4:	68 93       	.word	0x9368	; ????
    1ca6:	01 69       	ori	r16, 0x91	; 145
    1ca8:	93 01       	movw	r18, r6
    1caa:	02 8c       	ldd	r0, Z+26	; 0x1a
    1cac:	00 4a       	sbci	r16, 0xA0	; 160
    1cae:	01 66       	ori	r16, 0x61	; 97
    1cb0:	01 31       	cpi	r16, 0x11	; 17
    1cb2:	00 00       	nop
    1cb4:	62 5a       	subi	r22, 0xA2	; 162
    1cb6:	07 00       	.word	0x0007	; ????
    1cb8:	00 94       	com	r0
    1cba:	06 00       	.word	0x0006	; ????
    1cbc:	00 18       	sub	r0, r0
    1cbe:	00 00       	nop
    1cc0:	00 07       	cpc	r16, r16
    1cc2:	ae f6       	brtc	.-86     	; 0x1c6e <__data_load_end+0xee2>
    1cc4:	16 00       	.word	0x0016	; ????
    1cc6:	00 38       	cpi	r16, 0x80	; 128
    1cc8:	68 07       	cpc	r22, r24
    1cca:	00 00       	nop
    1ccc:	98 10       	cpse	r9, r8
    1cce:	00 00       	nop
    1cd0:	5e ac       	ldd	r5, Y+62	; 0x3e
    1cd2:	06 00       	.word	0x0006	; ????
    1cd4:	00 01       	movw	r0, r0
    1cd6:	4a 06       	cpc	r4, r26
    1cd8:	68 93       	.word	0x9368	; ????
    1cda:	01 69       	ori	r16, 0x91	; 145
    1cdc:	93 01       	movw	r18, r6
    1cde:	03 f3       	brvs	.-64     	; 0x1ca0 <__data_load_end+0xf14>
    1ce0:	01 68       	ori	r16, 0x81	; 129
    1ce2:	4a 01       	movw	r8, r20
    1ce4:	66 02       	muls	r22, r22
    1ce6:	09 ff       	.word	0xff09	; ????
    1ce8:	00 00       	nop
    1cea:	49 be       	out	0x39, r4	; 57
    1cec:	05 00       	.word	0x0005	; ????
    1cee:	00 1c       	adc	r0, r0
    1cf0:	0f 00       	.word	0x000f	; ????
    1cf2:	00 15       	cp	r16, r0
    1cf4:	17 00       	.word	0x0017	; ????
    1cf6:	00 4a       	sbci	r16, 0xA0	; 160
    1cf8:	0c 66       	ori	r16, 0x6C	; 108
    1cfa:	93 01       	movw	r18, r6
    1cfc:	67 93       	lat	Z, r22
    1cfe:	01 68       	ori	r16, 0x81	; 129
    1d00:	93 01       	movw	r18, r6
    1d02:	69 93       	st	Y+, r22
    1d04:	01 02       	muls	r16, r17
    1d06:	08 64       	ori	r16, 0x48	; 72
    1d08:	00 63       	ori	r16, 0x30	; 48
    1d0a:	d6 05       	cpc	r29, r6
    1d0c:	00 00       	nop
    1d0e:	34 17       	cp	r19, r20
    1d10:	00 00       	nop
    1d12:	4a 06       	cpc	r4, r26
    1d14:	68 93       	.word	0x9368	; ????
    1d16:	01 69       	ori	r16, 0x91	; 145
    1d18:	93 01       	movw	r18, r6
    1d1a:	02 8c       	ldd	r0, Z+26	; 0x1a
    1d1c:	00 4a       	sbci	r16, 0xA0	; 160
    1d1e:	01 66       	ori	r16, 0x61	; 97
    1d20:	01 33       	cpi	r16, 0x31	; 49
    1d22:	4a 01       	movw	r8, r20
    1d24:	64 01       	movw	r12, r8
    1d26:	32 00       	.word	0x0032	; ????
    1d28:	63 f0       	brvs	.+24     	; 0x1d42 <__data_load_end+0xfb6>
    1d2a:	05 00       	.word	0x0005	; ????
    1d2c:	00 53       	subi	r16, 0x30	; 48
    1d2e:	17 00       	.word	0x0017	; ????
    1d30:	00 4a       	sbci	r16, 0xA0	; 160
    1d32:	06 68       	ori	r16, 0x86	; 134
    1d34:	93 01       	movw	r18, r6
    1d36:	69 93       	st	Y+, r22
    1d38:	01 02       	muls	r16, r17
    1d3a:	8c 00       	.word	0x008c	; ????
    1d3c:	4a 01       	movw	r8, r20
    1d3e:	66 01       	movw	r12, r12
    1d40:	33 4a       	sbci	r19, 0xA3	; 163
    1d42:	01 64       	ori	r16, 0x41	; 65
    1d44:	01 32       	cpi	r16, 0x21	; 33
    1d46:	00 63       	ori	r16, 0x30	; 48
    1d48:	0c 06       	cpc	r0, r28
    1d4a:	00 00       	nop
    1d4c:	72 17       	cp	r23, r18
    1d4e:	00 00       	nop
    1d50:	4a 06       	cpc	r4, r26
    1d52:	68 93       	.word	0x9368	; ????
    1d54:	01 69       	ori	r16, 0x91	; 145
    1d56:	93 01       	movw	r18, r6
    1d58:	02 8c       	ldd	r0, Z+26	; 0x1a
    1d5a:	00 4a       	sbci	r16, 0xA0	; 160
    1d5c:	01 66       	ori	r16, 0x61	; 97
    1d5e:	01 33       	cpi	r16, 0x31	; 49
    1d60:	4a 01       	movw	r8, r20
    1d62:	64 01       	movw	r12, r8
    1d64:	32 00       	.word	0x0032	; ????
    1d66:	63 24       	eor	r6, r3
    1d68:	06 00       	.word	0x0006	; ????
    1d6a:	00 91 17 00 	lds	r16, 0x0017	; 0x800017 <__TEXT_REGION_LENGTH__+0x7e0017>
    1d6e:	00 4a       	sbci	r16, 0xA0	; 160
    1d70:	06 68       	ori	r16, 0x86	; 134
    1d72:	93 01       	movw	r18, r6
    1d74:	69 93       	st	Y+, r22
    1d76:	01 02       	muls	r16, r17
    1d78:	8c 00       	.word	0x008c	; ????
    1d7a:	4a 01       	movw	r8, r20
    1d7c:	66 01       	movw	r12, r12
    1d7e:	32 4a       	sbci	r19, 0xA2	; 162
    1d80:	01 64       	ori	r16, 0x41	; 65
    1d82:	01 32       	cpi	r16, 0x21	; 33
    1d84:	00 49       	sbci	r16, 0x90	; 144
    1d86:	2e 06       	cpc	r2, r30
    1d88:	00 00       	nop
    1d8a:	31 14       	cp	r3, r1
    1d8c:	00 00       	nop
    1d8e:	aa 17       	cp	r26, r26
    1d90:	00 00       	nop
    1d92:	4a 06       	cpc	r4, r26
    1d94:	68 93       	.word	0x9368	; ????
    1d96:	01 69       	ori	r16, 0x91	; 145
    1d98:	93 01       	movw	r18, r6
    1d9a:	02 8c       	ldd	r0, Z+26	; 0x1a
    1d9c:	00 00       	nop
    1d9e:	49 40       	sbci	r20, 0x09	; 9
    1da0:	06 00       	.word	0x0006	; ????
    1da2:	00 31       	cpi	r16, 0x10	; 16
    1da4:	14 00       	.word	0x0014	; ????
    1da6:	00 c3       	rjmp	.+1536   	; 0x23a8 <__data_load_end+0x161c>
    1da8:	17 00       	.word	0x0017	; ????
    1daa:	00 4a       	sbci	r16, 0xA0	; 160
    1dac:	06 68       	ori	r16, 0x86	; 134
    1dae:	93 01       	movw	r18, r6
    1db0:	69 93       	st	Y+, r22
    1db2:	01 02       	muls	r16, r17
    1db4:	8c 00       	.word	0x008c	; ????
    1db6:	00 49       	sbci	r16, 0x90	; 144
    1db8:	54 06       	cpc	r5, r20
    1dba:	00 00       	nop
    1dbc:	31 14       	cp	r3, r1
    1dbe:	00 00       	nop
    1dc0:	dc 17       	cp	r29, r28
    1dc2:	00 00       	nop
    1dc4:	4a 06       	cpc	r4, r26
    1dc6:	68 93       	.word	0x9368	; ????
    1dc8:	01 69       	ori	r16, 0x91	; 145
    1dca:	93 01       	movw	r18, r6
    1dcc:	02 8c       	ldd	r0, Z+26	; 0x1a
    1dce:	00 00       	nop
    1dd0:	49 64       	ori	r20, 0x49	; 73
    1dd2:	06 00       	.word	0x0006	; ????
    1dd4:	00 31       	cpi	r16, 0x10	; 16
    1dd6:	14 00       	.word	0x0014	; ????
    1dd8:	00 f5       	brcc	.+64     	; 0x1e1a <__data_load_end+0x108e>
    1dda:	17 00       	.word	0x0017	; ????
    1ddc:	00 4a       	sbci	r16, 0xA0	; 160
    1dde:	06 68       	ori	r16, 0x86	; 134
    1de0:	93 01       	movw	r18, r6
    1de2:	69 93       	st	Y+, r22
    1de4:	01 02       	muls	r16, r17
    1de6:	8c 00       	.word	0x008c	; ????
    1de8:	00 5c       	subi	r16, 0xC0	; 192
    1dea:	94 06       	cpc	r9, r20
    1dec:	00 00       	nop
    1dee:	31 14       	cp	r3, r1
    1df0:	00 00       	nop
    1df2:	4a 06       	cpc	r4, r26
    1df4:	68 93       	.word	0x9368	; ????
    1df6:	01 69       	ori	r16, 0x91	; 145
    1df8:	93 01       	movw	r18, r6
    1dfa:	02 8c       	ldd	r0, Z+26	; 0x1a
    1dfc:	00 4a       	sbci	r16, 0xA0	; 160
    1dfe:	01 66       	ori	r16, 0x61	; 97
    1e00:	01 36       	cpi	r16, 0x61	; 97
    1e02:	00 00       	nop
    1e04:	58 d7       	rcall	.+3760   	; 0x2cb6 <__data_load_end+0x1f2a>
    1e06:	02 00       	.word	0x0002	; ????
    1e08:	00 ac       	ldd	r0, Z+56	; 0x38
    1e0a:	06 00       	.word	0x0006	; ????
    1e0c:	00 ae       	std	Z+56, r0	; 0x38
    1e0e:	06 00       	.word	0x0006	; ????
    1e10:	00 03       	mulsu	r16, r16
    1e12:	92 20       	and	r9, r2
    1e14:	02 2a       	or	r0, r18
    1e16:	18 00       	.word	0x0018	; ????
    1e18:	00 01       	movw	r0, r0
    1e1a:	4a 18       	sub	r4, r10
    1e1c:	00 00       	nop
    1e1e:	59 bf       	out	0x39, r21	; 57
    1e20:	06 00       	.word	0x0006	; ????
    1e22:	00 55       	subi	r16, 0x50	; 80
    1e24:	07 00       	.word	0x0007	; ????
    1e26:	00 01       	movw	r0, r0
    1e28:	06 68       	ori	r16, 0x86	; 134
    1e2a:	93 01       	movw	r18, r6
    1e2c:	69 93       	st	Y+, r22
    1e2e:	01 64       	ori	r16, 0x41	; 65
    1e30:	e6 02       	muls	r30, r22
    1e32:	00 00       	nop
    1e34:	08 05       	cpc	r16, r8
    1e36:	02 51       	subi	r16, 0x12	; 18
    1e38:	01 00       	.word	0x0001	; ????
    1e3a:	00 01       	movw	r0, r0
    1e3c:	66 00       	.word	0x0066	; ????
    1e3e:	58 fd       	.word	0xfd58	; ????
    1e40:	02 00       	.word	0x0002	; ????
    1e42:	00 ae       	std	Z+56, r0	; 0x38
    1e44:	06 00       	.word	0x0006	; ????
    1e46:	00 b0       	in	r0, 0x00	; 0
    1e48:	06 00       	.word	0x0006	; ????
    1e4a:	00 03       	mulsu	r16, r16
    1e4c:	92 20       	and	r9, r2
    1e4e:	02 64       	ori	r16, 0x42	; 66
    1e50:	18 00       	.word	0x0018	; ????
    1e52:	00 01       	movw	r0, r0
    1e54:	97 18       	sub	r9, r7
    1e56:	00 00       	nop
    1e58:	59 bf       	out	0x39, r21	; 57
    1e5a:	06 00       	.word	0x0006	; ????
    1e5c:	00 55       	subi	r16, 0x50	; 80
    1e5e:	07 00       	.word	0x0007	; ????
    1e60:	00 01       	movw	r0, r0
    1e62:	06 68       	ori	r16, 0x86	; 134
    1e64:	93 01       	movw	r18, r6
    1e66:	69 93       	st	Y+, r22
    1e68:	01 64       	ori	r16, 0x41	; 65
    1e6a:	e6 02       	muls	r30, r22
    1e6c:	00 00       	nop
    1e6e:	08 f2       	brcs	.-126    	; 0x1df2 <__data_load_end+0x1066>
    1e70:	01 51       	subi	r16, 0x11	; 17
    1e72:	01 00       	.word	0x0001	; ????
    1e74:	00 01       	movw	r0, r0
    1e76:	66 65       	ori	r22, 0x56	; 86
    1e78:	70 6f       	ori	r23, 0xF0	; 240
    1e7a:	6c 00       	.word	0x006c	; ????
    1e7c:	08 f2       	brcs	.-126    	; 0x1e00 <__data_load_end+0x1074>
    1e7e:	01 34       	cpi	r16, 0x41	; 65
    1e80:	01 00       	.word	0x0001	; ????
    1e82:	00 06       	cpc	r0, r16
    1e84:	64 93       	xch	Z, r22
    1e86:	01 65       	ori	r16, 0x51	; 81
    1e88:	93 01       	movw	r18, r6
    1e8a:	00 0e       	add	r0, r16
    1e8c:	02 25       	eor	r16, r2
    1e8e:	03 00       	.word	0x0003	; ????
    1e90:	00 58       	subi	r16, 0x80	; 128
    1e92:	2f 03       	fmul	r18, r23
    1e94:	00 00       	nop
    1e96:	b0 06       	cpc	r11, r16
    1e98:	00 00       	nop
    1e9a:	b2 06       	cpc	r11, r18
    1e9c:	00 00       	nop
    1e9e:	03 92       	.word	0x9203	; ????
    1ea0:	20 02       	muls	r18, r16
    1ea2:	b7 18       	sub	r11, r7
    1ea4:	00 00       	nop
    1ea6:	01 c9       	rjmp	.-3582   	; 0x10aa <__data_load_end+0x31e>
    1ea8:	18 00       	.word	0x0018	; ????
    1eaa:	00 59       	subi	r16, 0x90	; 144
    1eac:	bf 06       	cpc	r11, r31
    1eae:	00 00       	nop
    1eb0:	c9 18       	sub	r12, r9
    1eb2:	00 00       	nop
    1eb4:	01 06       	cpc	r0, r17
    1eb6:	68 93       	.word	0x9368	; ????
    1eb8:	01 69       	ori	r16, 0x91	; 145
    1eba:	93 01       	movw	r18, r6
    1ebc:	00 28       	or	r0, r0
    1ebe:	97 18       	sub	r9, r7
    1ec0:	00 00       	nop
    1ec2:	58 4f       	sbci	r21, 0xF8	; 248
    1ec4:	03 00       	.word	0x0003	; ????
    1ec6:	00 b2       	in	r0, 0x10	; 16
    1ec8:	06 00       	.word	0x0006	; ????
    1eca:	00 b8       	out	0x00, r0	; 0
    1ecc:	06 00       	.word	0x0006	; ????
    1ece:	00 03       	mulsu	r16, r16
    1ed0:	92 20       	and	r9, r2
    1ed2:	02 e8       	ldi	r16, 0x82	; 130
    1ed4:	18 00       	.word	0x0018	; ????
    1ed6:	00 01       	movw	r0, r0
    1ed8:	f7 18       	sub	r15, r7
    1eda:	00 00       	nop
    1edc:	51 bf       	out	0x31, r21	; 49
    1ede:	06 00       	.word	0x0006	; ????
    1ee0:	00 c9       	rjmp	.-3584   	; 0x10e2 <__data_load_end+0x356>
    1ee2:	18 00       	.word	0x0018	; ????
    1ee4:	00 01       	movw	r0, r0
    1ee6:	ce 10       	cpse	r12, r14
    1ee8:	00 00       	nop
    1eea:	00 37       	cpi	r16, 0x70	; 112
    1eec:	c5 08       	sbc	r12, r5
    1eee:	00 00       	nop
    1ef0:	b8 06       	cpc	r11, r24
    1ef2:	00 00       	nop
    1ef4:	dc 06       	cpc	r13, r28
    1ef6:	00 00       	nop
    1ef8:	03 92       	.word	0x9203	; ????
    1efa:	20 02       	muls	r18, r16
    1efc:	01 48       	sbci	r16, 0x81	; 129
    1efe:	19 00       	.word	0x0019	; ????
    1f00:	00 38       	cpi	r16, 0x80	; 128
    1f02:	dd 08       	sbc	r13, r13
    1f04:	00 00       	nop
    1f06:	f4 10       	cpse	r15, r4
    1f08:	00 00       	nop
    1f0a:	61 d3       	rcall	.+1730   	; 0x25ce <__data_load_end+0x1842>
    1f0c:	08 00       	.word	0x0008	; ????
    1f0e:	00 06       	cpc	r0, r16
    1f10:	03 ca       	rjmp	.-3066   	; 0x1318 <__data_load_end+0x58c>
    1f12:	01 80       	ldd	r0, Z+1	; 0x01
    1f14:	00 9f       	mul	r16, r16
    1f16:	4b d6       	rcall	.+3222   	; 0x2bae <__data_load_end+0x1e22>
    1f18:	06 00       	.word	0x0006	; ????
    1f1a:	00 01       	movw	r0, r0
    1f1c:	70 0f       	add	r23, r16
    1f1e:	00 00       	nop
    1f20:	4a 06       	cpc	r4, r26
    1f22:	68 93       	.word	0x9368	; ????
    1f24:	01 69       	ori	r16, 0x91	; 145
    1f26:	93 01       	movw	r18, r6
    1f28:	05 03       	mulsu	r16, r21
    1f2a:	ca 01       	movw	r24, r20
    1f2c:	80 00       	.word	0x0080	; ????
    1f2e:	4a 06       	cpc	r4, r26
    1f30:	66 93       	lac	Z, r22
    1f32:	01 67       	ori	r16, 0x71	; 113
    1f34:	93 01       	movw	r18, r6
    1f36:	03 f3       	brvs	.-64     	; 0x1ef8 <__data_load_end+0x116c>
    1f38:	01 68       	ori	r16, 0x81	; 129
    1f3a:	00 00       	nop
    1f3c:	60 61       	ori	r22, 0x10	; 16
    1f3e:	08 00       	.word	0x0008	; ????
    1f40:	00 dc       	rcall	.-2048   	; 0x1742 <__data_load_end+0x9b6>
    1f42:	06 00       	.word	0x0006	; ????
    1f44:	00 5e       	subi	r16, 0xE0	; 224
    1f46:	07 00       	.word	0x0007	; ????
    1f48:	00 48       	sbci	r16, 0x80	; 128
    1f4a:	11 00       	.word	0x0011	; ????
    1f4c:	00 01       	movw	r0, r0
    1f4e:	ba 19       	sub	r27, r10
    1f50:	00 00       	nop
    1f52:	38 79       	andi	r19, 0x98	; 152
    1f54:	08 00       	.word	0x0008	; ????
    1f56:	00 dd       	rcall	.-1536   	; 0x1958 <__data_load_end+0xbcc>
    1f58:	11 00       	.word	0x0011	; ????
    1f5a:	00 38       	cpi	r16, 0x80	; 128
    1f5c:	82 08       	sbc	r8, r2
    1f5e:	00 00       	nop
    1f60:	27 12       	cpse	r2, r23
    1f62:	00 00       	nop
    1f64:	39 8d       	ldd	r19, Y+25	; 0x19
    1f66:	08 00       	.word	0x0008	; ????
    1f68:	00 02       	muls	r16, r16
    1f6a:	8c 01       	movw	r16, r24
    1f6c:	3a 98       	cbi	0x07, 2	; 7
    1f6e:	08 00       	.word	0x0008	; ????
    1f70:	00 48       	sbci	r16, 0x80	; 128
    1f72:	12 00       	.word	0x0012	; ????
    1f74:	00 61       	ori	r16, 0x10	; 16
    1f76:	6f 08       	sbc	r6, r15
    1f78:	00 00       	nop
    1f7a:	06 03       	mulsu	r16, r22
    1f7c:	ca 01       	movw	r24, r20
    1f7e:	80 00       	.word	0x0080	; ????
    1f80:	9f 3d       	cpi	r25, 0xDF	; 223
    1f82:	0a 07       	cpc	r16, r26
    1f84:	00 00       	nop
    1f86:	32 07       	cpc	r19, r18
    1f88:	00 00       	nop
    1f8a:	a4 19       	sub	r26, r4
    1f8c:	00 00       	nop
    1f8e:	3a a4       	ldd	r3, Y+42	; 0x2a
    1f90:	08 00       	.word	0x0008	; ????
    1f92:	00 6d       	ori	r16, 0xD0	; 208
    1f94:	12 00       	.word	0x0012	; ????
    1f96:	00 00       	nop
    1f98:	5c 40       	sbci	r21, 0x0C	; 12
    1f9a:	07 00       	.word	0x0007	; ????
    1f9c:	00 f7       	brcc	.-64     	; 0x1f5e <__data_load_end+0x11d2>
    1f9e:	18 00       	.word	0x0018	; ????
    1fa0:	00 4a       	sbci	r16, 0xA0	; 160
    1fa2:	06 68       	ori	r16, 0x86	; 134
    1fa4:	93 01       	movw	r18, r6
    1fa6:	69 93       	st	Y+, r22
    1fa8:	01 02       	muls	r16, r17
    1faa:	80 00       	.word	0x0080	; ????
    1fac:	00 00       	nop
    1fae:	66 51       	subi	r22, 0x16	; 22
    1fb0:	03 00       	.word	0x0003	; ????
    1fb2:	00 0a       	sbc	r0, r16
    1fb4:	18 01       	movw	r2, r16
    1fb6:	01 5e       	subi	r16, 0xE1	; 225
    1fb8:	07 00       	.word	0x0007	; ????
    1fba:	00 62       	ori	r16, 0x20	; 32
    1fbc:	07 00       	.word	0x0007	; ????
    1fbe:	00 03       	mulsu	r16, r16
    1fc0:	92 20       	and	r9, r2
    1fc2:	02 01       	movw	r0, r4
    1fc4:	da 19       	sub	r29, r10
    1fc6:	00 00       	nop
    1fc8:	67 62       	ori	r22, 0x27	; 39
    1fca:	07 00       	.word	0x0007	; ????
    1fcc:	00 00       	nop
    1fce:	68 27       	eor	r22, r24
    1fd0:	08 00       	.word	0x0008	; ????
    1fd2:	00 01       	movw	r0, r0
    1fd4:	01 01       	movw	r0, r2
    1fd6:	68 d2       	rcall	.+1232   	; 0x24a8 <__data_load_end+0x171c>
    1fd8:	06 00       	.word	0x0006	; ????
    1fda:	00 01       	movw	r0, r0
    1fdc:	01 01       	movw	r0, r2
    1fde:	69 a8       	ldd	r6, Y+49	; 0x31
    1fe0:	07 00       	.word	0x0007	; ????
    1fe2:	00 01       	movw	r0, r0
    1fe4:	01 4a       	sbci	r16, 0xA1	; 161
    1fe6:	0a 00       	.word	0x000a	; ????
    1fe8:	00 58       	subi	r16, 0x80	; 128
    1fea:	0b 00       	.word	0x000b	; ????
    1fec:	00 a3       	std	Z+32, r16	; 0x20
    1fee:	12 00       	.word	0x0012	; ????
    1ff0:	00 01       	movw	r0, r0
    1ff2:	0b 1c       	adc	r0, r11
    1ff4:	00 00       	nop
    1ff6:	6a 52       	subi	r22, 0x2A	; 42
    1ff8:	0a 00       	.word	0x000a	; ????
    1ffa:	00 7e       	andi	r16, 0xE0	; 224
    1ffc:	0a 00       	.word	0x000a	; ????
    1ffe:	00 06       	cpc	r0, r16
    2000:	4a 01       	movw	r8, r20
    2002:	59 1a       	sub	r5, r25
    2004:	00 00       	nop
    2006:	6b ec       	ldi	r22, 0xCB	; 203
    2008:	12 00       	.word	0x0012	; ????
    200a:	00 6b       	ori	r16, 0xB0	; 176
    200c:	01 13       	cpse	r16, r17
    200e:	00 00       	nop
    2010:	6c 71       	andi	r22, 0x1C	; 28
    2012:	0a 00       	.word	0x000a	; ????
    2014:	00 52       	subi	r16, 0x20	; 32
    2016:	0a 00       	.word	0x000a	; ????
    2018:	00 7e       	andi	r16, 0xE0	; 224
    201a:	0a 00       	.word	0x000a	; ????
    201c:	00 06       	cpc	r0, r16
    201e:	4a 01       	movw	r8, r20
    2020:	57 7f       	andi	r21, 0xF7	; 247
    2022:	0a 00       	.word	0x000a	; ????
    2024:	00 6d       	ori	r16, 0xD0	; 208
    2026:	4d 0a       	sbc	r4, r29
    2028:	00 00       	nop
    202a:	52 0a       	sbc	r5, r18
    202c:	00 00       	nop
    202e:	72 0a       	sbc	r7, r18
    2030:	00 00       	nop
    2032:	06 31       	cpi	r16, 0x16	; 22
    2034:	57 5b       	subi	r21, 0xB7	; 183
    2036:	0a 00       	.word	0x000a	; ????
    2038:	00 6d       	ori	r16, 0xD0	; 208
    203a:	0b 1c       	adc	r0, r11
    203c:	00 00       	nop
    203e:	52 0a       	sbc	r5, r18
    2040:	00 00       	nop
    2042:	5a 0a       	sbc	r5, r26
    2044:	00 00       	nop
    2046:	0b 3f       	cpi	r16, 0xFB	; 251
    2048:	6e 00       	.word	0x006e	; ????
    204a:	00 00       	nop
    204c:	00 6d       	ori	r16, 0xD0	; 208
    204e:	c2 0b       	sbc	r28, r18
    2050:	00 00       	nop
    2052:	7e 0a       	sbc	r7, r30
    2054:	00 00       	nop
    2056:	58 0b       	sbc	r21, r24
    2058:	00 00       	nop
    205a:	0d 2a       	or	r0, r29
    205c:	38 ce       	rjmp	.-912    	; 0x1cce <__data_load_end+0xf42>
    205e:	0b 00       	.word	0x000b	; ????
    2060:	00 15       	cp	r16, r0
    2062:	13 00       	.word	0x0013	; ????
    2064:	00 38       	cpi	r16, 0x80	; 128
    2066:	d9 0b       	sbc	r29, r25
    2068:	00 00       	nop
    206a:	29 13       	cpse	r18, r25
    206c:	00 00       	nop
    206e:	6d 44       	sbci	r22, 0x4D	; 77
    2070:	0b 00       	.word	0x000b	; ????
    2072:	00 7e       	andi	r16, 0xE0	; 224
    2074:	0a 00       	.word	0x000a	; ????
    2076:	00 58       	subi	r16, 0x80	; 128
    2078:	0b 00       	.word	0x000b	; ????
    207a:	00 0d       	add	r16, r0
    207c:	07 57       	subi	r16, 0x77	; 119
    207e:	52 0b       	sbc	r21, r18
    2080:	00 00       	nop
    2082:	38 5c       	subi	r19, 0xC8	; 200
    2084:	0b 00       	.word	0x000b	; ????
    2086:	00 3e       	cpi	r16, 0xE0	; 224
    2088:	13 00       	.word	0x0013	; ????
    208a:	00 38       	cpi	r16, 0x80	; 128
    208c:	66 0b       	sbc	r22, r22
    208e:	00 00       	nop
    2090:	52 13       	cpse	r21, r18
    2092:	00 00       	nop
    2094:	38 71       	andi	r19, 0x18	; 24
    2096:	0b 00       	.word	0x000b	; ????
    2098:	00 66       	ori	r16, 0x60	; 96
    209a:	13 00       	.word	0x0013	; ????
    209c:	00 38       	cpi	r16, 0x80	; 128
    209e:	7b 0b       	sbc	r23, r27
    20a0:	00 00       	nop
    20a2:	7a 13       	cpse	r23, r26
    20a4:	00 00       	nop
    20a6:	38 85       	ldd	r19, Y+8	; 0x08
    20a8:	0b 00       	.word	0x000b	; ????
    20aa:	00 8e       	std	Z+24, r0	; 0x18
    20ac:	13 00       	.word	0x0013	; ????
    20ae:	00 38       	cpi	r16, 0x80	; 128
    20b0:	8f 0b       	sbc	r24, r31
    20b2:	00 00       	nop
    20b4:	a2 13       	cpse	r26, r18
    20b6:	00 00       	nop
    20b8:	38 99       	sbic	0x07, 0	; 7
    20ba:	0b 00       	.word	0x000b	; ????
    20bc:	00 b6       	in	r0, 0x30	; 48
    20be:	13 00       	.word	0x0013	; ????
    20c0:	00 38       	cpi	r16, 0x80	; 128
    20c2:	a3 0b       	sbc	r26, r19
    20c4:	00 00       	nop
    20c6:	ca 13       	cpse	r28, r26
    20c8:	00 00       	nop
    20ca:	38 ad       	ldd	r19, Y+56	; 0x38
    20cc:	0b 00       	.word	0x000b	; ????
    20ce:	00 de       	rcall	.-1024   	; 0x1cd0 <__data_load_end+0xf44>
    20d0:	13 00       	.word	0x0013	; ????
    20d2:	00 38       	cpi	r16, 0x80	; 128
    20d4:	b7 0b       	sbc	r27, r23
    20d6:	00 00       	nop
    20d8:	f2 13       	cpse	r31, r18
    20da:	00 00       	nop
    20dc:	45 2b       	or	r20, r21
    20de:	0b 00       	.word	0x000b	; ????
    20e0:	00 7e       	andi	r16, 0xE0	; 224
    20e2:	0a 00       	.word	0x000a	; ????
    20e4:	00 86       	std	Z+8, r0	; 0x08
    20e6:	0a 00       	.word	0x000a	; ????
    20e8:	00 02       	muls	r16, r16
    20ea:	45 12       	cpse	r4, r21
    20ec:	1b 00       	.word	0x001b	; ????
    20ee:	00 57       	subi	r16, 0x70	; 112
    20f0:	39 0b       	sbc	r19, r25
    20f2:	00 00       	nop
    20f4:	6d 0b       	sbc	r22, r29
    20f6:	1c 00       	.word	0x001c	; ????
    20f8:	00 7e       	andi	r16, 0xE0	; 224
    20fa:	0a 00       	.word	0x000a	; ????
    20fc:	00 86       	std	Z+8, r0	; 0x08
    20fe:	0a 00       	.word	0x000a	; ????
    2100:	00 07       	cpc	r16, r16
    2102:	40 6e       	ori	r20, 0xE0	; 224
    2104:	00 00       	nop
    2106:	6d 8f       	std	Y+29, r22	; 0x1d
    2108:	0a 00       	.word	0x000a	; ????
    210a:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    210e:	00 58       	subi	r16, 0x80	; 128
    2110:	0b 00       	.word	0x000b	; ????
    2112:	00 02       	muls	r16, r16
    2114:	47 57       	subi	r20, 0x77	; 119
    2116:	9d 0a       	sbc	r9, r29
    2118:	00 00       	nop
    211a:	38 a7       	std	Y+40, r19	; 0x28
    211c:	0a 00       	.word	0x000a	; ????
    211e:	00 06       	cpc	r0, r16
    2120:	14 00       	.word	0x0014	; ????
    2122:	00 38       	cpi	r16, 0x80	; 128
    2124:	b2 0a       	sbc	r11, r18
    2126:	00 00       	nop
    2128:	1a 14       	cp	r1, r10
    212a:	00 00       	nop
    212c:	38 bc       	out	0x28, r3	; 40
    212e:	0a 00       	.word	0x000a	; ????
    2130:	00 2e       	mov	r0, r16
    2132:	14 00       	.word	0x0014	; ????
    2134:	00 38       	cpi	r16, 0x80	; 128
    2136:	c6 0a       	sbc	r12, r22
    2138:	00 00       	nop
    213a:	43 14       	cp	r4, r3
    213c:	00 00       	nop
    213e:	38 d1       	rcall	.+624    	; 0x23b0 <__data_load_end+0x1624>
    2140:	0a 00       	.word	0x000a	; ????
    2142:	00 57       	subi	r16, 0x70	; 112
    2144:	14 00       	.word	0x0014	; ????
    2146:	00 38       	cpi	r16, 0x80	; 128
    2148:	db 0a       	sbc	r13, r27
    214a:	00 00       	nop
    214c:	6b 14       	cp	r6, r11
    214e:	00 00       	nop
    2150:	38 e5       	ldi	r19, 0x58	; 88
    2152:	0a 00       	.word	0x000a	; ????
    2154:	00 7f       	andi	r16, 0xF0	; 240
    2156:	14 00       	.word	0x0014	; ????
    2158:	00 38       	cpi	r16, 0x80	; 128
    215a:	ef 0a       	sbc	r14, r31
    215c:	00 00       	nop
    215e:	93 14       	cp	r9, r3
    2160:	00 00       	nop
    2162:	38 f9       	.word	0xf938	; ????
    2164:	0a 00       	.word	0x000a	; ????
    2166:	00 a7       	std	Z+40, r16	; 0x28
    2168:	14 00       	.word	0x0014	; ????
    216a:	00 38       	cpi	r16, 0x80	; 128
    216c:	03 0b       	sbc	r16, r19
    216e:	00 00       	nop
    2170:	bb 14       	cp	r11, r11
    2172:	00 00       	nop
    2174:	38 0d       	add	r19, r8
    2176:	0b 00       	.word	0x000b	; ????
    2178:	00 cf       	rjmp	.-512    	; 0x1f7a <__data_load_end+0x11ee>
    217a:	14 00       	.word	0x0014	; ????
    217c:	00 38       	cpi	r16, 0x80	; 128
    217e:	17 0b       	sbc	r17, r23
    2180:	00 00       	nop
    2182:	e3 14       	cp	r14, r3
    2184:	00 00       	nop
    2186:	3e 92       	st	-X, r3
    2188:	0a 00       	.word	0x000a	; ????
    218a:	00 58       	subi	r16, 0x80	; 128
    218c:	0b 00       	.word	0x000b	; ????
    218e:	00 3a       	cpi	r16, 0xA0	; 160
    2190:	21 0b       	sbc	r18, r17
    2192:	00 00       	nop
    2194:	f7 14       	cp	r15, r7
    2196:	00 00       	nop
    2198:	47 e6       	ldi	r20, 0x67	; 103
    219a:	0a 00       	.word	0x000a	; ????
    219c:	00 e5       	ldi	r16, 0x50	; 80
    219e:	0b 00       	.word	0x000b	; ????
    21a0:	00 47       	sbci	r16, 0x70	; 112
    21a2:	f6 0a       	sbc	r15, r22
    21a4:	00 00       	nop
    21a6:	e5 0b       	sbc	r30, r21
    21a8:	00 00       	nop
    21aa:	47 04       	cpc	r4, r7
    21ac:	0b 00       	.word	0x000b	; ????
    21ae:	00 e5       	ldi	r16, 0x50	; 80
    21b0:	0b 00       	.word	0x000b	; ????
    21b2:	00 47       	sbci	r16, 0x70	; 112
    21b4:	10 0b       	sbc	r17, r16
    21b6:	00 00       	nop
    21b8:	e5 0b       	sbc	r30, r21
    21ba:	00 00       	nop
    21bc:	47 18       	sub	r4, r7
    21be:	0b 00       	.word	0x000b	; ????
    21c0:	00 e5       	ldi	r16, 0x50	; 80
    21c2:	0b 00       	.word	0x000b	; ????
    21c4:	00 49       	sbci	r16, 0x90	; 144
    21c6:	28 0b       	sbc	r18, r24
    21c8:	00 00       	nop
    21ca:	e7 0c       	add	r14, r7
    21cc:	00 00       	nop
    21ce:	e4 1b       	sub	r30, r20
    21d0:	00 00       	nop
    21d2:	4a 01       	movw	r8, r20
    21d4:	66 01       	movw	r12, r12
    21d6:	30 00       	.word	0x0030	; ????
    21d8:	49 32       	cpi	r20, 0x29	; 41
    21da:	0b 00       	.word	0x000b	; ????
    21dc:	00 e7       	ldi	r16, 0x70	; 112
    21de:	0c 00       	.word	0x000c	; ????
    21e0:	00 f7       	brcc	.-64     	; 0x21a2 <__data_load_end+0x1416>
    21e2:	1b 00       	.word	0x001b	; ????
    21e4:	00 4a       	sbci	r16, 0xA0	; 160
    21e6:	01 66       	ori	r16, 0x61	; 97
    21e8:	01 30       	cpi	r16, 0x01	; 1
    21ea:	00 5c       	subi	r16, 0xC0	; 192
    21ec:	40 0b       	sbc	r20, r16
    21ee:	00 00       	nop
    21f0:	e7 0c       	add	r14, r7
    21f2:	00 00       	nop
    21f4:	4a 01       	movw	r8, r20
    21f6:	66 01       	movw	r12, r12
    21f8:	30 00       	.word	0x0030	; ????
    21fa:	00 00       	nop
    21fc:	00 00       	nop
    21fe:	00 6f       	ori	r16, 0xF0	; 240
    2200:	73 03       	mulsu	r23, r19
    2202:	00 00       	nop
    2204:	03 70       	andi	r16, 0x03	; 3
    2206:	01 54       	subi	r16, 0x41	; 65
    2208:	08 00       	.word	0x0008	; ????
    220a:	00 03       	mulsu	r16, r16
    220c:	2d 01       	movw	r4, r26
    220e:	62 07       	cpc	r22, r18
    2210:	00 00       	nop
    2212:	f6 07       	cpc	r31, r22
    2214:	00 00       	nop
    2216:	84 15       	cp	r24, r4
    2218:	00 00       	nop
    221a:	01 46       	sbci	r16, 0x61	; 97
    221c:	1c 00       	.word	0x001c	; ????
    221e:	00 43       	sbci	r16, 0x30	; 48
    2220:	6d 00       	.word	0x006d	; ????
    2222:	03 32       	cpi	r16, 0x23	; 35
    2224:	e9 05       	cpc	r30, r9
    2226:	00 00       	nop
    2228:	01 16       	cp	r0, r17
    222a:	00 00       	nop
    222c:	43 66       	ori	r20, 0x63	; 99
    222e:	00 03       	mulsu	r16, r16
    2230:	33 5c       	subi	r19, 0xC3	; 195
    2232:	01 00       	.word	0x0001	; ????
    2234:	00 74       	andi	r16, 0x40	; 64
    2236:	16 00       	.word	0x0016	; ????
    2238:	00 00       	nop
    223a:	71 3d       	cpi	r23, 0xD1	; 209
    223c:	03 00       	.word	0x0003	; ????
    223e:	00 0d       	add	r16, r0
    2240:	10 01       	movw	r2, r0
    2242:	01 71       	andi	r16, 0x11	; 17
    2244:	bd 02       	muls	r27, r29
    2246:	00 00       	nop
    2248:	0c 1c       	adc	r0, r12
    224a:	01 01       	movw	r0, r2
    224c:	71 7e       	andi	r23, 0xE1	; 225
    224e:	06 00       	.word	0x0006	; ????
    2250:	00 03       	mulsu	r16, r16
    2252:	f1 01       	movw	r30, r2
    2254:	01 72       	andi	r16, 0x21	; 33
    2256:	dc 03       	fmulsu	r21, r20
    2258:	00 00       	nop
    225a:	03 41       	sbci	r16, 0x13	; 19
    225c:	01 e9       	ldi	r16, 0x91	; 145
    225e:	05 00       	.word	0x0005	; ????
    2260:	00 01       	movw	r0, r0
    2262:	87 1c       	adc	r8, r7
    2264:	00 00       	nop
    2266:	32 6d       	ori	r19, 0xD2	; 210
    2268:	00 03       	mulsu	r16, r16
    226a:	43 e9       	ldi	r20, 0x93	; 147
    226c:	05 00       	.word	0x0005	; ????
    226e:	00 2d       	mov	r16, r0
    2270:	51 04       	cpc	r5, r1
    2272:	00 00       	nop
    2274:	03 44       	sbci	r16, 0x43	; 67
    2276:	51 01       	movw	r10, r2
    2278:	00 00       	nop
    227a:	00 71       	andi	r16, 0x10	; 16
    227c:	cf 05       	cpc	r28, r15
    227e:	00 00       	nop
    2280:	0d 1a       	sub	r0, r29
    2282:	01 01       	movw	r0, r2
    2284:	36 1b       	sub	r19, r22
    2286:	08 00       	.word	0x0008	; ????
    2288:	00 01       	movw	r0, r0
    228a:	01 01       	movw	r0, r2
    228c:	aa 1c       	adc	r10, r10
    228e:	00 00       	nop
    2290:	30 2d       	mov	r19, r0
    2292:	fd 02       	muls	r31, r29
    2294:	00 00       	nop
    2296:	0d 1e       	adc	r0, r29
    2298:	e9 05       	cpc	r30, r9
    229a:	00 00       	nop
    229c:	00 00       	nop
    229e:	73 01       	movw	r14, r6
    22a0:	d6 02       	muls	r29, r22
    22a2:	00 00       	nop
    22a4:	0c 21       	and	r16, r12
    22a6:	01 3a       	cpi	r16, 0xA1	; 161
    22a8:	00 00       	nop
    22aa:	00 01       	movw	r0, r0
    22ac:	58 0b       	sbc	r21, r24
    22ae:	00 00       	nop
    22b0:	e8 0c       	add	r14, r8
    22b2:	00 00       	nop
    22b4:	03 92       	.word	0x9203	; ????
    22b6:	20 02       	muls	r18, r16
    22b8:	01 64       	ori	r16, 0x41	; 65
    22ba:	1f 00       	.word	0x001f	; ????
    22bc:	00 74       	andi	r16, 0x40	; 64
    22be:	58 1c       	adc	r5, r8
    22c0:	00 00       	nop
    22c2:	58 0b       	sbc	r21, r24
    22c4:	00 00       	nop
    22c6:	de 0b       	sbc	r29, r30
    22c8:	00 00       	nop
    22ca:	0c 23       	and	r16, r28
    22cc:	45 46       	sbci	r20, 0x65	; 101
    22ce:	1c 00       	.word	0x001c	; ????
    22d0:	00 de       	rcall	.-1024   	; 0x1ed2 <__data_load_end+0x1146>
    22d2:	0b 00       	.word	0x000b	; ????
    22d4:	00 1e       	adc	r0, r16
    22d6:	0c 00       	.word	0x000c	; ????
    22d8:	00 0c       	add	r0, r0
    22da:	2b 63       	ori	r18, 0x3B	; 59
    22dc:	1d 00       	.word	0x001d	; ????
    22de:	00 45       	sbci	r16, 0x50	; 80
    22e0:	61 1c       	adc	r6, r1
    22e2:	00 00       	nop
    22e4:	f8 0b       	sbc	r31, r24
    22e6:	00 00       	nop
    22e8:	0e 0c       	add	r0, r14
    22ea:	00 00       	nop
    22ec:	0d 17       	cp	r16, r29
    22ee:	1b 1d       	adc	r17, r11
    22f0:	00 00       	nop
    22f2:	3e f8       	.word	0xf83e	; ????
    22f4:	0b 00       	.word	0x000b	; ????
    22f6:	00 0e       	add	r0, r16
    22f8:	0c 00       	.word	0x000c	; ????
    22fa:	00 3a       	cpi	r16, 0xA0	; 160
    22fc:	72 1c       	adc	r7, r2
    22fe:	00 00       	nop
    2300:	b9 16       	cp	r11, r25
    2302:	00 00       	nop
    2304:	3a 7b       	andi	r19, 0xBA	; 186
    2306:	1c 00       	.word	0x001c	; ????
    2308:	00 d7       	rcall	.+3584   	; 0x310a <__data_load_end+0x237e>
    230a:	16 00       	.word	0x0016	; ????
    230c:	00 00       	nop
    230e:	00 49       	sbci	r16, 0x90	; 144
    2310:	ea 0b       	sbc	r30, r26
    2312:	00 00       	nop
    2314:	1c 0f       	add	r17, r28
    2316:	00 00       	nop
    2318:	3b 1d       	adc	r19, r11
    231a:	00 00       	nop
    231c:	4a 0c       	add	r4, r10
    231e:	66 93       	lac	Z, r22
    2320:	01 67       	ori	r16, 0x71	; 113
    2322:	93 01       	movw	r18, r6
    2324:	68 93       	.word	0x9368	; ????
    2326:	01 69       	ori	r16, 0x91	; 145
    2328:	93 01       	movw	r18, r6
    232a:	03 0a       	sbc	r0, r19
    232c:	e8 03       	fmulsu	r22, r16
    232e:	00 5c       	subi	r16, 0xC0	; 192
    2330:	f8 0b       	sbc	r31, r24
    2332:	00 00       	nop
    2334:	15 15       	cp	r17, r5
    2336:	00 00       	nop
    2338:	4a 06       	cpc	r4, r26
    233a:	68 93       	.word	0x9368	; ????
    233c:	01 69       	ori	r16, 0x91	; 145
    233e:	93 01       	movw	r18, r6
    2340:	05 03       	mulsu	r16, r21
    2342:	ca 01       	movw	r24, r20
    2344:	80 00       	.word	0x0080	; ????
    2346:	4a 01       	movw	r8, r20
    2348:	66 01       	movw	r12, r12
    234a:	40 4a       	sbci	r20, 0xA0	; 160
    234c:	01 64       	ori	r16, 0x41	; 65
    234e:	01 32       	cpi	r16, 0x21	; 33
    2350:	4a 01       	movw	r8, r20
    2352:	62 01       	movw	r12, r4
    2354:	30 00       	.word	0x0030	; ????
    2356:	00 62       	ori	r16, 0x20	; 32
    2358:	87 1c       	adc	r8, r7
    235a:	00 00       	nop
    235c:	1e 0c       	add	r1, r14
    235e:	00 00       	nop
    2360:	30 00       	.word	0x0030	; ????
    2362:	00 00       	nop
    2364:	0c 2e       	mov	r0, r28
    2366:	5e 1f       	adc	r21, r30
    2368:	00 00       	nop
    236a:	75 48       	sbci	r23, 0x85	; 133
    236c:	00 00       	nop
    236e:	00 39       	cpi	r16, 0x90	; 144
    2370:	9d 1c       	adc	r9, r13
    2372:	00 00       	nop
    2374:	0c 5c       	subi	r16, 0xCC	; 204
    2376:	93 01       	movw	r18, r6
    2378:	5d 93       	st	X+, r21
    237a:	01 5e       	subi	r16, 0xE1	; 225
    237c:	93 01       	movw	r18, r6
    237e:	5f 93       	push	r21
    2380:	01 62       	ori	r16, 0x21	; 33
    2382:	fc 14       	cp	r15, r12
    2384:	00 00       	nop
    2386:	1e 0c       	add	r1, r14
    2388:	00 00       	nop
    238a:	60 00       	.word	0x0060	; ????
    238c:	00 00       	nop
    238e:	0d 20       	and	r0, r13
    2390:	e0 1d       	adc	r30, r0
    2392:	00 00       	nop
    2394:	57 0a       	sbc	r5, r23
    2396:	15 00       	.word	0x0015	; ????
    2398:	00 62       	ori	r16, 0x20	; 32
    239a:	e4 14       	cp	r14, r4
    239c:	00 00       	nop
    239e:	1e 0c       	add	r1, r14
    23a0:	00 00       	nop
    23a2:	78 00       	.word	0x0078	; ????
    23a4:	00 00       	nop
    23a6:	07 b7       	in	r16, 0x37	; 55
    23a8:	c2 1d       	adc	r28, r2
    23aa:	00 00       	nop
    23ac:	38 f1       	brcs	.+78     	; 0x23fc <__data_load_end+0x1670>
    23ae:	14 00       	.word	0x0014	; ????
    23b0:	00 ea       	ldi	r16, 0xA0	; 160
    23b2:	16 00       	.word	0x0016	; ????
    23b4:	00 00       	nop
    23b6:	5c 7c       	andi	r21, 0xCC	; 204
    23b8:	0c 00       	.word	0x000c	; ????
    23ba:	00 31       	cpi	r16, 0x10	; 16
    23bc:	14 00       	.word	0x0014	; ????
    23be:	00 4a       	sbci	r16, 0xA0	; 160
    23c0:	06 68       	ori	r16, 0x86	; 134
    23c2:	93 01       	movw	r18, r6
    23c4:	69 93       	st	Y+, r22
    23c6:	01 05       	cpc	r16, r1
    23c8:	03 ca       	rjmp	.-3066   	; 0x17d0 <__data_load_end+0xa44>
    23ca:	01 80       	ldd	r0, Z+1	; 0x01
    23cc:	00 4a       	sbci	r16, 0xA0	; 160
    23ce:	01 66       	ori	r16, 0x61	; 97
    23d0:	01 31       	cpi	r16, 0x11	; 17
    23d2:	00 00       	nop
    23d4:	45 61       	ori	r20, 0x15	; 21
    23d6:	1c 00       	.word	0x001c	; ????
    23d8:	00 5c       	subi	r16, 0xC0	; 192
    23da:	0c 00       	.word	0x000c	; ????
    23dc:	00 72       	andi	r16, 0x20	; 32
    23de:	0c 00       	.word	0x000c	; ????
    23e0:	00 0d       	add	r16, r0
    23e2:	1e 10       	cpse	r1, r14
    23e4:	1e 00       	.word	0x001e	; ????
    23e6:	00 3e       	cpi	r16, 0xE0	; 224
    23e8:	5c 0c       	add	r5, r12
    23ea:	00 00       	nop
    23ec:	72 0c       	add	r7, r2
    23ee:	00 00       	nop
    23f0:	3a 72       	andi	r19, 0x2A	; 42
    23f2:	1c 00       	.word	0x001c	; ????
    23f4:	00 00       	nop
    23f6:	17 00       	.word	0x0017	; ????
    23f8:	00 3a       	cpi	r16, 0xA0	; 160
    23fa:	7b 1c       	adc	r7, r11
    23fc:	00 00       	nop
    23fe:	1e 17       	cp	r17, r30
    2400:	00 00       	nop
    2402:	00 00       	nop
    2404:	45 e7       	ldi	r20, 0x75	; 117
    2406:	07 00       	.word	0x0007	; ????
    2408:	00 88       	ldd	r0, Z+16	; 0x10
    240a:	0c 00       	.word	0x000c	; ????
    240c:	00 90 0c 00 	lds	r0, 0x000C	; 0x80000c <__TEXT_REGION_LENGTH__+0x7e000c>
    2410:	00 0d       	add	r16, r0
    2412:	22 46       	sbci	r18, 0x62	; 98
    2414:	1e 00       	.word	0x001e	; ????
    2416:	00 57       	subi	r16, 0x70	; 112
    2418:	f5 07       	cpc	r31, r21
    241a:	00 00       	nop
    241c:	57 ff       	sbrs	r21, 7
    241e:	07 00       	.word	0x0007	; ????
    2420:	00 5c       	subi	r16, 0xC0	; 192
    2422:	90 0c       	add	r9, r0
    2424:	00 00       	nop
    2426:	f7 18       	sub	r15, r7
    2428:	00 00       	nop
    242a:	4a 06       	cpc	r4, r26
    242c:	68 93       	.word	0x9368	; ????
    242e:	01 69       	ori	r16, 0x91	; 145
    2430:	93 01       	movw	r18, r6
    2432:	05 03       	mulsu	r16, r21
    2434:	32 01       	movw	r6, r4
    2436:	80 00       	.word	0x0080	; ????
    2438:	00 00       	nop
    243a:	45 b5       	in	r20, 0x25	; 37
    243c:	07 00       	.word	0x0007	; ????
    243e:	00 90 0c 00 	lds	r0, 0x000C	; 0x80000c <__TEXT_REGION_LENGTH__+0x7e000c>
    2442:	00 9e       	mul	r0, r16
    2444:	0c 00       	.word	0x000c	; ????
    2446:	00 0d       	add	r16, r0
    2448:	23 94       	inc	r2
    244a:	1e 00       	.word	0x001e	; ????
    244c:	00 57       	subi	r16, 0x70	; 112
    244e:	c3 07       	cpc	r28, r19
    2450:	00 00       	nop
    2452:	38 d6       	rcall	.+3184   	; 0x30c4 <__data_load_end+0x2338>
    2454:	07 00       	.word	0x0007	; ????
    2456:	00 31       	cpi	r16, 0x10	; 16
    2458:	17 00       	.word	0x0017	; ????
    245a:	00 38       	cpi	r16, 0x80	; 128
    245c:	cd 07       	cpc	r28, r29
    245e:	00 00       	nop
    2460:	45 17       	cp	r20, r21
    2462:	00 00       	nop
    2464:	5c 9e       	mul	r5, r28
    2466:	0c 00       	.word	0x000c	; ????
    2468:	00 48       	sbci	r16, 0x80	; 128
    246a:	19 00       	.word	0x0019	; ????
    246c:	00 4a       	sbci	r16, 0xA0	; 160
    246e:	0c 66       	ori	r16, 0x6C	; 108
    2470:	93 01       	movw	r18, r6
    2472:	67 93       	lat	Z, r22
    2474:	01 68       	ori	r16, 0x81	; 129
    2476:	93 01       	movw	r18, r6
    2478:	69 93       	st	Y+, r22
    247a:	01 05       	cpc	r16, r1
    247c:	0c c0       	rjmp	.+24     	; 0x2496 <__data_load_end+0x170a>
    247e:	c6 2d       	mov	r28, r6
    2480:	00 4a       	sbci	r16, 0xA0	; 160
    2482:	01 64       	ori	r16, 0x41	; 65
    2484:	01 3a       	cpi	r16, 0xA1	; 161
    2486:	00 00       	nop
    2488:	45 e7       	ldi	r20, 0x75	; 117
    248a:	07 00       	.word	0x0007	; ????
    248c:	00 a4       	ldd	r0, Z+40	; 0x28
    248e:	0c 00       	.word	0x000c	; ????
    2490:	00 ac       	ldd	r0, Z+56	; 0x38
    2492:	0c 00       	.word	0x000c	; ????
    2494:	00 0d       	add	r16, r0
    2496:	26 ca       	rjmp	.-2996   	; 0x18e4 <__data_load_end+0xb58>
    2498:	1e 00       	.word	0x001e	; ????
    249a:	00 57       	subi	r16, 0x70	; 112
    249c:	f5 07       	cpc	r31, r21
    249e:	00 00       	nop
    24a0:	57 ff       	sbrs	r21, 7
    24a2:	07 00       	.word	0x0007	; ????
    24a4:	00 5c       	subi	r16, 0xC0	; 192
    24a6:	ac 0c       	add	r10, r12
    24a8:	00 00       	nop
    24aa:	f7 18       	sub	r15, r7
    24ac:	00 00       	nop
    24ae:	4a 06       	cpc	r4, r26
    24b0:	68 93       	.word	0x9368	; ????
    24b2:	01 69       	ori	r16, 0x91	; 145
    24b4:	93 01       	movw	r18, r6
    24b6:	05 03       	mulsu	r16, r21
    24b8:	3a 01       	movw	r6, r20
    24ba:	80 00       	.word	0x0080	; ????
    24bc:	00 00       	nop
    24be:	45 b5       	in	r20, 0x25	; 37
    24c0:	07 00       	.word	0x0007	; ????
    24c2:	00 ac       	ldd	r0, Z+56	; 0x38
    24c4:	0c 00       	.word	0x000c	; ????
    24c6:	00 d2       	rcall	.+1024   	; 0x28c8 <__data_load_end+0x1b3c>
    24c8:	0c 00       	.word	0x000c	; ????
    24ca:	00 0d       	add	r16, r0
    24cc:	27 04       	cpc	r2, r7
    24ce:	1f 00       	.word	0x001f	; ????
    24d0:	00 57       	subi	r16, 0x70	; 112
    24d2:	c3 07       	cpc	r28, r19
    24d4:	00 00       	nop
    24d6:	38 d6       	rcall	.+3184   	; 0x3148 <__data_load_end+0x23bc>
    24d8:	07 00       	.word	0x0007	; ????
    24da:	00 5d       	subi	r16, 0xD0	; 208
    24dc:	17 00       	.word	0x0017	; ????
    24de:	00 38       	cpi	r16, 0x80	; 128
    24e0:	cd 07       	cpc	r28, r29
    24e2:	00 00       	nop
    24e4:	71 17       	cp	r23, r17
    24e6:	00 00       	nop
    24e8:	5c d2       	rcall	.+1208   	; 0x29a2 <__data_load_end+0x1c16>
    24ea:	0c 00       	.word	0x000c	; ????
    24ec:	00 48       	sbci	r16, 0x80	; 128
    24ee:	19 00       	.word	0x0019	; ????
    24f0:	00 4a       	sbci	r16, 0xA0	; 160
    24f2:	01 64       	ori	r16, 0x41	; 65
    24f4:	01 3a       	cpi	r16, 0xA1	; 161
    24f6:	00 00       	nop
    24f8:	45 e7       	ldi	r20, 0x75	; 117
    24fa:	07 00       	.word	0x0007	; ????
    24fc:	00 d2       	rcall	.+1024   	; 0x28fe <__data_load_end+0x1b72>
    24fe:	0c 00       	.word	0x000c	; ????
    2500:	00 da       	rcall	.-3072   	; 0x1902 <__data_load_end+0xb76>
    2502:	0c 00       	.word	0x000c	; ????
    2504:	00 0d       	add	r16, r0
    2506:	28 3a       	cpi	r18, 0xA8	; 168
    2508:	1f 00       	.word	0x001f	; ????
    250a:	00 57       	subi	r16, 0x70	; 112
    250c:	f5 07       	cpc	r31, r21
    250e:	00 00       	nop
    2510:	57 ff       	sbrs	r21, 7
    2512:	07 00       	.word	0x0007	; ????
    2514:	00 5c       	subi	r16, 0xC0	; 192
    2516:	da 0c       	add	r13, r10
    2518:	00 00       	nop
    251a:	f7 18       	sub	r15, r7
    251c:	00 00       	nop
    251e:	4a 06       	cpc	r4, r26
    2520:	68 93       	.word	0x9368	; ????
    2522:	01 69       	ori	r16, 0x91	; 145
    2524:	93 01       	movw	r18, r6
    2526:	05 03       	mulsu	r16, r21
    2528:	41 01       	movw	r8, r2
    252a:	80 00       	.word	0x0080	; ????
    252c:	00 00       	nop
    252e:	49 88       	ldd	r4, Y+17	; 0x11
    2530:	0c 00       	.word	0x000c	; ????
    2532:	00 89       	ldd	r16, Z+16	; 0x10
    2534:	14 00       	.word	0x0014	; ????
    2536:	00 4d       	sbci	r16, 0xD0	; 208
    2538:	1f 00       	.word	0x001f	; ????
    253a:	00 4a       	sbci	r16, 0xA0	; 160
    253c:	01 68       	ori	r16, 0x81	; 129
    253e:	01 30       	cpi	r16, 0x01	; 1
    2540:	00 5c       	subi	r16, 0xC0	; 192
    2542:	a4 0c       	add	r10, r4
    2544:	00 00       	nop
    2546:	89 14       	cp	r8, r9
    2548:	00 00       	nop
    254a:	4a 01       	movw	r8, r20
    254c:	68 01       	movw	r12, r16
    254e:	31 00       	.word	0x0031	; ????
    2550:	00 00       	nop
    2552:	67 e6       	ldi	r22, 0x67	; 103
    2554:	0c 00       	.word	0x000c	; ????
    2556:	00 00       	nop
    2558:	76 35       	cpi	r23, 0x56	; 86
    255a:	06 00       	.word	0x0006	; ????
    255c:	00 05       	cpc	r16, r0
    255e:	86 01       	movw	r16, r12
    2560:	01 01       	movw	r0, r2
    2562:	77 01       	movw	r14, r14
    2564:	f6 07       	cpc	r31, r22
    2566:	00 00       	nop
    2568:	05 8f       	std	Z+29, r16	; 0x1d
    256a:	01 01       	movw	r0, r2
    256c:	f6 07       	cpc	r31, r22
    256e:	00 00       	nop
    2570:	4a 0a       	sbc	r4, r26
    2572:	00 00       	nop
    2574:	a3 17       	cp	r26, r19
    2576:	00 00       	nop
    2578:	01 33       	cpi	r16, 0x31	; 49
    257a:	20 00       	.word	0x0020	; ????
    257c:	00 78       	andi	r16, 0x80	; 128
    257e:	33 20       	and	r3, r3
    2580:	00 00       	nop
    2582:	06 09       	sbc	r16, r6
    2584:	00 00       	nop
    2586:	0a 09       	sbc	r16, r10
    2588:	00 00       	nop
    258a:	05 a1       	ldd	r16, Z+37	; 0x25
    258c:	01 ae       	std	Z+57, r0	; 0x39
    258e:	1f 00       	.word	0x001f	; ????
    2590:	00 79       	andi	r16, 0x90	; 144
    2592:	61 63       	ori	r22, 0x31	; 49
    2594:	6b 00       	.word	0x006b	; ????
    2596:	05 8f       	std	Z+29, r16	; 0x1d
    2598:	01 51       	subi	r16, 0x11	; 17
    259a:	01 00       	.word	0x0001	; ????
    259c:	00 6e       	ori	r16, 0xE0	; 224
    259e:	18 00       	.word	0x0018	; ????
    25a0:	00 00       	nop
    25a2:	7a 64       	ori	r23, 0x4A	; 74
    25a4:	1f 00       	.word	0x001f	; ????
    25a6:	00 8c       	ldd	r0, Z+24	; 0x18
    25a8:	09 00       	.word	0x0009	; ????
    25aa:	00 96       	adiw	r24, 0x00	; 0
    25ac:	09 00       	.word	0x0009	; ????
    25ae:	00 05       	cpc	r16, r0
    25b0:	f4 01       	movw	r30, r8
    25b2:	78 33       	cpi	r23, 0x38	; 56
    25b4:	20 00       	.word	0x0020	; ????
    25b6:	00 0c       	add	r0, r0
    25b8:	0a 00       	.word	0x000a	; ????
    25ba:	00 14       	cp	r0, r0
    25bc:	0a 00       	.word	0x000a	; ????
    25be:	00 05       	cpc	r16, r0
    25c0:	1d 02       	muls	r17, r29
    25c2:	e3 1f       	adc	r30, r19
    25c4:	00 00       	nop
    25c6:	79 61       	ori	r23, 0x19	; 25
    25c8:	63 6b       	ori	r22, 0xB3	; 179
    25ca:	00 05       	cpc	r16, r0
    25cc:	8f 01       	movw	r16, r30
    25ce:	51 01       	movw	r10, r2
    25d0:	00 00       	nop
    25d2:	82 18       	sub	r8, r2
    25d4:	00 00       	nop
    25d6:	00 78       	andi	r16, 0x80	; 128
    25d8:	33 20       	and	r3, r3
    25da:	00 00       	nop
    25dc:	14 0a       	sbc	r1, r20
    25de:	00 00       	nop
    25e0:	1a 0a       	sbc	r1, r26
    25e2:	00 00       	nop
    25e4:	05 23       	and	r16, r21
    25e6:	02 08       	sbc	r0, r2
    25e8:	20 00       	.word	0x0020	; ????
    25ea:	00 79       	andi	r16, 0x90	; 144
    25ec:	61 63       	ori	r22, 0x31	; 49
    25ee:	6b 00       	.word	0x006b	; ????
    25f0:	05 8f       	std	Z+29, r16	; 0x1d
    25f2:	01 51       	subi	r16, 0x11	; 17
    25f4:	01 00       	.word	0x0001	; ????
    25f6:	00 96       	adiw	r24, 0x00	; 0
    25f8:	18 00       	.word	0x0018	; ????
    25fa:	00 00       	nop
    25fc:	7b ba       	out	0x1b, r7	; 27
    25fe:	09 00       	.word	0x0009	; ????
    2600:	00 01       	movw	r0, r0
    2602:	30 22       	and	r3, r16
    2604:	20 00       	.word	0x0020	; ????
    2606:	00 4a       	sbci	r16, 0xA0	; 160
    2608:	06 68       	ori	r16, 0x86	; 134
    260a:	93 01       	movw	r18, r6
    260c:	69 93       	st	Y+, r22
    260e:	01 05       	cpc	r16, r1
    2610:	03 69       	ori	r16, 0x93	; 147
    2612:	01 80       	ldd	r0, Z+1	; 0x01
    2614:	00 00       	nop
    2616:	7c d4       	rcall	.+2296   	; 0x2f10 <__data_load_end+0x2184>
    2618:	09 00       	.word	0x0009	; ????
    261a:	00 01       	movw	r0, r0
    261c:	30 47       	sbci	r19, 0x70	; 112
    261e:	28 0a       	sbc	r2, r24
    2620:	00 00       	nop
    2622:	d5 0f       	add	r29, r21
    2624:	00 00       	nop
    2626:	00 76       	andi	r16, 0x60	; 96
    2628:	ca 08       	sbc	r12, r10
    262a:	00 00       	nop
    262c:	05 61       	ori	r16, 0x15	; 21
    262e:	01 01       	movw	r0, r2
    2630:	01 7d       	andi	r16, 0xD1	; 209
    2632:	0c 03       	fmul	r16, r20
    2634:	00 00       	nop
    2636:	06 23       	and	r16, r22
    2638:	51 01       	movw	r10, r2
    263a:	00 00       	nop
    263c:	03 05       	cpc	r16, r3
    263e:	03 46       	sbci	r16, 0x63	; 99
    2640:	01 80       	ldd	r0, Z+1	; 0x01
    2642:	00 24       	eor	r0, r0
    2644:	51 01       	movw	r10, r2
    2646:	00 00       	nop
    2648:	5f 20       	and	r5, r15
    264a:	00 00       	nop
    264c:	25 7e       	andi	r18, 0xE5	; 229
    264e:	05 00       	.word	0x0005	; ????
    2650:	00 1f       	adc	r16, r16
    2652:	00 42       	sbci	r16, 0x20	; 32
    2654:	47 08       	sbc	r4, r7
    2656:	00 00       	nop
    2658:	05 35       	cpi	r16, 0x55	; 85
    265a:	4f 20       	and	r4, r15
    265c:	00 00       	nop
    265e:	05 03       	mulsu	r16, r21
    2660:	47 01       	movw	r8, r14
    2662:	80 00       	.word	0x0080	; ????
    2664:	42 65       	ori	r20, 0x52	; 82
    2666:	04 00       	.word	0x0004	; ????
    2668:	00 05       	cpc	r16, r0
    266a:	37 42       	sbci	r19, 0x27	; 39
    266c:	0a 00       	.word	0x000a	; ????
    266e:	00 05       	cpc	r16, r0
    2670:	03 67       	ori	r16, 0x73	; 115
    2672:	01 80       	ldd	r0, Z+1	; 0x01
    2674:	00 42       	sbci	r16, 0x20	; 32
    2676:	64 06       	cpc	r6, r20
    2678:	00 00       	nop
    267a:	05 36       	cpi	r16, 0x65	; 101
    267c:	42 0a       	sbc	r4, r18
    267e:	00 00       	nop
    2680:	05 03       	mulsu	r16, r21
    2682:	68 01       	movw	r12, r16
    2684:	80 00       	.word	0x0080	; ????
    2686:	42 49       	sbci	r20, 0x92	; 146
    2688:	07 00       	.word	0x0007	; ????
    268a:	00 05       	cpc	r16, r0
    268c:	39 4f       	sbci	r19, 0xF9	; 249
    268e:	20 00       	.word	0x0020	; ????
    2690:	00 05       	cpc	r16, r0
    2692:	03 69       	ori	r16, 0x93	; 147
    2694:	01 80       	ldd	r0, Z+1	; 0x01
    2696:	00 42       	sbci	r16, 0x20	; 32
    2698:	08 03       	fmul	r16, r16
    269a:	00 00       	nop
    269c:	05 3a       	cpi	r16, 0xA5	; 165
    269e:	42 0a       	sbc	r4, r18
    26a0:	00 00       	nop
    26a2:	05 03       	mulsu	r16, r21
    26a4:	89 01       	movw	r16, r18
    26a6:	80 00       	.word	0x0080	; ????
    26a8:	42 d8       	rcall	.-3964   	; 0x172e <__data_load_end+0x9a2>
    26aa:	07 00       	.word	0x0007	; ????
    26ac:	00 05       	cpc	r16, r0
    26ae:	3c 42       	sbci	r19, 0x2C	; 44
    26b0:	0a 00       	.word	0x000a	; ????
    26b2:	00 05       	cpc	r16, r0
    26b4:	03 8a       	std	Z+19, r0	; 0x13
    26b6:	01 80       	ldd	r0, Z+1	; 0x01
    26b8:	00 42       	sbci	r16, 0x20	; 32
    26ba:	10 02       	muls	r17, r16
    26bc:	00 00       	nop
    26be:	05 29       	or	r16, r5
    26c0:	42 0a       	sbc	r4, r18
    26c2:	00 00       	nop
    26c4:	05 03       	mulsu	r16, r21
    26c6:	8b 01       	movw	r16, r22
    26c8:	80 00       	.word	0x0080	; ????
    26ca:	42 e7       	ldi	r20, 0x72	; 114
    26cc:	05 00       	.word	0x0005	; ????
    26ce:	00 05       	cpc	r16, r0
    26d0:	2c 42       	sbci	r18, 0x2C	; 44
    26d2:	0a 00       	.word	0x000a	; ????
    26d4:	00 05       	cpc	r16, r0
    26d6:	03 8c       	ldd	r0, Z+27	; 0x1b
    26d8:	01 80       	ldd	r0, Z+1	; 0x01
    26da:	00 42       	sbci	r16, 0x20	; 32
    26dc:	c9 02       	muls	r28, r25
    26de:	00 00       	nop
    26e0:	05 2b       	or	r16, r21
    26e2:	42 0a       	sbc	r4, r18
    26e4:	00 00       	nop
    26e6:	05 03       	mulsu	r16, r21
    26e8:	8d 01       	movw	r16, r26
    26ea:	80 00       	.word	0x0080	; ????
    26ec:	42 c2       	rjmp	.+1156   	; 0x2b72 <__data_load_end+0x1de6>
    26ee:	04 00       	.word	0x0004	; ????
    26f0:	00 05       	cpc	r16, r0
    26f2:	31 4f       	sbci	r19, 0xF1	; 241
    26f4:	20 00       	.word	0x0020	; ????
    26f6:	00 05       	cpc	r16, r0
    26f8:	03 8e       	std	Z+27, r0	; 0x1b
    26fa:	01 80       	ldd	r0, Z+1	; 0x01
    26fc:	00 42       	sbci	r16, 0x20	; 32
    26fe:	74 02       	muls	r23, r20
    2700:	00 00       	nop
    2702:	05 33       	cpi	r16, 0x35	; 53
    2704:	42 0a       	sbc	r4, r18
    2706:	00 00       	nop
    2708:	05 03       	mulsu	r16, r21
    270a:	ae 01       	movw	r20, r28
    270c:	80 00       	.word	0x0080	; ????
    270e:	42 f7       	brpl	.-48     	; 0x26e0 <__data_load_end+0x1954>
    2710:	06 00       	.word	0x0006	; ????
    2712:	00 05       	cpc	r16, r0
    2714:	32 42       	sbci	r19, 0x22	; 34
    2716:	0a 00       	.word	0x000a	; ????
    2718:	00 05       	cpc	r16, r0
    271a:	03 af       	std	Z+59, r16	; 0x3b
    271c:	01 80       	ldd	r0, Z+1	; 0x01
    271e:	00 42       	sbci	r16, 0x20	; 32
    2720:	e1 04       	cpc	r14, r1
    2722:	00 00       	nop
    2724:	05 2a       	or	r0, r21
    2726:	42 0a       	sbc	r4, r18
    2728:	00 00       	nop
    272a:	05 03       	mulsu	r16, r21
    272c:	b0 01       	movw	r22, r0
    272e:	80 00       	.word	0x0080	; ????
    2730:	42 bc       	out	0x22, r4	; 34
    2732:	08 00       	.word	0x0008	; ????
    2734:	00 0d       	add	r16, r0
    2736:	0a e9       	ldi	r16, 0x9A	; 154
    2738:	05 00       	.word	0x0005	; ????
    273a:	00 05       	cpc	r16, r0
    273c:	03 b1       	in	r16, 0x03	; 3
    273e:	01 80       	ldd	r0, Z+1	; 0x01
    2740:	00 42       	sbci	r16, 0x20	; 32
    2742:	30 03       	mulsu	r19, r16
    2744:	00 00       	nop
    2746:	0d 0c       	add	r0, r13
    2748:	e9 05       	cpc	r30, r9
    274a:	00 00       	nop
    274c:	05 03       	mulsu	r16, r21
    274e:	00 01       	movw	r0, r0
    2750:	80 00       	.word	0x0080	; ????
    2752:	42 3f       	cpi	r20, 0xF2	; 242
    2754:	02 00       	.word	0x0002	; ????
    2756:	00 03       	mulsu	r16, r16
    2758:	28 5c       	subi	r18, 0xC8	; 200
    275a:	01 00       	.word	0x0001	; ????
    275c:	00 05       	cpc	r16, r0
    275e:	03 b5       	in	r16, 0x23	; 35
    2760:	01 80       	ldd	r0, Z+1	; 0x01
    2762:	00 42       	sbci	r16, 0x20	; 32
    2764:	d5 03       	fmuls	r21, r21
    2766:	00 00       	nop
    2768:	03 27       	eor	r16, r19
    276a:	87 21       	and	r24, r7
    276c:	00 00       	nop
    276e:	05 03       	mulsu	r16, r21
    2770:	b6 01       	movw	r22, r12
    2772:	80 00       	.word	0x0080	; ????
    2774:	0f 04       	cpc	r0, r15
    2776:	07 23       	and	r16, r23
    2778:	06 00       	.word	0x0006	; ????
    277a:	00 35       	cpi	r16, 0x50	; 80
    277c:	80 21       	and	r24, r0
    277e:	00 00       	nop
    2780:	42 25       	eor	r20, r2
    2782:	04 00       	.word	0x0004	; ????
    2784:	00 03       	mulsu	r16, r16
    2786:	26 87       	std	Z+14, r18	; 0x0e
    2788:	21 00       	.word	0x0021	; ????
    278a:	00 05       	cpc	r16, r0
    278c:	03 ba       	out	0x13, r0	; 19
    278e:	01 80       	ldd	r0, Z+1	; 0x01
    2790:	00 24       	eor	r0, r0
    2792:	6b 0f       	add	r22, r27
    2794:	00 00       	nop
    2796:	ad 21       	and	r26, r13
    2798:	00 00       	nop
    279a:	25 7e       	andi	r18, 0xE5	; 229
    279c:	05 00       	.word	0x0005	; ????
    279e:	00 13       	cpse	r16, r16
    27a0:	00 42       	sbci	r16, 0x20	; 32
    27a2:	6f 08       	sbc	r6, r15
    27a4:	00 00       	nop
    27a6:	13 c4       	rjmp	.+2086   	; 0x2fce <__data_load_end+0x2242>
    27a8:	be 21       	and	r27, r14
    27aa:	00 00       	nop
    27ac:	05 03       	mulsu	r16, r21
    27ae:	68 00       	.word	0x0068	; ????
    27b0:	00 00       	nop
    27b2:	28 9d       	mul	r18, r8
    27b4:	21 00       	.word	0x0021	; ????
    27b6:	00 24       	eor	r0, r0
    27b8:	d3 21       	and	r29, r3
    27ba:	00 00       	nop
    27bc:	d3 21       	and	r29, r3
    27be:	00 00       	nop
    27c0:	25 7e       	andi	r18, 0xE5	; 229
    27c2:	05 00       	.word	0x0005	; ????
    27c4:	00 04       	cpc	r0, r0
    27c6:	00 28       	or	r0, r0
    27c8:	0e 07       	cpc	r16, r30
    27ca:	00 00       	nop
    27cc:	42 d4       	rcall	.+2180   	; 0x3052 <__data_load_end+0x22c6>
    27ce:	05 00       	.word	0x0005	; ????
    27d0:	00 13       	cpse	r16, r16
    27d2:	86 e9       	ldi	r24, 0x96	; 150
    27d4:	21 00       	.word	0x0021	; ????
    27d6:	00 05       	cpc	r16, r0
    27d8:	03 7c       	andi	r16, 0xC3	; 195
    27da:	00 00       	nop
    27dc:	00 28       	or	r0, r0
    27de:	c3 21       	and	r28, r3
    27e0:	00 00       	nop
    27e2:	42 07       	cpc	r20, r18
    27e4:	04 00       	.word	0x0004	; ????
    27e6:	00 13       	cpse	r16, r16
    27e8:	7e ff       	.word	0xff7e	; ????
    27ea:	21 00       	.word	0x0021	; ????
    27ec:	00 05       	cpc	r16, r0
    27ee:	03 86       	std	Z+11, r0	; 0x0b
    27f0:	00 00       	nop
    27f2:	00 28       	or	r0, r0
    27f4:	c3 21       	and	r28, r3
    27f6:	00 00       	nop
    27f8:	42 ab       	std	Z+50, r20	; 0x32
    27fa:	03 00       	.word	0x0003	; ????
    27fc:	00 13       	cpse	r16, r16
    27fe:	96 15       	cp	r25, r6
    2800:	22 00       	.word	0x0022	; ????
    2802:	00 05       	cpc	r16, r0
    2804:	03 90       	.word	0x9003	; ????
    2806:	00 00       	nop
    2808:	00 28       	or	r0, r0
    280a:	9d 21       	and	r25, r13
    280c:	00 00       	nop
    280e:	42 58       	subi	r20, 0x82	; 130
    2810:	02 00       	.word	0x0002	; ????
    2812:	00 13       	cpse	r16, r16
    2814:	ad 2b       	or	r26, r29
    2816:	22 00       	.word	0x0022	; ????
    2818:	00 05       	cpc	r16, r0
    281a:	03 a4       	ldd	r0, Z+43	; 0x2b
    281c:	00 00       	nop
    281e:	00 28       	or	r0, r0
    2820:	9d 21       	and	r25, r13
    2822:	00 00       	nop
    2824:	7e 9d       	mul	r23, r14
    2826:	08 00       	.word	0x0008	; ????
    2828:	00 06       	cpc	r0, r16
    282a:	4a 01       	movw	r8, r20
    282c:	fb 05       	cpc	r31, r11
    282e:	00 00       	nop
    2830:	05 03       	mulsu	r16, r21
    2832:	be 01       	movw	r22, r28
    2834:	80 00       	.word	0x0080	; ????
    2836:	26 a7       	std	Z+46, r18	; 0x2e
    2838:	08 00       	.word	0x0008	; ????
    283a:	00 01       	movw	r0, r0
    283c:	4d 6c       	ori	r20, 0xCD	; 205
    283e:	63 64       	ori	r22, 0x43	; 67
    2840:	00 0d       	add	r16, r0
    2842:	07 42       	sbci	r16, 0x27	; 39
    2844:	22 00       	.word	0x0022	; ????
    2846:	00 05       	cpc	r16, r0
    2848:	03 ca       	rjmp	.-3066   	; 0x1c50 <__data_load_end+0xec4>
    284a:	01 80       	ldd	r0, Z+1	; 0x01
    284c:	00 00       	nop
    284e:	aa 00       	.word	0x00aa	; ????
    2850:	00 00       	nop
    2852:	02 00       	.word	0x0002	; ????
    2854:	00 0d       	add	r16, r0
    2856:	00 00       	nop
    2858:	04 01       	movw	r0, r8
    285a:	42 0e       	add	r4, r18
    285c:	00 00       	nop
    285e:	42 0d       	add	r20, r2
    2860:	00 00       	nop
    2862:	46 0d       	add	r20, r6
    2864:	00 00       	nop
    2866:	2e 2e       	mov	r2, r30
    2868:	2f 2e       	mov	r2, r31
    286a:	2e 2f       	mov	r18, r30
    286c:	2e 2e       	mov	r2, r30
    286e:	2f 2e       	mov	r2, r31
    2870:	2e 2f       	mov	r18, r30
    2872:	67 63       	ori	r22, 0x37	; 55
    2874:	63 2f       	mov	r22, r19
    2876:	6c 69       	ori	r22, 0x9C	; 156
    2878:	62 67       	ori	r22, 0x72	; 114
    287a:	63 63       	ori	r22, 0x33	; 51
    287c:	2f 63       	ori	r18, 0x3F	; 63
    287e:	6f 6e       	ori	r22, 0xEF	; 239
    2880:	66 69       	ori	r22, 0x96	; 150
    2882:	67 2f       	mov	r22, r23
    2884:	61 76       	andi	r22, 0x61	; 97
    2886:	72 2f       	mov	r23, r18
    2888:	6c 69       	ori	r22, 0x9C	; 156
    288a:	62 31       	cpi	r22, 0x12	; 18
    288c:	66 75       	andi	r22, 0x56	; 86
    288e:	6e 63       	ori	r22, 0x3E	; 62
    2890:	73 2e       	mov	r7, r19
    2892:	53 00       	.word	0x0053	; ????
    2894:	2f 55       	subi	r18, 0x5F	; 95
    2896:	73 65       	ori	r23, 0x53	; 83
    2898:	72 73       	andi	r23, 0x32	; 50
    289a:	2f 6a       	ori	r18, 0xAF	; 175
    289c:	65 6e       	ori	r22, 0xE5	; 229
    289e:	6b 69       	ori	r22, 0x9B	; 155
    28a0:	6e 73       	andi	r22, 0x3E	; 62
    28a2:	2f 6a       	ori	r18, 0xAF	; 175
    28a4:	65 6e       	ori	r22, 0xE5	; 229
    28a6:	6b 69       	ori	r22, 0x9B	; 155
    28a8:	6e 73       	andi	r22, 0x3E	; 62
    28aa:	2f 77       	andi	r18, 0x7F	; 127
    28ac:	6f 72       	andi	r22, 0x2F	; 47
    28ae:	6b 73       	andi	r22, 0x3B	; 59
    28b0:	70 61       	ori	r23, 0x10	; 16
    28b2:	63 65       	ori	r22, 0x53	; 83
    28b4:	2f 61       	ori	r18, 0x1F	; 31
    28b6:	76 72       	andi	r23, 0x26	; 38
    28b8:	2d 67       	ori	r18, 0x7D	; 125
    28ba:	63 63       	ori	r22, 0x33	; 51
    28bc:	2d 73       	andi	r18, 0x3D	; 61
    28be:	74 61       	ori	r23, 0x14	; 20
    28c0:	67 69       	ori	r22, 0x97	; 151
    28c2:	6e 67       	ori	r22, 0x7E	; 126
    28c4:	2f 6c       	ori	r18, 0xCF	; 207
    28c6:	61 62       	ori	r22, 0x21	; 33
    28c8:	65 6c       	ori	r22, 0xC5	; 197
    28ca:	2f 6d       	ori	r18, 0xDF	; 223
    28cc:	61 63       	ori	r22, 0x31	; 49
    28ce:	2d 6d       	ori	r18, 0xDD	; 221
    28d0:	69 6e       	ori	r22, 0xE9	; 233
    28d2:	69 2f       	mov	r22, r25
    28d4:	67 63       	ori	r22, 0x37	; 55
    28d6:	63 2d       	mov	r22, r3
    28d8:	62 75       	andi	r22, 0x52	; 82
    28da:	69 6c       	ori	r22, 0xC9	; 201
    28dc:	64 2f       	mov	r22, r20
    28de:	61 76       	andi	r22, 0x61	; 97
    28e0:	72 2f       	mov	r23, r18
    28e2:	61 76       	andi	r22, 0x61	; 97
    28e4:	72 35       	cpi	r23, 0x52	; 82
    28e6:	2f 6c       	ori	r18, 0xCF	; 207
    28e8:	69 62       	ori	r22, 0x29	; 41
    28ea:	67 63       	ori	r22, 0x37	; 55
    28ec:	63 00       	.word	0x0063	; ????
    28ee:	47 4e       	sbci	r20, 0xE7	; 231
    28f0:	55 20       	and	r5, r5
    28f2:	41 53       	subi	r20, 0x31	; 49
    28f4:	20 32       	cpi	r18, 0x20	; 32
    28f6:	2e 32       	cpi	r18, 0x2E	; 46
    28f8:	36 00       	.word	0x0036	; ????
    28fa:	01 80       	ldd	r0, Z+1	; 0x01
    28fc:	aa 00       	.word	0x00aa	; ????
    28fe:	00 00       	nop
    2900:	02 00       	.word	0x0002	; ????
    2902:	14 0d       	add	r17, r4
    2904:	00 00       	nop
    2906:	04 01       	movw	r0, r8
    2908:	a4 0e       	add	r10, r20
    290a:	00 00       	nop
    290c:	e8 0c       	add	r14, r8
    290e:	00 00       	nop
    2910:	2c 0d       	add	r18, r12
    2912:	00 00       	nop
    2914:	2e 2e       	mov	r2, r30
    2916:	2f 2e       	mov	r2, r31
    2918:	2e 2f       	mov	r18, r30
    291a:	2e 2e       	mov	r2, r30
    291c:	2f 2e       	mov	r2, r31
    291e:	2e 2f       	mov	r18, r30
    2920:	67 63       	ori	r22, 0x37	; 55
    2922:	63 2f       	mov	r22, r19
    2924:	6c 69       	ori	r22, 0x9C	; 156
    2926:	62 67       	ori	r22, 0x72	; 114
    2928:	63 63       	ori	r22, 0x33	; 51
    292a:	2f 63       	ori	r18, 0x3F	; 63
    292c:	6f 6e       	ori	r22, 0xEF	; 239
    292e:	66 69       	ori	r22, 0x96	; 150
    2930:	67 2f       	mov	r22, r23
    2932:	61 76       	andi	r22, 0x61	; 97
    2934:	72 2f       	mov	r23, r18
    2936:	6c 69       	ori	r22, 0x9C	; 156
    2938:	62 31       	cpi	r22, 0x12	; 18
    293a:	66 75       	andi	r22, 0x56	; 86
    293c:	6e 63       	ori	r22, 0x3E	; 62
    293e:	73 2e       	mov	r7, r19
    2940:	53 00       	.word	0x0053	; ????
    2942:	2f 55       	subi	r18, 0x5F	; 95
    2944:	73 65       	ori	r23, 0x53	; 83
    2946:	72 73       	andi	r23, 0x32	; 50
    2948:	2f 6a       	ori	r18, 0xAF	; 175
    294a:	65 6e       	ori	r22, 0xE5	; 229
    294c:	6b 69       	ori	r22, 0x9B	; 155
    294e:	6e 73       	andi	r22, 0x3E	; 62
    2950:	2f 6a       	ori	r18, 0xAF	; 175
    2952:	65 6e       	ori	r22, 0xE5	; 229
    2954:	6b 69       	ori	r22, 0x9B	; 155
    2956:	6e 73       	andi	r22, 0x3E	; 62
    2958:	2f 77       	andi	r18, 0x7F	; 127
    295a:	6f 72       	andi	r22, 0x2F	; 47
    295c:	6b 73       	andi	r22, 0x3B	; 59
    295e:	70 61       	ori	r23, 0x10	; 16
    2960:	63 65       	ori	r22, 0x53	; 83
    2962:	2f 61       	ori	r18, 0x1F	; 31
    2964:	76 72       	andi	r23, 0x26	; 38
    2966:	2d 67       	ori	r18, 0x7D	; 125
    2968:	63 63       	ori	r22, 0x33	; 51
    296a:	2d 73       	andi	r18, 0x3D	; 61
    296c:	74 61       	ori	r23, 0x14	; 20
    296e:	67 69       	ori	r22, 0x97	; 151
    2970:	6e 67       	ori	r22, 0x7E	; 126
    2972:	2f 6c       	ori	r18, 0xCF	; 207
    2974:	61 62       	ori	r22, 0x21	; 33
    2976:	65 6c       	ori	r22, 0xC5	; 197
    2978:	2f 6d       	ori	r18, 0xDF	; 223
    297a:	61 63       	ori	r22, 0x31	; 49
    297c:	2d 6d       	ori	r18, 0xDD	; 221
    297e:	69 6e       	ori	r22, 0xE9	; 233
    2980:	69 2f       	mov	r22, r25
    2982:	67 63       	ori	r22, 0x37	; 55
    2984:	63 2d       	mov	r22, r3
    2986:	62 75       	andi	r22, 0x52	; 82
    2988:	69 6c       	ori	r22, 0xC9	; 201
    298a:	64 2f       	mov	r22, r20
    298c:	61 76       	andi	r22, 0x61	; 97
    298e:	72 2f       	mov	r23, r18
    2990:	61 76       	andi	r22, 0x61	; 97
    2992:	72 35       	cpi	r23, 0x52	; 82
    2994:	2f 6c       	ori	r18, 0xCF	; 207
    2996:	69 62       	ori	r22, 0x29	; 41
    2998:	67 63       	ori	r22, 0x37	; 55
    299a:	63 00       	.word	0x0063	; ????
    299c:	47 4e       	sbci	r20, 0xE7	; 231
    299e:	55 20       	and	r5, r5
    29a0:	41 53       	subi	r20, 0x31	; 49
    29a2:	20 32       	cpi	r18, 0x20	; 32
    29a4:	2e 32       	cpi	r18, 0x2E	; 46
    29a6:	36 00       	.word	0x0036	; ????
    29a8:	01 80       	ldd	r0, Z+1	; 0x01
    29aa:	aa 00       	.word	0x00aa	; ????
    29ac:	00 00       	nop
    29ae:	02 00       	.word	0x0002	; ????
    29b0:	28 0d       	add	r18, r8
    29b2:	00 00       	nop
    29b4:	04 01       	movw	r0, r8
    29b6:	c6 0f       	add	r28, r22
    29b8:	00 00       	nop
    29ba:	c6 00       	.word	0x00c6	; ????
    29bc:	00 00       	nop
    29be:	dc 00       	.word	0x00dc	; ????
    29c0:	00 00       	nop
    29c2:	2e 2e       	mov	r2, r30
    29c4:	2f 2e       	mov	r2, r31
    29c6:	2e 2f       	mov	r18, r30
    29c8:	2e 2e       	mov	r2, r30
    29ca:	2f 2e       	mov	r2, r31
    29cc:	2e 2f       	mov	r18, r30
    29ce:	67 63       	ori	r22, 0x37	; 55
    29d0:	63 2f       	mov	r22, r19
    29d2:	6c 69       	ori	r22, 0x9C	; 156
    29d4:	62 67       	ori	r22, 0x72	; 114
    29d6:	63 63       	ori	r22, 0x33	; 51
    29d8:	2f 63       	ori	r18, 0x3F	; 63
    29da:	6f 6e       	ori	r22, 0xEF	; 239
    29dc:	66 69       	ori	r22, 0x96	; 150
    29de:	67 2f       	mov	r22, r23
    29e0:	61 76       	andi	r22, 0x61	; 97
    29e2:	72 2f       	mov	r23, r18
    29e4:	6c 69       	ori	r22, 0x9C	; 156
    29e6:	62 31       	cpi	r22, 0x12	; 18
    29e8:	66 75       	andi	r22, 0x56	; 86
    29ea:	6e 63       	ori	r22, 0x3E	; 62
    29ec:	73 2e       	mov	r7, r19
    29ee:	53 00       	.word	0x0053	; ????
    29f0:	2f 55       	subi	r18, 0x5F	; 95
    29f2:	73 65       	ori	r23, 0x53	; 83
    29f4:	72 73       	andi	r23, 0x32	; 50
    29f6:	2f 6a       	ori	r18, 0xAF	; 175
    29f8:	65 6e       	ori	r22, 0xE5	; 229
    29fa:	6b 69       	ori	r22, 0x9B	; 155
    29fc:	6e 73       	andi	r22, 0x3E	; 62
    29fe:	2f 6a       	ori	r18, 0xAF	; 175
    2a00:	65 6e       	ori	r22, 0xE5	; 229
    2a02:	6b 69       	ori	r22, 0x9B	; 155
    2a04:	6e 73       	andi	r22, 0x3E	; 62
    2a06:	2f 77       	andi	r18, 0x7F	; 127
    2a08:	6f 72       	andi	r22, 0x2F	; 47
    2a0a:	6b 73       	andi	r22, 0x3B	; 59
    2a0c:	70 61       	ori	r23, 0x10	; 16
    2a0e:	63 65       	ori	r22, 0x53	; 83
    2a10:	2f 61       	ori	r18, 0x1F	; 31
    2a12:	76 72       	andi	r23, 0x26	; 38
    2a14:	2d 67       	ori	r18, 0x7D	; 125
    2a16:	63 63       	ori	r22, 0x33	; 51
    2a18:	2d 73       	andi	r18, 0x3D	; 61
    2a1a:	74 61       	ori	r23, 0x14	; 20
    2a1c:	67 69       	ori	r22, 0x97	; 151
    2a1e:	6e 67       	ori	r22, 0x7E	; 126
    2a20:	2f 6c       	ori	r18, 0xCF	; 207
    2a22:	61 62       	ori	r22, 0x21	; 33
    2a24:	65 6c       	ori	r22, 0xC5	; 197
    2a26:	2f 6d       	ori	r18, 0xDF	; 223
    2a28:	61 63       	ori	r22, 0x31	; 49
    2a2a:	2d 6d       	ori	r18, 0xDD	; 221
    2a2c:	69 6e       	ori	r22, 0xE9	; 233
    2a2e:	69 2f       	mov	r22, r25
    2a30:	67 63       	ori	r22, 0x37	; 55
    2a32:	63 2d       	mov	r22, r3
    2a34:	62 75       	andi	r22, 0x52	; 82
    2a36:	69 6c       	ori	r22, 0xC9	; 201
    2a38:	64 2f       	mov	r22, r20
    2a3a:	61 76       	andi	r22, 0x61	; 97
    2a3c:	72 2f       	mov	r23, r18
    2a3e:	61 76       	andi	r22, 0x61	; 97
    2a40:	72 35       	cpi	r23, 0x52	; 82
    2a42:	2f 6c       	ori	r18, 0xCF	; 207
    2a44:	69 62       	ori	r22, 0x29	; 41
    2a46:	67 63       	ori	r22, 0x37	; 55
    2a48:	63 00       	.word	0x0063	; ????
    2a4a:	47 4e       	sbci	r20, 0xE7	; 231
    2a4c:	55 20       	and	r5, r5
    2a4e:	41 53       	subi	r20, 0x31	; 49
    2a50:	20 32       	cpi	r18, 0x20	; 32
    2a52:	2e 32       	cpi	r18, 0x2E	; 46
    2a54:	36 00       	.word	0x0036	; ????
    2a56:	01 80       	ldd	r0, Z+1	; 0x01
    2a58:	aa 00       	.word	0x00aa	; ????
    2a5a:	00 00       	nop
    2a5c:	02 00       	.word	0x0002	; ????
    2a5e:	3c 0d       	add	r19, r12
    2a60:	00 00       	nop
    2a62:	04 01       	movw	r0, r8
    2a64:	5e 10       	cpse	r5, r14
    2a66:	00 00       	nop
    2a68:	dc 00       	.word	0x00dc	; ????
    2a6a:	00 00       	nop
    2a6c:	ec 00       	.word	0x00ec	; ????
    2a6e:	00 00       	nop
    2a70:	2e 2e       	mov	r2, r30
    2a72:	2f 2e       	mov	r2, r31
    2a74:	2e 2f       	mov	r18, r30
    2a76:	2e 2e       	mov	r2, r30
    2a78:	2f 2e       	mov	r2, r31
    2a7a:	2e 2f       	mov	r18, r30
    2a7c:	67 63       	ori	r22, 0x37	; 55
    2a7e:	63 2f       	mov	r22, r19
    2a80:	6c 69       	ori	r22, 0x9C	; 156
    2a82:	62 67       	ori	r22, 0x72	; 114
    2a84:	63 63       	ori	r22, 0x33	; 51
    2a86:	2f 63       	ori	r18, 0x3F	; 63
    2a88:	6f 6e       	ori	r22, 0xEF	; 239
    2a8a:	66 69       	ori	r22, 0x96	; 150
    2a8c:	67 2f       	mov	r22, r23
    2a8e:	61 76       	andi	r22, 0x61	; 97
    2a90:	72 2f       	mov	r23, r18
    2a92:	6c 69       	ori	r22, 0x9C	; 156
    2a94:	62 31       	cpi	r22, 0x12	; 18
    2a96:	66 75       	andi	r22, 0x56	; 86
    2a98:	6e 63       	ori	r22, 0x3E	; 62
    2a9a:	73 2e       	mov	r7, r19
    2a9c:	53 00       	.word	0x0053	; ????
    2a9e:	2f 55       	subi	r18, 0x5F	; 95
    2aa0:	73 65       	ori	r23, 0x53	; 83
    2aa2:	72 73       	andi	r23, 0x32	; 50
    2aa4:	2f 6a       	ori	r18, 0xAF	; 175
    2aa6:	65 6e       	ori	r22, 0xE5	; 229
    2aa8:	6b 69       	ori	r22, 0x9B	; 155
    2aaa:	6e 73       	andi	r22, 0x3E	; 62
    2aac:	2f 6a       	ori	r18, 0xAF	; 175
    2aae:	65 6e       	ori	r22, 0xE5	; 229
    2ab0:	6b 69       	ori	r22, 0x9B	; 155
    2ab2:	6e 73       	andi	r22, 0x3E	; 62
    2ab4:	2f 77       	andi	r18, 0x7F	; 127
    2ab6:	6f 72       	andi	r22, 0x2F	; 47
    2ab8:	6b 73       	andi	r22, 0x3B	; 59
    2aba:	70 61       	ori	r23, 0x10	; 16
    2abc:	63 65       	ori	r22, 0x53	; 83
    2abe:	2f 61       	ori	r18, 0x1F	; 31
    2ac0:	76 72       	andi	r23, 0x26	; 38
    2ac2:	2d 67       	ori	r18, 0x7D	; 125
    2ac4:	63 63       	ori	r22, 0x33	; 51
    2ac6:	2d 73       	andi	r18, 0x3D	; 61
    2ac8:	74 61       	ori	r23, 0x14	; 20
    2aca:	67 69       	ori	r22, 0x97	; 151
    2acc:	6e 67       	ori	r22, 0x7E	; 126
    2ace:	2f 6c       	ori	r18, 0xCF	; 207
    2ad0:	61 62       	ori	r22, 0x21	; 33
    2ad2:	65 6c       	ori	r22, 0xC5	; 197
    2ad4:	2f 6d       	ori	r18, 0xDF	; 223
    2ad6:	61 63       	ori	r22, 0x31	; 49
    2ad8:	2d 6d       	ori	r18, 0xDD	; 221
    2ada:	69 6e       	ori	r22, 0xE9	; 233
    2adc:	69 2f       	mov	r22, r25
    2ade:	67 63       	ori	r22, 0x37	; 55
    2ae0:	63 2d       	mov	r22, r3
    2ae2:	62 75       	andi	r22, 0x52	; 82
    2ae4:	69 6c       	ori	r22, 0xC9	; 201
    2ae6:	64 2f       	mov	r22, r20
    2ae8:	61 76       	andi	r22, 0x61	; 97
    2aea:	72 2f       	mov	r23, r18
    2aec:	61 76       	andi	r22, 0x61	; 97
    2aee:	72 35       	cpi	r23, 0x52	; 82
    2af0:	2f 6c       	ori	r18, 0xCF	; 207
    2af2:	69 62       	ori	r22, 0x29	; 41
    2af4:	67 63       	ori	r22, 0x37	; 55
    2af6:	63 00       	.word	0x0063	; ????
    2af8:	47 4e       	sbci	r20, 0xE7	; 231
    2afa:	55 20       	and	r5, r5
    2afc:	41 53       	subi	r20, 0x31	; 49
    2afe:	20 32       	cpi	r18, 0x20	; 32
    2b00:	2e 32       	cpi	r18, 0x2E	; 46
    2b02:	36 00       	.word	0x0036	; ????
    2b04:	01 80       	ldd	r0, Z+1	; 0x01
    2b06:	aa 00       	.word	0x00aa	; ????
    2b08:	00 00       	nop
    2b0a:	02 00       	.word	0x0002	; ????
    2b0c:	50 0d       	add	r21, r0
    2b0e:	00 00       	nop
    2b10:	04 01       	movw	r0, r8
    2b12:	e4 10       	cpse	r14, r4
    2b14:	00 00       	nop
    2b16:	ec 00       	.word	0x00ec	; ????
    2b18:	00 00       	nop
    2b1a:	02 01       	movw	r0, r4
    2b1c:	00 00       	nop
    2b1e:	2e 2e       	mov	r2, r30
    2b20:	2f 2e       	mov	r2, r31
    2b22:	2e 2f       	mov	r18, r30
    2b24:	2e 2e       	mov	r2, r30
    2b26:	2f 2e       	mov	r2, r31
    2b28:	2e 2f       	mov	r18, r30
    2b2a:	67 63       	ori	r22, 0x37	; 55
    2b2c:	63 2f       	mov	r22, r19
    2b2e:	6c 69       	ori	r22, 0x9C	; 156
    2b30:	62 67       	ori	r22, 0x72	; 114
    2b32:	63 63       	ori	r22, 0x33	; 51
    2b34:	2f 63       	ori	r18, 0x3F	; 63
    2b36:	6f 6e       	ori	r22, 0xEF	; 239
    2b38:	66 69       	ori	r22, 0x96	; 150
    2b3a:	67 2f       	mov	r22, r23
    2b3c:	61 76       	andi	r22, 0x61	; 97
    2b3e:	72 2f       	mov	r23, r18
    2b40:	6c 69       	ori	r22, 0x9C	; 156
    2b42:	62 31       	cpi	r22, 0x12	; 18
    2b44:	66 75       	andi	r22, 0x56	; 86
    2b46:	6e 63       	ori	r22, 0x3E	; 62
    2b48:	73 2e       	mov	r7, r19
    2b4a:	53 00       	.word	0x0053	; ????
    2b4c:	2f 55       	subi	r18, 0x5F	; 95
    2b4e:	73 65       	ori	r23, 0x53	; 83
    2b50:	72 73       	andi	r23, 0x32	; 50
    2b52:	2f 6a       	ori	r18, 0xAF	; 175
    2b54:	65 6e       	ori	r22, 0xE5	; 229
    2b56:	6b 69       	ori	r22, 0x9B	; 155
    2b58:	6e 73       	andi	r22, 0x3E	; 62
    2b5a:	2f 6a       	ori	r18, 0xAF	; 175
    2b5c:	65 6e       	ori	r22, 0xE5	; 229
    2b5e:	6b 69       	ori	r22, 0x9B	; 155
    2b60:	6e 73       	andi	r22, 0x3E	; 62
    2b62:	2f 77       	andi	r18, 0x7F	; 127
    2b64:	6f 72       	andi	r22, 0x2F	; 47
    2b66:	6b 73       	andi	r22, 0x3B	; 59
    2b68:	70 61       	ori	r23, 0x10	; 16
    2b6a:	63 65       	ori	r22, 0x53	; 83
    2b6c:	2f 61       	ori	r18, 0x1F	; 31
    2b6e:	76 72       	andi	r23, 0x26	; 38
    2b70:	2d 67       	ori	r18, 0x7D	; 125
    2b72:	63 63       	ori	r22, 0x33	; 51
    2b74:	2d 73       	andi	r18, 0x3D	; 61
    2b76:	74 61       	ori	r23, 0x14	; 20
    2b78:	67 69       	ori	r22, 0x97	; 151
    2b7a:	6e 67       	ori	r22, 0x7E	; 126
    2b7c:	2f 6c       	ori	r18, 0xCF	; 207
    2b7e:	61 62       	ori	r22, 0x21	; 33
    2b80:	65 6c       	ori	r22, 0xC5	; 197
    2b82:	2f 6d       	ori	r18, 0xDF	; 223
    2b84:	61 63       	ori	r22, 0x31	; 49
    2b86:	2d 6d       	ori	r18, 0xDD	; 221
    2b88:	69 6e       	ori	r22, 0xE9	; 233
    2b8a:	69 2f       	mov	r22, r25
    2b8c:	67 63       	ori	r22, 0x37	; 55
    2b8e:	63 2d       	mov	r22, r3
    2b90:	62 75       	andi	r22, 0x52	; 82
    2b92:	69 6c       	ori	r22, 0xC9	; 201
    2b94:	64 2f       	mov	r22, r20
    2b96:	61 76       	andi	r22, 0x61	; 97
    2b98:	72 2f       	mov	r23, r18
    2b9a:	61 76       	andi	r22, 0x61	; 97
    2b9c:	72 35       	cpi	r23, 0x52	; 82
    2b9e:	2f 6c       	ori	r18, 0xCF	; 207
    2ba0:	69 62       	ori	r22, 0x29	; 41
    2ba2:	67 63       	ori	r22, 0x37	; 55
    2ba4:	63 00       	.word	0x0063	; ????
    2ba6:	47 4e       	sbci	r20, 0xE7	; 231
    2ba8:	55 20       	and	r5, r5
    2baa:	41 53       	subi	r20, 0x31	; 49
    2bac:	20 32       	cpi	r18, 0x20	; 32
    2bae:	2e 32       	cpi	r18, 0x2E	; 46
    2bb0:	36 00       	.word	0x0036	; ????
    2bb2:	01 80       	ldd	r0, Z+1	; 0x01
    2bb4:	aa 00       	.word	0x00aa	; ????
    2bb6:	00 00       	nop
    2bb8:	02 00       	.word	0x0002	; ????
    2bba:	64 0d       	add	r22, r4
    2bbc:	00 00       	nop
    2bbe:	04 01       	movw	r0, r8
    2bc0:	76 11       	cpse	r23, r6
    2bc2:	00 00       	nop
    2bc4:	2c 0d       	add	r18, r12
    2bc6:	00 00       	nop
    2bc8:	38 0d       	add	r19, r8
    2bca:	00 00       	nop
    2bcc:	2e 2e       	mov	r2, r30
    2bce:	2f 2e       	mov	r2, r31
    2bd0:	2e 2f       	mov	r18, r30
    2bd2:	2e 2e       	mov	r2, r30
    2bd4:	2f 2e       	mov	r2, r31
    2bd6:	2e 2f       	mov	r18, r30
    2bd8:	67 63       	ori	r22, 0x37	; 55
    2bda:	63 2f       	mov	r22, r19
    2bdc:	6c 69       	ori	r22, 0x9C	; 156
    2bde:	62 67       	ori	r22, 0x72	; 114
    2be0:	63 63       	ori	r22, 0x33	; 51
    2be2:	2f 63       	ori	r18, 0x3F	; 63
    2be4:	6f 6e       	ori	r22, 0xEF	; 239
    2be6:	66 69       	ori	r22, 0x96	; 150
    2be8:	67 2f       	mov	r22, r23
    2bea:	61 76       	andi	r22, 0x61	; 97
    2bec:	72 2f       	mov	r23, r18
    2bee:	6c 69       	ori	r22, 0x9C	; 156
    2bf0:	62 31       	cpi	r22, 0x12	; 18
    2bf2:	66 75       	andi	r22, 0x56	; 86
    2bf4:	6e 63       	ori	r22, 0x3E	; 62
    2bf6:	73 2e       	mov	r7, r19
    2bf8:	53 00       	.word	0x0053	; ????
    2bfa:	2f 55       	subi	r18, 0x5F	; 95
    2bfc:	73 65       	ori	r23, 0x53	; 83
    2bfe:	72 73       	andi	r23, 0x32	; 50
    2c00:	2f 6a       	ori	r18, 0xAF	; 175
    2c02:	65 6e       	ori	r22, 0xE5	; 229
    2c04:	6b 69       	ori	r22, 0x9B	; 155
    2c06:	6e 73       	andi	r22, 0x3E	; 62
    2c08:	2f 6a       	ori	r18, 0xAF	; 175
    2c0a:	65 6e       	ori	r22, 0xE5	; 229
    2c0c:	6b 69       	ori	r22, 0x9B	; 155
    2c0e:	6e 73       	andi	r22, 0x3E	; 62
    2c10:	2f 77       	andi	r18, 0x7F	; 127
    2c12:	6f 72       	andi	r22, 0x2F	; 47
    2c14:	6b 73       	andi	r22, 0x3B	; 59
    2c16:	70 61       	ori	r23, 0x10	; 16
    2c18:	63 65       	ori	r22, 0x53	; 83
    2c1a:	2f 61       	ori	r18, 0x1F	; 31
    2c1c:	76 72       	andi	r23, 0x26	; 38
    2c1e:	2d 67       	ori	r18, 0x7D	; 125
    2c20:	63 63       	ori	r22, 0x33	; 51
    2c22:	2d 73       	andi	r18, 0x3D	; 61
    2c24:	74 61       	ori	r23, 0x14	; 20
    2c26:	67 69       	ori	r22, 0x97	; 151
    2c28:	6e 67       	ori	r22, 0x7E	; 126
    2c2a:	2f 6c       	ori	r18, 0xCF	; 207
    2c2c:	61 62       	ori	r22, 0x21	; 33
    2c2e:	65 6c       	ori	r22, 0xC5	; 197
    2c30:	2f 6d       	ori	r18, 0xDF	; 223
    2c32:	61 63       	ori	r22, 0x31	; 49
    2c34:	2d 6d       	ori	r18, 0xDD	; 221
    2c36:	69 6e       	ori	r22, 0xE9	; 233
    2c38:	69 2f       	mov	r22, r25
    2c3a:	67 63       	ori	r22, 0x37	; 55
    2c3c:	63 2d       	mov	r22, r3
    2c3e:	62 75       	andi	r22, 0x52	; 82
    2c40:	69 6c       	ori	r22, 0xC9	; 201
    2c42:	64 2f       	mov	r22, r20
    2c44:	61 76       	andi	r22, 0x61	; 97
    2c46:	72 2f       	mov	r23, r18
    2c48:	61 76       	andi	r22, 0x61	; 97
    2c4a:	72 35       	cpi	r23, 0x52	; 82
    2c4c:	2f 6c       	ori	r18, 0xCF	; 207
    2c4e:	69 62       	ori	r22, 0x29	; 41
    2c50:	67 63       	ori	r22, 0x37	; 55
    2c52:	63 00       	.word	0x0063	; ????
    2c54:	47 4e       	sbci	r20, 0xE7	; 231
    2c56:	55 20       	and	r5, r5
    2c58:	41 53       	subi	r20, 0x31	; 49
    2c5a:	20 32       	cpi	r18, 0x20	; 32
    2c5c:	2e 32       	cpi	r18, 0x2E	; 46
    2c5e:	36 00       	.word	0x0036	; ????
    2c60:	01 80       	ldd	r0, Z+1	; 0x01

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	01 11       	cpse	r16, r1
   2:	01 25       	eor	r16, r1
   4:	0e 10       	cpse	r0, r14
   6:	06 00       	.word	0x0006	; ????
   8:	00 02       	muls	r16, r16
   a:	24 00       	.word	0x0024	; ????
   c:	03 0e       	add	r0, r19
   e:	0b 0b       	sbc	r16, r27
  10:	3e 0b       	sbc	r19, r30
  12:	00 00       	nop
  14:	03 24       	eor	r0, r3
  16:	00 03       	mulsu	r16, r16
  18:	0e 0b       	sbc	r16, r30
  1a:	0b 3e       	cpi	r16, 0xEB	; 235
  1c:	0b 00       	.word	0x000b	; ????
  1e:	00 04       	cpc	r0, r0
  20:	01 01       	movw	r0, r2
  22:	49 13       	cpse	r20, r25
  24:	00 00       	nop
  26:	05 21       	and	r16, r5
  28:	00 49       	sbci	r16, 0x90	; 144
  2a:	13 2f       	mov	r17, r19
  2c:	05 00       	.word	0x0005	; ????
  2e:	00 06       	cpc	r0, r16
  30:	34 00       	.word	0x0034	; ????
  32:	03 0e       	add	r0, r19
  34:	3a 0b       	sbc	r19, r26
  36:	3b 0b       	sbc	r19, r27
  38:	49 13       	cpse	r20, r25
  3a:	3f 0c       	add	r3, r15
  3c:	02 0a       	sbc	r0, r18
  3e:	00 00       	nop
  40:	07 34       	cpi	r16, 0x47	; 71
  42:	00 03       	mulsu	r16, r16
  44:	0e 3a       	cpi	r16, 0xAE	; 174
  46:	0b 3b       	cpi	r16, 0xBB	; 187
  48:	0b 49       	sbci	r16, 0x9B	; 155
  4a:	13 3f       	cpi	r17, 0xF3	; 243
  4c:	0c 02       	muls	r16, r28
  4e:	0a 00       	.word	0x000a	; ????
  50:	00 08       	sbc	r0, r0
  52:	34 00       	.word	0x0034	; ????
  54:	03 0e       	add	r0, r19
  56:	3a 0b       	sbc	r19, r26
  58:	3b 0b       	sbc	r19, r27
  5a:	49 13       	cpse	r20, r25
  5c:	3f 0c       	add	r3, r15
  5e:	02 0a       	sbc	r0, r18
  60:	00 00       	nop
  62:	09 34       	cpi	r16, 0x49	; 73
  64:	00 03       	mulsu	r16, r16
  66:	0e 3a       	cpi	r16, 0xAE	; 174
  68:	0b 3b       	cpi	r16, 0xBB	; 187
  6a:	0b 49       	sbci	r16, 0x9B	; 155
  6c:	13 3f       	cpi	r17, 0xF3	; 243
  6e:	0c 02       	muls	r16, r28
  70:	0a 00       	.word	0x000a	; ????
  72:	00 0a       	sbc	r0, r16
  74:	34 00       	.word	0x0034	; ????
  76:	03 0e       	add	r0, r19
  78:	3a 0b       	sbc	r19, r26
  7a:	3b 0b       	sbc	r19, r27
  7c:	49 13       	cpse	r20, r25
  7e:	3f 0c       	add	r3, r15
  80:	02 0a       	sbc	r0, r18
  82:	00 00       	nop
  84:	0b 34       	cpi	r16, 0x4B	; 75
  86:	00 03       	mulsu	r16, r16
  88:	0e 3a       	cpi	r16, 0xAE	; 174
  8a:	0b 3b       	cpi	r16, 0xBB	; 187
  8c:	0b 49       	sbci	r16, 0x9B	; 155
  8e:	13 3f       	cpi	r17, 0xF3	; 243
  90:	0c 02       	muls	r16, r28
  92:	0a 00       	.word	0x000a	; ????
  94:	00 0c       	add	r0, r0
  96:	34 00       	.word	0x0034	; ????
  98:	03 0e       	add	r0, r19
  9a:	3a 0b       	sbc	r19, r26
  9c:	3b 0b       	sbc	r19, r27
  9e:	49 13       	cpse	r20, r25
  a0:	3f 0c       	add	r3, r15
  a2:	02 0a       	sbc	r0, r18
  a4:	00 00       	nop
  a6:	0d 34       	cpi	r16, 0x4D	; 77
  a8:	00 03       	mulsu	r16, r16
  aa:	0e 3a       	cpi	r16, 0xAE	; 174
  ac:	0b 3b       	cpi	r16, 0xBB	; 187
  ae:	0b 49       	sbci	r16, 0x9B	; 155
  b0:	13 3f       	cpi	r17, 0xF3	; 243
  b2:	0c 02       	muls	r16, r28
  b4:	0a 00       	.word	0x000a	; ????
  b6:	00 0e       	add	r0, r16
  b8:	34 00       	.word	0x0034	; ????
  ba:	03 0e       	add	r0, r19
  bc:	3a 0b       	sbc	r19, r26
  be:	3b 0b       	sbc	r19, r27
  c0:	49 13       	cpse	r20, r25
  c2:	3f 0c       	add	r3, r15
  c4:	02 0a       	sbc	r0, r18
  c6:	00 00       	nop
  c8:	0f 34       	cpi	r16, 0x4F	; 79
  ca:	00 03       	mulsu	r16, r16
  cc:	0e 3a       	cpi	r16, 0xAE	; 174
  ce:	0b 3b       	cpi	r16, 0xBB	; 187
  d0:	0b 49       	sbci	r16, 0x9B	; 155
  d2:	13 3f       	cpi	r17, 0xF3	; 243
  d4:	0c 02       	muls	r16, r28
  d6:	0a 00       	.word	0x000a	; ????
  d8:	00 10       	cpse	r0, r0
  da:	34 00       	.word	0x0034	; ????
  dc:	03 0e       	add	r0, r19
  de:	3a 0b       	sbc	r19, r26
  e0:	3b 0b       	sbc	r19, r27
  e2:	49 13       	cpse	r20, r25
  e4:	3f 0c       	add	r3, r15
  e6:	02 0a       	sbc	r0, r18
  e8:	00 00       	nop
  ea:	11 34       	cpi	r17, 0x41	; 65
  ec:	00 03       	mulsu	r16, r16
  ee:	0e 3a       	cpi	r16, 0xAE	; 174
  f0:	0b 3b       	cpi	r16, 0xBB	; 187
  f2:	0b 49       	sbci	r16, 0x9B	; 155
  f4:	13 3f       	cpi	r17, 0xF3	; 243
  f6:	0c 02       	muls	r16, r28
  f8:	0a 00       	.word	0x000a	; ????
  fa:	00 12       	cpse	r0, r16
  fc:	34 00       	.word	0x0034	; ????
  fe:	03 0e       	add	r0, r19
 100:	3a 0b       	sbc	r19, r26
 102:	3b 0b       	sbc	r19, r27
 104:	49 13       	cpse	r20, r25
 106:	3f 0c       	add	r3, r15
 108:	02 0a       	sbc	r0, r18
 10a:	00 00       	nop
 10c:	13 34       	cpi	r17, 0x43	; 67
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 10e:	00 03       	mulsu	r16, r16
 110:	0e 3a       	cpi	r16, 0xAE	; 174
 112:	0b 3b       	cpi	r16, 0xBB	; 187
 114:	0b 49       	sbci	r16, 0x9B	; 155
 116:	13 3f       	cpi	r17, 0xF3	; 243
	uint8_t port = digitalPinToPort(pin);
 118:	0c 02       	muls	r16, r28
 11a:	0a 00       	.word	0x000a	; ????
 11c:	00 14       	cp	r0, r0
 11e:	34 00       	.word	0x0034	; ????
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 120:	03 0e       	add	r0, r19
 122:	3a 0b       	sbc	r19, r26

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 124:	3b 0b       	sbc	r19, r27
 126:	49 13       	cpse	r20, r25
 128:	3f 0c       	add	r3, r15
 12a:	02 0a       	sbc	r0, r18
 12c:	00 00       	nop
 12e:	15 34       	cpi	r17, 0x45	; 69
 130:	00 03       	mulsu	r16, r16
 132:	0e 3a       	cpi	r16, 0xAE	; 174
	out = portOutputRegister(port);
 134:	0b 3b       	cpi	r16, 0xBB	; 187
 136:	0b 49       	sbci	r16, 0x9B	; 155
 138:	13 3f       	cpi	r17, 0xF3	; 243
 13a:	0c 02       	muls	r16, r28
 13c:	0a 00       	.word	0x000a	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 13e:	00 16       	cp	r0, r16
                cli();
 140:	34 00       	.word	0x0034	; ????
		*reg |= bit;
 142:	03 0e       	add	r0, r19
 144:	3a 0b       	sbc	r19, r26
 146:	3b 0b       	sbc	r19, r27
		SREG = oldSREG;
 148:	49 13       	cpse	r20, r25
 14a:	3f 0c       	add	r3, r15
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 14c:	02 0a       	sbc	r0, r18
 14e:	00 00       	nop
 150:	17 34       	cpi	r17, 0x47	; 71
 152:	00 03       	mulsu	r16, r16
 154:	0e 3a       	cpi	r16, 0xAE	; 174
	uint8_t bit = digitalPinToBitMask(pin);
 156:	0b 3b       	cpi	r16, 0xBB	; 187
 158:	0b 49       	sbci	r16, 0x9B	; 155
 15a:	13 3f       	cpi	r17, 0xF3	; 243
 15c:	0c 02       	muls	r16, r28
	uint8_t port = digitalPinToPort(pin);
 15e:	0a 00       	.word	0x000a	; ????
 160:	00 18       	sub	r0, r0
 162:	34 00       	.word	0x0034	; ????
 164:	03 0e       	add	r0, r19
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 166:	3a 0b       	sbc	r19, r26
 168:	3b 0b       	sbc	r19, r27
 16a:	49 13       	cpse	r20, r25

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 16c:	3f 0c       	add	r3, r15
 16e:	02 0a       	sbc	r0, r18
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 170:	00 00       	nop
 172:	19 34       	cpi	r17, 0x49	; 73
 174:	00 03       	mulsu	r16, r16
 176:	0e 3a       	cpi	r16, 0xAE	; 174
 178:	0b 3b       	cpi	r16, 0xBB	; 187
 17a:	0b 49       	sbci	r16, 0x9B	; 155
 17c:	13 3f       	cpi	r17, 0xF3	; 243
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17e:	0c 02       	muls	r16, r28
 180:	0a 00       	.word	0x000a	; ????
 182:	00 1a       	sub	r0, r16
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 184:	34 00       	.word	0x0034	; ????
 186:	03 0e       	add	r0, r19
 188:	3a 0b       	sbc	r19, r26
 18a:	3b 0b       	sbc	r19, r27
 18c:	49 13       	cpse	r20, r25
 18e:	3f 0c       	add	r3, r15
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 190:	02 0a       	sbc	r0, r18
 192:	00 00       	nop
 194:	1b 34       	cpi	r17, 0x4B	; 75
 196:	00 03       	mulsu	r16, r16
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 198:	0e 3a       	cpi	r16, 0xAE	; 174
 19a:	0b 3b       	cpi	r16, 0xBB	; 187
 19c:	0b 49       	sbci	r16, 0x9B	; 155
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 19e:	13 3f       	cpi	r17, 0xF3	; 243
 1a0:	0c 02       	muls	r16, r28
 1a2:	0a 00       	.word	0x000a	; ????
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 1a4:	00 1c       	adc	r0, r0
 1a6:	34 00       	.word	0x0034	; ????
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 1a8:	03 0e       	add	r0, r19
 1aa:	3a 0b       	sbc	r19, r26
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 1ac:	3b 0b       	sbc	r19, r27
 1ae:	49 13       	cpse	r20, r25
 1b0:	3f 0c       	add	r3, r15
 1b2:	02 0a       	sbc	r0, r18
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 1b4:	00 00       	nop
 1b6:	1d 34       	cpi	r17, 0x4D	; 77
 1b8:	00 03       	mulsu	r16, r16
 1ba:	0e 3a       	cpi	r16, 0xAE	; 174
 1bc:	0b 3b       	cpi	r16, 0xBB	; 187

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 1be:	0b 49       	sbci	r16, 0x9B	; 155
 1c0:	13 3f       	cpi	r17, 0xF3	; 243
 1c2:	0c 02       	muls	r16, r28
 1c4:	0a 00       	.word	0x000a	; ????
 1c6:	00 1e       	adc	r0, r16
 1c8:	34 00       	.word	0x0034	; ????
 1ca:	03 0e       	add	r0, r19

	uint8_t oldSREG = SREG;
 1cc:	3a 0b       	sbc	r19, r26
	cli();
 1ce:	3b 0b       	sbc	r19, r27

	if (val == LOW) {
 1d0:	49 13       	cpse	r20, r25
 1d2:	3f 0c       	add	r3, r15
		*out &= ~bit;
 1d4:	02 0a       	sbc	r0, r18
 1d6:	00 00       	nop
 1d8:	1f 34       	cpi	r17, 0x4F	; 79
 1da:	00 03       	mulsu	r16, r16
	} else {
		*out |= bit;
 1dc:	0e 3a       	cpi	r16, 0xAE	; 174
 1de:	0b 3b       	cpi	r16, 0xBB	; 187
 1e0:	0b 49       	sbci	r16, 0x9B	; 155
	}

	SREG = oldSREG;
 1e2:	13 3f       	cpi	r17, 0xF3	; 243
 1e4:	0c 02       	muls	r16, r28
   digitalWrite(_enable_pin, LOW);
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
 1e6:	0a 00       	.word	0x000a	; ????
 1e8:	00 20       	and	r0, r0
 1ea:	34 00       	.word	0x0034	; ????
 1ec:	03 0e       	add	r0, r19
 1ee:	3a 0b       	sbc	r19, r26
 1f0:	3b 0b       	sbc	r19, r27
 1f2:	49 13       	cpse	r20, r25
 1f4:	3f 0c       	add	r3, r15
 1f6:	02 0a       	sbc	r0, r18
 1f8:	00 00       	nop
 1fa:	21 34       	cpi	r18, 0x41	; 65
 1fc:	00 03       	mulsu	r16, r16
 1fe:	0e 3a       	cpi	r16, 0xAE	; 174
 200:	0b 3b       	cpi	r16, 0xBB	; 187
 202:	0b 49       	sbci	r16, 0x9B	; 155
 204:	13 3f       	cpi	r17, 0xF3	; 243
 206:	0c 02       	muls	r16, r28
 208:	0a 00       	.word	0x000a	; ????
 20a:	00 22       	and	r0, r16
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 20c:	34 00       	.word	0x0034	; ????
 20e:	03 0e       	add	r0, r19

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
 210:	3a 0b       	sbc	r19, r26
 212:	3b 0b       	sbc	r19, r27
 214:	49 13       	cpse	r20, r25
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 216:	3f 0c       	add	r3, r15
 218:	02 0a       	sbc	r0, r18
 21a:	00 00       	nop
 21c:	23 34       	cpi	r18, 0x43	; 67
 21e:	00 03       	mulsu	r16, r16
 220:	0e 3a       	cpi	r16, 0xAE	; 174
 222:	0b 3b       	cpi	r16, 0xBB	; 187
 224:	0b 49       	sbci	r16, 0x9B	; 155
 226:	13 3f       	cpi	r17, 0xF3	; 243
 228:	0c 02       	muls	r16, r28
 22a:	0a 00       	.word	0x000a	; ????
 22c:	00 24       	eor	r0, r0
 22e:	34 00       	.word	0x0034	; ????
 230:	03 0e       	add	r0, r19
 232:	3a 0b       	sbc	r19, r26
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
 234:	3b 0b       	sbc	r19, r27
 236:	49 13       	cpse	r20, r25
 238:	3f 0c       	add	r3, r15
 23a:	02 0a       	sbc	r0, r18
 23c:	00 00       	nop
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 23e:	25 34       	cpi	r18, 0x45	; 69
 240:	00 03       	mulsu	r16, r16
 242:	0e 3a       	cpi	r16, 0xAE	; 174
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
 244:	0b 3b       	cpi	r16, 0xBB	; 187
 246:	0b 49       	sbci	r16, 0x9B	; 155
 248:	13 3f       	cpi	r17, 0xF3	; 243
 24a:	0c 02       	muls	r16, r28
 24c:	0a 00       	.word	0x000a	; ????
 24e:	00 26       	eor	r0, r16
 250:	34 00       	.word	0x0034	; ????
 252:	03 0e       	add	r0, r19
 254:	3a 0b       	sbc	r19, r26
 256:	3b 0b       	sbc	r19, r27
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 258:	49 13       	cpse	r20, r25
 25a:	3f 0c       	add	r3, r15
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
 25c:	02 0a       	sbc	r0, r18
	
	cli();
 25e:	00 00       	nop
	m = timer0_overflow_count;
 260:	27 34       	cpi	r18, 0x47	; 71
 262:	00 03       	mulsu	r16, r16
 264:	0e 3a       	cpi	r16, 0xAE	; 174
 266:	0b 3b       	cpi	r16, 0xBB	; 187
 268:	0b 49       	sbci	r16, 0x9B	; 155
 26a:	13 3f       	cpi	r17, 0xF3	; 243
 26c:	0c 02       	muls	r16, r28
 26e:	0a 00       	.word	0x000a	; ????
#if defined(TCNT0)
	t = TCNT0;
 270:	00 28       	or	r0, r0
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
 272:	34 00       	.word	0x0034	; ????
 274:	03 0e       	add	r0, r19
 276:	3a 0b       	sbc	r19, r26
 278:	3b 0b       	sbc	r19, r27
		m++;
 27a:	49 13       	cpse	r20, r25
 27c:	3f 0c       	add	r3, r15
 27e:	02 0a       	sbc	r0, r18
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
 280:	00 00       	nop
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
 282:	29 34       	cpi	r18, 0x49	; 73
 284:	00 03       	mulsu	r16, r16
 286:	0e 3a       	cpi	r16, 0xAE	; 174
 288:	0b 3b       	cpi	r16, 0xBB	; 187
 28a:	0b 49       	sbci	r16, 0x9B	; 155
 28c:	13 3f       	cpi	r17, 0xF3	; 243
 28e:	0c 02       	muls	r16, r28
 290:	0a 00       	.word	0x000a	; ????
 292:	00 2a       	or	r0, r16
 294:	34 00       	.word	0x0034	; ????
 296:	03 0e       	add	r0, r19
 298:	3a 0b       	sbc	r19, r26
 29a:	3b 0b       	sbc	r19, r27
 29c:	49 13       	cpse	r20, r25
 29e:	3f 0c       	add	r3, r15
 2a0:	02 0a       	sbc	r0, r18
 2a2:	00 00       	nop
}
 2a4:	2b 34       	cpi	r18, 0x4B	; 75

void delay(unsigned long ms)
{
 2a6:	00 03       	mulsu	r16, r16
 2a8:	0e 3a       	cpi	r16, 0xAE	; 174
 2aa:	0b 3b       	cpi	r16, 0xBB	; 187
 2ac:	0b 49       	sbci	r16, 0x9B	; 155
 2ae:	13 3f       	cpi	r17, 0xF3	; 243
 2b0:	0c 02       	muls	r16, r28
 2b2:	0a 00       	.word	0x000a	; ????
 2b4:	00 2c       	mov	r0, r0
 2b6:	34 00       	.word	0x0034	; ????
 2b8:	03 0e       	add	r0, r19
	uint32_t start = micros();
 2ba:	3a 0b       	sbc	r19, r26
 2bc:	3b 0b       	sbc	r19, r27
 2be:	49 13       	cpse	r20, r25
 2c0:	3f 0c       	add	r3, r15

	while (ms > 0) {
 2c2:	02 0a       	sbc	r0, r18
 2c4:	00 00       	nop
 2c6:	2d 34       	cpi	r18, 0x4D	; 77
 2c8:	00 03       	mulsu	r16, r16
 2ca:	0e 3a       	cpi	r16, 0xAE	; 174
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2cc:	0b 3b       	cpi	r16, 0xBB	; 187
 2ce:	0b 49       	sbci	r16, 0x9B	; 155
 2d0:	13 3f       	cpi	r17, 0xF3	; 243
 2d2:	0c 02       	muls	r16, r28
 2d4:	0a 00       	.word	0x000a	; ????
 2d6:	00 2e       	mov	r0, r16
 2d8:	34 00       	.word	0x0034	; ????
 2da:	03 0e       	add	r0, r19
 2dc:	3a 0b       	sbc	r19, r26
 2de:	3b 0b       	sbc	r19, r27
 2e0:	49 13       	cpse	r20, r25
 2e2:	3f 0c       	add	r3, r15
 2e4:	02 0a       	sbc	r0, r18
			ms--;
 2e6:	00 00       	nop
 2e8:	2f 34       	cpi	r18, 0x4F	; 79
 2ea:	00 03       	mulsu	r16, r16
 2ec:	0e 3a       	cpi	r16, 0xAE	; 174
 2ee:	0b 3b       	cpi	r16, 0xBB	; 187
			start += 1000;
 2f0:	0b 49       	sbci	r16, 0x9B	; 155
 2f2:	13 3f       	cpi	r17, 0xF3	; 243
 2f4:	0c 02       	muls	r16, r28
 2f6:	0a 00       	.word	0x000a	; ????
 2f8:	00 30       	cpi	r16, 0x00	; 0
 2fa:	34 00       	.word	0x0034	; ????
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2fc:	03 0e       	add	r0, r19
 2fe:	3a 0b       	sbc	r19, r26
 300:	3b 0b       	sbc	r19, r27
 302:	49 13       	cpse	r20, r25
 304:	3f 0c       	add	r3, r15
 306:	02 0a       	sbc	r0, r18
			ms--;
			start += 1000;
		}
	}
}
 308:	00 00       	nop
 30a:	31 34       	cpi	r19, 0x41	; 65
 30c:	00 03       	mulsu	r16, r16
 30e:	0e 3a       	cpi	r16, 0xAE	; 174
 310:	0b 3b       	cpi	r16, 0xBB	; 187
 312:	0b 49       	sbci	r16, 0x9B	; 155
 314:	13 3f       	cpi	r17, 0xF3	; 243
 316:	0c 02       	muls	r16, r28
 318:	0a 00       	.word	0x000a	; ????

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 31a:	00 32       	cpi	r16, 0x20	; 32
 31c:	34 00       	.word	0x0034	; ????
 31e:	03 0e       	add	r0, r19
 320:	3a 0b       	sbc	r19, r26
 322:	3b 0b       	sbc	r19, r27
 324:	49 13       	cpse	r20, r25
 326:	3f 0c       	add	r3, r15
 328:	02 0a       	sbc	r0, r18
 32a:	00 00       	nop
 32c:	33 34       	cpi	r19, 0x43	; 67
 32e:	00 03       	mulsu	r16, r16
  size_t n = 0;
 330:	0e 3a       	cpi	r16, 0xAE	; 174
 332:	0b 3b       	cpi	r16, 0xBB	; 187
  while (size--) {
 334:	0b 49       	sbci	r16, 0x9B	; 155
 336:	13 3f       	cpi	r17, 0xF3	; 243
 338:	0c 02       	muls	r16, r28
    if (write(*buffer++)) n++;
 33a:	0a 00       	.word	0x000a	; ????
 33c:	00 34       	cpi	r16, 0x40	; 64
 33e:	34 00       	.word	0x0034	; ????
 340:	03 0e       	add	r0, r19
 342:	3a 0b       	sbc	r19, r26
 344:	3b 0b       	sbc	r19, r27
 346:	49 13       	cpse	r20, r25
 348:	3f 0c       	add	r3, r15
 34a:	02 0a       	sbc	r0, r18
 34c:	00 00       	nop
 34e:	35 34       	cpi	r19, 0x45	; 69
 350:	00 03       	mulsu	r16, r16
 352:	0e 3a       	cpi	r16, 0xAE	; 174
 354:	0b 3b       	cpi	r16, 0xBB	; 187
 356:	0b 49       	sbci	r16, 0x9B	; 155
 358:	13 3f       	cpi	r17, 0xF3	; 243
    else break;
  }
  return n;
}
 35a:	0c 02       	muls	r16, r28
 35c:	0a 00       	.word	0x000a	; ????
 35e:	00 36       	cpi	r16, 0x60	; 96
 360:	34 00       	.word	0x0034	; ????
 362:	03 0e       	add	r0, r19
 364:	3a 0b       	sbc	r19, r26
 366:	3b 0b       	sbc	r19, r27
 368:	49 13       	cpse	r20, r25
 36a:	3f 0c       	add	r3, r15
 36c:	02 0a       	sbc	r0, r18
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 36e:	00 00       	nop
 370:	37 34       	cpi	r19, 0x47	; 71
 372:	00 03       	mulsu	r16, r16

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
 374:	0e 3a       	cpi	r16, 0xAE	; 174
 376:	0b 3b       	cpi	r16, 0xBB	; 187
 378:	0b 49       	sbci	r16, 0x9B	; 155
 37a:	13 3f       	cpi	r17, 0xF3	; 243
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
 37c:	0c 02       	muls	r16, r28
 37e:	0a 00       	.word	0x000a	; ????
 380:	00 38       	cpi	r16, 0x80	; 128
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
 382:	34 00       	.word	0x0034	; ????
 384:	03 0e       	add	r0, r19
 386:	3a 0b       	sbc	r19, r26
 388:	3b 0b       	sbc	r19, r27
 38a:	49 13       	cpse	r20, r25
 38c:	3f 0c       	add	r3, r15
 38e:	02 0a       	sbc	r0, r18
 390:	00 00       	nop
 392:	39 34       	cpi	r19, 0x49	; 73
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
 394:	00 03       	mulsu	r16, r16
 396:	0e 3a       	cpi	r16, 0xAE	; 174
 398:	0b 3b       	cpi	r16, 0xBB	; 187
 39a:	0b 49       	sbci	r16, 0x9B	; 155
 39c:	13 3f       	cpi	r17, 0xF3	; 243
 39e:	0c 02       	muls	r16, r28
 3a0:	0a 00       	.word	0x000a	; ????
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
 3a2:	00 3a       	cpi	r16, 0xA0	; 160
 3a4:	34 00       	.word	0x0034	; ????
    twi_txBuffer[twi_txBufferLength+i] = data[i];
 3a6:	03 0e       	add	r0, r19
 3a8:	3a 0b       	sbc	r19, r26
 3aa:	3b 0b       	sbc	r19, r27
 3ac:	49 13       	cpse	r20, r25
 3ae:	3f 0c       	add	r3, r15
 3b0:	02 0a       	sbc	r0, r18
 3b2:	00 00       	nop
 3b4:	3b 34       	cpi	r19, 0x4B	; 75
 3b6:	00 03       	mulsu	r16, r16
 3b8:	0e 3a       	cpi	r16, 0xAE	; 174
 3ba:	0b 3b       	cpi	r16, 0xBB	; 187
  }
  twi_txBufferLength += length;
 3bc:	0b 49       	sbci	r16, 0x9B	; 155
 3be:	13 3f       	cpi	r17, 0xF3	; 243
 3c0:	0c 02       	muls	r16, r28
 3c2:	0a 00       	.word	0x000a	; ????
 3c4:	00 3c       	cpi	r16, 0xC0	; 192
 3c6:	34 00       	.word	0x0034	; ????
 3c8:	03 0e       	add	r0, r19
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
 3ca:	3a 0b       	sbc	r19, r26
 3cc:	3b 0b       	sbc	r19, r27
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
 3ce:	49 13       	cpse	r20, r25
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
 3d0:	3f 0c       	add	r3, r15

  return value;
}

void TwoWire::flush(void)
{
 3d2:	02 0a       	sbc	r0, r18
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
 3d4:	00 00       	nop
 3d6:	3d 34       	cpi	r19, 0x4D	; 77
 3d8:	00 03       	mulsu	r16, r16
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
 3da:	0e 3a       	cpi	r16, 0xAE	; 174
 3dc:	0b 3b       	cpi	r16, 0xBB	; 187
 3de:	0b 49       	sbci	r16, 0x9B	; 155
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
 3e0:	13 3f       	cpi	r17, 0xF3	; 243
 3e2:	0c 02       	muls	r16, r28
 3e4:	0a 00       	.word	0x000a	; ????
}
 3e6:	00 3e       	cpi	r16, 0xE0	; 224
 3e8:	34 00       	.word	0x0034	; ????
 3ea:	03 0e       	add	r0, r19
 3ec:	3a 0b       	sbc	r19, r26

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 3ee:	3b 0b       	sbc	r19, r27
 3f0:	49 13       	cpse	r20, r25
 3f2:	3f 0c       	add	r3, r15
 3f4:	02 0a       	sbc	r0, r18
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
 3f6:	00 00       	nop
 3f8:	3f 34       	cpi	r19, 0x4F	; 79
 3fa:	00 03       	mulsu	r16, r16
  }
  return quantity;
}
 3fc:	0e 3a       	cpi	r16, 0xAE	; 174
 3fe:	0b 3b       	cpi	r16, 0xBB	; 187
 400:	0b 49       	sbci	r16, 0x9B	; 155
 402:	13 3f       	cpi	r17, 0xF3	; 243

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
 404:	0c 02       	muls	r16, r28
 406:	0a 00       	.word	0x000a	; ????
 408:	00 40       	sbci	r16, 0x00	; 0
 40a:	34 00       	.word	0x0034	; ????
 40c:	03 0e       	add	r0, r19
 40e:	3a 0b       	sbc	r19, r26
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
 410:	3b 0b       	sbc	r19, r27
 412:	49 13       	cpse	r20, r25
 414:	3f 0c       	add	r3, r15
 416:	02 0a       	sbc	r0, r18
 418:	00 00       	nop
  }
  return 1;
}
 41a:	41 34       	cpi	r20, 0x41	; 65
 41c:	00 03       	mulsu	r16, r16
 41e:	0e 3a       	cpi	r16, 0xAE	; 174
 420:	0b 3b       	cpi	r16, 0xBB	; 187
 422:	0b 49       	sbci	r16, 0x9B	; 155
 424:	13 3f       	cpi	r17, 0xF3	; 243
#endif

//
// setBackligh
void LiquidCrystal::setBacklight ( uint8_t value )
{
 426:	0c 02       	muls	r16, r28
   // Check if there is a pin assigned to the backlight
   // ---------------------------------------------------
   if ( _backlightPin != LCD_NOBACKLIGHT )
 428:	0a 00       	.word	0x000a	; ????
 42a:	00 42       	sbci	r16, 0x20	; 32
 42c:	34 00       	.word	0x0034	; ????
 42e:	03 0e       	add	r0, r19
 430:	3a 0b       	sbc	r19, r26
         }
      }
      // Not a PWM pin, set the backlight pin for POSI or NEG
      // polarity
      // --------------------------------------------------------
      else if (((value > 0) && (_polarity == POSITIVE)) ||
 432:	3b 0b       	sbc	r19, r27
 434:	49 13       	cpse	r20, r25
 436:	3f 0c       	add	r3, r15
 438:	02 0a       	sbc	r0, r18
 43a:	00 00       	nop
               ((value == 0) && (_polarity == NEGATIVE)))
 43c:	43 34       	cpi	r20, 0x43	; 67
 43e:	00 03       	mulsu	r16, r16
 440:	0e 3a       	cpi	r16, 0xAE	; 174
      {
         digitalWrite( _backlightPin, HIGH);
 442:	0b 3b       	cpi	r16, 0xBB	; 187
 444:	0b 49       	sbci	r16, 0x9B	; 155
      }
      else
      {
         digitalWrite( _backlightPin, LOW);
 446:	13 3f       	cpi	r17, 0xF3	; 243
 448:	0c 02       	muls	r16, r28
 44a:	0a 00       	.word	0x000a	; ????
 44c:	00 44       	sbci	r16, 0x40	; 64
}

//
// setBacklightPin
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
 44e:	34 00       	.word	0x0034	; ????
 450:	03 0e       	add	r0, r19
 452:	3a 0b       	sbc	r19, r26
 454:	3b 0b       	sbc	r19, r27
 456:	49 13       	cpse	r20, r25
 458:	3f 0c       	add	r3, r15
 45a:	02 0a       	sbc	r0, r18
 45c:	00 00       	nop
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
 45e:	45 34       	cpi	r20, 0x45	; 69
 460:	00 03       	mulsu	r16, r16
 462:	0e 3a       	cpi	r16, 0xAE	; 174
   _backlightPin = pin;
 464:	0b 3b       	cpi	r16, 0xBB	; 187
   _polarity = pol;
 466:	0b 49       	sbci	r16, 0x9B	; 155
 468:	13 3f       	cpi	r17, 0xF3	; 243
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
 46a:	0c 02       	muls	r16, r28
 46c:	0a 00       	.word	0x000a	; ????
 46e:	00 46       	sbci	r16, 0x60	; 96
 470:	34 00       	.word	0x0034	; ????
 472:	03 0e       	add	r0, r19
 474:	3a 0b       	sbc	r19, r26
 476:	3b 0b       	sbc	r19, r27
}
 478:	49 13       	cpse	r20, r25
 47a:	3f 0c       	add	r3, r15
 47c:	02 0a       	sbc	r0, r18
 47e:	00 00       	nop
 480:	47 34       	cpi	r20, 0x47	; 71
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
   _backlightPin = pin;
   _polarity = pol;
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
 482:	00 03       	mulsu	r16, r16

/************ low level data pushing commands **********/
//
// send
void LiquidCrystal::send(uint8_t value, uint8_t mode) 
{
 484:	0e 3a       	cpi	r16, 0xAE	; 174
 486:	0b 3b       	cpi	r16, 0xBB	; 187
 488:	0b 49       	sbci	r16, 0x9B	; 155
 48a:	13 3f       	cpi	r17, 0xF3	; 243
 48c:	0c 02       	muls	r16, r28
 48e:	0a 00       	.word	0x000a	; ????
 490:	00 48       	sbci	r16, 0x80	; 128
   // Only interested in COMMAND or DATA
   digitalWrite( _rs_pin, ( mode == LCD_DATA ) );
 492:	34 00       	.word	0x0034	; ????
 494:	03 0e       	add	r0, r19
 496:	3a 0b       	sbc	r19, r26
 498:	3b 0b       	sbc	r19, r27
 49a:	49 13       	cpse	r20, r25
 49c:	3f 0c       	add	r3, r15
 49e:	02 0a       	sbc	r0, r18
   
   // if there is a RW pin indicated, set it low to Write
   // ---------------------------------------------------
   if (_rw_pin != 255) 
 4a0:	00 00       	nop
 4a2:	49 34       	cpi	r20, 0x49	; 73
 4a4:	00 03       	mulsu	r16, r16
   { 
      digitalWrite(_rw_pin, LOW);
 4a6:	0e 3a       	cpi	r16, 0xAE	; 174
 4a8:	0b 3b       	cpi	r16, 0xBB	; 187
 4aa:	0b 49       	sbci	r16, 0x9B	; 155
   }
   
   if ( mode != FOUR_BITS )
 4ac:	13 3f       	cpi	r17, 0xF3	; 243
 4ae:	0c 02       	muls	r16, r28
   {   
      if ( (_displayfunction & LCD_8BITMODE ) )
 4b0:	0a 00       	.word	0x000a	; ????
 4b2:	00 4a       	sbci	r16, 0xA0	; 160
 4b4:	34 00       	.word	0x0034	; ????
      {
         writeNbits(value, 8); 
 4b6:	03 0e       	add	r0, r19
 4b8:	3a 0b       	sbc	r19, r26
      } 
      else 
      {
         writeNbits ( value >> 4, 4 );
 4ba:	3b 0b       	sbc	r19, r27
 4bc:	49 13       	cpse	r20, r25
 4be:	3f 0c       	add	r3, r15
 4c0:	02 0a       	sbc	r0, r18
 4c2:	00 00       	nop
 4c4:	4b 34       	cpi	r20, 0x4B	; 75
 4c6:	00 03       	mulsu	r16, r16
 4c8:	0e 3a       	cpi	r16, 0xAE	; 174
 4ca:	0b 3b       	cpi	r16, 0xBB	; 187
 4cc:	0b 49       	sbci	r16, 0x9B	; 155
 4ce:	13 3f       	cpi	r17, 0xF3	; 243
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
 4d0:	0c 02       	muls	r16, r28
 4d2:	0a 00       	.word	0x000a	; ????
 4d4:	00 4c       	sbci	r16, 0xC0	; 192
   }
   waitUsec ( EXEC_TIME ); // wait for the command to execute by the LCD
}
 4d6:	34 00       	.word	0x0034	; ????
 4d8:	03 0e       	add	r0, r19
 4da:	3a 0b       	sbc	r19, r26
 4dc:	3b 0b       	sbc	r19, r27
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
 4de:	49 13       	cpse	r20, r25
 4e0:	3f 0c       	add	r3, r15
   send(value, LCD_DATA);
}
#else
size_t LCD::write(uint8_t value) 
{
   send(value, LCD_DATA);
 4e2:	02 0a       	sbc	r0, r18
 4e4:	00 00       	nop
 4e6:	4d 34       	cpi	r20, 0x4D	; 77
 4e8:	00 03       	mulsu	r16, r16
 4ea:	0e 3a       	cpi	r16, 0xAE	; 174
 4ec:	0b 3b       	cpi	r16, 0xBB	; 187
 4ee:	0b 49       	sbci	r16, 0x9B	; 155
 4f0:	13 3f       	cpi	r17, 0xF3	; 243
   return 1;             // assume OK
}
 4f2:	0c 02       	muls	r16, r28
 4f4:	0a 00       	.word	0x000a	; ????
 4f6:	00 4e       	sbci	r16, 0xE0	; 224

// General LCD commands - generic methods used by the rest of the commands
// ---------------------------------------------------------------------------
void LCD::command(uint8_t value) 
{
   send(value, COMMAND);
 4f8:	34 00       	.word	0x0034	; ????
 4fa:	03 0e       	add	r0, r19
 4fc:	3a 0b       	sbc	r19, r26
 4fe:	3b 0b       	sbc	r19, r27
 500:	49 13       	cpse	r20, r25
 502:	3f 0c       	add	r3, r15
 504:	02 0a       	sbc	r0, r18
 506:	00 00       	nop
{
   command(LCD_RETURNHOME);             // set cursor position to zero
   delayMicroseconds(HOME_CLEAR_EXEC);  // This command is time consuming
}

void LCD::setCursor(uint8_t col, uint8_t row)
 508:	4f 34       	cpi	r20, 0x4F	; 79
 50a:	00 03       	mulsu	r16, r16
 50c:	0e 3a       	cpi	r16, 0xAE	; 174
 50e:	0b 3b       	cpi	r16, 0xBB	; 187
 510:	0b 49       	sbci	r16, 0x9B	; 155
 512:	13 3f       	cpi	r17, 0xF3	; 243
 514:	0c 02       	muls	r16, r28
 516:	0a 00       	.word	0x000a	; ????
 518:	00 50       	subi	r16, 0x00	; 0
 51a:	34 00       	.word	0x0034	; ????
{
   const byte row_offsetsDef[]   = { 0x00, 0x40, 0x14, 0x54 }; // For regular LCDs
 51c:	03 0e       	add	r0, r19
 51e:	3a 0b       	sbc	r19, r26
 520:	3b 0b       	sbc	r19, r27
 522:	49 13       	cpse	r20, r25
 524:	3f 0c       	add	r3, r15
 526:	02 0a       	sbc	r0, r18
 528:	00 00       	nop
 52a:	51 34       	cpi	r21, 0x41	; 65
 52c:	00 03       	mulsu	r16, r16
 52e:	0e 3a       	cpi	r16, 0xAE	; 174
 530:	0b 3b       	cpi	r16, 0xBB	; 187
 532:	0b 49       	sbci	r16, 0x9B	; 155
   const byte row_offsetsLarge[] = { 0x00, 0x40, 0x10, 0x50 }; // For 16x4 LCDs
 534:	13 3f       	cpi	r17, 0xF3	; 243
 536:	0c 02       	muls	r16, r28
 538:	0a 00       	.word	0x000a	; ????
 53a:	00 52       	subi	r16, 0x20	; 32
 53c:	34 00       	.word	0x0034	; ????
 53e:	03 0e       	add	r0, r19
 540:	3a 0b       	sbc	r19, r26
 542:	3b 0b       	sbc	r19, r27
 544:	49 13       	cpse	r20, r25
 546:	3f 0c       	add	r3, r15
 548:	02 0a       	sbc	r0, r18
 54a:	00 00       	nop
   
   if ( row >= _numlines ) 
 54c:	53 34       	cpi	r21, 0x43	; 67
 54e:	00 03       	mulsu	r16, r16
 550:	0e 3a       	cpi	r16, 0xAE	; 174
 552:	0b 3b       	cpi	r16, 0xBB	; 187
   {
      row = _numlines-1;    // rows start at 0
 554:	0b 49       	sbci	r16, 0x9B	; 155
 556:	13 3f       	cpi	r17, 0xF3	; 243
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
 558:	0c 02       	muls	r16, r28
 55a:	0a 00       	.word	0x000a	; ????
 55c:	00 54       	subi	r16, 0x40	; 64
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
 55e:	34 00       	.word	0x0034	; ????
 560:	03 0e       	add	r0, r19
 562:	3a 0b       	sbc	r19, r26
      row = _numlines-1;    // rows start at 0
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
 564:	3b 0b       	sbc	r19, r27
 566:	49 13       	cpse	r20, r25
 568:	3f 0c       	add	r3, r15
 56a:	02 0a       	sbc	r0, r18
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
 56c:	00 00       	nop
 56e:	55 34       	cpi	r21, 0x45	; 69
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
 570:	00 03       	mulsu	r16, r16
 572:	0e 3a       	cpi	r16, 0xAE	; 174
 574:	0b 3b       	cpi	r16, 0xBB	; 187
 576:	0b 49       	sbci	r16, 0x9B	; 155
   }
   
}
 578:	13 3f       	cpi	r17, 0xF3	; 243
 57a:	0c 02       	muls	r16, r28
 57c:	0a 00       	.word	0x000a	; ????
 57e:	00 56       	subi	r16, 0x60	; 96
 580:	34 00       	.word	0x0034	; ????
 582:	03 0e       	add	r0, r19
 584:	3a 0b       	sbc	r19, r26
 586:	3b 0b       	sbc	r19, r27
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
 588:	49 13       	cpse	r20, r25
 58a:	3f 0c       	add	r3, r15
// can't assume that its in that state when a application starts (and the
// LiquidCrystal constructor is called).
// A call to begin() will reinitialize the LCD.
//
void LCD::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) 
{
 58c:	02 0a       	sbc	r0, r18
 58e:	00 00       	nop
 590:	57 34       	cpi	r21, 0x47	; 71
 592:	00 03       	mulsu	r16, r16
 594:	0e 3a       	cpi	r16, 0xAE	; 174
   if (lines > 1) 
 596:	0b 3b       	cpi	r16, 0xBB	; 187
 598:	0b 49       	sbci	r16, 0x9B	; 155
   {
      _displayfunction |= LCD_2LINE;
 59a:	13 3f       	cpi	r17, 0xF3	; 243
 59c:	0c 02       	muls	r16, r28
 59e:	0a 00       	.word	0x000a	; ????
   }
   _numlines = lines;
 5a0:	00 00       	nop
   _cols = cols;
 5a2:	01 11       	cpse	r16, r1
   
   // for some 1 line displays you can select a 10 pixel high font
   // ------------------------------------------------------------
   if ((dotsize != LCD_5x8DOTS) && (lines == 1)) 
 5a4:	01 25       	eor	r16, r1
 5a6:	0e 13       	cpse	r16, r30
 5a8:	0b 03       	fmul	r16, r19
 5aa:	0e 55       	subi	r16, 0x5E	; 94
   {
      _displayfunction |= LCD_5x10DOTS;
 5ac:	06 11       	cpse	r16, r6
 5ae:	01 52       	subi	r16, 0x21	; 33
 5b0:	01 10       	cpse	r0, r1
   // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
   // according to datasheet, we need at least 40ms after power rises above 2.7V
   // before sending commands. Arduino can turn on way before 4.5V so we'll wait 
   // 50
   // ---------------------------------------------------------------------------
   delay (100); // 100ms delay
 5b2:	06 00       	.word	0x0006	; ????
 5b4:	00 02       	muls	r16, r16
 5b6:	0f 00       	.word	0x000f	; ????
 5b8:	0b 0b       	sbc	r16, r27
 5ba:	03 0e       	add	r0, r19
 5bc:	49 13       	cpse	r20, r25
   
   //put the LCD into 4 bit or 8 bit mode
   // -------------------------------------
   if (! (_displayfunction & LCD_8BITMODE)) 
 5be:	00 00       	nop
 5c0:	03 15       	cp	r16, r3
 5c2:	01 49       	sbci	r16, 0x91	; 145
      // this is according to the hitachi HD44780 datasheet
      // figure 24, pg 46
      
      // we start in 8bit mode, try to set 4 bit mode
      // Special case of "Function Set"
      send(0x03, FOUR_BITS);
 5c4:	13 01       	movw	r2, r6
 5c6:	13 00       	.word	0x0013	; ????
 5c8:	00 04       	cpc	r0, r0
 5ca:	18 00       	.word	0x0018	; ????
 5cc:	00 00       	nop
 5ce:	05 24       	eor	r0, r5
 5d0:	00 0b       	sbc	r16, r16
 5d2:	0b 3e       	cpi	r16, 0xEB	; 235
 5d4:	0b 03       	fmul	r16, r19
	

#endif

	// busy wait
	__asm__ __volatile__ (
 5d6:	08 00       	.word	0x0008	; ????
 5d8:	00 06       	cpc	r0, r16
 5da:	13 01       	movw	r2, r6
 5dc:	03 0e       	add	r0, r19
      delayMicroseconds(4500); // wait min 4.1ms
      
      // second try
      send ( 0x03, FOUR_BITS );
 5de:	0b 0b       	sbc	r16, r27
 5e0:	3a 0b       	sbc	r19, r26
 5e2:	3b 0b       	sbc	r19, r27
 5e4:	1d 13       	cpse	r17, r29
 5e6:	01 13       	cpse	r16, r17
 5e8:	00 00       	nop
 5ea:	07 0d       	add	r16, r7
 5ec:	00 03       	mulsu	r16, r16
 5ee:	0e 49       	sbci	r16, 0x9E	; 158
 5f0:	13 38       	cpi	r17, 0x83	; 131
 5f2:	0a 34       	cpi	r16, 0x4A	; 74
 5f4:	0c 00       	.word	0x000c	; ????
 5f6:	00 08       	sbc	r0, r0
 5f8:	0d 00       	.word	0x000d	; ????
      delayMicroseconds(150); // wait min 100us
      
      // third go!
      send( 0x03, FOUR_BITS );
 5fa:	03 0e       	add	r0, r19
 5fc:	3a 0b       	sbc	r19, r26
 5fe:	3b 0b       	sbc	r19, r27
 600:	49 13       	cpse	r20, r25
 602:	38 0a       	sbc	r3, r24
 604:	32 0b       	sbc	r19, r18
 606:	00 00       	nop
 608:	09 2e       	mov	r0, r25
 60a:	01 03       	mulsu	r16, r17
 60c:	0e 3a       	cpi	r16, 0xAE	; 174
 60e:	0b 3b       	cpi	r16, 0xBB	; 187
 610:	0b 27       	eor	r16, r27
      delayMicroseconds(150); // wait min of 100us
      
      // finally, set to 4-bit interface
      send ( 0x02, FOUR_BITS );
 612:	0c 49       	sbci	r16, 0x9C	; 156
 614:	13 3c       	cpi	r17, 0xC3	; 195
 616:	0c 64       	ori	r16, 0x4C	; 76
 618:	13 01       	movw	r2, r6
 61a:	13 00       	.word	0x0013	; ????
 61c:	00 0a       	sbc	r0, r16
 61e:	05 00       	.word	0x0005	; ????
 620:	49 13       	cpse	r20, r25
 622:	34 0c       	add	r3, r4
 624:	00 00       	nop
   {
      // this is according to the hitachi HD44780 datasheet
      // page 45 figure 23
      
      // Send function set command sequence
      command(LCD_FUNCTIONSET | _displayfunction);
 626:	0b 05       	cpc	r16, r11
 628:	00 49       	sbci	r16, 0x90	; 144
 62a:	13 00       	.word	0x0013	; ????
 62c:	00 0c       	add	r0, r0
 62e:	2e 01       	movw	r4, r28
 630:	03 0e       	add	r0, r19
 632:	3a 0b       	sbc	r19, r26
 634:	3b 0b       	sbc	r19, r27
      delayMicroseconds(4500);  // wait more than 4.1ms
      
      // second try
      command(LCD_FUNCTIONSET | _displayfunction);
 636:	27 0c       	add	r2, r7
 638:	49 13       	cpse	r20, r25
 63a:	32 0b       	sbc	r19, r18
 63c:	3c 0c       	add	r3, r12
 63e:	64 13       	cpse	r22, r20
 640:	01 13       	cpse	r16, r17
 642:	00 00       	nop
 644:	0d 2e       	mov	r0, r29
 646:	01 03       	mulsu	r16, r17
 648:	0e 3a       	cpi	r16, 0xAE	; 174
      delayMicroseconds(150);
      
      // third go
      command(LCD_FUNCTIONSET | _displayfunction);
 64a:	0b 3b       	cpi	r16, 0xBB	; 187
 64c:	0b 27       	eor	r16, r27
 64e:	0c 49       	sbci	r16, 0x9C	; 156
 650:	13 4c       	sbci	r17, 0xC3	; 195
 652:	0b 4d       	sbci	r16, 0xDB	; 219
 654:	0a 1d       	adc	r16, r10
 656:	13 3c       	cpi	r17, 0xC3	; 195
 658:	0c 64       	ori	r16, 0x4C	; 76
      delayMicroseconds(150);

   }
   
   // finally, set # lines, font size, etc.
   command(LCD_FUNCTIONSET | _displayfunction);
 65a:	13 00       	.word	0x0013	; ????
 65c:	00 0e       	add	r0, r16
 65e:	0f 00       	.word	0x000f	; ????
 660:	0b 0b       	sbc	r16, r27
 662:	49 13       	cpse	r20, r25
 664:	00 00       	nop
 666:	0f 24       	eor	r0, r15
 668:	00 0b       	sbc	r16, r16
 66a:	0b 3e       	cpi	r16, 0xEB	; 235
   delayMicroseconds ( 60 );  // wait more
   
   // turn the display on with no cursor or blinking default
   _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
 66c:	0b 03       	fmul	r16, r19
 66e:	0e 00       	.word	0x000e	; ????
}

void LCD::display() 
{
   _displaycontrol |= LCD_DISPLAYON;
   command(LCD_DISPLAYCONTROL | _displaycontrol);
 670:	00 10       	cpse	r0, r0
 672:	04 01       	movw	r0, r8
 674:	03 0e       	add	r0, r19
 676:	0b 0b       	sbc	r16, r27

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
 678:	49 13       	cpse	r20, r25
 67a:	3a 0b       	sbc	r19, r26
 67c:	3b 0b       	sbc	r19, r27
 67e:	01 13       	cpse	r16, r17
 680:	00 00       	nop
 682:	11 28       	or	r1, r1
 684:	00 03       	mulsu	r16, r16
 686:	0e 1c       	adc	r0, r14
   
   // clear the LCD
   clear();
   
   // Initialize to default text direction (for romance languages)
   _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
 688:	0b 00       	.word	0x000b	; ????
 68a:	00 12       	cpse	r0, r16
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);
 68c:	16 00       	.word	0x0016	; ????
 68e:	03 0e       	add	r0, r19
 690:	3a 0b       	sbc	r19, r26
 692:	3b 0b       	sbc	r19, r27

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
 694:	49 13       	cpse	r20, r25
 696:	00 00       	nop
 698:	13 13       	cpse	r17, r19
 69a:	01 03       	mulsu	r16, r17
 69c:	08 0b       	sbc	r16, r24
 69e:	0b 3a       	cpi	r16, 0xAB	; 171
 6a0:	0b 3b       	cpi	r16, 0xBB	; 187
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);

   backlight();

}
 6a2:	0b 1d       	adc	r16, r11
 6a4:	13 01       	movw	r2, r6
 6a6:	13 00       	.word	0x0013	; ????
 6a8:	00 14       	cp	r0, r0

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
 6aa:	1c 00       	.word	0x001c	; ????
    
    @param      0..255 - the value is very dependent on the LCD. However, 
    BACKLIGHT_OFF will be interpreted as off and BACKLIGHT_ON will drive the
    backlight on.
    */
   virtual void setBacklight ( uint8_t value ) { };
 6ac:	49 13       	cpse	r20, r25
    empty function call is provided that does nothing.
    
    @param      value: pin associated to backlight control.
    @param      pol: backlight polarity control (POSITIVE, NEGATIVE)
    */
   virtual void setBacklightPin ( uint8_t value, t_backlightPol pol ) { };
 6ae:	38 0a       	sbc	r3, r24
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 6b0:	32 0b       	sbc	r19, r18
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 6b2:	00 00       	nop
 6b4:	15 0d       	add	r17, r5
 6b6:	00 03       	mulsu	r16, r16
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 6b8:	0e 3a       	cpi	r16, 0xAE	; 174
 6ba:	0b 3b       	cpi	r16, 0xBB	; 187
      return write((const uint8_t *)str, strlen(str));
 6bc:	05 49       	sbci	r16, 0x95	; 149
 6be:	13 38       	cpi	r17, 0x83	; 131
 6c0:	0a 32       	cpi	r16, 0x2A	; 42
 6c2:	0b 00       	.word	0x000b	; ????
 6c4:	00 16       	cp	r0, r16
 6c6:	2e 01       	movw	r4, r28
 6c8:	03 0e       	add	r0, r19
 6ca:	3a 0b       	sbc	r19, r26
 6cc:	3b 0b       	sbc	r19, r27
 6ce:	27 0c       	add	r2, r7
 6d0:	3c 0c       	add	r3, r12
 6d2:	64 13       	cpse	r22, r20
 6d4:	01 13       	cpse	r16, r17
    }
 6d6:	00 00       	nop
 6d8:	17 2e       	mov	r1, r23
 6da:	01 03       	mulsu	r16, r17
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 6dc:	0e 3a       	cpi	r16, 0xAE	; 174
 6de:	0b 3b       	cpi	r16, 0xBB	; 187
 6e0:	05 27       	eor	r16, r21
 6e2:	0c 3c       	cpi	r16, 0xCC	; 204
 6e4:	0c 64       	ori	r16, 0x4C	; 76
 6e6:	13 01       	movw	r2, r6
 6e8:	13 00       	.word	0x0013	; ????
 6ea:	00 18       	sub	r0, r0
 6ec:	2e 01       	movw	r4, r28
 6ee:	03 0e       	add	r0, r19
 6f0:	3a 0b       	sbc	r19, r26
 6f2:	3b 05       	cpc	r19, r11
 6f4:	27 0c       	add	r2, r7
 6f6:	49 13       	cpse	r20, r25
 6f8:	4c 0b       	sbc	r20, r28
 6fa:	4d 0a       	sbc	r4, r29
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 6fc:	1d 13       	cpse	r17, r29

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 6fe:	3c 0c       	add	r3, r12
 700:	64 13       	cpse	r22, r20
 702:	01 13       	cpse	r16, r17
 704:	00 00       	nop
 706:	19 2e       	mov	r1, r25
 708:	01 03       	mulsu	r16, r17

  do {
    char c = n % base;
 70a:	0e 3a       	cpi	r16, 0xAE	; 174
 70c:	0b 3b       	cpi	r16, 0xBB	; 187
 70e:	05 27       	eor	r16, r21
 710:	0c 32       	cpi	r16, 0x2C	; 44
 712:	0b 3c       	cpi	r16, 0xCB	; 203
 714:	0c 64       	ori	r16, 0x4C	; 76
 716:	13 01       	movw	r2, r6
 718:	13 00       	.word	0x0013	; ????
 71a:	00 1a       	sub	r0, r16
    n /= base;
 71c:	2e 01       	movw	r4, r28
 71e:	03 0e       	add	r0, r19

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 720:	3a 0b       	sbc	r19, r26
 722:	3b 0b       	sbc	r19, r27
 724:	27 0c       	add	r2, r7
 726:	4c 0b       	sbc	r20, r28
 728:	4d 0a       	sbc	r4, r29
 72a:	1d 13       	cpse	r17, r29
 72c:	3c 0c       	add	r3, r12
 72e:	64 13       	cpse	r22, r20
 730:	01 13       	cpse	r16, r17
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 732:	00 00       	nop
 734:	1b 2e       	mov	r1, r27
 736:	01 03       	mulsu	r16, r17
 738:	0e 3a       	cpi	r16, 0xAE	; 174
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 73a:	0b 3b       	cpi	r16, 0xBB	; 187
 73c:	05 27       	eor	r16, r21
 73e:	0c 4c       	sbci	r16, 0xCC	; 204
}
 740:	0b 4d       	sbci	r16, 0xDB	; 219
 742:	0a 1d       	adc	r16, r10
 744:	13 3c       	cpi	r17, 0xC3	; 195
 746:	0c 64       	ori	r16, 0x4C	; 76
 748:	13 01       	movw	r2, r6
 74a:	13 00       	.word	0x0013	; ????
 74c:	00 1c       	adc	r0, r0
 74e:	2e 01       	movw	r4, r28
 750:	03 0e       	add	r0, r19
 752:	3a 0b       	sbc	r19, r26
 754:	3b 05       	cpc	r19, r11
 756:	27 0c       	add	r2, r7
 758:	4c 0b       	sbc	r20, r28
 75a:	4d 0a       	sbc	r4, r29
 75c:	1d 13       	cpse	r17, r29
 75e:	3c 0c       	add	r3, r12
 760:	64 13       	cpse	r22, r20
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 762:	00 00       	nop
 764:	1d 13       	cpse	r17, r29
 766:	01 03       	mulsu	r16, r17
 768:	0e 3c       	cpi	r16, 0xCE	; 206
 76a:	0c 01       	movw	r0, r24
 76c:	13 00       	.word	0x0013	; ????
 76e:	00 1e       	adc	r0, r16
 770:	2e 01       	movw	r4, r28
 772:	03 0e       	add	r0, r19
 774:	3a 0b       	sbc	r19, r26
 776:	3b 0b       	sbc	r19, r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 778:	27 0c       	add	r2, r7
 77a:	49 13       	cpse	r20, r25
 77c:	4c 0b       	sbc	r20, r28
 77e:	4d 0a       	sbc	r4, r29
 780:	1d 13       	cpse	r17, r29
 782:	3c 0c       	add	r3, r12
 784:	64 13       	cpse	r22, r20
 786:	01 13       	cpse	r16, r17
	unsigned char f = timer0_fract;
 788:	00 00       	nop
 78a:	1f 2e       	mov	r1, r31

	m += MILLIS_INC;
	f += FRACT_INC;
 78c:	01 3f       	cpi	r16, 0xF1	; 241
 78e:	0c 03       	fmul	r16, r20
	if (f >= FRACT_MAX) {
 790:	0e 3a       	cpi	r16, 0xAE	; 174
 792:	0b 3b       	cpi	r16, 0xBB	; 187
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 794:	0b 87       	std	Y+11, r16	; 0x0b
 796:	40 0e       	add	r4, r16
 798:	27 0c       	add	r2, r7
 79a:	3c 0c       	add	r3, r12
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 79c:	64 13       	cpse	r22, r20
 79e:	00 00       	nop
		m += 1;
 7a0:	20 2e       	mov	r2, r16
 7a2:	01 03       	mulsu	r16, r17
 7a4:	0e 27       	eor	r16, r30
	}

	timer0_fract = f;
 7a6:	0c 4c       	sbci	r16, 0xCC	; 204
 7a8:	0b 4d       	sbci	r16, 0xDB	; 219
	timer0_millis = m;
 7aa:	0a 1d       	adc	r16, r10
 7ac:	13 34       	cpi	r17, 0x43	; 67
 7ae:	0c 3c       	cpi	r16, 0xCC	; 204
 7b0:	0c 64       	ori	r16, 0x4C	; 76
 7b2:	13 01       	movw	r2, r6
 7b4:	13 00       	.word	0x0013	; ????
 7b6:	00 21       	and	r16, r0
 7b8:	2e 01       	movw	r4, r28
	timer0_overflow_count++;
 7ba:	03 0e       	add	r0, r19
 7bc:	3a 0b       	sbc	r19, r26
 7be:	3b 0b       	sbc	r19, r27
 7c0:	27 0c       	add	r2, r7
 7c2:	32 0b       	sbc	r19, r18
 7c4:	3c 0c       	add	r3, r12
 7c6:	64 13       	cpse	r22, r20
 7c8:	01 13       	cpse	r16, r17
 7ca:	00 00       	nop
 7cc:	22 2e       	mov	r2, r18
 7ce:	01 03       	mulsu	r16, r17
 7d0:	0e 3a       	cpi	r16, 0xAE	; 174
 7d2:	0b 3b       	cpi	r16, 0xBB	; 187
 7d4:	0b 27       	eor	r16, r27
 7d6:	0c 4c       	sbci	r16, 0xCC	; 204
 7d8:	0b 4d       	sbci	r16, 0xDB	; 219
 7da:	0a 1d       	adc	r16, r10
 7dc:	13 3c       	cpi	r17, 0xC3	; 195
 7de:	0c 64       	ori	r16, 0x4C	; 76
}
 7e0:	13 00       	.word	0x0013	; ????
 7e2:	00 23       	and	r16, r16
 7e4:	13 00       	.word	0x0013	; ????
 7e6:	03 08       	sbc	r0, r3
 7e8:	3c 0c       	add	r3, r12
 7ea:	00 00       	nop
 7ec:	24 01       	movw	r4, r8
 7ee:	01 49       	sbci	r16, 0x91	; 145
 7f0:	13 01       	movw	r2, r6
 7f2:	13 00       	.word	0x0013	; ????
 7f4:	00 25       	eor	r16, r0
  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
 7f6:	21 00       	.word	0x0021	; ????
 7f8:	49 13       	cpse	r20, r25
 7fa:	2f 0b       	sbc	r18, r31
 7fc:	00 00       	nop
 7fe:	26 13       	cpse	r18, r22
 800:	00 03       	mulsu	r16, r16
 802:	0e 3c       	cpi	r16, 0xCE	; 206
 804:	0c 00       	.word	0x000c	; ????
 806:	00 27       	eor	r16, r16
 808:	2e 01       	movw	r4, r28
 80a:	03 0e       	add	r0, r19
 80c:	3a 0b       	sbc	r19, r26
 80e:	3b 0b       	sbc	r19, r27
 810:	27 0c       	add	r2, r7
 812:	3c 0c       	add	r3, r12
 814:	64 13       	cpse	r22, r20
 816:	00 00       	nop
  switch(TW_STATUS){
 818:	28 26       	eor	r2, r24
 81a:	00 49       	sbci	r16, 0x90	; 144
 81c:	13 00       	.word	0x0013	; ????
 81e:	00 29       	or	r16, r0
 820:	2e 01       	movw	r4, r28
 822:	47 13       	cpse	r20, r23
 824:	20 0b       	sbc	r18, r16
 826:	64 13       	cpse	r22, r20
 828:	01 13       	cpse	r16, r17
 82a:	00 00       	nop
 82c:	2a 05       	cpc	r18, r10
 82e:	00 03       	mulsu	r16, r16
 830:	0e 49       	sbci	r16, 0x9E	; 158
 832:	13 34       	cpi	r17, 0x43	; 67
 834:	0c 00       	.word	0x000c	; ????
 836:	00 2b       	or	r16, r16
 838:	2e 01       	movw	r4, r28
 83a:	47 13       	cpse	r20, r23
 83c:	3a 0b       	sbc	r19, r26
 83e:	3b 0b       	sbc	r19, r27
 840:	20 0b       	sbc	r18, r16
 842:	64 13       	cpse	r22, r20
 844:	01 13       	cpse	r16, r17
 846:	00 00       	nop
 848:	2c 05       	cpc	r18, r12
 84a:	00 03       	mulsu	r16, r16
 84c:	0e 3a       	cpi	r16, 0xAE	; 174
 84e:	0b 3b       	cpi	r16, 0xBB	; 187
 850:	0b 49       	sbci	r16, 0x9B	; 155
 852:	13 00       	.word	0x0013	; ????
 854:	00 2d       	mov	r16, r0
 856:	34 00       	.word	0x0034	; ????
 858:	03 0e       	add	r0, r19
 85a:	3a 0b       	sbc	r19, r26
 85c:	3b 0b       	sbc	r19, r27
 85e:	49 13       	cpse	r20, r25
 860:	00 00       	nop
 862:	2e 05       	cpc	r18, r14
 864:	00 03       	mulsu	r16, r16
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
 866:	08 3a       	cpi	r16, 0xA8	; 168
 868:	0b 3b       	cpi	r16, 0xBB	; 187
 86a:	0b 49       	sbci	r16, 0x9B	; 155
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 86c:	13 00       	.word	0x0013	; ????
 86e:	00 2f       	mov	r16, r16
 870:	05 00       	.word	0x0005	; ????
 872:	03 0e       	add	r0, r19
 874:	3a 0b       	sbc	r19, r26
 876:	3b 05       	cpc	r19, r11
 878:	49 13       	cpse	r20, r25
 87a:	00 00       	nop
 87c:	30 0b       	sbc	r19, r16
 87e:	01 00       	.word	0x0001	; ????
 880:	00 31       	cpi	r16, 0x10	; 16
 882:	34 00       	.word	0x0034	; ????
 884:	03 08       	sbc	r0, r3
 886:	3a 0b       	sbc	r19, r26
 888:	3b 05       	cpc	r19, r11
 88a:	49 13       	cpse	r20, r25
 88c:	00 00       	nop
 88e:	32 34       	cpi	r19, 0x42	; 66
 890:	00 03       	mulsu	r16, r16
 892:	08 3a       	cpi	r16, 0xA8	; 168
 894:	0b 3b       	cpi	r16, 0xBB	; 187
 896:	0b 49       	sbci	r16, 0x9B	; 155
 898:	13 00       	.word	0x0013	; ????
 89a:	00 33       	cpi	r16, 0x30	; 48
 89c:	2e 01       	movw	r4, r28
 89e:	03 0e       	add	r0, r19
 8a0:	3a 0b       	sbc	r19, r26
 8a2:	3b 0b       	sbc	r19, r27
 8a4:	27 0c       	add	r2, r7
 8a6:	20 0b       	sbc	r18, r16
 8a8:	01 13       	cpse	r16, r17
 8aa:	00 00       	nop
 8ac:	34 0b       	sbc	r19, r20
 8ae:	01 01       	movw	r0, r2
 8b0:	13 00       	.word	0x0013	; ????
 8b2:	00 35       	cpi	r16, 0x50	; 80
 8b4:	35 00       	.word	0x0035	; ????
 8b6:	49 13       	cpse	r20, r25
 8b8:	00 00       	nop
 8ba:	36 2e       	mov	r3, r22
 8bc:	01 03       	mulsu	r16, r17
 8be:	0e 27       	eor	r16, r30
 8c0:	0c 34       	cpi	r16, 0x4C	; 76
 8c2:	0c 20       	and	r0, r12
 8c4:	0b 01       	movw	r0, r22
 8c6:	13 00       	.word	0x0013	; ????
 8c8:	00 37       	cpi	r16, 0x70	; 112
 8ca:	2e 01       	movw	r4, r28
 8cc:	31 13       	cpse	r19, r17
 8ce:	11 01       	movw	r2, r2
 8d0:	12 01       	movw	r2, r4
 8d2:	40 0a       	sbc	r4, r16
 8d4:	97 42       	sbci	r25, 0x27	; 39
 8d6:	0c 01       	movw	r0, r24
 8d8:	13 00       	.word	0x0013	; ????
 8da:	00 38       	cpi	r16, 0x80	; 128
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
 8dc:	05 00       	.word	0x0005	; ????
 8de:	31 13       	cpse	r19, r17
 8e0:	02 06       	cpc	r0, r18

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
 8e2:	00 00       	nop
 8e4:	39 34       	cpi	r19, 0x49	; 73
 8e6:	00 31       	cpi	r16, 0x10	; 16
 8e8:	13 02       	muls	r17, r19
 8ea:	0a 00       	.word	0x000a	; ????
 8ec:	00 3a       	cpi	r16, 0xA0	; 160
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
 8ee:	34 00       	.word	0x0034	; ????
 8f0:	31 13       	cpse	r19, r17
 8f2:	02 06       	cpc	r0, r18
 8f4:	00 00       	nop
 8f6:	3b 34       	cpi	r19, 0x4B	; 75
 8f8:	00 31       	cpi	r16, 0x10	; 16
 8fa:	13 00       	.word	0x0013	; ????
 8fc:	00 3c       	cpi	r16, 0xC0	; 192
 8fe:	05 00       	.word	0x0005	; ????
 900:	31 13       	cpse	r19, r17
 902:	1c 0b       	sbc	r17, r28
 904:	00 00       	nop
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 906:	3d 0b       	sbc	r19, r29
 908:	01 11       	cpse	r16, r1
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
 90a:	01 12       	cpse	r0, r17
 90c:	01 01       	movw	r0, r2
 90e:	13 00       	.word	0x0013	; ????
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 910:	00 3e       	cpi	r16, 0xE0	; 224
 912:	0b 01       	movw	r0, r22
 914:	11 01       	movw	r2, r2
 916:	12 01       	movw	r2, r4
 918:	00 00       	nop
 91a:	3f 2e       	mov	r3, r31
 91c:	01 03       	mulsu	r16, r17
 91e:	0e 3a       	cpi	r16, 0xAE	; 174
 920:	0b 3b       	cpi	r16, 0xBB	; 187
 922:	0b 27       	eor	r16, r27
 924:	0c 11       	cpse	r16, r12
 926:	01 12       	cpse	r0, r17
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
 928:	01 40       	sbci	r16, 0x01	; 1
 92a:	0a 97       	sbiw	r24, 0x0a	; 10
 92c:	42 0c       	add	r4, r2
 92e:	01 13       	cpse	r16, r17
 930:	00 00       	nop
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 932:	40 05       	cpc	r20, r0
 934:	00 03       	mulsu	r16, r16
 936:	08 3a       	cpi	r16, 0xA8	; 168
 938:	0b 3b       	cpi	r16, 0xBB	; 187
 93a:	0b 49       	sbci	r16, 0x9B	; 155
 93c:	13 02       	muls	r17, r19
 93e:	06 00       	.word	0x0006	; ????
 940:	00 41       	sbci	r16, 0x10	; 16
 942:	05 00       	.word	0x0005	; ????
 944:	03 08       	sbc	r0, r3
 946:	3a 0b       	sbc	r19, r26
 948:	3b 0b       	sbc	r19, r27
	if (twi_sendStop)
 94a:	49 13       	cpse	r20, r25
 94c:	02 0a       	sbc	r0, r18
 94e:	00 00       	nop
 950:	42 34       	cpi	r20, 0x42	; 66
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
 952:	00 03       	mulsu	r16, r16
 954:	0e 3a       	cpi	r16, 0xAE	; 174
 956:	0b 3b       	cpi	r16, 0xBB	; 187
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
 958:	0b 49       	sbci	r16, 0x9B	; 155
 95a:	13 02       	muls	r17, r19
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
 95c:	0a 00       	.word	0x000a	; ????
 95e:	00 43       	sbci	r16, 0x30	; 48
 960:	34 00       	.word	0x0034	; ????
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
 962:	03 08       	sbc	r0, r3
 964:	3a 0b       	sbc	r19, r26
 966:	3b 0b       	sbc	r19, r27
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 968:	49 13       	cpse	r20, r25
 96a:	02 06       	cpc	r0, r18
 96c:	00 00       	nop
 96e:	44 34       	cpi	r20, 0x44	; 68
 970:	00 03       	mulsu	r16, r16
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
 972:	0e 3a       	cpi	r16, 0xAE	; 174
 974:	0b 3b       	cpi	r16, 0xBB	; 187
 976:	0b 49       	sbci	r16, 0x9B	; 155
 978:	13 02       	muls	r17, r19
 97a:	06 00       	.word	0x0006	; ????
 97c:	00 45       	sbci	r16, 0x50	; 80
 97e:	1d 01       	movw	r2, r26
 980:	31 13       	cpse	r19, r17
 982:	11 01       	movw	r2, r2
 984:	12 01       	movw	r2, r4
 986:	58 0b       	sbc	r21, r24
 988:	59 0b       	sbc	r21, r25
 98a:	01 13       	cpse	r16, r17
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
 98c:	00 00       	nop
 98e:	46 2e       	mov	r4, r22
 990:	01 31       	cpi	r16, 0x11	; 17

  // update twi state
  twi_state = TWI_READY;
 992:	13 11       	cpse	r17, r3
 994:	01 12       	cpse	r0, r17
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 996:	01 40       	sbci	r16, 0x01	; 1
 998:	06 64       	ori	r16, 0x46	; 70
 99a:	13 97       	sbiw	r26, 0x03	; 3
 99c:	42 0c       	add	r4, r2
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
 99e:	01 13       	cpse	r16, r17
 9a0:	00 00       	nop
 9a2:	47 89       	ldd	r20, Z+23	; 0x17
 9a4:	82 01       	movw	r16, r4
 9a6:	00 11       	cpse	r16, r0
 9a8:	01 31       	cpi	r16, 0x11	; 17
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
 9aa:	13 00       	.word	0x0013	; ????
 9ac:	00 48       	sbci	r16, 0x80	; 128
 9ae:	1d 01       	movw	r2, r26
 9b0:	31 13       	cpse	r19, r17
 9b2:	52 01       	movw	r10, r4
 9b4:	55 06       	cpc	r5, r21
 9b6:	58 0b       	sbc	r21, r24
 9b8:	59 05       	cpc	r21, r9
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
 9ba:	00 00       	nop
 9bc:	49 89       	ldd	r20, Y+17	; 0x11
 9be:	82 01       	movw	r16, r4
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
 9c0:	01 11       	cpse	r16, r1
 9c2:	01 31       	cpi	r16, 0x11	; 17
 9c4:	13 01       	movw	r2, r6
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
 9c6:	13 00       	.word	0x0013	; ????
 9c8:	00 4a       	sbci	r16, 0xA0	; 160
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
 9ca:	8a 82       	std	Y+2, r8	; 0x02
 9cc:	01 00       	.word	0x0001	; ????
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
 9ce:	02 0a       	sbc	r0, r18
 9d0:	91 42       	sbci	r25, 0x21	; 33
 9d2:	0a 00       	.word	0x000a	; ????
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
 9d4:	00 4b       	sbci	r16, 0xB0	; 176
 9d6:	89 82       	std	Y+1, r8	; 0x01
 9d8:	01 01       	movw	r0, r2
 9da:	11 01       	movw	r2, r2
        twi_txBufferLength = 1;
 9dc:	95 42       	sbci	r25, 0x25	; 37
 9de:	0c 31       	cpi	r16, 0x1C	; 28
 9e0:	13 00       	.word	0x0013	; ????
        twi_txBuffer[0] = 0x00;
 9e2:	00 4c       	sbci	r16, 0xC0	; 192
 9e4:	2e 01       	movw	r4, r28
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
 9e6:	03 0e       	add	r0, r19
 9e8:	3a 0b       	sbc	r19, r26
 9ea:	3b 0b       	sbc	r19, r27
 9ec:	27 0c       	add	r2, r7
 9ee:	49 13       	cpse	r20, r25
 9f0:	11 01       	movw	r2, r2
 9f2:	12 01       	movw	r2, r4
 9f4:	40 0a       	sbc	r4, r16
 9f6:	97 42       	sbci	r25, 0x27	; 39
 9f8:	0c 01       	movw	r0, r24
 9fa:	13 00       	.word	0x0013	; ????
 9fc:	00 4d       	sbci	r16, 0xD0	; 208
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
 9fe:	34 00       	.word	0x0034	; ????
 a00:	03 08       	sbc	r0, r3
 a02:	3a 0b       	sbc	r19, r26
 a04:	3b 0b       	sbc	r19, r27
 a06:	49 13       	cpse	r20, r25
 a08:	02 0a       	sbc	r0, r18
 a0a:	00 00       	nop
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 a0c:	4e 2e       	mov	r4, r30
 a0e:	00 03       	mulsu	r16, r16
 a10:	0e 3a       	cpi	r16, 0xAE	; 174
 a12:	0b 3b       	cpi	r16, 0xBB	; 187
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 a14:	0b 20       	and	r0, r11
 a16:	0b 00       	.word	0x000b	; ????
 a18:	00 4f       	sbci	r16, 0xF0	; 240
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
 a1a:	2e 01       	movw	r4, r28
 a1c:	03 0e       	add	r0, r19
 a1e:	3a 0b       	sbc	r19, r26

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
 a20:	3b 0b       	sbc	r19, r27
 a22:	27 0c       	add	r2, r7
      twi_stop();
 a24:	11 01       	movw	r2, r2
 a26:	12 01       	movw	r2, r4
      break;
  }
}
 a28:	40 06       	cpc	r4, r16
 a2a:	97 42       	sbci	r25, 0x27	; 39
 a2c:	0c 01       	movw	r0, r24
 a2e:	13 00       	.word	0x0013	; ????
 a30:	00 50       	subi	r16, 0x00	; 0
 a32:	2e 01       	movw	r4, r28
 a34:	47 13       	cpse	r20, r23
 a36:	11 01       	movw	r2, r2
 a38:	12 01       	movw	r2, r4
 a3a:	40 06       	cpc	r4, r16
 a3c:	64 13       	cpse	r22, r20
 a3e:	97 42       	sbci	r25, 0x27	; 39
 a40:	0c 01       	movw	r0, r24
 a42:	13 00       	.word	0x0013	; ????
 a44:	00 51       	subi	r16, 0x10	; 16
 a46:	05 00       	.word	0x0005	; ????
 a48:	03 0e       	add	r0, r19
 a4a:	49 13       	cpse	r20, r25
 a4c:	34 0c       	add	r3, r4
 a4e:	02 06       	cpc	r0, r18
 a50:	00 00       	nop
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 a52:	52 05       	cpc	r21, r2
 a54:	00 03       	mulsu	r16, r16
 a56:	0e 3a       	cpi	r16, 0xAE	; 174
 a58:	0b 3b       	cpi	r16, 0xBB	; 187
 a5a:	0b 49       	sbci	r16, 0x9B	; 155
 a5c:	13 02       	muls	r17, r19
 a5e:	06 00       	.word	0x0006	; ????
 a60:	00 53       	subi	r16, 0x30	; 48
 a62:	89 82       	std	Y+1, r8	; 0x01
 a64:	01 01       	movw	r0, r2
 a66:	11 01       	movw	r2, r2
 a68:	00 00       	nop
 a6a:	54 2e       	mov	r5, r20
 a6c:	00 03       	mulsu	r16, r16
 a6e:	0e 3a       	cpi	r16, 0xAE	; 174
 a70:	0b 3b       	cpi	r16, 0xBB	; 187
void (*TwoWire::user_onRequest)(void);
void (*TwoWire::user_onReceive)(int);

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire()
 a72:	05 27       	eor	r16, r21
 a74:	0c 11       	cpse	r16, r12
 a76:	01 12       	cpse	r0, r17
 a78:	01 40       	sbci	r16, 0x01	; 1
 a7a:	0a 97       	sbiw	r24, 0x0a	; 10
 a7c:	42 0c       	add	r4, r2
 a7e:	00 00       	nop
 a80:	55 2e       	mov	r5, r21
 a82:	01 03       	mulsu	r16, r17
 a84:	0e 27       	eor	r16, r30
// CONSTRUCTORS
// ---------------------------------------------------------------------------

LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
                             uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
                             uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
 a86:	0c 49       	sbci	r16, 0x9C	; 156
 a88:	13 34       	cpi	r17, 0x43	; 67
 a8a:	0c 20       	and	r0, r12
 a8c:	0b 01       	movw	r0, r22
 a8e:	13 00       	.word	0x0013	; ????
 a90:	00 56       	subi	r16, 0x60	; 96
   uint8_t i;
   
   // Initialize the IO pins
   // -----------------------
   
   _rs_pin = rs;
 a92:	2e 01       	movw	r4, r28
 a94:	03 0e       	add	r0, r19
 a96:	3a 0b       	sbc	r19, r26
   _rw_pin = rw;
 a98:	3b 05       	cpc	r19, r11
 a9a:	27 0c       	add	r2, r7
 a9c:	49 13       	cpse	r20, r25
   _enable_pin = enable;
 a9e:	20 0b       	sbc	r18, r16
 aa0:	01 13       	cpse	r16, r17
 aa2:	00 00       	nop
   
   _data_pins[0] = d0;
 aa4:	57 05       	cpc	r21, r7
 aa6:	00 31       	cpi	r16, 0x10	; 16
 aa8:	13 00       	.word	0x0013	; ????
   _data_pins[1] = d1;
 aaa:	00 58       	subi	r16, 0x80	; 128
 aac:	2e 01       	movw	r4, r28
 aae:	47 13       	cpse	r20, r23
   _data_pins[2] = d2;
 ab0:	11 01       	movw	r2, r2
 ab2:	12 01       	movw	r2, r4
 ab4:	40 0a       	sbc	r4, r16
   _data_pins[3] = d3; 
 ab6:	64 13       	cpse	r22, r20
 ab8:	97 42       	sbci	r25, 0x27	; 39
 aba:	0c 01       	movw	r0, r24
   _data_pins[4] = d4;
 abc:	13 00       	.word	0x0013	; ????
 abe:	00 59       	subi	r16, 0x90	; 144
 ac0:	05 00       	.word	0x0005	; ????
   _data_pins[5] = d5;
 ac2:	03 0e       	add	r0, r19
 ac4:	49 13       	cpse	r20, r25
 ac6:	34 0c       	add	r3, r4
   _data_pins[6] = d6;
 ac8:	02 0a       	sbc	r0, r18
 aca:	00 00       	nop
 acc:	5a 34       	cpi	r21, 0x4A	; 74
   _data_pins[7] = d7;
 ace:	00 03       	mulsu	r16, r16
 ad0:	0e 3a       	cpi	r16, 0xAE	; 174
 ad2:	0b 3b       	cpi	r16, 0xBB	; 187
 ad4:	05 49       	sbci	r16, 0x95	; 149
 ad6:	13 1c       	adc	r1, r3
 ad8:	0d 00       	.word	0x000d	; ????
 ada:	00 5b       	subi	r16, 0xB0	; 176
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
   {
      pinMode ( _data_pins[i], OUTPUT );
 adc:	34 00       	.word	0x0034	; ????
 ade:	03 0e       	add	r0, r19
 ae0:	3a 0b       	sbc	r19, r26
 ae2:	3b 0b       	sbc	r19, r27
 ae4:	49 13       	cpse	r20, r25
   _data_pins[7] = d7;
   
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
 ae6:	1c 0d       	add	r17, r12
 ae8:	00 00       	nop
 aea:	5c 89       	ldd	r21, Y+20	; 0x14
 aec:	82 01       	movw	r16, r4
 aee:	01 11       	cpse	r16, r1
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
      {
         pinMode ( _data_pins[i], OUTPUT );
 af0:	01 31       	cpi	r16, 0x11	; 17
 af2:	13 00       	.word	0x0013	; ????
 af4:	00 5d       	subi	r16, 0xD0	; 208
   // Initialize the rest of the ports if it is an 8bit controlled LCD
   // ----------------------------------------------------------------
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
 af6:	89 82       	std	Y+1, r8	; 0x01
 af8:	01 00       	.word	0x0001	; ????
 afa:	11 01       	movw	r2, r2
      {
         pinMode ( _data_pins[i], OUTPUT );
      }
   }
   pinMode(_rs_pin, OUTPUT);
 afc:	95 42       	sbci	r25, 0x25	; 37
 afe:	0c 31       	cpi	r16, 0x1C	; 28
 b00:	13 00       	.word	0x0013	; ????
 b02:	00 5e       	subi	r16, 0xE0	; 224
   
   // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
   if (_rw_pin != 255) 
 b04:	89 82       	std	Y+1, r8	; 0x01
 b06:	01 01       	movw	r0, r2
 b08:	11 01       	movw	r2, r2
 b0a:	95 42       	sbci	r25, 0x25	; 37
   { 
      pinMode(_rw_pin, OUTPUT);
 b0c:	0c 00       	.word	0x000c	; ????
 b0e:	00 5f       	subi	r16, 0xF0	; 240
   }
   
   pinMode(_enable_pin, OUTPUT);
 b10:	05 00       	.word	0x0005	; ????
 b12:	03 0e       	add	r0, r19
 b14:	3a 0b       	sbc	r19, r26
 b16:	3b 05       	cpc	r19, r11
   // Initialise displaymode functions to defaults: LCD_1LINE and LCD_5x8DOTS
   // -------------------------------------------------------------------------
   if (fourbitmode)
      _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
   else 
      _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
 b18:	49 13       	cpse	r20, r25
 b1a:	02 06       	cpc	r0, r18
 b1c:	00 00       	nop
   
   // Now we pull both RS and R/W low to begin commands
   digitalWrite(_rs_pin, LOW);
 b1e:	60 2e       	mov	r6, r16
 b20:	01 31       	cpi	r16, 0x11	; 17
 b22:	13 11       	cpse	r17, r3
 b24:	01 12       	cpse	r0, r17
 b26:	01 40       	sbci	r16, 0x01	; 1
   digitalWrite(_enable_pin, LOW);
 b28:	06 97       	sbiw	r24, 0x06	; 6
 b2a:	42 0c       	add	r4, r2
 b2c:	01 13       	cpse	r16, r17
 b2e:	00 00       	nop
 b30:	61 05       	cpc	r22, r1
   
   if (_rw_pin != 255) 
 b32:	00 31       	cpi	r16, 0x10	; 16
 b34:	13 02       	muls	r17, r19
 b36:	0a 00       	.word	0x000a	; ????
 b38:	00 62       	ori	r16, 0x20	; 32
   { 
      digitalWrite(_rw_pin, LOW);
 b3a:	1d 01       	movw	r2, r26
 b3c:	31 13       	cpse	r19, r17
 b3e:	52 01       	movw	r10, r4
   }
   
   // Initialise the backlight pin no nothing
   _backlightPin = LCD_NOBACKLIGHT;
 b40:	55 06       	cpc	r5, r21
 b42:	58 0b       	sbc	r21, r24
 b44:	59 0b       	sbc	r21, r25
   _polarity = POSITIVE;
 b46:	01 13       	cpse	r16, r17
 b48:	00 00       	nop
 b4a:	63 89       	ldd	r22, Z+19	; 0x13
 b4c:	82 01       	movw	r16, r4
 b4e:	01 11       	cpse	r16, r1
 b50:	01 01       	movw	r0, r2
 b52:	13 00       	.word	0x0013	; ????
 b54:	00 64       	ori	r16, 0x40	; 64
 b56:	05 00       	.word	0x0005	; ????

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 b58:	03 0e       	add	r0, r19
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 b5a:	3a 0b       	sbc	r19, r26
 b5c:	3b 05       	cpc	r19, r11
 b5e:	49 13       	cpse	r20, r25
	sbi(TCCR0A, WGM00);
 b60:	02 0a       	sbc	r0, r18
 b62:	00 00       	nop
 b64:	65 05       	cpc	r22, r5
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 b66:	00 03       	mulsu	r16, r16
 b68:	08 3a       	cpi	r16, 0xA8	; 168
 b6a:	0b 3b       	cpi	r16, 0xBB	; 187
	sbi(TCCR0B, CS00);
 b6c:	05 49       	sbci	r16, 0x95	; 149
 b6e:	13 02       	muls	r17, r19
 b70:	0a 00       	.word	0x000a	; ????

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 b72:	00 66       	ori	r16, 0x60	; 96
 b74:	2e 01       	movw	r4, r28
 b76:	03 0e       	add	r0, r19
 b78:	3a 0b       	sbc	r19, r26
 b7a:	3b 0b       	sbc	r19, r27
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 b7c:	27 0c       	add	r2, r7
 b7e:	87 01       	movw	r16, r14

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 b80:	0c 11       	cpse	r16, r12
 b82:	01 12       	cpse	r0, r17
 b84:	01 40       	sbci	r16, 0x01	; 1
 b86:	0a 97       	sbiw	r24, 0x0a	; 10
 b88:	42 0c       	add	r4, r2
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 b8a:	01 13       	cpse	r16, r17
 b8c:	00 00       	nop
 b8e:	67 89       	ldd	r22, Z+23	; 0x17
 b90:	82 01       	movw	r16, r4
 b92:	00 11       	cpse	r16, r0
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 b94:	01 00       	.word	0x0001	; ????
 b96:	00 68       	ori	r16, 0x80	; 128
 b98:	2e 00       	.word	0x002e	; ????
 b9a:	03 0e       	add	r0, r19
 b9c:	27 0c       	add	r2, r7

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 b9e:	34 0c       	add	r3, r4
 ba0:	20 0b       	sbc	r18, r16
 ba2:	00 00       	nop
 ba4:	69 2e       	mov	r6, r25
 ba6:	01 03       	mulsu	r16, r17

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 ba8:	0e 27       	eor	r16, r30
 baa:	0c 34       	cpi	r16, 0x4C	; 76
 bac:	0c 11       	cpse	r16, r12
 bae:	01 12       	cpse	r0, r17
 bb0:	01 40       	sbci	r16, 0x01	; 1
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 bb2:	06 97       	sbiw	r24, 0x06	; 6
 bb4:	42 0c       	add	r4, r2
 bb6:	01 13       	cpse	r16, r17
 bb8:	00 00       	nop
 bba:	6a 1d       	adc	r22, r10
		sbi(ADCSRA, ADPS1);
 bbc:	01 11       	cpse	r16, r1
 bbe:	01 12       	cpse	r0, r17
 bc0:	01 58       	subi	r16, 0x81	; 129
 bc2:	0b 59       	subi	r16, 0x9B	; 155
 bc4:	05 01       	movw	r0, r10
		sbi(ADCSRA, ADPS0);
 bc6:	13 00       	.word	0x0013	; ????
 bc8:	00 6b       	ori	r16, 0xB0	; 176
 bca:	34 00       	.word	0x0034	; ????
 bcc:	02 06       	cpc	r0, r18
 bce:	00 00       	nop
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 bd0:	6c 1d       	adc	r22, r12
 bd2:	01 31       	cpi	r16, 0x11	; 17
 bd4:	13 11       	cpse	r17, r3
 bd6:	01 12       	cpse	r0, r17
 bd8:	01 58       	subi	r16, 0x81	; 129
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 bda:	0b 59       	subi	r16, 0x9B	; 155
 bdc:	05 00       	.word	0x0005	; ????
// ----------

void setup()
{
  // some displays need time to initialize
  delay(1000);
 bde:	00 6d       	ori	r16, 0xD0	; 208
 be0:	1d 01       	movw	r2, r26
 be2:	31 13       	cpse	r19, r17
 be4:	11 01       	movw	r2, r2
 be6:	12 01       	movw	r2, r4
 be8:	58 0b       	sbc	r21, r24
  // initialize LCD and set up the number of columns and rows
  lcd.begin(16, 2);
 bea:	59 0b       	sbc	r21, r25
 bec:	00 00       	nop
 bee:	6e 34       	cpi	r22, 0x4E	; 78
 bf0:	00 00       	nop
 bf2:	00 6f       	ori	r16, 0xF0	; 240
 bf4:	2e 00       	.word	0x002e	; ????
 bf6:	47 13       	cpse	r20, r23
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 bf8:	20 0b       	sbc	r18, r16

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 bfa:	00 00       	nop
	m = timer0_millis;
 bfc:	70 2e       	mov	r7, r16
 bfe:	01 3f       	cpi	r16, 0xF1	; 241
 c00:	0c 03       	fmul	r16, r20
 c02:	0e 3a       	cpi	r16, 0xAE	; 174
 c04:	0b 3b       	cpi	r16, 0xBB	; 187
 c06:	0b 27       	eor	r16, r27
 c08:	0c 11       	cpse	r16, r12
 c0a:	01 12       	cpse	r0, r17
	SREG = oldSREG;
 c0c:	01 40       	sbci	r16, 0x01	; 1

  _startTime_ms = millis();
 c0e:	06 97       	sbiw	r24, 0x06	; 6
 c10:	42 0c       	add	r4, r2
 c12:	01 13       	cpse	r16, r17
 c14:	00 00       	nop
 c16:	71 2e       	mov	r7, r17
 c18:	00 03       	mulsu	r16, r16
 c1a:	0e 3a       	cpi	r16, 0xAE	; 174
 c1c:	0b 3b       	cpi	r16, 0xBB	; 187
	

#endif

	// busy wait
	__asm__ __volatile__ (
 c1e:	0b 27       	eor	r16, r27
 c20:	0c 20       	and	r0, r12
 c22:	0b 00       	.word	0x000b	; ????
 c24:	00 72       	andi	r16, 0x20	; 32
}

void loop() 
{
  if (0 == _loopCounter--) {
 c26:	2e 01       	movw	r4, r28
 c28:	03 0e       	add	r0, r19
 c2a:	3a 0b       	sbc	r19, r26
 c2c:	3b 0b       	sbc	r19, r27
 c2e:	27 0c       	add	r2, r7
 c30:	49 13       	cpse	r20, r25
 c32:	20 0b       	sbc	r18, r16
 c34:	01 13       	cpse	r16, r17
 c36:	00 00       	nop
 c38:	73 2e       	mov	r7, r19
 c3a:	01 3f       	cpi	r16, 0xF1	; 241
 c3c:	0c 03       	fmul	r16, r20
 c3e:	0e 3a       	cpi	r16, 0xAE	; 174
 c40:	0b 3b       	cpi	r16, 0xBB	; 187
 c42:	0b 27       	eor	r16, r27
 c44:	0c 49       	sbci	r16, 0x9C	; 156
 c46:	13 87       	std	Z+11, r17	; 0x0b
 c48:	01 0c       	add	r0, r1
 c4a:	11 01       	movw	r2, r2
 c4c:	12 01       	movw	r2, r4
 c4e:	40 0a       	sbc	r4, r16
 c50:	97 42       	sbci	r25, 0x27	; 39
 c52:	0c 01       	movw	r0, r24
 c54:	13 00       	.word	0x0013	; ????
 c56:	00 74       	andi	r16, 0x40	; 64
 c58:	1d 00       	.word	0x001d	; ????
 c5a:	31 13       	cpse	r19, r17
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 c5c:	11 01       	movw	r2, r2

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 c5e:	12 01       	movw	r2, r4
	m = timer0_millis;
 c60:	58 0b       	sbc	r21, r24
 c62:	59 0b       	sbc	r21, r25
 c64:	00 00       	nop
 c66:	75 0b       	sbc	r23, r21
 c68:	01 55       	subi	r16, 0x51	; 81
 c6a:	06 00       	.word	0x0006	; ????
 c6c:	00 76       	andi	r16, 0x60	; 96
 c6e:	2e 00       	.word	0x002e	; ????
	SREG = oldSREG;
 c70:	03 0e       	add	r0, r19

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
 c72:	3a 0b       	sbc	r19, r26
 c74:	3b 05       	cpc	r19, r11
 c76:	27 0c       	add	r2, r7
 c78:	20 0b       	sbc	r18, r16
 c7a:	00 00       	nop
	

#endif

	// busy wait
	__asm__ __volatile__ (
 c7c:	77 2e       	mov	r7, r23
 c7e:	01 3f       	cpi	r16, 0xF1	; 241
 c80:	0c 03       	fmul	r16, r20
    // 3000000 loops in 6225 [ms]
    unsigned long endTime_ms = millis();
  
    lcd.clear();
    lcd.setCursor(0, 0);
 c82:	0e 3a       	cpi	r16, 0xAE	; 174
 c84:	0b 3b       	cpi	r16, 0xBB	; 187
 c86:	05 27       	eor	r16, r21
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 c88:	0c 11       	cpse	r16, r12
 c8a:	01 12       	cpse	r0, r17
 c8c:	01 40       	sbci	r16, 0x01	; 1
 c8e:	06 97       	sbiw	r24, 0x06	; 6
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 c90:	42 0c       	add	r4, r2
 c92:	01 13       	cpse	r16, r17
 c94:	00 00       	nop
 c96:	78 1d       	adc	r23, r8
 c98:	01 31       	cpi	r16, 0x11	; 17
 c9a:	13 11       	cpse	r17, r3
 c9c:	01 12       	cpse	r0, r17
    lcd.print("Loops: ");
    lcd.print(C_LOOP_COUNT);
  
    lcd.setCursor(0, 1);
 c9e:	01 58       	subi	r16, 0x81	; 129
 ca0:	0b 59       	subi	r16, 0x9B	; 155
 ca2:	05 01       	movw	r0, r10
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 ca4:	13 00       	.word	0x0013	; ????
 ca6:	00 79       	andi	r16, 0x90	; 144
 ca8:	34 00       	.word	0x0034	; ????
 caa:	03 08       	sbc	r0, r3
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 cac:	3a 0b       	sbc	r19, r26
 cae:	3b 05       	cpc	r19, r11
 cb0:	49 13       	cpse	r20, r25
 cb2:	02 06       	cpc	r0, r18
 cb4:	00 00       	nop
 cb6:	7a 1d       	adc	r23, r10
 cb8:	00 31       	cpi	r16, 0x10	; 16
 cba:	13 11       	cpse	r17, r3
 cbc:	01 12       	cpse	r0, r17
 cbe:	01 58       	subi	r16, 0x81	; 129
 cc0:	0b 59       	subi	r16, 0x9B	; 155
 cc2:	05 00       	.word	0x0005	; ????
 cc4:	00 7b       	andi	r16, 0xB0	; 176
 cc6:	89 82       	std	Y+1, r8	; 0x01
 cc8:	01 01       	movw	r0, r2
 cca:	11 01       	movw	r2, r2
 ccc:	93 42       	sbci	r25, 0x23	; 35
 cce:	0a 01       	movw	r0, r20
 cd0:	13 00       	.word	0x0013	; ????
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
 cd2:	00 7c       	andi	r16, 0xC0	; 192
 cd4:	89 82       	std	Y+1, r8	; 0x01
 cd6:	01 00       	.word	0x0001	; ????
 cd8:	11 01       	movw	r2, r2
 cda:	93 42       	sbci	r25, 0x23	; 35
 cdc:	0a 00       	.word	0x000a	; ????
 cde:	00 7d       	andi	r16, 0xD0	; 208
 ce0:	34 00       	.word	0x0034	; ????
 ce2:	03 0e       	add	r0, r19
 ce4:	3a 0b       	sbc	r19, r26
 ce6:	3b 0b       	sbc	r19, r27
 ce8:	49 13       	cpse	r20, r25
 cea:	32 0b       	sbc	r19, r18
 cec:	02 0a       	sbc	r0, r18
 cee:	00 00       	nop
 cf0:	7e 34       	cpi	r23, 0x4E	; 78
 cf2:	00 03       	mulsu	r16, r16
 cf4:	0e 3a       	cpi	r16, 0xAE	; 174
 cf6:	0b 3b       	cpi	r16, 0xBB	; 187
 cf8:	05 49       	sbci	r16, 0x95	; 149
 cfa:	13 02       	muls	r17, r19
 cfc:	0a 00       	.word	0x000a	; ????
 cfe:	00 00       	nop
 d00:	01 11       	cpse	r16, r1
 d02:	00 10       	cpse	r0, r0
 d04:	06 11       	cpse	r16, r6
 d06:	01 12       	cpse	r0, r17
 d08:	01 03       	mulsu	r16, r17
 d0a:	08 1b       	sub	r16, r24
 d0c:	08 25       	eor	r16, r8
 d0e:	08 13       	cpse	r16, r24
 d10:	05 00       	.word	0x0005	; ????
 d12:	00 00       	nop
 d14:	01 11       	cpse	r16, r1
 d16:	00 10       	cpse	r0, r0
 d18:	06 11       	cpse	r16, r6
 d1a:	01 12       	cpse	r0, r17
 d1c:	01 03       	mulsu	r16, r17
 d1e:	08 1b       	sub	r16, r24
 d20:	08 25       	eor	r16, r8
 d22:	08 13       	cpse	r16, r24
 d24:	05 00       	.word	0x0005	; ????
 d26:	00 00       	nop
 d28:	01 11       	cpse	r16, r1
 d2a:	00 10       	cpse	r0, r0
 d2c:	06 11       	cpse	r16, r6
 d2e:	01 12       	cpse	r0, r17
 d30:	01 03       	mulsu	r16, r17
 d32:	08 1b       	sub	r16, r24
 d34:	08 25       	eor	r16, r8
 d36:	08 13       	cpse	r16, r24
 d38:	05 00       	.word	0x0005	; ????
 d3a:	00 00       	nop
 d3c:	01 11       	cpse	r16, r1
 d3e:	00 10       	cpse	r0, r0
 d40:	06 11       	cpse	r16, r6
 d42:	01 12       	cpse	r0, r17
 d44:	01 03       	mulsu	r16, r17
 d46:	08 1b       	sub	r16, r24
 d48:	08 25       	eor	r16, r8
 d4a:	08 13       	cpse	r16, r24
 d4c:	05 00       	.word	0x0005	; ????
 d4e:	00 00       	nop
 d50:	01 11       	cpse	r16, r1
 d52:	00 10       	cpse	r0, r0
 d54:	06 11       	cpse	r16, r6
 d56:	01 12       	cpse	r0, r17
 d58:	01 03       	mulsu	r16, r17
 d5a:	08 1b       	sub	r16, r24
 d5c:	08 25       	eor	r16, r8
 d5e:	08 13       	cpse	r16, r24
 d60:	05 00       	.word	0x0005	; ????
 d62:	00 00       	nop
 d64:	01 11       	cpse	r16, r1
 d66:	00 10       	cpse	r0, r0
 d68:	06 11       	cpse	r16, r6
 d6a:	01 12       	cpse	r0, r17
 d6c:	01 03       	mulsu	r16, r17
 d6e:	08 1b       	sub	r16, r24
 d70:	08 25       	eor	r16, r8
 d72:	08 13       	cpse	r16, r24
 d74:	05 00       	.word	0x0005	; ????
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	16 00       	.word	0x0016	; ????
       2:	00 00       	nop
       4:	02 00       	.word	0x0002	; ????
       6:	10 00       	.word	0x0010	; ????
       8:	00 00       	nop
       a:	02 01       	movw	r0, r4
       c:	fb 0e       	add	r15, r27
       e:	0a 00       	.word	0x000a	; ????
      10:	01 01       	movw	r0, r2
      12:	01 01       	movw	r0, r2
      14:	00 00       	nop
      16:	00 01       	movw	r0, r0
      18:	00 00       	nop
      1a:	24 0e       	add	r2, r20
      1c:	00 00       	nop
      1e:	02 00       	.word	0x0002	; ????
      20:	2e 06       	cpc	r2, r30
      22:	00 00       	nop
      24:	02 01       	movw	r0, r4
      26:	fb 0e       	add	r15, r27
      28:	0a 00       	.word	0x000a	; ????
      2a:	01 01       	movw	r0, r2
      2c:	01 01       	movw	r0, r2
      2e:	00 00       	nop
      30:	00 01       	movw	r0, r0
      32:	2f 70       	andi	r18, 0x0F	; 15
      34:	72 69       	ori	r23, 0x92	; 146
      36:	76 61       	ori	r23, 0x16	; 22
      38:	74 65       	ori	r23, 0x54	; 84
      3a:	2f 76       	andi	r18, 0x6F	; 111
      3c:	61 72       	andi	r22, 0x21	; 33
      3e:	2f 66       	ori	r18, 0x6F	; 111
      40:	6f 6c       	ori	r22, 0xCF	; 207
      42:	64 65       	ori	r22, 0x54	; 84
      44:	72 73       	andi	r23, 0x32	; 50
      46:	2f 76       	andi	r18, 0x6F	; 111
      48:	39 2f       	mov	r19, r25
      4a:	66 5f       	subi	r22, 0xF6	; 246
      4c:	5f 70       	andi	r21, 0x0F	; 15
      4e:	39 66       	ori	r19, 0x69	; 105
      50:	74 73       	andi	r23, 0x34	; 52
      52:	33 6d       	ori	r19, 0xD3	; 211
      54:	39 37       	cpi	r19, 0x79	; 121
      56:	7a 30       	cpi	r23, 0x0A	; 10
      58:	38 30       	cpi	r19, 0x08	; 8
      5a:	72 33       	cpi	r23, 0x32	; 50
      5c:	71 71       	andi	r23, 0x11	; 17
      5e:	76 5f       	subi	r23, 0xF6	; 246
      60:	71 30       	cpi	r23, 0x01	; 1
      62:	30 30       	cpi	r19, 0x00	; 0
      64:	30 30       	cpi	r19, 0x00	; 0
      66:	67 6e       	ori	r22, 0xE7	; 231
      68:	2f 54       	subi	r18, 0x4F	; 79
      6a:	2f 41       	sbci	r18, 0x1F	; 31
      6c:	70 70       	andi	r23, 0x00	; 0
      6e:	54 72       	andi	r21, 0x24	; 36
      70:	61 6e       	ori	r22, 0xE1	; 225
      72:	73 6c       	ori	r23, 0xC3	; 195
      74:	6f 63       	ori	r22, 0x3F	; 63
      76:	61 74       	andi	r22, 0x41	; 65
      78:	69 6f       	ori	r22, 0xF9	; 249
      7a:	6e 2f       	mov	r22, r30
      7c:	34 46       	sbci	r19, 0x64	; 100
      7e:	34 35       	cpi	r19, 0x54	; 84
      80:	46 31       	cpi	r20, 0x16	; 22
      82:	35 36       	cpi	r19, 0x65	; 101
      84:	2d 33       	cpi	r18, 0x3D	; 61
      86:	37 45       	sbci	r19, 0x57	; 87
      88:	42 2d       	mov	r20, r2
      8a:	34 38       	cpi	r19, 0x84	; 132
      8c:	34 30       	cpi	r19, 0x04	; 4
      8e:	2d 38       	cpi	r18, 0x8D	; 141
      90:	33 43       	sbci	r19, 0x33	; 51
      92:	43 2d       	mov	r20, r3
      94:	42 41       	sbci	r20, 0x12	; 18
      96:	39 43       	sbci	r19, 0x39	; 57
      98:	46 45       	sbci	r20, 0x56	; 86
      9a:	30 31       	cpi	r19, 0x10	; 16
      9c:	39 43       	sbci	r19, 0x39	; 57
      9e:	35 33       	cpi	r19, 0x35	; 53
      a0:	2f 64       	ori	r18, 0x4F	; 79
      a2:	2f 41       	sbci	r18, 0x1F	; 31
      a4:	72 64       	ori	r23, 0x42	; 66
      a6:	75 69       	ori	r23, 0x95	; 149
      a8:	6e 6f       	ori	r22, 0xFE	; 254
      aa:	20 31       	cpi	r18, 0x10	; 16
      ac:	2e 38       	cpi	r18, 0x8E	; 142
      ae:	2e 39       	cpi	r18, 0x9E	; 158
      b0:	2e 61       	ori	r18, 0x1E	; 30
      b2:	70 70       	andi	r23, 0x00	; 0
      b4:	2f 43       	sbci	r18, 0x3F	; 63
      b6:	6f 6e       	ori	r22, 0xEF	; 239
      b8:	74 65       	ori	r23, 0x54	; 84
      ba:	6e 74       	andi	r22, 0x4E	; 78
      bc:	73 2f       	mov	r23, r19
      be:	4a 61       	ori	r20, 0x1A	; 26
      c0:	76 61       	ori	r23, 0x16	; 22
      c2:	2f 68       	ori	r18, 0x8F	; 143
      c4:	61 72       	andi	r22, 0x21	; 33
      c6:	64 77       	andi	r22, 0x74	; 116
      c8:	61 72       	andi	r22, 0x21	; 33
      ca:	65 2f       	mov	r22, r21
      cc:	61 72       	andi	r22, 0x21	; 33
      ce:	64 75       	andi	r22, 0x54	; 84
      d0:	69 6e       	ori	r22, 0xE9	; 233
      d2:	6f 2f       	mov	r22, r31
      d4:	61 76       	andi	r22, 0x61	; 97
      d6:	72 2f       	mov	r23, r18
      d8:	63 6f       	ori	r22, 0xF3	; 243
      da:	72 65       	ori	r23, 0x52	; 82
      dc:	73 2f       	mov	r23, r19
      de:	61 72       	andi	r22, 0x21	; 33
      e0:	64 75       	andi	r22, 0x54	; 84
      e2:	69 6e       	ori	r22, 0xE9	; 233
      e4:	6f 00       	.word	0x006f	; ????
      e6:	2f 55       	subi	r18, 0x5F	; 95
      e8:	73 65       	ori	r23, 0x53	; 83
      ea:	72 73       	andi	r23, 0x32	; 50
      ec:	2f 6a       	ori	r18, 0xAF	; 175
      ee:	65 6e       	ori	r22, 0xE5	; 229
      f0:	73 62       	ori	r23, 0x23	; 35
      f2:	72 65       	ori	r23, 0x52	; 82
      f4:	69 74       	andi	r22, 0x49	; 73
      f6:	65 6e       	ori	r22, 0xE5	; 229
      f8:	73 74       	andi	r23, 0x43	; 67
      fa:	65 69       	ori	r22, 0x95	; 149
      fc:	6e 2f       	mov	r22, r30
      fe:	44 6f       	ori	r20, 0xF4	; 244
     100:	63 75       	andi	r22, 0x53	; 83
     102:	6d 65       	ori	r22, 0x5D	; 93
     104:	6e 74       	andi	r22, 0x4E	; 78
     106:	73 2f       	mov	r23, r19
     108:	41 72       	andi	r20, 0x21	; 33
     10a:	64 75       	andi	r22, 0x54	; 84
     10c:	69 6e       	ori	r22, 0xE9	; 233
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
     10e:	6f 2f       	mov	r22, r31
     110:	6c 69       	ori	r22, 0x9C	; 156
     112:	62 72       	andi	r22, 0x22	; 34
     114:	61 72       	andi	r22, 0x21	; 33
     116:	69 65       	ori	r22, 0x59	; 89
	uint8_t port = digitalPinToPort(pin);
     118:	73 2f       	mov	r23, r19
     11a:	4e 65       	ori	r20, 0x5E	; 94
     11c:	77 4c       	sbci	r23, 0xC7	; 199
     11e:	69 71       	andi	r22, 0x19	; 25
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     120:	75 69       	ori	r23, 0x95	; 149
     122:	64 43       	sbci	r22, 0x34	; 52

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     124:	72 79       	andi	r23, 0x92	; 146
     126:	73 74       	andi	r23, 0x43	; 67
     128:	61 6c       	ori	r22, 0xC1	; 193
     12a:	5f 6c       	ori	r21, 0xCF	; 207
     12c:	69 62       	ori	r22, 0x29	; 41
     12e:	00 2f       	mov	r16, r16
     130:	70 72       	andi	r23, 0x20	; 32
     132:	69 76       	andi	r22, 0x69	; 105
	out = portOutputRegister(port);
     134:	61 74       	andi	r22, 0x41	; 65
     136:	65 2f       	mov	r22, r21
     138:	76 61       	ori	r23, 0x16	; 22
     13a:	72 2f       	mov	r23, r18
     13c:	66 6f       	ori	r22, 0xF6	; 246
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
     13e:	6c 64       	ori	r22, 0x4C	; 76
                cli();
     140:	65 72       	andi	r22, 0x25	; 37
		*reg |= bit;
     142:	73 2f       	mov	r23, r19
     144:	76 39       	cpi	r23, 0x96	; 150
     146:	2f 66       	ori	r18, 0x6F	; 111
		SREG = oldSREG;
     148:	5f 5f       	subi	r21, 0xFF	; 255
     14a:	70 39       	cpi	r23, 0x90	; 144
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
     14c:	66 74       	andi	r22, 0x46	; 70
     14e:	73 33       	cpi	r23, 0x33	; 51
     150:	6d 39       	cpi	r22, 0x9D	; 157
     152:	37 7a       	andi	r19, 0xA7	; 167
     154:	30 38       	cpi	r19, 0x80	; 128
	uint8_t bit = digitalPinToBitMask(pin);
     156:	30 72       	andi	r19, 0x20	; 32
     158:	33 71       	andi	r19, 0x13	; 19
     15a:	71 76       	andi	r23, 0x61	; 97
     15c:	5f 71       	andi	r21, 0x1F	; 31
	uint8_t port = digitalPinToPort(pin);
     15e:	30 30       	cpi	r19, 0x00	; 0
     160:	30 30       	cpi	r19, 0x00	; 0
     162:	30 67       	ori	r19, 0x70	; 112
     164:	6e 2f       	mov	r22, r30
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     166:	54 2f       	mov	r21, r20
     168:	41 70       	andi	r20, 0x01	; 1
     16a:	70 54       	subi	r23, 0x40	; 64

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     16c:	72 61       	ori	r23, 0x12	; 18
     16e:	6e 73       	andi	r22, 0x3E	; 62
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     170:	6c 6f       	ori	r22, 0xFC	; 252
     172:	63 61       	ori	r22, 0x13	; 19
     174:	74 69       	ori	r23, 0x94	; 148
     176:	6f 6e       	ori	r22, 0xEF	; 239
     178:	2f 34       	cpi	r18, 0x4F	; 79
     17a:	46 34       	cpi	r20, 0x46	; 70
     17c:	35 46       	sbci	r19, 0x65	; 101
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     17e:	31 35       	cpi	r19, 0x51	; 81
     180:	36 2d       	mov	r19, r6
     182:	33 37       	cpi	r19, 0x73	; 115
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     184:	45 42       	sbci	r20, 0x25	; 37
     186:	2d 34       	cpi	r18, 0x4D	; 77
     188:	38 34       	cpi	r19, 0x48	; 72
     18a:	30 2d       	mov	r19, r0
     18c:	38 33       	cpi	r19, 0x38	; 56
     18e:	43 43       	sbci	r20, 0x33	; 51
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     190:	2d 42       	sbci	r18, 0x2D	; 45
     192:	41 39       	cpi	r20, 0x91	; 145
     194:	43 46       	sbci	r20, 0x63	; 99
     196:	45 30       	cpi	r20, 0x05	; 5
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     198:	31 39       	cpi	r19, 0x91	; 145
     19a:	43 35       	cpi	r20, 0x53	; 83
     19c:	33 2f       	mov	r19, r19
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     19e:	64 2f       	mov	r22, r20
     1a0:	41 72       	andi	r20, 0x21	; 33
     1a2:	64 75       	andi	r22, 0x54	; 84
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     1a4:	69 6e       	ori	r22, 0xE9	; 233
     1a6:	6f 20       	and	r6, r15
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     1a8:	31 2e       	mov	r3, r17
     1aa:	38 2e       	mov	r3, r24
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     1ac:	39 2e       	mov	r3, r25
     1ae:	61 70       	andi	r22, 0x01	; 1
     1b0:	70 2f       	mov	r23, r16
     1b2:	43 6f       	ori	r20, 0xF3	; 243
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     1b4:	6e 74       	andi	r22, 0x4E	; 78
     1b6:	65 6e       	ori	r22, 0xE5	; 229
     1b8:	74 73       	andi	r23, 0x34	; 52
     1ba:	2f 4a       	sbci	r18, 0xAF	; 175
     1bc:	61 76       	andi	r22, 0x61	; 97

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
     1be:	61 2f       	mov	r22, r17
     1c0:	68 61       	ori	r22, 0x18	; 24
     1c2:	72 64       	ori	r23, 0x42	; 66
     1c4:	77 61       	ori	r23, 0x17	; 23
     1c6:	72 65       	ori	r23, 0x52	; 82
     1c8:	2f 61       	ori	r18, 0x1F	; 31
     1ca:	72 64       	ori	r23, 0x42	; 66

	uint8_t oldSREG = SREG;
     1cc:	75 69       	ori	r23, 0x95	; 149
	cli();
     1ce:	6e 6f       	ori	r22, 0xFE	; 254

	if (val == LOW) {
     1d0:	2f 61       	ori	r18, 0x1F	; 31
     1d2:	76 72       	andi	r23, 0x26	; 38
		*out &= ~bit;
     1d4:	2f 6c       	ori	r18, 0xCF	; 207
     1d6:	69 62       	ori	r22, 0x29	; 41
     1d8:	72 61       	ori	r23, 0x12	; 18
     1da:	72 69       	ori	r23, 0x92	; 146
	} else {
		*out |= bit;
     1dc:	65 73       	andi	r22, 0x35	; 53
     1de:	2f 57       	subi	r18, 0x7F	; 127
     1e0:	69 72       	andi	r22, 0x29	; 41
	}

	SREG = oldSREG;
     1e2:	65 2f       	mov	r22, r21
     1e4:	73 72       	andi	r23, 0x23	; 35
   digitalWrite(_enable_pin, LOW);
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
     1e6:	63 2f       	mov	r22, r19
     1e8:	75 74       	andi	r23, 0x45	; 69
     1ea:	69 6c       	ori	r22, 0xC9	; 201
     1ec:	69 74       	andi	r22, 0x49	; 73
     1ee:	79 00       	.word	0x0079	; ????
     1f0:	2f 70       	andi	r18, 0x0F	; 15
     1f2:	72 69       	ori	r23, 0x92	; 146
     1f4:	76 61       	ori	r23, 0x16	; 22
     1f6:	74 65       	ori	r23, 0x54	; 84
     1f8:	2f 76       	andi	r18, 0x6F	; 111
     1fa:	61 72       	andi	r22, 0x21	; 33
     1fc:	2f 66       	ori	r18, 0x6F	; 111
     1fe:	6f 6c       	ori	r22, 0xCF	; 207
     200:	64 65       	ori	r22, 0x54	; 84
     202:	72 73       	andi	r23, 0x32	; 50
     204:	2f 76       	andi	r18, 0x6F	; 111
     206:	39 2f       	mov	r19, r25
     208:	66 5f       	subi	r22, 0xF6	; 246
     20a:	5f 70       	andi	r21, 0x0F	; 15
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
     20c:	39 66       	ori	r19, 0x69	; 105
     20e:	74 73       	andi	r23, 0x34	; 52

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
     210:	33 6d       	ori	r19, 0xD3	; 211
     212:	39 37       	cpi	r19, 0x79	; 121
     214:	7a 30       	cpi	r23, 0x0A	; 10
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
     216:	38 30       	cpi	r19, 0x08	; 8
     218:	72 33       	cpi	r23, 0x32	; 50
     21a:	71 71       	andi	r23, 0x11	; 17
     21c:	76 5f       	subi	r23, 0xF6	; 246
     21e:	71 30       	cpi	r23, 0x01	; 1
     220:	30 30       	cpi	r19, 0x00	; 0
     222:	30 30       	cpi	r19, 0x00	; 0
     224:	67 6e       	ori	r22, 0xE7	; 231
     226:	2f 54       	subi	r18, 0x4F	; 79
     228:	2f 41       	sbci	r18, 0x1F	; 31
     22a:	70 70       	andi	r23, 0x00	; 0
     22c:	54 72       	andi	r21, 0x24	; 36
     22e:	61 6e       	ori	r22, 0xE1	; 225
     230:	73 6c       	ori	r23, 0xC3	; 195
     232:	6f 63       	ori	r22, 0x3F	; 63
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
     234:	61 74       	andi	r22, 0x41	; 65
     236:	69 6f       	ori	r22, 0xF9	; 249
     238:	6e 2f       	mov	r22, r30
     23a:	34 46       	sbci	r19, 0x64	; 100
     23c:	34 35       	cpi	r19, 0x54	; 84
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
     23e:	46 31       	cpi	r20, 0x16	; 22
     240:	35 36       	cpi	r19, 0x65	; 101
     242:	2d 33       	cpi	r18, 0x3D	; 61
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
     244:	37 45       	sbci	r19, 0x57	; 87
     246:	42 2d       	mov	r20, r2
     248:	34 38       	cpi	r19, 0x84	; 132
     24a:	34 30       	cpi	r19, 0x04	; 4
     24c:	2d 38       	cpi	r18, 0x8D	; 141
     24e:	33 43       	sbci	r19, 0x33	; 51
     250:	43 2d       	mov	r20, r3
     252:	42 41       	sbci	r20, 0x12	; 18
     254:	39 43       	sbci	r19, 0x39	; 57
     256:	46 45       	sbci	r20, 0x56	; 86
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
     258:	30 31       	cpi	r19, 0x10	; 16
     25a:	39 43       	sbci	r19, 0x39	; 57
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     25c:	35 33       	cpi	r19, 0x35	; 53
	
	cli();
     25e:	2f 64       	ori	r18, 0x4F	; 79
	m = timer0_overflow_count;
     260:	2f 41       	sbci	r18, 0x1F	; 31
     262:	72 64       	ori	r23, 0x42	; 66
     264:	75 69       	ori	r23, 0x95	; 149
     266:	6e 6f       	ori	r22, 0xFE	; 254
     268:	20 31       	cpi	r18, 0x10	; 16
     26a:	2e 38       	cpi	r18, 0x8E	; 142
     26c:	2e 39       	cpi	r18, 0x9E	; 158
     26e:	2e 61       	ori	r18, 0x1E	; 30
#if defined(TCNT0)
	t = TCNT0;
     270:	70 70       	andi	r23, 0x00	; 0
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     272:	2f 43       	sbci	r18, 0x3F	; 63
     274:	6f 6e       	ori	r22, 0xEF	; 239
     276:	74 65       	ori	r23, 0x54	; 84
     278:	6e 74       	andi	r22, 0x4E	; 78
		m++;
     27a:	73 2f       	mov	r23, r19
     27c:	4a 61       	ori	r20, 0x1A	; 26
     27e:	76 61       	ori	r23, 0x16	; 22
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     280:	2f 68       	ori	r18, 0x8F	; 143
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     282:	61 72       	andi	r22, 0x21	; 33
     284:	64 77       	andi	r22, 0x74	; 116
     286:	61 72       	andi	r22, 0x21	; 33
     288:	65 2f       	mov	r22, r21
     28a:	61 72       	andi	r22, 0x21	; 33
     28c:	64 75       	andi	r22, 0x54	; 84
     28e:	69 6e       	ori	r22, 0xE9	; 233
     290:	6f 2f       	mov	r22, r31
     292:	61 76       	andi	r22, 0x61	; 97
     294:	72 2f       	mov	r23, r18
     296:	6c 69       	ori	r22, 0x9C	; 156
     298:	62 72       	andi	r22, 0x22	; 34
     29a:	61 72       	andi	r22, 0x21	; 33
     29c:	69 65       	ori	r22, 0x59	; 89
     29e:	73 2f       	mov	r23, r19
     2a0:	57 69       	ori	r21, 0x97	; 151
     2a2:	72 65       	ori	r23, 0x52	; 82
}
     2a4:	2f 73       	andi	r18, 0x3F	; 63

void delay(unsigned long ms)
{
     2a6:	72 63       	ori	r23, 0x32	; 50
     2a8:	00 2f       	mov	r16, r16
     2aa:	5f 73       	andi	r21, 0x3F	; 63
     2ac:	68 61       	ori	r22, 0x18	; 24
     2ae:	72 65       	ori	r23, 0x52	; 82
     2b0:	64 5f       	subi	r22, 0xF4	; 244
     2b2:	2f 64       	ori	r18, 0x4F	; 79
     2b4:	65 76       	andi	r22, 0x65	; 101
     2b6:	2f 64       	ori	r18, 0x4F	; 79
     2b8:	65 76       	andi	r22, 0x65	; 101
	uint32_t start = micros();
     2ba:	2e 70       	andi	r18, 0x0E	; 14
     2bc:	72 6f       	ori	r23, 0xF2	; 242
     2be:	6a 65       	ori	r22, 0x5A	; 90
     2c0:	63 74       	andi	r22, 0x43	; 67

	while (ms > 0) {
     2c2:	73 2f       	mov	r23, r19
     2c4:	54 4f       	sbci	r21, 0xF4	; 244
     2c6:	43 2f       	mov	r20, r19
     2c8:	4d 49       	sbci	r20, 0x9D	; 157
     2ca:	44 49       	sbci	r20, 0x94	; 148
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     2cc:	2d 46       	sbci	r18, 0x6D	; 109
     2ce:	4f 4f       	sbci	r20, 0xFF	; 255
     2d0:	54 2d       	mov	r21, r4
     2d2:	43 4f       	sbci	r20, 0xF3	; 243
     2d4:	4e 54       	subi	r20, 0x4E	; 78
     2d6:	52 4f       	sbci	r21, 0xF2	; 242
     2d8:	4c 4c       	sbci	r20, 0xCC	; 204
     2da:	45 52       	subi	r20, 0x25	; 37
     2dc:	2e 50       	subi	r18, 0x0E	; 14
     2de:	55 42       	sbci	r21, 0x25	; 37
     2e0:	4c 49       	sbci	r20, 0x9C	; 156
     2e2:	43 2e       	mov	r4, r19
     2e4:	47 49       	sbci	r20, 0x97	; 151
			ms--;
     2e6:	54 2f       	mov	r21, r20
     2e8:	61 72       	andi	r22, 0x21	; 33
     2ea:	64 75       	andi	r22, 0x54	; 84
     2ec:	69 6e       	ori	r22, 0xE9	; 233
     2ee:	6f 2f       	mov	r22, r31
			start += 1000;
     2f0:	4a 42       	sbci	r20, 0x2A	; 42
     2f2:	5f 43       	sbci	r21, 0x3F	; 63
     2f4:	50 55       	subi	r21, 0x50	; 80
     2f6:	5f 55       	subi	r21, 0x5F	; 95
     2f8:	73 61       	ori	r23, 0x13	; 19
     2fa:	67 65       	ori	r22, 0x57	; 87
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     2fc:	5f 42       	sbci	r21, 0x2F	; 47
     2fe:	61 73       	andi	r22, 0x31	; 49
     300:	69 63       	ori	r22, 0x39	; 57
     302:	00 2f       	mov	r16, r16
     304:	70 72       	andi	r23, 0x20	; 32
     306:	69 76       	andi	r22, 0x69	; 105
			ms--;
			start += 1000;
		}
	}
}
     308:	61 74       	andi	r22, 0x41	; 65
     30a:	65 2f       	mov	r22, r21
     30c:	76 61       	ori	r23, 0x16	; 22
     30e:	72 2f       	mov	r23, r18
     310:	66 6f       	ori	r22, 0xF6	; 246
     312:	6c 64       	ori	r22, 0x4C	; 76
     314:	65 72       	andi	r22, 0x25	; 37
     316:	73 2f       	mov	r23, r19
     318:	76 39       	cpi	r23, 0x96	; 150

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     31a:	2f 66       	ori	r18, 0x6F	; 111
     31c:	5f 5f       	subi	r21, 0xFF	; 255
     31e:	70 39       	cpi	r23, 0x90	; 144
     320:	66 74       	andi	r22, 0x46	; 70
     322:	73 33       	cpi	r23, 0x33	; 51
     324:	6d 39       	cpi	r22, 0x9D	; 157
     326:	37 7a       	andi	r19, 0xA7	; 167
     328:	30 38       	cpi	r19, 0x80	; 128
     32a:	30 72       	andi	r19, 0x20	; 32
     32c:	33 71       	andi	r19, 0x13	; 19
     32e:	71 76       	andi	r23, 0x61	; 97
  size_t n = 0;
     330:	5f 71       	andi	r21, 0x1F	; 31
     332:	30 30       	cpi	r19, 0x00	; 0
  while (size--) {
     334:	30 30       	cpi	r19, 0x00	; 0
     336:	30 67       	ori	r19, 0x70	; 112
     338:	6e 2f       	mov	r22, r30
    if (write(*buffer++)) n++;
     33a:	54 2f       	mov	r21, r20
     33c:	41 70       	andi	r20, 0x01	; 1
     33e:	70 54       	subi	r23, 0x40	; 64
     340:	72 61       	ori	r23, 0x12	; 18
     342:	6e 73       	andi	r22, 0x3E	; 62
     344:	6c 6f       	ori	r22, 0xFC	; 252
     346:	63 61       	ori	r22, 0x13	; 19
     348:	74 69       	ori	r23, 0x94	; 148
     34a:	6f 6e       	ori	r22, 0xEF	; 239
     34c:	2f 34       	cpi	r18, 0x4F	; 79
     34e:	46 34       	cpi	r20, 0x46	; 70
     350:	35 46       	sbci	r19, 0x65	; 101
     352:	31 35       	cpi	r19, 0x51	; 81
     354:	36 2d       	mov	r19, r6
     356:	33 37       	cpi	r19, 0x73	; 115
     358:	45 42       	sbci	r20, 0x25	; 37
    else break;
  }
  return n;
}
     35a:	2d 34       	cpi	r18, 0x4D	; 77
     35c:	38 34       	cpi	r19, 0x48	; 72
     35e:	30 2d       	mov	r19, r0
     360:	38 33       	cpi	r19, 0x38	; 56
     362:	43 43       	sbci	r20, 0x33	; 51
     364:	2d 42       	sbci	r18, 0x2D	; 45
     366:	41 39       	cpi	r20, 0x91	; 145
     368:	43 46       	sbci	r20, 0x63	; 99
     36a:	45 30       	cpi	r20, 0x05	; 5
     36c:	31 39       	cpi	r19, 0x91	; 145
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
     36e:	43 35       	cpi	r20, 0x53	; 83
     370:	33 2f       	mov	r19, r19
     372:	64 2f       	mov	r22, r20

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
     374:	41 72       	andi	r20, 0x21	; 33
     376:	64 75       	andi	r22, 0x54	; 84
     378:	69 6e       	ori	r22, 0xE9	; 233
     37a:	6f 20       	and	r6, r15
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
     37c:	31 2e       	mov	r3, r17
     37e:	38 2e       	mov	r3, r24
     380:	39 2e       	mov	r3, r25
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
     382:	61 70       	andi	r22, 0x01	; 1
     384:	70 2f       	mov	r23, r16
     386:	43 6f       	ori	r20, 0xF3	; 243
     388:	6e 74       	andi	r22, 0x4E	; 78
     38a:	65 6e       	ori	r22, 0xE5	; 229
     38c:	74 73       	andi	r23, 0x34	; 52
     38e:	2f 4a       	sbci	r18, 0xAF	; 175
     390:	61 76       	andi	r22, 0x61	; 97
     392:	61 2f       	mov	r22, r17
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
     394:	68 61       	ori	r22, 0x18	; 24
     396:	72 64       	ori	r23, 0x42	; 66
     398:	77 61       	ori	r23, 0x17	; 23
     39a:	72 65       	ori	r23, 0x52	; 82
     39c:	2f 74       	andi	r18, 0x4F	; 79
     39e:	6f 6f       	ori	r22, 0xFF	; 255
     3a0:	6c 73       	andi	r22, 0x3C	; 60
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
     3a2:	2f 61       	ori	r18, 0x1F	; 31
     3a4:	76 72       	andi	r23, 0x26	; 38
    twi_txBuffer[twi_txBufferLength+i] = data[i];
     3a6:	2f 61       	ori	r18, 0x1F	; 31
     3a8:	76 72       	andi	r23, 0x26	; 38
     3aa:	2f 69       	ori	r18, 0x9F	; 159
     3ac:	6e 63       	ori	r22, 0x3E	; 62
     3ae:	6c 75       	andi	r22, 0x5C	; 92
     3b0:	64 65       	ori	r22, 0x54	; 84
     3b2:	00 2f       	mov	r16, r16
     3b4:	70 72       	andi	r23, 0x20	; 32
     3b6:	69 76       	andi	r22, 0x69	; 105
     3b8:	61 74       	andi	r22, 0x41	; 65
     3ba:	65 2f       	mov	r22, r21
  }
  twi_txBufferLength += length;
     3bc:	76 61       	ori	r23, 0x16	; 22
     3be:	72 2f       	mov	r23, r18
     3c0:	66 6f       	ori	r22, 0xF6	; 246
     3c2:	6c 64       	ori	r22, 0x4C	; 76
     3c4:	65 72       	andi	r22, 0x25	; 37
     3c6:	73 2f       	mov	r23, r19
     3c8:	76 39       	cpi	r23, 0x96	; 150
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
     3ca:	2f 66       	ori	r18, 0x6F	; 111
     3cc:	5f 5f       	subi	r21, 0xFF	; 255
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
     3ce:	70 39       	cpi	r23, 0x90	; 144
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
     3d0:	66 74       	andi	r22, 0x46	; 70

  return value;
}

void TwoWire::flush(void)
{
     3d2:	73 33       	cpi	r23, 0x33	; 51
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     3d4:	6d 39       	cpi	r22, 0x9D	; 157
     3d6:	37 7a       	andi	r19, 0xA7	; 167
     3d8:	30 38       	cpi	r19, 0x80	; 128
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
     3da:	30 72       	andi	r19, 0x20	; 32
     3dc:	33 71       	andi	r19, 0x13	; 19
     3de:	71 76       	andi	r23, 0x61	; 97
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
     3e0:	5f 71       	andi	r21, 0x1F	; 31
     3e2:	30 30       	cpi	r19, 0x00	; 0
     3e4:	30 30       	cpi	r19, 0x00	; 0
}
     3e6:	30 67       	ori	r19, 0x70	; 112
     3e8:	6e 2f       	mov	r22, r30
     3ea:	54 2f       	mov	r21, r20
     3ec:	41 70       	andi	r20, 0x01	; 1

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     3ee:	70 54       	subi	r23, 0x40	; 64
     3f0:	72 61       	ori	r23, 0x12	; 18
     3f2:	6e 73       	andi	r22, 0x3E	; 62
     3f4:	6c 6f       	ori	r22, 0xFC	; 252
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
     3f6:	63 61       	ori	r22, 0x13	; 19
     3f8:	74 69       	ori	r23, 0x94	; 148
     3fa:	6f 6e       	ori	r22, 0xEF	; 239
  }
  return quantity;
}
     3fc:	2f 34       	cpi	r18, 0x4F	; 79
     3fe:	46 34       	cpi	r20, 0x46	; 70
     400:	35 46       	sbci	r19, 0x65	; 101
     402:	31 35       	cpi	r19, 0x51	; 81

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
     404:	36 2d       	mov	r19, r6
     406:	33 37       	cpi	r19, 0x73	; 115
     408:	45 42       	sbci	r20, 0x25	; 37
     40a:	2d 34       	cpi	r18, 0x4D	; 77
     40c:	38 34       	cpi	r19, 0x48	; 72
     40e:	30 2d       	mov	r19, r0
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
     410:	38 33       	cpi	r19, 0x38	; 56
     412:	43 43       	sbci	r20, 0x33	; 51
     414:	2d 42       	sbci	r18, 0x2D	; 45
     416:	41 39       	cpi	r20, 0x91	; 145
     418:	43 46       	sbci	r20, 0x63	; 99
  }
  return 1;
}
     41a:	45 30       	cpi	r20, 0x05	; 5
     41c:	31 39       	cpi	r19, 0x91	; 145
     41e:	43 35       	cpi	r20, 0x53	; 83
     420:	33 2f       	mov	r19, r19
     422:	64 2f       	mov	r22, r20
     424:	41 72       	andi	r20, 0x21	; 33
#endif

//
// setBackligh
void LiquidCrystal::setBacklight ( uint8_t value )
{
     426:	64 75       	andi	r22, 0x54	; 84
   // Check if there is a pin assigned to the backlight
   // ---------------------------------------------------
   if ( _backlightPin != LCD_NOBACKLIGHT )
     428:	69 6e       	ori	r22, 0xE9	; 233
     42a:	6f 20       	and	r6, r15
     42c:	31 2e       	mov	r3, r17
     42e:	38 2e       	mov	r3, r24
     430:	39 2e       	mov	r3, r25
         }
      }
      // Not a PWM pin, set the backlight pin for POSI or NEG
      // polarity
      // --------------------------------------------------------
      else if (((value > 0) && (_polarity == POSITIVE)) ||
     432:	61 70       	andi	r22, 0x01	; 1
     434:	70 2f       	mov	r23, r16
     436:	43 6f       	ori	r20, 0xF3	; 243
     438:	6e 74       	andi	r22, 0x4E	; 78
     43a:	65 6e       	ori	r22, 0xE5	; 229
               ((value == 0) && (_polarity == NEGATIVE)))
     43c:	74 73       	andi	r23, 0x34	; 52
     43e:	2f 4a       	sbci	r18, 0xAF	; 175
     440:	61 76       	andi	r22, 0x61	; 97
      {
         digitalWrite( _backlightPin, HIGH);
     442:	61 2f       	mov	r22, r17
     444:	68 61       	ori	r22, 0x18	; 24
      }
      else
      {
         digitalWrite( _backlightPin, LOW);
     446:	72 64       	ori	r23, 0x42	; 66
     448:	77 61       	ori	r23, 0x17	; 23
     44a:	72 65       	ori	r23, 0x52	; 82
     44c:	2f 74       	andi	r18, 0x4F	; 79
}

//
// setBacklightPin
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
     44e:	6f 6f       	ori	r22, 0xFF	; 255
     450:	6c 73       	andi	r22, 0x3C	; 60
     452:	2f 61       	ori	r18, 0x1F	; 31
     454:	76 72       	andi	r23, 0x26	; 38
     456:	2f 6c       	ori	r18, 0xCF	; 207
     458:	69 62       	ori	r22, 0x29	; 41
     45a:	2f 67       	ori	r18, 0x7F	; 127
     45c:	63 63       	ori	r22, 0x33	; 51
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
     45e:	2f 61       	ori	r18, 0x1F	; 31
     460:	76 72       	andi	r23, 0x26	; 38
     462:	2f 35       	cpi	r18, 0x5F	; 95
   _backlightPin = pin;
     464:	2e 34       	cpi	r18, 0x4E	; 78
   _polarity = pol;
     466:	2e 30       	cpi	r18, 0x0E	; 14
     468:	2f 69       	ori	r18, 0x9F	; 159
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
     46a:	6e 63       	ori	r22, 0x3E	; 62
     46c:	6c 75       	andi	r22, 0x5C	; 92
     46e:	64 65       	ori	r22, 0x54	; 84
     470:	00 2f       	mov	r16, r16
     472:	70 72       	andi	r23, 0x20	; 32
     474:	69 76       	andi	r22, 0x69	; 105
     476:	61 74       	andi	r22, 0x41	; 65
}
     478:	65 2f       	mov	r22, r21
     47a:	76 61       	ori	r23, 0x16	; 22
     47c:	72 2f       	mov	r23, r18
     47e:	66 6f       	ori	r22, 0xF6	; 246
     480:	6c 64       	ori	r22, 0x4C	; 76
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
   _backlightPin = pin;
   _polarity = pol;
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
     482:	65 72       	andi	r22, 0x25	; 37

/************ low level data pushing commands **********/
//
// send
void LiquidCrystal::send(uint8_t value, uint8_t mode) 
{
     484:	73 2f       	mov	r23, r19
     486:	76 39       	cpi	r23, 0x96	; 150
     488:	2f 66       	ori	r18, 0x6F	; 111
     48a:	5f 5f       	subi	r21, 0xFF	; 255
     48c:	70 39       	cpi	r23, 0x90	; 144
     48e:	66 74       	andi	r22, 0x46	; 70
     490:	73 33       	cpi	r23, 0x33	; 51
   // Only interested in COMMAND or DATA
   digitalWrite( _rs_pin, ( mode == LCD_DATA ) );
     492:	6d 39       	cpi	r22, 0x9D	; 157
     494:	37 7a       	andi	r19, 0xA7	; 167
     496:	30 38       	cpi	r19, 0x80	; 128
     498:	30 72       	andi	r19, 0x20	; 32
     49a:	33 71       	andi	r19, 0x13	; 19
     49c:	71 76       	andi	r23, 0x61	; 97
     49e:	5f 71       	andi	r21, 0x1F	; 31
   
   // if there is a RW pin indicated, set it low to Write
   // ---------------------------------------------------
   if (_rw_pin != 255) 
     4a0:	30 30       	cpi	r19, 0x00	; 0
     4a2:	30 30       	cpi	r19, 0x00	; 0
     4a4:	30 67       	ori	r19, 0x70	; 112
   { 
      digitalWrite(_rw_pin, LOW);
     4a6:	6e 2f       	mov	r22, r30
     4a8:	54 2f       	mov	r21, r20
     4aa:	41 70       	andi	r20, 0x01	; 1
   }
   
   if ( mode != FOUR_BITS )
     4ac:	70 54       	subi	r23, 0x40	; 64
     4ae:	72 61       	ori	r23, 0x12	; 18
   {   
      if ( (_displayfunction & LCD_8BITMODE ) )
     4b0:	6e 73       	andi	r22, 0x3E	; 62
     4b2:	6c 6f       	ori	r22, 0xFC	; 252
     4b4:	63 61       	ori	r22, 0x13	; 19
      {
         writeNbits(value, 8); 
     4b6:	74 69       	ori	r23, 0x94	; 148
     4b8:	6f 6e       	ori	r22, 0xEF	; 239
      } 
      else 
      {
         writeNbits ( value >> 4, 4 );
     4ba:	2f 34       	cpi	r18, 0x4F	; 79
     4bc:	46 34       	cpi	r20, 0x46	; 70
     4be:	35 46       	sbci	r19, 0x65	; 101
     4c0:	31 35       	cpi	r19, 0x51	; 81
     4c2:	36 2d       	mov	r19, r6
     4c4:	33 37       	cpi	r19, 0x73	; 115
     4c6:	45 42       	sbci	r20, 0x25	; 37
     4c8:	2d 34       	cpi	r18, 0x4D	; 77
     4ca:	38 34       	cpi	r19, 0x48	; 72
     4cc:	30 2d       	mov	r19, r0
     4ce:	38 33       	cpi	r19, 0x38	; 56
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
     4d0:	43 43       	sbci	r20, 0x33	; 51
     4d2:	2d 42       	sbci	r18, 0x2D	; 45
     4d4:	41 39       	cpi	r20, 0x91	; 145
   }
   waitUsec ( EXEC_TIME ); // wait for the command to execute by the LCD
}
     4d6:	43 46       	sbci	r20, 0x63	; 99
     4d8:	45 30       	cpi	r20, 0x05	; 5
     4da:	31 39       	cpi	r19, 0x91	; 145
     4dc:	43 35       	cpi	r20, 0x53	; 83
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
     4de:	33 2f       	mov	r19, r19
     4e0:	64 2f       	mov	r22, r20
   send(value, LCD_DATA);
}
#else
size_t LCD::write(uint8_t value) 
{
   send(value, LCD_DATA);
     4e2:	41 72       	andi	r20, 0x21	; 33
     4e4:	64 75       	andi	r22, 0x54	; 84
     4e6:	69 6e       	ori	r22, 0xE9	; 233
     4e8:	6f 20       	and	r6, r15
     4ea:	31 2e       	mov	r3, r17
     4ec:	38 2e       	mov	r3, r24
     4ee:	39 2e       	mov	r3, r25
     4f0:	61 70       	andi	r22, 0x01	; 1
   return 1;             // assume OK
}
     4f2:	70 2f       	mov	r23, r16
     4f4:	43 6f       	ori	r20, 0xF3	; 243
     4f6:	6e 74       	andi	r22, 0x4E	; 78

// General LCD commands - generic methods used by the rest of the commands
// ---------------------------------------------------------------------------
void LCD::command(uint8_t value) 
{
   send(value, COMMAND);
     4f8:	65 6e       	ori	r22, 0xE5	; 229
     4fa:	74 73       	andi	r23, 0x34	; 52
     4fc:	2f 4a       	sbci	r18, 0xAF	; 175
     4fe:	61 76       	andi	r22, 0x61	; 97
     500:	61 2f       	mov	r22, r17
     502:	68 61       	ori	r22, 0x18	; 24
     504:	72 64       	ori	r23, 0x42	; 66
     506:	77 61       	ori	r23, 0x17	; 23
{
   command(LCD_RETURNHOME);             // set cursor position to zero
   delayMicroseconds(HOME_CLEAR_EXEC);  // This command is time consuming
}

void LCD::setCursor(uint8_t col, uint8_t row)
     508:	72 65       	ori	r23, 0x52	; 82
     50a:	2f 61       	ori	r18, 0x1F	; 31
     50c:	72 64       	ori	r23, 0x42	; 66
     50e:	75 69       	ori	r23, 0x95	; 149
     510:	6e 6f       	ori	r22, 0xFE	; 254
     512:	2f 61       	ori	r18, 0x1F	; 31
     514:	76 72       	andi	r23, 0x26	; 38
     516:	2f 76       	andi	r18, 0x6F	; 111
     518:	61 72       	andi	r22, 0x21	; 33
     51a:	69 61       	ori	r22, 0x19	; 25
{
   const byte row_offsetsDef[]   = { 0x00, 0x40, 0x14, 0x54 }; // For regular LCDs
     51c:	6e 74       	andi	r22, 0x4E	; 78
     51e:	73 2f       	mov	r23, r19
     520:	65 69       	ori	r22, 0x95	; 149
     522:	67 68       	ori	r22, 0x87	; 135
     524:	74 61       	ori	r23, 0x14	; 20
     526:	6e 61       	ori	r22, 0x1E	; 30
     528:	6c 6f       	ori	r22, 0xFC	; 252
     52a:	67 69       	ori	r22, 0x97	; 151
     52c:	6e 70       	andi	r22, 0x0E	; 14
     52e:	75 74       	andi	r23, 0x45	; 69
     530:	73 2f       	mov	r23, r19
     532:	2e 2e       	mov	r2, r30
   const byte row_offsetsLarge[] = { 0x00, 0x40, 0x10, 0x50 }; // For 16x4 LCDs
     534:	2f 73       	andi	r18, 0x3F	; 63
     536:	74 61       	ori	r23, 0x14	; 20
     538:	6e 64       	ori	r22, 0x4E	; 78
     53a:	61 72       	andi	r22, 0x21	; 33
     53c:	64 00       	.word	0x0064	; ????
     53e:	00 77       	andi	r16, 0x70	; 112
     540:	69 72       	andi	r22, 0x29	; 41
     542:	69 6e       	ori	r22, 0xE9	; 233
     544:	67 5f       	subi	r22, 0xF7	; 247
     546:	64 69       	ori	r22, 0x94	; 148
     548:	67 69       	ori	r22, 0x97	; 151
     54a:	74 61       	ori	r23, 0x14	; 20
   
   if ( row >= _numlines ) 
     54c:	6c 2e       	mov	r6, r28
     54e:	63 00       	.word	0x0063	; ????
     550:	01 00       	.word	0x0001	; ????
     552:	00 4c       	sbci	r16, 0xC0	; 192
   {
      row = _numlines-1;    // rows start at 0
     554:	69 71       	andi	r22, 0x19	; 25
     556:	75 69       	ori	r23, 0x95	; 149
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
     558:	64 43       	sbci	r22, 0x34	; 52
     55a:	72 79       	andi	r23, 0x92	; 146
     55c:	73 74       	andi	r23, 0x43	; 67
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
     55e:	61 6c       	ori	r22, 0xC1	; 193
     560:	2e 63       	ori	r18, 0x3E	; 62
     562:	70 70       	andi	r23, 0x00	; 0
      row = _numlines-1;    // rows start at 0
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
     564:	00 02       	muls	r16, r16
     566:	00 00       	nop
     568:	77 69       	ori	r23, 0x97	; 151
     56a:	72 69       	ori	r23, 0x92	; 146
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
     56c:	6e 67       	ori	r22, 0x7E	; 126
     56e:	2e 63       	ori	r18, 0x3E	; 62
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
     570:	00 01       	movw	r0, r0
     572:	00 00       	nop
     574:	50 72       	andi	r21, 0x20	; 32
     576:	69 6e       	ori	r22, 0xE9	; 233
   }
   
}
     578:	74 2e       	mov	r7, r20
     57a:	63 70       	andi	r22, 0x03	; 3
     57c:	70 00       	.word	0x0070	; ????
     57e:	01 00       	.word	0x0001	; ????
     580:	00 74       	andi	r16, 0x40	; 64
     582:	77 69       	ori	r23, 0x97	; 151
     584:	2e 63       	ori	r18, 0x3E	; 62
     586:	00 03       	mulsu	r16, r16
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
     588:	00 00       	nop
     58a:	57 69       	ori	r21, 0x97	; 151
// can't assume that its in that state when a application starts (and the
// LiquidCrystal constructor is called).
// A call to begin() will reinitialize the LCD.
//
void LCD::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) 
{
     58c:	72 65       	ori	r23, 0x52	; 82
     58e:	2e 63       	ori	r18, 0x3E	; 62
     590:	70 70       	andi	r23, 0x00	; 0
     592:	00 04       	cpc	r0, r0
     594:	00 00       	nop
   if (lines > 1) 
     596:	4c 43       	sbci	r20, 0x3C	; 60
     598:	44 2e       	mov	r4, r20
   {
      _displayfunction |= LCD_2LINE;
     59a:	63 70       	andi	r22, 0x03	; 3
     59c:	70 00       	.word	0x0070	; ????
     59e:	02 00       	.word	0x0002	; ????
   }
   _numlines = lines;
     5a0:	00 4c       	sbci	r16, 0xC0	; 192
   _cols = cols;
     5a2:	43 44       	sbci	r20, 0x43	; 67
   
   // for some 1 line displays you can select a 10 pixel high font
   // ------------------------------------------------------------
   if ((dotsize != LCD_5x8DOTS) && (lines == 1)) 
     5a4:	2e 68       	ori	r18, 0x8E	; 142
     5a6:	00 02       	muls	r16, r16
     5a8:	00 00       	nop
     5aa:	50 72       	andi	r21, 0x20	; 32
   {
      _displayfunction |= LCD_5x10DOTS;
     5ac:	69 6e       	ori	r22, 0xE9	; 233
     5ae:	74 2e       	mov	r7, r20
     5b0:	68 00       	.word	0x0068	; ????
   // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
   // according to datasheet, we need at least 40ms after power rises above 2.7V
   // before sending commands. Arduino can turn on way before 4.5V so we'll wait 
   // 50
   // ---------------------------------------------------------------------------
   delay (100); // 100ms delay
     5b2:	01 00       	.word	0x0001	; ????
     5b4:	00 61       	ori	r16, 0x10	; 16
     5b6:	62 69       	ori	r22, 0x92	; 146
     5b8:	2e 63       	ori	r18, 0x3E	; 62
     5ba:	70 70       	andi	r23, 0x00	; 0
     5bc:	00 01       	movw	r0, r0
   
   //put the LCD into 4 bit or 8 bit mode
   // -------------------------------------
   if (! (_displayfunction & LCD_8BITMODE)) 
     5be:	00 00       	nop
     5c0:	53 74       	andi	r21, 0x43	; 67
     5c2:	72 65       	ori	r23, 0x52	; 82
      // this is according to the hitachi HD44780 datasheet
      // figure 24, pg 46
      
      // we start in 8bit mode, try to set 4 bit mode
      // Special case of "Function Set"
      send(0x03, FOUR_BITS);
     5c4:	61 6d       	ori	r22, 0xD1	; 209
     5c6:	2e 68       	ori	r18, 0x8E	; 142
     5c8:	00 01       	movw	r0, r0
     5ca:	00 00       	nop
     5cc:	6d 61       	ori	r22, 0x1D	; 29
     5ce:	69 6e       	ori	r22, 0xE9	; 233
     5d0:	2e 63       	ori	r18, 0x3E	; 62
     5d2:	70 70       	andi	r23, 0x00	; 0
     5d4:	00 01       	movw	r0, r0
	

#endif

	// busy wait
	__asm__ __volatile__ (
     5d6:	00 00       	nop
     5d8:	4a 42       	sbci	r20, 0x2A	; 42
     5da:	5f 43       	sbci	r21, 0x3F	; 63
     5dc:	50 55       	subi	r21, 0x50	; 80
      delayMicroseconds(4500); // wait min 4.1ms
      
      // second try
      send ( 0x03, FOUR_BITS );
     5de:	5f 55       	subi	r21, 0x5F	; 95
     5e0:	73 61       	ori	r23, 0x13	; 19
     5e2:	67 65       	ori	r22, 0x57	; 87
     5e4:	5f 42       	sbci	r21, 0x2F	; 47
     5e6:	61 73       	andi	r22, 0x31	; 49
     5e8:	69 63       	ori	r22, 0x39	; 57
     5ea:	2e 69       	ori	r18, 0x9E	; 158
     5ec:	6e 6f       	ori	r22, 0xFE	; 254
     5ee:	00 05       	cpc	r16, r0
     5f0:	00 00       	nop
     5f2:	4c 69       	ori	r20, 0x9C	; 156
     5f4:	71 75       	andi	r23, 0x51	; 81
     5f6:	69 64       	ori	r22, 0x49	; 73
     5f8:	43 72       	andi	r20, 0x23	; 35
      delayMicroseconds(150); // wait min 100us
      
      // third go!
      send( 0x03, FOUR_BITS );
     5fa:	79 73       	andi	r23, 0x39	; 57
     5fc:	74 61       	ori	r23, 0x14	; 20
     5fe:	6c 2e       	mov	r6, r28
     600:	68 00       	.word	0x0068	; ????
     602:	02 00       	.word	0x0002	; ????
     604:	00 73       	andi	r16, 0x30	; 48
     606:	74 64       	ori	r23, 0x44	; 68
     608:	69 6e       	ori	r22, 0xE9	; 233
     60a:	74 2e       	mov	r7, r20
     60c:	68 00       	.word	0x0068	; ????
     60e:	06 00       	.word	0x0006	; ????
     610:	00 73       	andi	r16, 0x30	; 48
      delayMicroseconds(150); // wait min of 100us
      
      // finally, set to 4-bit interface
      send ( 0x02, FOUR_BITS );
     612:	74 64       	ori	r23, 0x44	; 68
     614:	64 65       	ori	r22, 0x54	; 84
     616:	66 2e       	mov	r6, r22
     618:	68 00       	.word	0x0068	; ????
     61a:	07 00       	.word	0x0007	; ????
     61c:	00 57       	subi	r16, 0x70	; 112
     61e:	69 72       	andi	r22, 0x29	; 41
     620:	65 2e       	mov	r6, r21
     622:	68 00       	.word	0x0068	; ????
     624:	04 00       	.word	0x0004	; ????
   {
      // this is according to the hitachi HD44780 datasheet
      // page 45 figure 23
      
      // Send function set command sequence
      command(LCD_FUNCTIONSET | _displayfunction);
     626:	00 41       	sbci	r16, 0x10	; 16
     628:	72 64       	ori	r23, 0x42	; 66
     62a:	75 69       	ori	r23, 0x95	; 149
     62c:	6e 6f       	ori	r22, 0xFE	; 254
     62e:	2e 68       	ori	r18, 0x8E	; 142
     630:	00 01       	movw	r0, r0
     632:	00 00       	nop
     634:	70 69       	ori	r23, 0x90	; 144
      delayMicroseconds(4500);  // wait more than 4.1ms
      
      // second try
      command(LCD_FUNCTIONSET | _displayfunction);
     636:	6e 73       	andi	r22, 0x3E	; 62
     638:	5f 61       	ori	r21, 0x1F	; 31
     63a:	72 64       	ori	r23, 0x42	; 66
     63c:	75 69       	ori	r23, 0x95	; 149
     63e:	6e 6f       	ori	r22, 0xFE	; 254
     640:	2e 68       	ori	r18, 0x8E	; 142
     642:	00 08       	sbc	r0, r0
     644:	00 00       	nop
     646:	68 6f       	ori	r22, 0xF8	; 248
     648:	6f 6b       	ori	r22, 0xBF	; 191
      delayMicroseconds(150);
      
      // third go
      command(LCD_FUNCTIONSET | _displayfunction);
     64a:	73 2e       	mov	r7, r19
     64c:	63 00       	.word	0x0063	; ????
     64e:	01 00       	.word	0x0001	; ????
     650:	00 00       	nop
     652:	00 05       	cpc	r16, r0
     654:	02 0e       	add	r0, r18
     656:	01 00       	.word	0x0001	; ????
     658:	00 03       	mulsu	r16, r16
      delayMicroseconds(150);

   }
   
   // finally, set # lines, font size, etc.
   command(LCD_FUNCTIONSET | _displayfunction);
     65a:	1c 01       	movw	r2, r24
     65c:	03 02       	muls	r16, r19
     65e:	09 00       	.word	0x0009	; ????
     660:	00 01       	movw	r0, r0
     662:	03 01       	movw	r0, r6
     664:	09 0a       	sbc	r0, r25
     666:	00 01       	movw	r0, r0
     668:	03 03       	mulsu	r16, r19
     66a:	09 08       	sbc	r0, r9
   delayMicroseconds ( 60 );  // wait more
   
   // turn the display on with no cursor or blinking default
   _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
     66c:	00 01       	movw	r0, r0
     66e:	03 03       	mulsu	r16, r19
}

void LCD::display() 
{
   _displaycontrol |= LCD_DISPLAYON;
   command(LCD_DISPLAYCONTROL | _displaycontrol);
     670:	09 04       	cpc	r0, r9
     672:	00 01       	movw	r0, r0
     674:	03 01       	movw	r0, r6
     676:	09 10       	cpse	r0, r9

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
     678:	00 01       	movw	r0, r0
     67a:	03 0f       	add	r16, r19
     67c:	09 0a       	sbc	r0, r25
     67e:	00 01       	movw	r0, r0
     680:	03 01       	movw	r0, r6
     682:	09 02       	muls	r16, r25
     684:	00 01       	movw	r0, r0
     686:	03 01       	movw	r0, r6
   
   // clear the LCD
   clear();
   
   // Initialize to default text direction (for romance languages)
   _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
     688:	09 02       	muls	r16, r25
     68a:	00 01       	movw	r0, r0
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);
     68c:	03 01       	movw	r0, r6
     68e:	09 06       	cpc	r0, r25
     690:	00 01       	movw	r0, r0
     692:	03 d2       	rcall	.+1030   	; 0xa9a <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x50>

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
     694:	00 09       	sbc	r16, r0
     696:	04 00       	.word	0x0004	; ????
     698:	01 03       	mulsu	r16, r17
     69a:	01 09       	sbc	r16, r1
     69c:	00 00       	nop
     69e:	01 03       	mulsu	r16, r17
     6a0:	01 09       	sbc	r16, r1
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);

   backlight();

}
     6a2:	0a 00       	.word	0x000a	; ????
     6a4:	01 03       	mulsu	r16, r17
     6a6:	01 09       	sbc	r16, r1
     6a8:	08 00       	.word	0x0008	; ????

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
     6aa:	01 03       	mulsu	r16, r17
    
    @param      0..255 - the value is very dependent on the LCD. However, 
    BACKLIGHT_OFF will be interpreted as off and BACKLIGHT_ON will drive the
    backlight on.
    */
   virtual void setBacklight ( uint8_t value ) { };
     6ac:	03 09       	sbc	r16, r3
    empty function call is provided that does nothing.
    
    @param      value: pin associated to backlight control.
    @param      pol: backlight polarity control (POSITIVE, NEGATIVE)
    */
   virtual void setBacklightPin ( uint8_t value, t_backlightPol pol ) { };
     6ae:	08 00       	.word	0x0008	; ????
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     6b0:	01 03       	mulsu	r16, r17
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     6b2:	04 09       	sbc	r16, r4
     6b4:	06 00       	.word	0x0006	; ????
     6b6:	01 03       	mulsu	r16, r17
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     6b8:	b8 7f       	andi	r27, 0xF8	; 248
     6ba:	09 04       	cpc	r0, r9
      return write((const uint8_t *)str, strlen(str));
     6bc:	00 01       	movw	r0, r0
     6be:	03 15       	cp	r16, r3
     6c0:	09 0e       	add	r0, r25
     6c2:	00 01       	movw	r0, r0
     6c4:	03 6b       	ori	r16, 0xB3	; 179
     6c6:	09 06       	cpc	r0, r25
     6c8:	00 01       	movw	r0, r0
     6ca:	03 06       	cpc	r0, r19
     6cc:	09 0c       	add	r0, r9
     6ce:	00 01       	movw	r0, r0
     6d0:	03 7d       	andi	r16, 0xD3	; 211
     6d2:	09 08       	sbc	r0, r9
     6d4:	00 01       	movw	r0, r0
    }
     6d6:	03 03       	mulsu	r16, r19
     6d8:	09 06       	cpc	r0, r25
     6da:	00 01       	movw	r0, r0
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
     6dc:	03 0b       	sbc	r16, r19
     6de:	09 06       	cpc	r0, r25
     6e0:	00 01       	movw	r0, r0
     6e2:	03 04       	cpc	r0, r3
     6e4:	09 04       	cpc	r0, r9
     6e6:	00 01       	movw	r0, r0
     6e8:	03 03       	mulsu	r16, r19
     6ea:	09 04       	cpc	r0, r9
     6ec:	00 01       	movw	r0, r0
     6ee:	03 03       	mulsu	r16, r19
     6f0:	09 08       	sbc	r0, r9
     6f2:	00 01       	movw	r0, r0
     6f4:	03 2f       	mov	r16, r19
     6f6:	09 0a       	sbc	r0, r25
     6f8:	00 01       	movw	r0, r0
     6fa:	03 02       	muls	r16, r19
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     6fc:	09 0e       	add	r0, r25

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     6fe:	00 01       	movw	r0, r0
     700:	03 01       	movw	r0, r6
     702:	09 02       	muls	r16, r25
     704:	00 01       	movw	r0, r0
     706:	03 02       	muls	r16, r19
     708:	09 02       	muls	r16, r25

  do {
    char c = n % base;
     70a:	00 01       	movw	r0, r0
     70c:	03 01       	movw	r0, r6
     70e:	09 04       	cpc	r0, r9
     710:	00 01       	movw	r0, r0
     712:	03 02       	muls	r16, r19
     714:	09 08       	sbc	r0, r9
     716:	00 01       	movw	r0, r0
     718:	03 03       	mulsu	r16, r19
     71a:	09 06       	cpc	r0, r25
    n /= base;
     71c:	00 01       	movw	r0, r0
     71e:	04 02       	muls	r16, r20

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     720:	03 a3       	std	Z+35, r16	; 0x23
     722:	01 09       	sbc	r16, r1
     724:	04 00       	.word	0x0004	; ????
     726:	01 03       	mulsu	r16, r17
     728:	00 09       	sbc	r16, r0
     72a:	22 00       	.word	0x0022	; ????
     72c:	01 03       	mulsu	r16, r17
     72e:	04 09       	sbc	r16, r4
     730:	04 00       	.word	0x0004	; ????
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
     732:	01 03       	mulsu	r16, r17
     734:	7e 09       	sbc	r23, r14
     736:	04 00       	.word	0x0004	; ????
     738:	01 03       	mulsu	r16, r17
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
     73a:	02 09       	sbc	r16, r2
     73c:	06 00       	.word	0x0006	; ????
     73e:	01 03       	mulsu	r16, r17
}
     740:	75 09       	sbc	r23, r5
     742:	1e 00       	.word	0x001e	; ????
     744:	01 03       	mulsu	r16, r17
     746:	02 09       	sbc	r16, r2
     748:	0a 00       	.word	0x000a	; ????
     74a:	01 03       	mulsu	r16, r17
     74c:	0c 09       	sbc	r16, r12
     74e:	06 00       	.word	0x0006	; ????
     750:	01 03       	mulsu	r16, r17
     752:	74 09       	sbc	r23, r4
     754:	14 00       	.word	0x0014	; ????
     756:	01 04       	cpc	r0, r1
     758:	03 03       	mulsu	r16, r19
     75a:	8f 7e       	andi	r24, 0xEF	; 239
     75c:	09 04       	cpc	r0, r9
     75e:	00 01       	movw	r0, r0
     760:	03 02       	muls	r16, r19
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     762:	09 00       	.word	0x0009	; ????
     764:	00 01       	movw	r0, r0
     766:	03 02       	muls	r16, r19
     768:	09 02       	muls	r16, r25
     76a:	00 01       	movw	r0, r0
     76c:	03 01       	movw	r0, r6
     76e:	09 02       	muls	r16, r25
     770:	00 01       	movw	r0, r0
     772:	03 02       	muls	r16, r19
     774:	09 10       	cpse	r0, r9
     776:	00 01       	movw	r0, r0
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     778:	03 08       	sbc	r0, r3
     77a:	09 02       	muls	r16, r25
     77c:	00 01       	movw	r0, r0
     77e:	03 01       	movw	r0, r6
     780:	09 08       	sbc	r0, r9
     782:	00 01       	movw	r0, r0
     784:	03 06       	cpc	r0, r19
     786:	09 06       	cpc	r0, r25
	unsigned char f = timer0_fract;
     788:	00 01       	movw	r0, r0
     78a:	03 02       	muls	r16, r19

	m += MILLIS_INC;
	f += FRACT_INC;
     78c:	09 02       	muls	r16, r25
     78e:	00 01       	movw	r0, r0
	if (f >= FRACT_MAX) {
     790:	03 01       	movw	r0, r6
     792:	09 22       	and	r0, r25
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
     794:	00 01       	movw	r0, r0
     796:	03 03       	mulsu	r16, r19
     798:	09 02       	muls	r16, r25
     79a:	00 01       	movw	r0, r0
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     79c:	03 01       	movw	r0, r6
     79e:	09 14       	cp	r0, r9
		m += 1;
     7a0:	00 01       	movw	r0, r0
     7a2:	03 02       	muls	r16, r19
     7a4:	09 08       	sbc	r0, r9
	}

	timer0_fract = f;
     7a6:	00 01       	movw	r0, r0
     7a8:	03 02       	muls	r16, r19
	timer0_millis = m;
     7aa:	09 0a       	sbc	r0, r25
     7ac:	00 01       	movw	r0, r0
     7ae:	03 01       	movw	r0, r6
     7b0:	09 1a       	sub	r0, r25
     7b2:	00 01       	movw	r0, r0
     7b4:	03 01       	movw	r0, r6
     7b6:	09 0a       	sbc	r0, r25
     7b8:	00 01       	movw	r0, r0
	timer0_overflow_count++;
     7ba:	03 7e       	andi	r16, 0xE3	; 227
     7bc:	09 0c       	add	r0, r9
     7be:	00 01       	movw	r0, r0
     7c0:	03 05       	cpc	r16, r3
     7c2:	09 0c       	add	r0, r9
     7c4:	00 01       	movw	r0, r0
     7c6:	04 04       	cpc	r0, r4
     7c8:	03 ae       	std	Z+59, r0	; 0x3b
     7ca:	7f 09       	sbc	r23, r15
     7cc:	12 00       	.word	0x0012	; ????
     7ce:	01 03       	mulsu	r16, r17
     7d0:	01 09       	sbc	r16, r1
     7d2:	16 00       	.word	0x0016	; ????
     7d4:	01 03       	mulsu	r16, r17
     7d6:	01 09       	sbc	r16, r1
     7d8:	04 00       	.word	0x0004	; ????
     7da:	01 03       	mulsu	r16, r17
     7dc:	01 09       	sbc	r16, r1
     7de:	06 00       	.word	0x0006	; ????
}
     7e0:	01 03       	mulsu	r16, r17
     7e2:	04 09       	sbc	r16, r4
     7e4:	20 00       	.word	0x0020	; ????
     7e6:	01 04       	cpc	r0, r1
     7e8:	05 03       	mulsu	r16, r21
     7ea:	c8 02       	muls	r28, r24
     7ec:	09 14       	cp	r0, r9
     7ee:	00 01       	movw	r0, r0
     7f0:	03 02       	muls	r16, r19
     7f2:	09 00       	.word	0x0009	; ????
     7f4:	00 01       	movw	r0, r0
  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
     7f6:	03 04       	cpc	r0, r3
     7f8:	09 06       	cpc	r0, r25
     7fa:	00 01       	movw	r0, r0
     7fc:	03 05       	cpc	r16, r3
     7fe:	09 08       	sbc	r0, r9
     800:	00 01       	movw	r0, r0
     802:	03 b2       	in	r0, 0x13	; 19
     804:	7f 09       	sbc	r23, r15
     806:	06 00       	.word	0x0006	; ????
     808:	01 03       	mulsu	r16, r17
     80a:	04 09       	sbc	r16, r4
     80c:	00 00       	nop
     80e:	01 03       	mulsu	r16, r17
     810:	05 09       	sbc	r16, r5
     812:	12 00       	.word	0x0012	; ????
     814:	01 03       	mulsu	r16, r17
     816:	05 09       	sbc	r16, r5
  switch(TW_STATUS){
     818:	0e 00       	.word	0x000e	; ????
     81a:	01 03       	mulsu	r16, r17
     81c:	01 09       	sbc	r16, r1
     81e:	04 00       	.word	0x0004	; ????
     820:	01 03       	mulsu	r16, r17
     822:	02 09       	sbc	r16, r2
     824:	16 00       	.word	0x0016	; ????
     826:	01 03       	mulsu	r16, r17
     828:	74 09       	sbc	r23, r4
     82a:	0e 00       	.word	0x000e	; ????
     82c:	01 03       	mulsu	r16, r17
     82e:	05 09       	sbc	r16, r5
     830:	04 00       	.word	0x0004	; ????
     832:	01 03       	mulsu	r16, r17
     834:	0a 09       	sbc	r16, r10
     836:	02 00       	.word	0x0002	; ????
     838:	01 04       	cpc	r0, r1
     83a:	06 03       	mulsu	r16, r22
     83c:	4d 09       	sbc	r20, r13
     83e:	02 00       	.word	0x0002	; ????
     840:	01 03       	mulsu	r16, r17
     842:	75 09       	sbc	r23, r5
     844:	02 00       	.word	0x0002	; ????
     846:	01 03       	mulsu	r16, r17
     848:	08 09       	sbc	r16, r8
     84a:	00 00       	nop
     84c:	01 03       	mulsu	r16, r17
     84e:	68 09       	sbc	r22, r8
     850:	06 00       	.word	0x0006	; ????
     852:	01 03       	mulsu	r16, r17
     854:	0a 09       	sbc	r16, r10
     856:	00 00       	nop
     858:	01 03       	mulsu	r16, r17
     85a:	6e 09       	sbc	r22, r14
     85c:	06 00       	.word	0x0006	; ????
     85e:	01 03       	mulsu	r16, r17
     860:	01 09       	sbc	r16, r1
     862:	00 00       	nop
     864:	01 03       	mulsu	r16, r17
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
     866:	01 09       	sbc	r16, r1
     868:	06 00       	.word	0x0006	; ????
     86a:	01 03       	mulsu	r16, r17
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     86c:	6c 09       	sbc	r22, r12
     86e:	08 00       	.word	0x0008	; ????
     870:	01 03       	mulsu	r16, r17
     872:	09 09       	sbc	r16, r9
     874:	08 00       	.word	0x0008	; ????
     876:	01 03       	mulsu	r16, r17
     878:	03 09       	sbc	r16, r3
     87a:	06 00       	.word	0x0006	; ????
     87c:	01 03       	mulsu	r16, r17
     87e:	5b 09       	sbc	r21, r11
     880:	08 00       	.word	0x0008	; ????
     882:	01 03       	mulsu	r16, r17
     884:	10 09       	sbc	r17, r0
     886:	0c 00       	.word	0x000c	; ????
     888:	01 03       	mulsu	r16, r17
     88a:	03 09       	sbc	r16, r3
     88c:	0a 00       	.word	0x000a	; ????
     88e:	01 04       	cpc	r0, r1
     890:	02 03       	mulsu	r16, r18
     892:	69 09       	sbc	r22, r9
     894:	0c 00       	.word	0x000c	; ????
     896:	01 03       	mulsu	r16, r17
     898:	03 09       	sbc	r16, r3
     89a:	02 00       	.word	0x0002	; ????
     89c:	01 03       	mulsu	r16, r17
     89e:	1f 09       	sbc	r17, r15
     8a0:	0a 00       	.word	0x000a	; ????
     8a2:	01 03       	mulsu	r16, r17
     8a4:	01 09       	sbc	r16, r1
     8a6:	0a 00       	.word	0x000a	; ????
     8a8:	01 03       	mulsu	r16, r17
     8aa:	02 09       	sbc	r16, r2
     8ac:	06 00       	.word	0x0006	; ????
     8ae:	01 03       	mulsu	r16, r17
     8b0:	04 09       	sbc	r16, r4
     8b2:	04 00       	.word	0x0004	; ????
     8b4:	01 03       	mulsu	r16, r17
     8b6:	41 09       	sbc	r20, r1
     8b8:	08 00       	.word	0x0008	; ????
     8ba:	01 03       	mulsu	r16, r17
     8bc:	01 09       	sbc	r16, r1
     8be:	10 00       	.word	0x0010	; ????
     8c0:	01 03       	mulsu	r16, r17
     8c2:	01 09       	sbc	r16, r1
     8c4:	06 00       	.word	0x0006	; ????
     8c6:	01 03       	mulsu	r16, r17
     8c8:	01 09       	sbc	r16, r1
     8ca:	02 00       	.word	0x0002	; ????
     8cc:	01 03       	mulsu	r16, r17
     8ce:	01 09       	sbc	r16, r1
     8d0:	04 00       	.word	0x0004	; ????
     8d2:	01 03       	mulsu	r16, r17
     8d4:	01 09       	sbc	r16, r1
     8d6:	0e 00       	.word	0x000e	; ????
     8d8:	01 03       	mulsu	r16, r17
     8da:	7f 09       	sbc	r23, r15
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
     8dc:	0a 00       	.word	0x000a	; ????
     8de:	01 03       	mulsu	r16, r17
     8e0:	5b 09       	sbc	r21, r11

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
     8e2:	02 00       	.word	0x0002	; ????
     8e4:	01 03       	mulsu	r16, r17
     8e6:	02 09       	sbc	r16, r2
     8e8:	0e 00       	.word	0x000e	; ????
     8ea:	01 03       	mulsu	r16, r17
     8ec:	04 09       	sbc	r16, r4
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
     8ee:	0e 00       	.word	0x000e	; ????
     8f0:	01 03       	mulsu	r16, r17
     8f2:	02 09       	sbc	r16, r2
     8f4:	06 00       	.word	0x0006	; ????
     8f6:	01 03       	mulsu	r16, r17
     8f8:	03 09       	sbc	r16, r3
     8fa:	06 00       	.word	0x0006	; ????
     8fc:	01 03       	mulsu	r16, r17
     8fe:	02 09       	sbc	r16, r2
     900:	04 00       	.word	0x0004	; ????
     902:	01 03       	mulsu	r16, r17
     904:	02 09       	sbc	r16, r2
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     906:	06 00       	.word	0x0006	; ????
     908:	01 03       	mulsu	r16, r17
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
     90a:	04 09       	sbc	r16, r4
     90c:	04 00       	.word	0x0004	; ????
     90e:	01 03       	mulsu	r16, r17
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     910:	06 09       	sbc	r16, r6
     912:	16 00       	.word	0x0016	; ????
     914:	01 03       	mulsu	r16, r17
     916:	03 09       	sbc	r16, r3
     918:	06 00       	.word	0x0006	; ????
     91a:	01 03       	mulsu	r16, r17
     91c:	7d 09       	sbc	r23, r13
     91e:	08 00       	.word	0x0008	; ????
     920:	01 04       	cpc	r0, r1
     922:	07 03       	mulsu	r16, r23
     924:	dc 01       	movw	r26, r24
     926:	09 04       	cpc	r0, r9
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
     928:	00 01       	movw	r0, r0
     92a:	03 01       	movw	r0, r6
     92c:	09 00       	.word	0x0009	; ????
     92e:	00 01       	movw	r0, r0
     930:	03 02       	muls	r16, r19
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     932:	09 10       	cpse	r0, r9
     934:	00 01       	movw	r0, r0
     936:	03 72       	andi	r16, 0x23	; 35
     938:	09 06       	cpc	r0, r25
     93a:	00 01       	movw	r0, r0
     93c:	03 01       	movw	r0, r6
     93e:	09 00       	.word	0x0009	; ????
     940:	00 01       	movw	r0, r0
     942:	03 ce       	rjmp	.-1018   	; 0x54a <_ZN3LCD9setCursorEhh.constprop.36+0x42>
     944:	7e 09       	sbc	r23, r14
     946:	10 00       	.word	0x0010	; ????
     948:	01 03       	mulsu	r16, r17
	if (twi_sendStop)
     94a:	02 09       	sbc	r16, r2
     94c:	14 00       	.word	0x0014	; ????
     94e:	01 03       	mulsu	r16, r17
     950:	01 09       	sbc	r16, r1
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
     952:	18 00       	.word	0x0018	; ????
     954:	01 03       	mulsu	r16, r17
     956:	02 09       	sbc	r16, r2
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
     958:	18 00       	.word	0x0018	; ????
     95a:	01 03       	mulsu	r16, r17
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
     95c:	02 09       	sbc	r16, r2
     95e:	08 00       	.word	0x0008	; ????
     960:	01 03       	mulsu	r16, r17
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
     962:	05 09       	sbc	r16, r5
     964:	04 00       	.word	0x0004	; ????
     966:	01 03       	mulsu	r16, r17
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     968:	02 09       	sbc	r16, r2
     96a:	06 00       	.word	0x0006	; ????
     96c:	01 03       	mulsu	r16, r17
     96e:	7e 09       	sbc	r23, r14
     970:	06 00       	.word	0x0006	; ????
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
     972:	01 03       	mulsu	r16, r17
     974:	02 09       	sbc	r16, r2
     976:	08 00       	.word	0x0008	; ????
     978:	01 03       	mulsu	r16, r17
     97a:	04 09       	sbc	r16, r4
     97c:	04 00       	.word	0x0004	; ????
     97e:	01 03       	mulsu	r16, r17
     980:	03 09       	sbc	r16, r3
     982:	08 00       	.word	0x0008	; ????
     984:	01 03       	mulsu	r16, r17
     986:	7d 09       	sbc	r23, r13
     988:	10 00       	.word	0x0010	; ????
     98a:	01 03       	mulsu	r16, r17
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
     98c:	8a 7f       	andi	r24, 0xFA	; 250
     98e:	09 04       	cpc	r0, r9
     990:	00 01       	movw	r0, r0

  // update twi state
  twi_state = TWI_READY;
     992:	03 01       	movw	r0, r6
     994:	09 0a       	sbc	r0, r25
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     996:	00 01       	movw	r0, r0
     998:	03 02       	muls	r16, r19
     99a:	09 04       	cpc	r0, r9
     99c:	00 01       	movw	r0, r0
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
     99e:	03 02       	muls	r16, r19
     9a0:	09 06       	cpc	r0, r25
     9a2:	00 01       	movw	r0, r0
     9a4:	03 01       	movw	r0, r6
     9a6:	09 02       	muls	r16, r25
     9a8:	00 01       	movw	r0, r0
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
     9aa:	03 04       	cpc	r0, r3
     9ac:	09 02       	muls	r16, r25
     9ae:	00 01       	movw	r0, r0
     9b0:	03 02       	muls	r16, r19
     9b2:	09 08       	sbc	r0, r9
     9b4:	00 01       	movw	r0, r0
     9b6:	03 08       	sbc	r0, r3
     9b8:	09 06       	cpc	r0, r25
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
     9ba:	00 01       	movw	r0, r0
     9bc:	03 04       	cpc	r0, r3
     9be:	09 0c       	add	r0, r9
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
     9c0:	00 01       	movw	r0, r0
     9c2:	03 07       	cpc	r16, r19
     9c4:	09 06       	cpc	r0, r25
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
     9c6:	00 01       	movw	r0, r0
     9c8:	04 03       	mulsu	r16, r20
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
     9ca:	03 ef       	ldi	r16, 0xF3	; 243
     9cc:	00 09       	sbc	r16, r0
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
     9ce:	12 00       	.word	0x0012	; ????
     9d0:	01 04       	cpc	r0, r1
     9d2:	07 03       	mulsu	r16, r23
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
     9d4:	95 7f       	andi	r25, 0xF5	; 245
     9d6:	09 08       	sbc	r0, r9
     9d8:	00 01       	movw	r0, r0
     9da:	04 03       	mulsu	r16, r20
        twi_txBufferLength = 1;
     9dc:	03 eb       	ldi	r16, 0xB3	; 179
     9de:	00 09       	sbc	r16, r0
     9e0:	12 00       	.word	0x0012	; ????
        twi_txBuffer[0] = 0x00;
     9e2:	01 04       	cpc	r0, r1
     9e4:	07 03       	mulsu	r16, r23
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
     9e6:	99 7f       	andi	r25, 0xF9	; 249
     9e8:	09 0a       	sbc	r0, r25
     9ea:	00 01       	movw	r0, r0
     9ec:	04 03       	mulsu	r16, r20
     9ee:	03 e7       	ldi	r16, 0x73	; 115
     9f0:	00 09       	sbc	r16, r0
     9f2:	12 00       	.word	0x0012	; ????
     9f4:	01 04       	cpc	r0, r1
     9f6:	07 03       	mulsu	r16, r23
     9f8:	9d 7f       	andi	r25, 0xFD	; 253
     9fa:	09 06       	cpc	r0, r25
     9fc:	00 01       	movw	r0, r0
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
     9fe:	03 0a       	sbc	r0, r19
     a00:	09 14       	cp	r0, r9
     a02:	00 01       	movw	r0, r0
     a04:	04 03       	mulsu	r16, r20
     a06:	03 d9       	rcall	.-3578   	; 0xfffffc0e <__eeprom_end+0xff7efc0e>
     a08:	00 09       	sbc	r16, r0
     a0a:	08 00       	.word	0x0008	; ????
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
     a0c:	01 04       	cpc	r0, r1
     a0e:	07 03       	mulsu	r16, r23
     a10:	ab 7f       	andi	r26, 0xFB	; 251
     a12:	09 08       	sbc	r0, r9
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     a14:	00 01       	movw	r0, r0
     a16:	04 03       	mulsu	r16, r20
     a18:	03 d5       	rcall	.+2566   	; 0x1420 <__data_load_end+0x694>
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
     a1a:	00 09       	sbc	r16, r0
     a1c:	0a 00       	.word	0x000a	; ????
     a1e:	01 04       	cpc	r0, r1

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
     a20:	07 03       	mulsu	r16, r23
     a22:	af 7f       	andi	r26, 0xFF	; 255
      twi_stop();
     a24:	09 0a       	sbc	r0, r25
     a26:	00 01       	movw	r0, r0
      break;
  }
}
     a28:	04 03       	mulsu	r16, r20
     a2a:	03 d1       	rcall	.+518    	; 0xc32 <main+0xda>
     a2c:	00 09       	sbc	r16, r0
     a2e:	0a 00       	.word	0x000a	; ????
     a30:	01 04       	cpc	r0, r1
     a32:	07 03       	mulsu	r16, r23
     a34:	b5 7f       	andi	r27, 0xF5	; 245
     a36:	09 06       	cpc	r0, r25
     a38:	00 01       	movw	r0, r0
     a3a:	04 03       	mulsu	r16, r20
     a3c:	03 cb       	rjmp	.-2554   	; 0x44 <__SREG__+0x5>
     a3e:	00 09       	sbc	r16, r0
     a40:	0a 00       	.word	0x000a	; ????
     a42:	01 04       	cpc	r0, r1
     a44:	07 03       	mulsu	r16, r23
     a46:	b9 7f       	andi	r27, 0xF9	; 249
     a48:	09 08       	sbc	r0, r9
     a4a:	00 01       	movw	r0, r0
     a4c:	03 3e       	cpi	r16, 0xE3	; 227
     a4e:	09 04       	cpc	r0, r9
     a50:	00 01       	movw	r0, r0
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     a52:	03 55       	subi	r16, 0x53	; 83
     a54:	09 08       	sbc	r0, r9
     a56:	00 01       	movw	r0, r0
     a58:	04 03       	mulsu	r16, r20
     a5a:	03 34       	cpi	r16, 0x43	; 67
     a5c:	09 08       	sbc	r0, r9
     a5e:	00 01       	movw	r0, r0
     a60:	04 07       	cpc	r16, r20
     a62:	03 40       	sbci	r16, 0x03	; 3
     a64:	09 08       	sbc	r0, r9
     a66:	00 01       	movw	r0, r0
     a68:	03 02       	muls	r16, r19
     a6a:	09 04       	cpc	r0, r9
     a6c:	00 01       	movw	r0, r0
     a6e:	03 a8       	ldd	r0, Z+51	; 0x33
     a70:	01 09       	sbc	r16, r1
void (*TwoWire::user_onRequest)(void);
void (*TwoWire::user_onReceive)(int);

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire()
     a72:	08 00       	.word	0x0008	; ????
     a74:	01 03       	mulsu	r16, r17
     a76:	dc 7e       	andi	r29, 0xEC	; 236
     a78:	09 0e       	add	r0, r25
     a7a:	00 01       	movw	r0, r0
     a7c:	03 a4       	ldd	r0, Z+43	; 0x2b
     a7e:	01 09       	sbc	r16, r1
     a80:	08 00       	.word	0x0008	; ????
     a82:	01 04       	cpc	r0, r1
     a84:	08 03       	fmul	r16, r16
// CONSTRUCTORS
// ---------------------------------------------------------------------------

LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
                             uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
                             uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
     a86:	b1 01       	movw	r22, r2
     a88:	09 02       	muls	r16, r25
     a8a:	00 01       	movw	r0, r0
     a8c:	03 6d       	ori	r16, 0xD3	; 211
     a8e:	09 02       	muls	r16, r25
     a90:	00 01       	movw	r0, r0
   uint8_t i;
   
   // Initialize the IO pins
   // -----------------------
   
   _rs_pin = rs;
     a92:	04 09       	sbc	r16, r4
     a94:	03 e8       	ldi	r16, 0x83	; 131
     a96:	7c 09       	sbc	r23, r12
   _rw_pin = rw;
     a98:	02 00       	.word	0x0002	; ????
     a9a:	01 03       	mulsu	r16, r17
     a9c:	65 09       	sbc	r22, r5
   _enable_pin = enable;
     a9e:	02 00       	.word	0x0002	; ????
     aa0:	01 03       	mulsu	r16, r17
     aa2:	00 09       	sbc	r16, r0
   
   _data_pins[0] = d0;
     aa4:	00 00       	nop
     aa6:	01 03       	mulsu	r16, r17
     aa8:	75 09       	sbc	r23, r5
   _data_pins[1] = d1;
     aaa:	06 00       	.word	0x0006	; ????
     aac:	01 03       	mulsu	r16, r17
     aae:	01 09       	sbc	r16, r1
   _data_pins[2] = d2;
     ab0:	00 00       	nop
     ab2:	01 03       	mulsu	r16, r17
     ab4:	01 09       	sbc	r16, r1
   _data_pins[3] = d3; 
     ab6:	04 00       	.word	0x0004	; ????
     ab8:	01 03       	mulsu	r16, r17
     aba:	01 09       	sbc	r16, r1
   _data_pins[4] = d4;
     abc:	1a 00       	.word	0x001a	; ????
     abe:	01 04       	cpc	r0, r1
     ac0:	04 03       	mulsu	r16, r20
   _data_pins[5] = d5;
     ac2:	94 01       	movw	r18, r8
     ac4:	09 06       	cpc	r0, r25
     ac6:	00 01       	movw	r0, r0
   _data_pins[6] = d6;
     ac8:	03 05       	cpc	r16, r3
     aca:	09 20       	and	r0, r9
     acc:	00 01       	movw	r0, r0
   _data_pins[7] = d7;
     ace:	03 03       	mulsu	r16, r19
     ad0:	09 02       	muls	r16, r25
     ad2:	00 01       	movw	r0, r0
     ad4:	03 03       	mulsu	r16, r19
     ad6:	09 0c       	add	r0, r9
     ad8:	00 01       	movw	r0, r0
     ada:	03 01       	movw	r0, r6
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
   {
      pinMode ( _data_pins[i], OUTPUT );
     adc:	09 12       	cpse	r0, r25
     ade:	00 01       	movw	r0, r0
     ae0:	03 02       	muls	r16, r19
     ae2:	09 04       	cpc	r0, r9
     ae4:	00 01       	movw	r0, r0
   _data_pins[7] = d7;
   
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
     ae6:	03 7c       	andi	r16, 0xC3	; 195
     ae8:	09 12       	cpse	r0, r25
     aea:	00 01       	movw	r0, r0
     aec:	03 07       	cpc	r16, r19
     aee:	09 08       	sbc	r0, r9
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
      {
         pinMode ( _data_pins[i], OUTPUT );
     af0:	00 01       	movw	r0, r0
     af2:	03 01       	movw	r0, r6
     af4:	09 06       	cpc	r0, r25
   // Initialize the rest of the ports if it is an 8bit controlled LCD
   // ----------------------------------------------------------------
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
     af6:	00 01       	movw	r0, r0
     af8:	04 0a       	sbc	r0, r20
     afa:	03 bb       	out	0x13, r16	; 19
      {
         pinMode ( _data_pins[i], OUTPUT );
      }
   }
   pinMode(_rs_pin, OUTPUT);
     afc:	7e 09       	sbc	r23, r14
     afe:	1e 00       	.word	0x001e	; ????
     b00:	01 03       	mulsu	r16, r17
     b02:	03 09       	sbc	r16, r3
   
   // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
   if (_rw_pin != 255) 
     b04:	00 00       	nop
     b06:	01 04       	cpc	r0, r1
     b08:	03 03       	mulsu	r16, r19
     b0a:	14 09       	sbc	r17, r4
   { 
      pinMode(_rw_pin, OUTPUT);
     b0c:	04 00       	.word	0x0004	; ????
     b0e:	01 03       	mulsu	r16, r17
   }
   
   pinMode(_enable_pin, OUTPUT);
     b10:	03 09       	sbc	r16, r3
     b12:	16 00       	.word	0x0016	; ????
     b14:	01 03       	mulsu	r16, r17
     b16:	01 09       	sbc	r16, r1
   // Initialise displaymode functions to defaults: LCD_1LINE and LCD_5x8DOTS
   // -------------------------------------------------------------------------
   if (fourbitmode)
      _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
   else 
      _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
     b18:	10 00       	.word	0x0010	; ????
     b1a:	01 03       	mulsu	r16, r17
     b1c:	03 09       	sbc	r16, r3
   
   // Now we pull both RS and R/W low to begin commands
   digitalWrite(_rs_pin, LOW);
     b1e:	04 00       	.word	0x0004	; ????
     b20:	01 03       	mulsu	r16, r17
     b22:	01 09       	sbc	r16, r1
     b24:	04 00       	.word	0x0004	; ????
     b26:	01 03       	mulsu	r16, r17
   digitalWrite(_enable_pin, LOW);
     b28:	7e 09       	sbc	r23, r14
     b2a:	04 00       	.word	0x0004	; ????
     b2c:	01 03       	mulsu	r16, r17
     b2e:	03 09       	sbc	r16, r3
     b30:	08 00       	.word	0x0008	; ????
   
   if (_rw_pin != 255) 
     b32:	01 03       	mulsu	r16, r17
     b34:	01 09       	sbc	r16, r1
     b36:	04 00       	.word	0x0004	; ????
     b38:	01 03       	mulsu	r16, r17
   { 
      digitalWrite(_rw_pin, LOW);
     b3a:	03 09       	sbc	r16, r3
     b3c:	06 00       	.word	0x0006	; ????
     b3e:	01 03       	mulsu	r16, r17
   }
   
   // Initialise the backlight pin no nothing
   _backlightPin = LCD_NOBACKLIGHT;
     b40:	01 09       	sbc	r16, r1
     b42:	04 00       	.word	0x0004	; ????
     b44:	01 03       	mulsu	r16, r17
   _polarity = POSITIVE;
     b46:	01 09       	sbc	r16, r1
     b48:	10 00       	.word	0x0010	; ????
     b4a:	01 03       	mulsu	r16, r17
     b4c:	01 09       	sbc	r16, r1
     b4e:	26 00       	.word	0x0026	; ????
     b50:	01 04       	cpc	r0, r1
     b52:	05 03       	mulsu	r16, r21
     b54:	d1 02       	muls	r29, r17
     b56:	09 16       	cp	r0, r25

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     b58:	00 01       	movw	r0, r0
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     b5a:	03 01       	movw	r0, r6
     b5c:	09 22       	and	r0, r25
     b5e:	00 01       	movw	r0, r0
	sbi(TCCR0A, WGM00);
     b60:	03 27       	eor	r16, r19
     b62:	09 4e       	sbci	r16, 0xE9	; 233
     b64:	00 01       	movw	r0, r0
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     b66:	03 59       	subi	r16, 0x93	; 147
     b68:	09 06       	cpc	r0, r25
     b6a:	00 01       	movw	r0, r0
	sbi(TCCR0B, CS00);
     b6c:	03 05       	cpc	r16, r3
     b6e:	09 70       	andi	r16, 0x09	; 9
     b70:	00 01       	movw	r0, r0

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     b72:	03 08       	sbc	r0, r3
     b74:	09 06       	cpc	r0, r25
     b76:	00 01       	movw	r0, r0
     b78:	03 02       	muls	r16, r19
     b7a:	09 0c       	add	r0, r9
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     b7c:	00 01       	movw	r0, r0
     b7e:	03 45       	sbci	r16, 0x53	; 83

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     b80:	09 18       	sub	r0, r9
     b82:	00 01       	movw	r0, r0
     b84:	03 cf       	rjmp	.-506    	; 0x98c <__stack+0x8d>
     b86:	00 09       	sbc	r16, r0
     b88:	04 00       	.word	0x0004	; ????
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     b8a:	01 03       	mulsu	r16, r17
     b8c:	0b 09       	sbc	r16, r11
     b8e:	06 00       	.word	0x0006	; ????
     b90:	01 03       	mulsu	r16, r17
     b92:	03 09       	sbc	r16, r3
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     b94:	18 00       	.word	0x0018	; ????
     b96:	01 03       	mulsu	r16, r17
     b98:	08 09       	sbc	r16, r8
     b9a:	0a 00       	.word	0x000a	; ????
     b9c:	01 03       	mulsu	r16, r17

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     b9e:	01 09       	sbc	r16, r1
     ba0:	18 00       	.word	0x0018	; ????
     ba2:	01 03       	mulsu	r16, r17
     ba4:	03 09       	sbc	r16, r3
     ba6:	08 00       	.word	0x0008	; ????

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     ba8:	01 03       	mulsu	r16, r17
     baa:	04 09       	sbc	r16, r4
     bac:	06 00       	.word	0x0006	; ????
     bae:	01 03       	mulsu	r16, r17
     bb0:	0f 09       	sbc	r16, r15
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     bb2:	04 00       	.word	0x0004	; ????
     bb4:	01 03       	mulsu	r16, r17
     bb6:	02 09       	sbc	r16, r2
     bb8:	06 00       	.word	0x0006	; ????
     bba:	01 03       	mulsu	r16, r17
		sbi(ADCSRA, ADPS1);
     bbc:	06 09       	sbc	r16, r6
     bbe:	06 00       	.word	0x0006	; ????
     bc0:	01 03       	mulsu	r16, r17
     bc2:	02 09       	sbc	r16, r2
     bc4:	0a 00       	.word	0x000a	; ????
		sbi(ADCSRA, ADPS0);
     bc6:	01 03       	mulsu	r16, r17
     bc8:	9e 7f       	andi	r25, 0xFE	; 254
     bca:	09 1a       	sub	r0, r25
     bcc:	00 01       	movw	r0, r0
     bce:	03 03       	mulsu	r16, r19
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     bd0:	09 06       	cpc	r0, r25
     bd2:	00 01       	movw	r0, r0
     bd4:	03 ea       	ldi	r16, 0xA3	; 163
     bd6:	00 09       	sbc	r16, r0
     bd8:	04 00       	.word	0x0004	; ????
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     bda:	01 03       	mulsu	r16, r17
     bdc:	01 09       	sbc	r16, r1
// ----------

void setup()
{
  // some displays need time to initialize
  delay(1000);
     bde:	08 00       	.word	0x0008	; ????
     be0:	01 03       	mulsu	r16, r17
     be2:	03 09       	sbc	r16, r3
     be4:	0c 00       	.word	0x000c	; ????
     be6:	01 03       	mulsu	r16, r17
     be8:	02 09       	sbc	r16, r2
  // initialize LCD and set up the number of columns and rows
  lcd.begin(16, 2);
     bea:	10 00       	.word	0x0010	; ????
     bec:	01 03       	mulsu	r16, r17
     bee:	0c 09       	sbc	r16, r12
     bf0:	06 00       	.word	0x0006	; ????
     bf2:	01 03       	mulsu	r16, r17
     bf4:	02 09       	sbc	r16, r2
     bf6:	06 00       	.word	0x0006	; ????
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     bf8:	01 03       	mulsu	r16, r17

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     bfa:	02 09       	sbc	r16, r2
	m = timer0_millis;
     bfc:	04 00       	.word	0x0004	; ????
     bfe:	01 03       	mulsu	r16, r17
     c00:	03 09       	sbc	r16, r3
     c02:	04 00       	.word	0x0004	; ????
     c04:	01 03       	mulsu	r16, r17
     c06:	02 09       	sbc	r16, r2
     c08:	06 00       	.word	0x0006	; ????
     c0a:	01 03       	mulsu	r16, r17
	SREG = oldSREG;
     c0c:	01 09       	sbc	r16, r1

  _startTime_ms = millis();
     c0e:	08 00       	.word	0x0008	; ????
     c10:	01 03       	mulsu	r16, r17
     c12:	01 09       	sbc	r16, r1
     c14:	06 00       	.word	0x0006	; ????
     c16:	01 03       	mulsu	r16, r17
     c18:	05 09       	sbc	r16, r5
     c1a:	04 00       	.word	0x0004	; ????
     c1c:	01 03       	mulsu	r16, r17
	

#endif

	// busy wait
	__asm__ __volatile__ (
     c1e:	02 09       	sbc	r16, r2
     c20:	18 00       	.word	0x0018	; ????
     c22:	01 03       	mulsu	r16, r17
     c24:	cd 7e       	andi	r28, 0xED	; 237
}

void loop() 
{
  if (0 == _loopCounter--) {
     c26:	09 0e       	add	r0, r25
     c28:	00 01       	movw	r0, r0
     c2a:	03 7e       	andi	r16, 0xE3	; 227
     c2c:	09 08       	sbc	r0, r9
     c2e:	00 01       	movw	r0, r0
     c30:	03 c0       	rjmp	.+6      	; 0xc38 <main+0xe0>
     c32:	01 09       	sbc	r16, r1
     c34:	06 00       	.word	0x0006	; ????
     c36:	01 03       	mulsu	r16, r17
     c38:	07 09       	sbc	r16, r7
     c3a:	06 00       	.word	0x0006	; ????
     c3c:	01 03       	mulsu	r16, r17
     c3e:	01 09       	sbc	r16, r1
     c40:	04 00       	.word	0x0004	; ????
     c42:	01 03       	mulsu	r16, r17
     c44:	03 09       	sbc	r16, r3
     c46:	04 00       	.word	0x0004	; ????
     c48:	01 09       	sbc	r16, r1
     c4a:	22 00       	.word	0x0022	; ????
     c4c:	00 01       	movw	r0, r0
     c4e:	01 04       	cpc	r0, r1
     c50:	09 00       	.word	0x0009	; ????
     c52:	05 02       	muls	r16, r21
     c54:	52 0a       	sbc	r5, r18
     c56:	00 00       	nop
     c58:	03 2d       	mov	r16, r3
     c5a:	01 04       	cpc	r0, r1
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     c5c:	0b 03       	fmul	r16, r19

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     c5e:	11 09       	sbc	r17, r1
	m = timer0_millis;
     c60:	08 00       	.word	0x0008	; ????
     c62:	01 04       	cpc	r0, r1
     c64:	06 03       	mulsu	r16, r22
     c66:	72 09       	sbc	r23, r2
     c68:	18 00       	.word	0x0018	; ????
     c6a:	01 04       	cpc	r0, r1
     c6c:	09 03       	fmul	r16, r17
     c6e:	7d 09       	sbc	r23, r13
	SREG = oldSREG;
     c70:	0c 00       	.word	0x000c	; ????

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
     c72:	01 04       	cpc	r0, r1
     c74:	02 03       	mulsu	r16, r18
     c76:	17 09       	sbc	r17, r7
     c78:	08 00       	.word	0x0008	; ????
     c7a:	01 03       	mulsu	r16, r17
	

#endif

	// busy wait
	__asm__ __volatile__ (
     c7c:	b5 01       	movw	r22, r10
     c7e:	09 0c       	add	r0, r9
     c80:	00 01       	movw	r0, r0
    // 3000000 loops in 6225 [ms]
    unsigned long endTime_ms = millis();
  
    lcd.clear();
    lcd.setCursor(0, 0);
     c82:	03 01       	movw	r0, r6
     c84:	09 06       	cpc	r0, r25
     c86:	00 01       	movw	r0, r0
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     c88:	03 01       	movw	r0, r6
     c8a:	09 06       	cpc	r0, r25
     c8c:	00 01       	movw	r0, r0
     c8e:	03 02       	muls	r16, r19
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     c90:	09 06       	cpc	r0, r25
     c92:	00 01       	movw	r0, r0
     c94:	03 01       	movw	r0, r6
     c96:	09 06       	cpc	r0, r25
     c98:	00 01       	movw	r0, r0
     c9a:	03 01       	movw	r0, r6
     c9c:	09 06       	cpc	r0, r25
    lcd.print("Loops: ");
    lcd.print(C_LOOP_COUNT);
  
    lcd.setCursor(0, 1);
     c9e:	00 01       	movw	r0, r0
     ca0:	03 01       	movw	r0, r6
     ca2:	09 06       	cpc	r0, r25
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     ca4:	00 01       	movw	r0, r0
     ca6:	03 01       	movw	r0, r6
     ca8:	09 06       	cpc	r0, r25
     caa:	00 01       	movw	r0, r0
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     cac:	03 01       	movw	r0, r6
     cae:	09 06       	cpc	r0, r25
     cb0:	00 01       	movw	r0, r0
     cb2:	03 01       	movw	r0, r6
     cb4:	09 06       	cpc	r0, r25
     cb6:	00 01       	movw	r0, r0
     cb8:	03 01       	movw	r0, r6
     cba:	09 06       	cpc	r0, r25
     cbc:	00 01       	movw	r0, r0
     cbe:	03 07       	cpc	r16, r19
     cc0:	09 0e       	add	r0, r25
     cc2:	00 01       	movw	r0, r0
     cc4:	03 7e       	andi	r16, 0xE3	; 227
     cc6:	09 0a       	sbc	r0, r25
     cc8:	00 01       	movw	r0, r0
     cca:	03 0c       	add	r0, r3
     ccc:	09 0a       	sbc	r0, r25
     cce:	00 01       	movw	r0, r0
     cd0:	03 7e       	andi	r16, 0xE3	; 227
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     cd2:	09 06       	cpc	r0, r25
     cd4:	00 01       	movw	r0, r0
     cd6:	03 05       	cpc	r16, r3
     cd8:	09 06       	cpc	r0, r25
     cda:	00 01       	movw	r0, r0
     cdc:	03 03       	mulsu	r16, r19
     cde:	09 08       	sbc	r0, r9
     ce0:	00 01       	movw	r0, r0
     ce2:	03 02       	muls	r16, r19
     ce4:	09 08       	sbc	r0, r9
     ce6:	00 01       	movw	r0, r0
     ce8:	03 03       	mulsu	r16, r19
     cea:	09 04       	cpc	r0, r9
     cec:	00 01       	movw	r0, r0
     cee:	03 07       	cpc	r16, r19
     cf0:	09 08       	sbc	r0, r9
     cf2:	00 01       	movw	r0, r0
     cf4:	03 03       	mulsu	r16, r19
     cf6:	09 06       	cpc	r0, r25
     cf8:	00 01       	movw	r0, r0
     cfa:	03 01       	movw	r0, r6
     cfc:	09 0a       	sbc	r0, r25
     cfe:	00 01       	movw	r0, r0
     d00:	03 02       	muls	r16, r19
     d02:	09 0a       	sbc	r0, r25
     d04:	00 01       	movw	r0, r0
     d06:	03 02       	muls	r16, r19
     d08:	09 08       	sbc	r0, r9
     d0a:	00 01       	movw	r0, r0
     d0c:	03 04       	cpc	r0, r3
     d0e:	09 06       	cpc	r0, r25
     d10:	00 01       	movw	r0, r0
     d12:	03 01       	movw	r0, r6
     d14:	09 06       	cpc	r0, r25
     d16:	00 01       	movw	r0, r0
     d18:	04 0c       	add	r0, r4
     d1a:	03 ed       	ldi	r16, 0xD3	; 211
     d1c:	7d 09       	sbc	r23, r13
     d1e:	12 00       	.word	0x0012	; ????
     d20:	01 04       	cpc	r0, r1
     d22:	03 03       	mulsu	r16, r19
     d24:	d3 01       	movw	r26, r6
     d26:	09 00       	.word	0x0009	; ????
     d28:	00 01       	movw	r0, r0
     d2a:	03 06       	cpc	r0, r19
     d2c:	09 02       	muls	r16, r25
     d2e:	00 01       	movw	r0, r0
     d30:	03 01       	movw	r0, r6
     d32:	09 06       	cpc	r0, r25
     d34:	00 01       	movw	r0, r0
     d36:	03 0d       	add	r16, r3
     d38:	09 06       	cpc	r0, r25
     d3a:	00 01       	movw	r0, r0
     d3c:	03 01       	movw	r0, r6
     d3e:	09 06       	cpc	r0, r25
     d40:	00 01       	movw	r0, r0
     d42:	03 0d       	add	r16, r3
     d44:	09 06       	cpc	r0, r25
     d46:	00 01       	movw	r0, r0
     d48:	03 0b       	sbc	r16, r19
     d4a:	09 0a       	sbc	r0, r25
     d4c:	00 01       	movw	r0, r0
     d4e:	03 03       	mulsu	r16, r19
     d50:	09 04       	cpc	r0, r9
     d52:	00 01       	movw	r0, r0
     d54:	03 02       	muls	r16, r19
     d56:	09 0a       	sbc	r0, r25
     d58:	00 01       	movw	r0, r0
     d5a:	03 0a       	sbc	r0, r19
     d5c:	09 0a       	sbc	r0, r25
     d5e:	00 01       	movw	r0, r0
     d60:	03 07       	cpc	r16, r19
     d62:	09 0a       	sbc	r0, r25
     d64:	00 01       	movw	r0, r0
     d66:	03 09       	sbc	r16, r3
     d68:	09 0a       	sbc	r0, r25
     d6a:	00 01       	movw	r0, r0
     d6c:	03 23       	and	r16, r19
     d6e:	09 0a       	sbc	r0, r25
     d70:	00 01       	movw	r0, r0
     d72:	03 01       	movw	r0, r6
     d74:	09 0a       	sbc	r0, r25
     d76:	00 01       	movw	r0, r0
     d78:	03 01       	movw	r0, r6
     d7a:	09 0a       	sbc	r0, r25
     d7c:	00 01       	movw	r0, r0
     d7e:	03 17       	cp	r16, r19
     d80:	09 0a       	sbc	r0, r25
     d82:	00 01       	movw	r0, r0
     d84:	03 09       	sbc	r16, r3
     d86:	09 0a       	sbc	r0, r25
     d88:	00 01       	movw	r0, r0
     d8a:	04 0d       	add	r16, r4
     d8c:	03 8d       	ldd	r16, Z+27	; 0x1b
     d8e:	7d 09       	sbc	r23, r13
     d90:	04 00       	.word	0x0004	; ????
     d92:	01 03       	mulsu	r16, r17
     d94:	02 09       	sbc	r16, r2
     d96:	0c 00       	.word	0x000c	; ????
     d98:	01 04       	cpc	r0, r1
     d9a:	03 03       	mulsu	r16, r19
     d9c:	2f 09       	sbc	r18, r15
     d9e:	0e 00       	.word	0x000e	; ????
     da0:	01 03       	mulsu	r16, r17
     da2:	04 09       	sbc	r16, r4
     da4:	02 00       	.word	0x0002	; ????
     da6:	01 03       	mulsu	r16, r17
     da8:	01 09       	sbc	r16, r1
     daa:	02 00       	.word	0x0002	; ????
     dac:	01 03       	mulsu	r16, r17
     dae:	01 09       	sbc	r16, r1
     db0:	10 00       	.word	0x0010	; ????
     db2:	01 04       	cpc	r0, r1
     db4:	0d 03       	fmul	r16, r21
     db6:	4d 09       	sbc	r20, r13
     db8:	02 00       	.word	0x0002	; ????
     dba:	01 04       	cpc	r0, r1
     dbc:	03 03       	mulsu	r16, r19
     dbe:	d3 01       	movw	r26, r6
     dc0:	09 10       	cpse	r0, r9
     dc2:	00 01       	movw	r0, r0
     dc4:	04 0c       	add	r0, r4
     dc6:	03 c5       	rjmp	.+2566   	; 0x17ce <__data_load_end+0xa42>
     dc8:	7e 09       	sbc	r23, r14
     dca:	04 00       	.word	0x0004	; ????
     dcc:	01 04       	cpc	r0, r1
     dce:	0d 03       	fmul	r16, r21
     dd0:	6d 09       	sbc	r22, r13
     dd2:	04 00       	.word	0x0004	; ????
     dd4:	01 04       	cpc	r0, r1
     dd6:	03 03       	mulsu	r16, r19
     dd8:	28 09       	sbc	r18, r8
     dda:	36 00       	.word	0x0036	; ????
     ddc:	01 03       	mulsu	r16, r17
     dde:	04 09       	sbc	r16, r4
     de0:	02 00       	.word	0x0002	; ????
     de2:	01 03       	mulsu	r16, r17
     de4:	01 09       	sbc	r16, r1
     de6:	02 00       	.word	0x0002	; ????
     de8:	01 03       	mulsu	r16, r17
     dea:	01 09       	sbc	r16, r1
     dec:	10 00       	.word	0x0010	; ????
     dee:	01 04       	cpc	r0, r1
     df0:	07 03       	mulsu	r16, r23
     df2:	ec 00       	.word	0x00ec	; ????
     df4:	09 02       	muls	r16, r25
     df6:	00 01       	movw	r0, r0
     df8:	04 03       	mulsu	r16, r20
     dfa:	03 34       	cpi	r16, 0x43	; 67
     dfc:	09 0a       	sbc	r0, r25
     dfe:	00 01       	movw	r0, r0
     e00:	04 0d       	add	r16, r4
     e02:	03 b7       	in	r16, 0x33	; 51
     e04:	7e 09       	sbc	r23, r14
     e06:	06 00       	.word	0x0006	; ????
     e08:	01 04       	cpc	r0, r1
     e0a:	04 03       	mulsu	r16, r20
     e0c:	1f 09       	sbc	r17, r15
     e0e:	06 00       	.word	0x0006	; ????
     e10:	01 03       	mulsu	r16, r17
     e12:	2a 09       	sbc	r18, r10
     e14:	08 00       	.word	0x0008	; ????
     e16:	01 04       	cpc	r0, r1
     e18:	0d 03       	fmul	r16, r21
     e1a:	bb 7f       	andi	r27, 0xFB	; 251
     e1c:	09 0e       	add	r0, r25
     e1e:	00 01       	movw	r0, r0
     e20:	04 04       	cpc	r0, r4
     e22:	03 1b       	sub	r16, r19
     e24:	09 06       	cpc	r0, r25
     e26:	00 01       	movw	r0, r0
     e28:	03 2a       	or	r0, r19
     e2a:	09 08       	sbc	r0, r9
     e2c:	00 01       	movw	r0, r0
     e2e:	03 56       	subi	r16, 0x63	; 99
     e30:	09 26       	eor	r0, r25
     e32:	00 01       	movw	r0, r0
     e34:	04 0c       	add	r0, r4
     e36:	03 6f       	ori	r16, 0xF3	; 243
     e38:	09 08       	sbc	r0, r9
     e3a:	00 01       	movw	r0, r0
     e3c:	09 0e       	add	r0, r25
     e3e:	00 00       	nop
     e40:	01 01       	movw	r0, r2
     e42:	5e 00       	.word	0x005e	; ????
     e44:	00 00       	nop
     e46:	02 00       	.word	0x0002	; ????
     e48:	41 00       	.word	0x0041	; ????
     e4a:	00 00       	nop
     e4c:	02 01       	movw	r0, r4
     e4e:	fb 0e       	add	r15, r27
     e50:	0a 00       	.word	0x000a	; ????
     e52:	01 01       	movw	r0, r2
     e54:	01 01       	movw	r0, r2
     e56:	00 00       	nop
     e58:	00 01       	movw	r0, r0
     e5a:	2e 2e       	mov	r2, r30
     e5c:	2f 2e       	mov	r2, r31
     e5e:	2e 2f       	mov	r18, r30
     e60:	2e 2e       	mov	r2, r30
     e62:	2f 2e       	mov	r2, r31
     e64:	2e 2f       	mov	r18, r30
     e66:	67 63       	ori	r22, 0x37	; 55
     e68:	63 2f       	mov	r22, r19
     e6a:	6c 69       	ori	r22, 0x9C	; 156
     e6c:	62 67       	ori	r22, 0x72	; 114
     e6e:	63 63       	ori	r22, 0x33	; 51
     e70:	2f 63       	ori	r18, 0x3F	; 63
     e72:	6f 6e       	ori	r22, 0xEF	; 239
     e74:	66 69       	ori	r22, 0x96	; 150
     e76:	67 2f       	mov	r22, r23
     e78:	61 76       	andi	r22, 0x61	; 97
     e7a:	72 00       	.word	0x0072	; ????
     e7c:	00 6c       	ori	r16, 0xC0	; 192
     e7e:	69 62       	ori	r22, 0x29	; 41
     e80:	31 66       	ori	r19, 0x61	; 97
     e82:	75 6e       	ori	r23, 0xE5	; 229
     e84:	63 73       	andi	r22, 0x33	; 51
     e86:	2e 53       	subi	r18, 0x3E	; 62
     e88:	00 01       	movw	r0, r0
     e8a:	00 00       	nop
     e8c:	00 00       	nop
     e8e:	05 02       	muls	r16, r21
     e90:	42 0d       	add	r20, r2
     e92:	00 00       	nop
     e94:	03 e6       	ldi	r16, 0x63	; 99
     e96:	11 01       	movw	r2, r2
     e98:	03 02       	muls	r16, r19
     e9a:	09 02       	muls	r16, r25
     e9c:	00 01       	movw	r0, r0
     e9e:	09 02       	muls	r16, r25
     ea0:	00 00       	nop
     ea2:	01 01       	movw	r0, r2
     ea4:	1e 01       	movw	r2, r28
     ea6:	00 00       	nop
     ea8:	02 00       	.word	0x0002	; ????
     eaa:	41 00       	.word	0x0041	; ????
     eac:	00 00       	nop
     eae:	02 01       	movw	r0, r4
     eb0:	fb 0e       	add	r15, r27
     eb2:	0a 00       	.word	0x000a	; ????
     eb4:	01 01       	movw	r0, r2
     eb6:	01 01       	movw	r0, r2
     eb8:	00 00       	nop
     eba:	00 01       	movw	r0, r0
     ebc:	2e 2e       	mov	r2, r30
     ebe:	2f 2e       	mov	r2, r31
     ec0:	2e 2f       	mov	r18, r30
     ec2:	2e 2e       	mov	r2, r30
     ec4:	2f 2e       	mov	r2, r31
     ec6:	2e 2f       	mov	r18, r30
     ec8:	67 63       	ori	r22, 0x37	; 55
     eca:	63 2f       	mov	r22, r19
     ecc:	6c 69       	ori	r22, 0x9C	; 156
     ece:	62 67       	ori	r22, 0x72	; 114
     ed0:	63 63       	ori	r22, 0x33	; 51
     ed2:	2f 63       	ori	r18, 0x3F	; 63
     ed4:	6f 6e       	ori	r22, 0xEF	; 239
     ed6:	66 69       	ori	r22, 0x96	; 150
     ed8:	67 2f       	mov	r22, r23
     eda:	61 76       	andi	r22, 0x61	; 97
     edc:	72 00       	.word	0x0072	; ????
     ede:	00 6c       	ori	r16, 0xC0	; 192
     ee0:	69 62       	ori	r22, 0x29	; 41
     ee2:	31 66       	ori	r19, 0x61	; 97
     ee4:	75 6e       	ori	r23, 0xE5	; 229
     ee6:	63 73       	andi	r22, 0x33	; 51
     ee8:	2e 53       	subi	r18, 0x3E	; 62
     eea:	00 01       	movw	r0, r0
     eec:	00 00       	nop
     eee:	00 00       	nop
     ef0:	05 02       	muls	r16, r21
     ef2:	e8 0c       	add	r14, r8
     ef4:	00 00       	nop
     ef6:	03 e6       	ldi	r16, 0x63	; 99
     ef8:	0c 01       	movw	r0, r24
     efa:	03 01       	movw	r0, r6
     efc:	09 02       	muls	r16, r25
     efe:	00 01       	movw	r0, r0
     f00:	03 01       	movw	r0, r6
     f02:	09 02       	muls	r16, r25
     f04:	00 01       	movw	r0, r0
     f06:	03 01       	movw	r0, r6
     f08:	09 02       	muls	r16, r25
     f0a:	00 01       	movw	r0, r0
     f0c:	03 01       	movw	r0, r6
     f0e:	09 02       	muls	r16, r25
     f10:	00 01       	movw	r0, r0
     f12:	03 02       	muls	r16, r19
     f14:	09 02       	muls	r16, r25
     f16:	00 01       	movw	r0, r0
     f18:	03 02       	muls	r16, r19
     f1a:	09 02       	muls	r16, r25
     f1c:	00 01       	movw	r0, r0
     f1e:	03 01       	movw	r0, r6
     f20:	09 02       	muls	r16, r25
     f22:	00 01       	movw	r0, r0
     f24:	03 01       	movw	r0, r6
     f26:	09 02       	muls	r16, r25
     f28:	00 01       	movw	r0, r0
     f2a:	03 01       	movw	r0, r6
     f2c:	09 02       	muls	r16, r25
     f2e:	00 01       	movw	r0, r0
     f30:	03 01       	movw	r0, r6
     f32:	09 02       	muls	r16, r25
     f34:	00 01       	movw	r0, r0
     f36:	03 01       	movw	r0, r6
     f38:	09 02       	muls	r16, r25
     f3a:	00 01       	movw	r0, r0
     f3c:	03 01       	movw	r0, r6
     f3e:	09 02       	muls	r16, r25
     f40:	00 01       	movw	r0, r0
     f42:	03 01       	movw	r0, r6
     f44:	09 02       	muls	r16, r25
     f46:	00 01       	movw	r0, r0
     f48:	03 01       	movw	r0, r6
     f4a:	09 02       	muls	r16, r25
     f4c:	00 01       	movw	r0, r0
     f4e:	03 01       	movw	r0, r6
     f50:	09 02       	muls	r16, r25
     f52:	00 01       	movw	r0, r0
     f54:	03 01       	movw	r0, r6
     f56:	09 02       	muls	r16, r25
     f58:	00 01       	movw	r0, r0
     f5a:	03 01       	movw	r0, r6
     f5c:	09 02       	muls	r16, r25
     f5e:	00 01       	movw	r0, r0
     f60:	03 01       	movw	r0, r6
     f62:	09 02       	muls	r16, r25
     f64:	00 01       	movw	r0, r0
     f66:	03 02       	muls	r16, r19
     f68:	09 02       	muls	r16, r25
     f6a:	00 01       	movw	r0, r0
     f6c:	03 01       	movw	r0, r6
     f6e:	09 02       	muls	r16, r25
     f70:	00 01       	movw	r0, r0
     f72:	03 01       	movw	r0, r6
     f74:	09 02       	muls	r16, r25
     f76:	00 01       	movw	r0, r0
     f78:	03 01       	movw	r0, r6
     f7a:	09 02       	muls	r16, r25
     f7c:	00 01       	movw	r0, r0
     f7e:	03 01       	movw	r0, r6
     f80:	09 02       	muls	r16, r25
     f82:	00 01       	movw	r0, r0
     f84:	03 01       	movw	r0, r6
     f86:	09 02       	muls	r16, r25
     f88:	00 01       	movw	r0, r0
     f8a:	03 02       	muls	r16, r19
     f8c:	09 02       	muls	r16, r25
     f8e:	00 01       	movw	r0, r0
     f90:	03 01       	movw	r0, r6
     f92:	09 02       	muls	r16, r25
     f94:	00 01       	movw	r0, r0
     f96:	03 01       	movw	r0, r6
     f98:	09 02       	muls	r16, r25
     f9a:	00 01       	movw	r0, r0
     f9c:	03 01       	movw	r0, r6
     f9e:	09 02       	muls	r16, r25
     fa0:	00 01       	movw	r0, r0
     fa2:	03 02       	muls	r16, r19
     fa4:	09 02       	muls	r16, r25
     fa6:	00 01       	movw	r0, r0
     fa8:	03 02       	muls	r16, r19
     faa:	09 02       	muls	r16, r25
     fac:	00 01       	movw	r0, r0
     fae:	03 02       	muls	r16, r19
     fb0:	09 02       	muls	r16, r25
     fb2:	00 01       	movw	r0, r0
     fb4:	03 02       	muls	r16, r19
     fb6:	09 02       	muls	r16, r25
     fb8:	00 01       	movw	r0, r0
     fba:	03 02       	muls	r16, r19
     fbc:	09 02       	muls	r16, r25
     fbe:	00 01       	movw	r0, r0
     fc0:	09 02       	muls	r16, r25
     fc2:	00 00       	nop
     fc4:	01 01       	movw	r0, r2
     fc6:	94 00       	.word	0x0094	; ????
     fc8:	00 00       	nop
     fca:	02 00       	.word	0x0002	; ????
     fcc:	41 00       	.word	0x0041	; ????
     fce:	00 00       	nop
     fd0:	02 01       	movw	r0, r4
     fd2:	fb 0e       	add	r15, r27
     fd4:	0a 00       	.word	0x000a	; ????
     fd6:	01 01       	movw	r0, r2
     fd8:	01 01       	movw	r0, r2
     fda:	00 00       	nop
     fdc:	00 01       	movw	r0, r0
     fde:	2e 2e       	mov	r2, r30
     fe0:	2f 2e       	mov	r2, r31
     fe2:	2e 2f       	mov	r18, r30
     fe4:	2e 2e       	mov	r2, r30
     fe6:	2f 2e       	mov	r2, r31
     fe8:	2e 2f       	mov	r18, r30
     fea:	67 63       	ori	r22, 0x37	; 55
     fec:	63 2f       	mov	r22, r19
     fee:	6c 69       	ori	r22, 0x9C	; 156
     ff0:	62 67       	ori	r22, 0x72	; 114
     ff2:	63 63       	ori	r22, 0x33	; 51
     ff4:	2f 63       	ori	r18, 0x3F	; 63
     ff6:	6f 6e       	ori	r22, 0xEF	; 239
     ff8:	66 69       	ori	r22, 0x96	; 150
     ffa:	67 2f       	mov	r22, r23
     ffc:	61 76       	andi	r22, 0x61	; 97
     ffe:	72 00       	.word	0x0072	; ????
    1000:	00 6c       	ori	r16, 0xC0	; 192
    1002:	69 62       	ori	r22, 0x29	; 41
    1004:	31 66       	ori	r19, 0x61	; 97
    1006:	75 6e       	ori	r23, 0xE5	; 229
    1008:	63 73       	andi	r22, 0x33	; 51
    100a:	2e 53       	subi	r18, 0x3E	; 62
    100c:	00 01       	movw	r0, r0
    100e:	00 00       	nop
    1010:	00 00       	nop
    1012:	05 02       	muls	r16, r21
    1014:	c6 00       	.word	0x00c6	; ????
    1016:	00 00       	nop
    1018:	03 e9       	ldi	r16, 0x93	; 147
    101a:	12 01       	movw	r2, r4
    101c:	03 01       	movw	r0, r6
    101e:	09 02       	muls	r16, r25
    1020:	00 01       	movw	r0, r0
    1022:	03 01       	movw	r0, r6
    1024:	09 02       	muls	r16, r25
    1026:	00 01       	movw	r0, r0
    1028:	03 01       	movw	r0, r6
    102a:	09 02       	muls	r16, r25
    102c:	00 01       	movw	r0, r0
    102e:	03 01       	movw	r0, r6
    1030:	09 02       	muls	r16, r25
    1032:	00 01       	movw	r0, r0
    1034:	03 01       	movw	r0, r6
    1036:	09 02       	muls	r16, r25
    1038:	00 01       	movw	r0, r0
    103a:	03 03       	mulsu	r16, r19
    103c:	09 02       	muls	r16, r25
    103e:	00 01       	movw	r0, r0
    1040:	03 05       	cpc	r16, r3
    1042:	09 02       	muls	r16, r25
    1044:	00 01       	movw	r0, r0
    1046:	03 02       	muls	r16, r19
    1048:	09 02       	muls	r16, r25
    104a:	00 01       	movw	r0, r0
    104c:	03 01       	movw	r0, r6
    104e:	09 02       	muls	r16, r25
    1050:	00 01       	movw	r0, r0
    1052:	03 01       	movw	r0, r6
    1054:	09 02       	muls	r16, r25
    1056:	00 01       	movw	r0, r0
    1058:	09 02       	muls	r16, r25
    105a:	00 00       	nop
    105c:	01 01       	movw	r0, r2
    105e:	82 00       	.word	0x0082	; ????
    1060:	00 00       	nop
    1062:	02 00       	.word	0x0002	; ????
    1064:	41 00       	.word	0x0041	; ????
    1066:	00 00       	nop
    1068:	02 01       	movw	r0, r4
    106a:	fb 0e       	add	r15, r27
    106c:	0a 00       	.word	0x000a	; ????
    106e:	01 01       	movw	r0, r2
    1070:	01 01       	movw	r0, r2
    1072:	00 00       	nop
    1074:	00 01       	movw	r0, r0
    1076:	2e 2e       	mov	r2, r30
    1078:	2f 2e       	mov	r2, r31
    107a:	2e 2f       	mov	r18, r30
    107c:	2e 2e       	mov	r2, r30
    107e:	2f 2e       	mov	r2, r31
    1080:	2e 2f       	mov	r18, r30
    1082:	67 63       	ori	r22, 0x37	; 55
    1084:	63 2f       	mov	r22, r19
    1086:	6c 69       	ori	r22, 0x9C	; 156
    1088:	62 67       	ori	r22, 0x72	; 114
    108a:	63 63       	ori	r22, 0x33	; 51
    108c:	2f 63       	ori	r18, 0x3F	; 63
    108e:	6f 6e       	ori	r22, 0xEF	; 239
    1090:	66 69       	ori	r22, 0x96	; 150
    1092:	67 2f       	mov	r22, r23
    1094:	61 76       	andi	r22, 0x61	; 97
    1096:	72 00       	.word	0x0072	; ????
    1098:	00 6c       	ori	r16, 0xC0	; 192
    109a:	69 62       	ori	r22, 0x29	; 41
    109c:	31 66       	ori	r19, 0x61	; 97
    109e:	75 6e       	ori	r23, 0xE5	; 229
    10a0:	63 73       	andi	r22, 0x33	; 51
    10a2:	2e 53       	subi	r18, 0x3E	; 62
    10a4:	00 01       	movw	r0, r0
    10a6:	00 00       	nop
    10a8:	00 00       	nop
    10aa:	05 02       	muls	r16, r21
    10ac:	dc 00       	.word	0x00dc	; ????
    10ae:	00 00       	nop
    10b0:	03 89       	ldd	r16, Z+19	; 0x13
    10b2:	13 01       	movw	r2, r6
    10b4:	03 01       	movw	r0, r6
    10b6:	09 02       	muls	r16, r25
    10b8:	00 01       	movw	r0, r0
    10ba:	03 01       	movw	r0, r6
    10bc:	09 02       	muls	r16, r25
    10be:	00 01       	movw	r0, r0
    10c0:	03 01       	movw	r0, r6
    10c2:	09 02       	muls	r16, r25
    10c4:	00 01       	movw	r0, r0
    10c6:	03 02       	muls	r16, r19
    10c8:	09 02       	muls	r16, r25
    10ca:	00 01       	movw	r0, r0
    10cc:	03 02       	muls	r16, r19
    10ce:	09 02       	muls	r16, r25
    10d0:	00 01       	movw	r0, r0
    10d2:	03 01       	movw	r0, r6
    10d4:	09 02       	muls	r16, r25
    10d6:	00 01       	movw	r0, r0
    10d8:	03 01       	movw	r0, r6
    10da:	09 02       	muls	r16, r25
    10dc:	00 01       	movw	r0, r0
    10de:	09 02       	muls	r16, r25
    10e0:	00 00       	nop
    10e2:	01 01       	movw	r0, r2
    10e4:	8e 00       	.word	0x008e	; ????
    10e6:	00 00       	nop
    10e8:	02 00       	.word	0x0002	; ????
    10ea:	41 00       	.word	0x0041	; ????
    10ec:	00 00       	nop
    10ee:	02 01       	movw	r0, r4
    10f0:	fb 0e       	add	r15, r27
    10f2:	0a 00       	.word	0x000a	; ????
    10f4:	01 01       	movw	r0, r2
    10f6:	01 01       	movw	r0, r2
    10f8:	00 00       	nop
    10fa:	00 01       	movw	r0, r0
    10fc:	2e 2e       	mov	r2, r30
    10fe:	2f 2e       	mov	r2, r31
    1100:	2e 2f       	mov	r18, r30
    1102:	2e 2e       	mov	r2, r30
    1104:	2f 2e       	mov	r2, r31
    1106:	2e 2f       	mov	r18, r30
    1108:	67 63       	ori	r22, 0x37	; 55
    110a:	63 2f       	mov	r22, r19
    110c:	6c 69       	ori	r22, 0x9C	; 156
    110e:	62 67       	ori	r22, 0x72	; 114
    1110:	63 63       	ori	r22, 0x33	; 51
    1112:	2f 63       	ori	r18, 0x3F	; 63
    1114:	6f 6e       	ori	r22, 0xEF	; 239
    1116:	66 69       	ori	r22, 0x96	; 150
    1118:	67 2f       	mov	r22, r23
    111a:	61 76       	andi	r22, 0x61	; 97
    111c:	72 00       	.word	0x0072	; ????
    111e:	00 6c       	ori	r16, 0xC0	; 192
    1120:	69 62       	ori	r22, 0x29	; 41
    1122:	31 66       	ori	r19, 0x61	; 97
    1124:	75 6e       	ori	r23, 0xE5	; 229
    1126:	63 73       	andi	r22, 0x33	; 51
    1128:	2e 53       	subi	r18, 0x3E	; 62
    112a:	00 01       	movw	r0, r0
    112c:	00 00       	nop
    112e:	00 00       	nop
    1130:	05 02       	muls	r16, r21
    1132:	ec 00       	.word	0x00ec	; ????
    1134:	00 00       	nop
    1136:	03 a2       	std	Z+35, r0	; 0x23
    1138:	13 01       	movw	r2, r6
    113a:	03 01       	movw	r0, r6
    113c:	09 02       	muls	r16, r25
    113e:	00 01       	movw	r0, r0
    1140:	03 01       	movw	r0, r6
    1142:	09 02       	muls	r16, r25
    1144:	00 01       	movw	r0, r0
    1146:	03 04       	cpc	r0, r3
    1148:	09 02       	muls	r16, r25
    114a:	00 01       	movw	r0, r0
    114c:	03 02       	muls	r16, r19
    114e:	09 02       	muls	r16, r25
    1150:	00 01       	movw	r0, r0
    1152:	03 06       	cpc	r0, r19
    1154:	09 02       	muls	r16, r25
    1156:	00 01       	movw	r0, r0
    1158:	03 01       	movw	r0, r6
    115a:	09 02       	muls	r16, r25
    115c:	00 01       	movw	r0, r0
    115e:	03 02       	muls	r16, r19
    1160:	09 04       	cpc	r0, r9
    1162:	00 01       	movw	r0, r0
    1164:	03 01       	movw	r0, r6
    1166:	09 02       	muls	r16, r25
    1168:	00 01       	movw	r0, r0
    116a:	03 05       	cpc	r16, r3
    116c:	09 02       	muls	r16, r25
    116e:	00 01       	movw	r0, r0
    1170:	09 02       	muls	r16, r25
    1172:	00 00       	nop
    1174:	01 01       	movw	r0, r2
    1176:	76 00       	.word	0x0076	; ????
    1178:	00 00       	nop
    117a:	02 00       	.word	0x0002	; ????
    117c:	41 00       	.word	0x0041	; ????
    117e:	00 00       	nop
    1180:	02 01       	movw	r0, r4
    1182:	fb 0e       	add	r15, r27
    1184:	0a 00       	.word	0x000a	; ????
    1186:	01 01       	movw	r0, r2
    1188:	01 01       	movw	r0, r2
    118a:	00 00       	nop
    118c:	00 01       	movw	r0, r0
    118e:	2e 2e       	mov	r2, r30
    1190:	2f 2e       	mov	r2, r31
    1192:	2e 2f       	mov	r18, r30
    1194:	2e 2e       	mov	r2, r30
    1196:	2f 2e       	mov	r2, r31
    1198:	2e 2f       	mov	r18, r30
    119a:	67 63       	ori	r22, 0x37	; 55
    119c:	63 2f       	mov	r22, r19
    119e:	6c 69       	ori	r22, 0x9C	; 156
    11a0:	62 67       	ori	r22, 0x72	; 114
    11a2:	63 63       	ori	r22, 0x33	; 51
    11a4:	2f 63       	ori	r18, 0x3F	; 63
    11a6:	6f 6e       	ori	r22, 0xEF	; 239
    11a8:	66 69       	ori	r22, 0x96	; 150
    11aa:	67 2f       	mov	r22, r23
    11ac:	61 76       	andi	r22, 0x61	; 97
    11ae:	72 00       	.word	0x0072	; ????
    11b0:	00 6c       	ori	r16, 0xC0	; 192
    11b2:	69 62       	ori	r22, 0x29	; 41
    11b4:	31 66       	ori	r19, 0x61	; 97
    11b6:	75 6e       	ori	r23, 0xE5	; 229
    11b8:	63 73       	andi	r22, 0x33	; 51
    11ba:	2e 53       	subi	r18, 0x3E	; 62
    11bc:	00 01       	movw	r0, r0
    11be:	00 00       	nop
    11c0:	00 00       	nop
    11c2:	05 02       	muls	r16, r21
    11c4:	2c 0d       	add	r18, r12
    11c6:	00 00       	nop
    11c8:	03 f8       	bld	r0, 3
    11ca:	11 01       	movw	r2, r2
    11cc:	03 01       	movw	r0, r6
    11ce:	09 02       	muls	r16, r25
    11d0:	00 01       	movw	r0, r0
    11d2:	03 1f       	adc	r16, r19
    11d4:	09 02       	muls	r16, r25
    11d6:	00 01       	movw	r0, r0
    11d8:	03 01       	movw	r0, r6
    11da:	09 02       	muls	r16, r25
    11dc:	00 01       	movw	r0, r0
    11de:	03 01       	movw	r0, r6
    11e0:	09 02       	muls	r16, r25
    11e2:	00 01       	movw	r0, r0
    11e4:	03 01       	movw	r0, r6
    11e6:	09 02       	muls	r16, r25
    11e8:	00 01       	movw	r0, r0
    11ea:	09 02       	muls	r16, r25
    11ec:	00 00       	nop
    11ee:	01 01       	movw	r0, r2

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	10 00       	.word	0x0010	; ????
   2:	00 00       	nop
   4:	ff ff       	.word	0xffff	; ????
   6:	ff ff       	.word	0xffff	; ????
   8:	01 00       	.word	0x0001	; ????
   a:	02 7f       	andi	r16, 0xF2	; 242
   c:	24 0c       	add	r2, r4
   e:	20 02       	muls	r18, r16
  10:	a4 01       	movw	r20, r8
  12:	00 00       	nop
  14:	0c 00       	.word	0x000c	; ????
  16:	00 00       	nop
  18:	00 00       	nop
  1a:	00 00       	nop
  1c:	0e 01       	movw	r0, r28
  1e:	00 00       	nop
  20:	3e 00       	.word	0x003e	; ????
  22:	00 00       	nop
  24:	0c 00       	.word	0x000c	; ????
  26:	00 00       	nop
  28:	00 00       	nop
  2a:	00 00       	nop
  2c:	4c 01       	movw	r8, r24
  2e:	00 00       	nop
  30:	9a 00       	.word	0x009a	; ????
  32:	00 00       	nop
  34:	40 00       	.word	0x0040	; ????
  36:	00 00       	nop
  38:	00 00       	nop
  3a:	00 00       	nop
  3c:	e6 01       	movw	r28, r12
  3e:	00 00       	nop
  40:	76 00       	.word	0x0076	; ????
  42:	00 00       	nop
  44:	41 0e       	add	r4, r17
  46:	03 8a       	std	Z+19, r0	; 0x13
  48:	02 41       	sbci	r16, 0x12	; 18
  4a:	0e 04       	cpc	r0, r14
  4c:	8b 03       	fmulsu	r16, r19
  4e:	41 0e       	add	r4, r17
  50:	05 8c       	ldd	r0, Z+29	; 0x1d
  52:	04 41       	sbci	r16, 0x14	; 20
  54:	0e 06       	cpc	r0, r30
  56:	8d 05       	cpc	r24, r13
  58:	41 0e       	add	r4, r17
  5a:	07 8e       	std	Z+31, r0	; 0x1f
  5c:	06 41       	sbci	r16, 0x16	; 22
  5e:	0e 08       	sbc	r0, r14
  60:	8f 07       	cpc	r24, r31
  62:	41 0e       	add	r4, r17
  64:	09 90       	ld	r0, Y+
  66:	08 41       	sbci	r16, 0x18	; 24
  68:	0e 0a       	sbc	r0, r30
  6a:	91 09       	sbc	r25, r1
  6c:	41 0e       	add	r4, r17
  6e:	0b 9c       	mul	r0, r11
  70:	0a 41       	sbci	r16, 0x1A	; 26
  72:	0e 0c       	add	r0, r14
  74:	9d 0b       	sbc	r25, r29
  76:	00 00       	nop
  78:	0c 00       	.word	0x000c	; ????
  7a:	00 00       	nop
  7c:	00 00       	nop
  7e:	00 00       	nop
  80:	5c 02       	muls	r21, r28
  82:	00 00       	nop
  84:	4a 00       	.word	0x004a	; ????
  86:	00 00       	nop
  88:	34 00       	.word	0x0034	; ????
  8a:	00 00       	nop
  8c:	00 00       	nop
  8e:	00 00       	nop
  90:	a6 02       	muls	r26, r22
  92:	00 00       	nop
  94:	74 00       	.word	0x0074	; ????
  96:	00 00       	nop
  98:	41 0e       	add	r4, r17
  9a:	03 88       	ldd	r0, Z+19	; 0x13
  9c:	02 41       	sbci	r16, 0x12	; 18
  9e:	0e 04       	cpc	r0, r14
  a0:	89 03       	fmulsu	r16, r17
  a2:	41 0e       	add	r4, r17
  a4:	05 8a       	std	Z+21, r0	; 0x15
  a6:	04 41       	sbci	r16, 0x14	; 20
  a8:	0e 06       	cpc	r0, r30
  aa:	8b 05       	cpc	r24, r11
  ac:	41 0e       	add	r4, r17
  ae:	07 8c       	ldd	r0, Z+31	; 0x1f
  b0:	06 41       	sbci	r16, 0x16	; 22
  b2:	0e 08       	sbc	r0, r14
  b4:	8d 07       	cpc	r24, r29
  b6:	41 0e       	add	r4, r17
  b8:	09 8e       	std	Y+25, r0	; 0x19
  ba:	08 41       	sbci	r16, 0x18	; 24
  bc:	0e 0a       	sbc	r0, r30
  be:	8f 09       	sbc	r24, r15
  c0:	34 00       	.word	0x0034	; ????
  c2:	00 00       	nop
  c4:	00 00       	nop
  c6:	00 00       	nop
  c8:	1a 03       	fmul	r17, r18
  ca:	00 00       	nop
  cc:	54 00       	.word	0x0054	; ????
  ce:	00 00       	nop
  d0:	41 0e       	add	r4, r17
  d2:	03 8c       	ldd	r0, Z+27	; 0x1b
  d4:	02 41       	sbci	r16, 0x12	; 18
  d6:	0e 04       	cpc	r0, r14
  d8:	8d 03       	fmulsu	r16, r21
  da:	41 0e       	add	r4, r17
  dc:	05 8e       	std	Z+29, r0	; 0x1d
  de:	04 41       	sbci	r16, 0x14	; 20
  e0:	0e 06       	cpc	r0, r30
  e2:	8f 05       	cpc	r24, r15
  e4:	41 0e       	add	r4, r17
  e6:	07 90       	elpm	r0, Z+
  e8:	06 41       	sbci	r16, 0x16	; 22
  ea:	0e 08       	sbc	r0, r14
  ec:	91 07       	cpc	r25, r17
  ee:	41 0e       	add	r4, r17
  f0:	09 9c       	mul	r0, r9
  f2:	08 41       	sbci	r16, 0x18	; 24
  f4:	0e 0a       	sbc	r0, r30
  f6:	9d 09       	sbc	r25, r13
  f8:	0c 00       	.word	0x000c	; ????
  fa:	00 00       	nop
  fc:	00 00       	nop
  fe:	00 00       	nop
 100:	6e 03       	fmul	r22, r22
 102:	00 00       	nop
 104:	14 00       	.word	0x0014	; ????
 106:	00 00       	nop
 108:	0c 00       	.word	0x000c	; ????
 10a:	00 00       	nop
 10c:	00 00       	nop
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 10e:	00 00       	nop
 110:	82 03       	fmuls	r16, r18
 112:	00 00       	nop
 114:	50 00       	.word	0x0050	; ????
 116:	00 00       	nop
	uint8_t port = digitalPinToPort(pin);
 118:	0c 00       	.word	0x000c	; ????
 11a:	00 00       	nop
 11c:	00 00       	nop
 11e:	00 00       	nop
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 120:	d2 03       	fmuls	r21, r18
 122:	00 00       	nop

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 124:	02 00       	.word	0x0002	; ????
 126:	00 00       	nop
 128:	0c 00       	.word	0x000c	; ????
 12a:	00 00       	nop
 12c:	00 00       	nop
 12e:	00 00       	nop
 130:	d4 03       	fmuls	r21, r20
 132:	00 00       	nop
	out = portOutputRegister(port);
 134:	06 00       	.word	0x0006	; ????
 136:	00 00       	nop
 138:	0c 00       	.word	0x000c	; ????
 13a:	00 00       	nop
 13c:	00 00       	nop
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 13e:	00 00       	nop
                cli();
 140:	da 03       	fmulsu	r21, r18
		*reg |= bit;
 142:	00 00       	nop
 144:	06 00       	.word	0x0006	; ????
 146:	00 00       	nop
		SREG = oldSREG;
 148:	0c 00       	.word	0x000c	; ????
 14a:	00 00       	nop
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 14c:	00 00       	nop
 14e:	00 00       	nop
 150:	e0 03       	fmuls	r22, r16
 152:	00 00       	nop
 154:	0e 00       	.word	0x000e	; ????
	uint8_t bit = digitalPinToBitMask(pin);
 156:	00 00       	nop
 158:	18 00       	.word	0x0018	; ????
 15a:	00 00       	nop
 15c:	00 00       	nop
	uint8_t port = digitalPinToPort(pin);
 15e:	00 00       	nop
 160:	ee 03       	fmulsu	r22, r22
 162:	00 00       	nop
 164:	16 00       	.word	0x0016	; ????
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 166:	00 00       	nop
 168:	41 0e       	add	r4, r17
 16a:	03 9c       	mul	r0, r3

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 16c:	02 41       	sbci	r16, 0x12	; 18
 16e:	0e 04       	cpc	r0, r14
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 170:	9d 03       	fmulsu	r17, r21
 172:	00 00       	nop
 174:	1c 00       	.word	0x001c	; ????
 176:	00 00       	nop
 178:	00 00       	nop
 17a:	00 00       	nop
 17c:	04 04       	cpc	r0, r4
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17e:	00 00       	nop
 180:	22 00       	.word	0x0022	; ????
 182:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 184:	41 0e       	add	r4, r17
 186:	03 9c       	mul	r0, r3
 188:	02 41       	sbci	r16, 0x12	; 18
 18a:	0e 04       	cpc	r0, r14
 18c:	9d 03       	fmulsu	r17, r21
 18e:	41 0e       	add	r4, r17
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 190:	05 42       	sbci	r16, 0x25	; 37
 192:	0d 1c       	adc	r0, r13
 194:	0c 00       	.word	0x000c	; ????
 196:	00 00       	nop
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 198:	00 00       	nop
 19a:	00 00       	nop
 19c:	26 04       	cpc	r2, r6
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 19e:	00 00       	nop
 1a0:	28 00       	.word	0x0028	; ????
 1a2:	00 00       	nop
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 1a4:	28 00       	.word	0x0028	; ????
 1a6:	00 00       	nop
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 1a8:	00 00       	nop
 1aa:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 1ac:	4e 04       	cpc	r4, r14
 1ae:	00 00       	nop
 1b0:	36 00       	.word	0x0036	; ????
 1b2:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 1b4:	41 0e       	add	r4, r17
 1b6:	03 8e       	std	Z+27, r0	; 0x1b
 1b8:	02 41       	sbci	r16, 0x12	; 18
 1ba:	0e 04       	cpc	r0, r14
 1bc:	8f 03       	fmulsu	r16, r23

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 1be:	41 0e       	add	r4, r17
 1c0:	05 91       	lpm	r16, Z+
 1c2:	04 41       	sbci	r16, 0x14	; 20
 1c4:	0e 06       	cpc	r0, r30
 1c6:	9c 05       	cpc	r25, r12
 1c8:	41 0e       	add	r4, r17
 1ca:	07 9d       	mul	r16, r7

	uint8_t oldSREG = SREG;
 1cc:	06 00       	.word	0x0006	; ????
	cli();
 1ce:	00 00       	nop

	if (val == LOW) {
 1d0:	20 00       	.word	0x0020	; ????
 1d2:	00 00       	nop
		*out &= ~bit;
 1d4:	00 00       	nop
 1d6:	00 00       	nop
 1d8:	84 04       	cpc	r8, r4
 1da:	00 00       	nop
	} else {
		*out |= bit;
 1dc:	5e 00       	.word	0x005e	; ????
 1de:	00 00       	nop
 1e0:	41 0e       	add	r4, r17
	}

	SREG = oldSREG;
 1e2:	03 90       	.word	0x9003	; ????
 1e4:	02 41       	sbci	r16, 0x12	; 18
   digitalWrite(_enable_pin, LOW);
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
 1e6:	0e 04       	cpc	r0, r14
 1e8:	91 03       	fmuls	r17, r17
 1ea:	41 0e       	add	r4, r17
 1ec:	05 9c       	mul	r0, r5
 1ee:	04 41       	sbci	r16, 0x14	; 20
 1f0:	0e 06       	cpc	r0, r30
 1f2:	9d 05       	cpc	r25, r13
 1f4:	0c 00       	.word	0x000c	; ????
 1f6:	00 00       	nop
 1f8:	00 00       	nop
 1fa:	00 00       	nop
 1fc:	e2 04       	cpc	r14, r2
 1fe:	00 00       	nop
 200:	16 00       	.word	0x0016	; ????
 202:	00 00       	nop
 204:	0c 00       	.word	0x000c	; ????
 206:	00 00       	nop
 208:	00 00       	nop
 20a:	00 00       	nop
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 20c:	f8 04       	cpc	r15, r8
 20e:	00 00       	nop

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
 210:	10 00       	.word	0x0010	; ????
 212:	00 00       	nop
 214:	1c 00       	.word	0x001c	; ????
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 216:	00 00       	nop
 218:	00 00       	nop
 21a:	00 00       	nop
 21c:	08 05       	cpc	r16, r8
 21e:	00 00       	nop
 220:	84 00       	.word	0x0084	; ????
 222:	00 00       	nop
 224:	41 0e       	add	r4, r17
 226:	03 9c       	mul	r0, r3
 228:	02 41       	sbci	r16, 0x12	; 18
 22a:	0e 04       	cpc	r0, r14
 22c:	9d 03       	fmulsu	r17, r21
 22e:	42 0d       	add	r20, r2
 230:	1c 41       	sbci	r17, 0x1C	; 28
 232:	0e 0c       	add	r0, r14
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
 234:	20 00       	.word	0x0020	; ????
 236:	00 00       	nop
 238:	00 00       	nop
 23a:	00 00       	nop
 23c:	8c 05       	cpc	r24, r12
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 23e:	00 00       	nop
 240:	20 01       	movw	r4, r0
 242:	00 00       	nop
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
 244:	41 0e       	add	r4, r17
 246:	03 90       	.word	0x9003	; ????
 248:	02 41       	sbci	r16, 0x12	; 18
 24a:	0e 04       	cpc	r0, r14
 24c:	91 03       	fmuls	r17, r17
 24e:	41 0e       	add	r4, r17
 250:	05 9c       	mul	r0, r5
 252:	04 41       	sbci	r16, 0x14	; 20
 254:	0e 06       	cpc	r0, r30
 256:	9d 05       	cpc	r25, r13
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 258:	0c 00       	.word	0x000c	; ????
 25a:	00 00       	nop
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
 25c:	00 00       	nop
	
	cli();
 25e:	00 00       	nop
	m = timer0_overflow_count;
 260:	ac 06       	cpc	r10, r28
 262:	00 00       	nop
 264:	02 00       	.word	0x0002	; ????
 266:	00 00       	nop
 268:	0c 00       	.word	0x000c	; ????
 26a:	00 00       	nop
 26c:	00 00       	nop
 26e:	00 00       	nop
#if defined(TCNT0)
	t = TCNT0;
 270:	ae 06       	cpc	r10, r30
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
 272:	00 00       	nop
 274:	02 00       	.word	0x0002	; ????
 276:	00 00       	nop
 278:	0c 00       	.word	0x000c	; ????
		m++;
 27a:	00 00       	nop
 27c:	00 00       	nop
 27e:	00 00       	nop
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
 280:	b0 06       	cpc	r11, r16
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
 282:	00 00       	nop
 284:	02 00       	.word	0x0002	; ????
 286:	00 00       	nop
 288:	0c 00       	.word	0x000c	; ????
 28a:	00 00       	nop
 28c:	00 00       	nop
 28e:	00 00       	nop
 290:	b2 06       	cpc	r11, r18
 292:	00 00       	nop
 294:	06 00       	.word	0x0006	; ????
 296:	00 00       	nop
 298:	0c 00       	.word	0x000c	; ????
 29a:	00 00       	nop
 29c:	00 00       	nop
 29e:	00 00       	nop
 2a0:	b8 06       	cpc	r11, r24
 2a2:	00 00       	nop
}
 2a4:	24 00       	.word	0x0024	; ????

void delay(unsigned long ms)
{
 2a6:	00 00       	nop
 2a8:	3c 00       	.word	0x003c	; ????
 2aa:	00 00       	nop
 2ac:	00 00       	nop
 2ae:	00 00       	nop
 2b0:	dc 06       	cpc	r13, r28
 2b2:	00 00       	nop
 2b4:	82 00       	.word	0x0082	; ????
 2b6:	00 00       	nop
 2b8:	41 0e       	add	r4, r17
	uint32_t start = micros();
 2ba:	03 88       	ldd	r0, Z+19	; 0x13
 2bc:	02 41       	sbci	r16, 0x12	; 18
 2be:	0e 04       	cpc	r0, r14
 2c0:	89 03       	fmulsu	r16, r17

	while (ms > 0) {
 2c2:	41 0e       	add	r4, r17
 2c4:	05 8a       	std	Z+21, r0	; 0x15
 2c6:	04 41       	sbci	r16, 0x14	; 20
 2c8:	0e 06       	cpc	r0, r30
 2ca:	8b 05       	cpc	r24, r11
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2cc:	41 0e       	add	r4, r17
 2ce:	07 90       	elpm	r0, Z+
 2d0:	06 41       	sbci	r16, 0x16	; 22
 2d2:	0e 08       	sbc	r0, r14
 2d4:	91 07       	cpc	r25, r17
 2d6:	41 0e       	add	r4, r17
 2d8:	09 9c       	mul	r0, r9
 2da:	08 41       	sbci	r16, 0x18	; 24
 2dc:	0e 0a       	sbc	r0, r30
 2de:	9d 09       	sbc	r25, r13
 2e0:	42 0d       	add	r20, r2
 2e2:	1c 41       	sbci	r17, 0x1C	; 28
 2e4:	0e 2b       	or	r16, r30
			ms--;
 2e6:	00 00       	nop
 2e8:	0c 00       	.word	0x000c	; ????
 2ea:	00 00       	nop
 2ec:	00 00       	nop
 2ee:	00 00       	nop
			start += 1000;
 2f0:	5e 07       	cpc	r21, r30
 2f2:	00 00       	nop
 2f4:	04 00       	.word	0x0004	; ????
 2f6:	00 00       	nop
 2f8:	20 00       	.word	0x0020	; ????
 2fa:	00 00       	nop
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2fc:	00 00       	nop
 2fe:	00 00       	nop
 300:	4a 0a       	sbc	r4, r26
 302:	00 00       	nop
 304:	0e 01       	movw	r0, r28
 306:	00 00       	nop
			ms--;
			start += 1000;
		}
	}
}
 308:	41 0e       	add	r4, r17
 30a:	03 90       	.word	0x9003	; ????
 30c:	02 41       	sbci	r16, 0x12	; 18
 30e:	0e 04       	cpc	r0, r14
 310:	91 03       	fmuls	r17, r17
 312:	41 0e       	add	r4, r17
 314:	05 9c       	mul	r0, r5
 316:	04 41       	sbci	r16, 0x14	; 20
 318:	0e 06       	cpc	r0, r30

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 31a:	9d 05       	cpc	r25, r13
 31c:	34 00       	.word	0x0034	; ????
 31e:	00 00       	nop
 320:	00 00       	nop
 322:	00 00       	nop
 324:	62 07       	cpc	r22, r18
 326:	00 00       	nop
 328:	94 00       	.word	0x0094	; ????
 32a:	00 00       	nop
 32c:	41 0e       	add	r4, r17
 32e:	03 81       	ldd	r16, Z+3	; 0x03
  size_t n = 0;
 330:	02 41       	sbci	r16, 0x12	; 18
 332:	0e 04       	cpc	r0, r14
  while (size--) {
 334:	80 03       	fmuls	r16, r16
 336:	44 0e       	add	r4, r20
 338:	05 92       	las	Z, r0
    if (write(*buffer++)) n++;
 33a:	04 41       	sbci	r16, 0x14	; 20
 33c:	0e 06       	cpc	r0, r30
 33e:	93 05       	cpc	r25, r3
 340:	41 0e       	add	r4, r17
 342:	07 98       	cbi	0x00, 7	; 0
 344:	06 41       	sbci	r16, 0x16	; 22
 346:	0e 08       	sbc	r0, r14
 348:	99 07       	cpc	r25, r25
 34a:	41 0e       	add	r4, r17
 34c:	09 9a       	sbi	0x01, 1	; 1
 34e:	08 41       	sbci	r16, 0x18	; 24
 350:	0e 0a       	sbc	r0, r30
 352:	9b 09       	sbc	r25, r11
 354:	0c 00       	.word	0x000c	; ????
 356:	00 00       	nop
 358:	00 00       	nop
    else break;
  }
  return n;
}
 35a:	00 00       	nop
 35c:	58 0b       	sbc	r21, r24
 35e:	00 00       	nop
 360:	90 01       	movw	r18, r0
 362:	00 00       	nop
 364:	54 00       	.word	0x0054	; ????
 366:	00 00       	nop
 368:	00 00       	nop
 36a:	00 00       	nop
 36c:	f6 07       	cpc	r31, r22
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 36e:	00 00       	nop
 370:	54 02       	muls	r21, r20
 372:	00 00       	nop

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
 374:	41 0e       	add	r4, r17
 376:	03 81       	ldd	r16, Z+3	; 0x03
 378:	02 41       	sbci	r16, 0x12	; 18
 37a:	0e 04       	cpc	r0, r14
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
 37c:	80 03       	fmuls	r16, r16
 37e:	44 0e       	add	r4, r20
 380:	05 92       	las	Z, r0
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
 382:	04 41       	sbci	r16, 0x14	; 20
 384:	0e 06       	cpc	r0, r30
 386:	93 05       	cpc	r25, r3
 388:	41 0e       	add	r4, r17
 38a:	07 94       	ror	r0
 38c:	06 41       	sbci	r16, 0x16	; 22
 38e:	0e 08       	sbc	r0, r14
 390:	95 07       	cpc	r25, r21
 392:	41 0e       	add	r4, r17
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
 394:	09 96       	adiw	r24, 0x09	; 9
 396:	08 41       	sbci	r16, 0x18	; 24
 398:	0e 0a       	sbc	r0, r30
 39a:	97 09       	sbc	r25, r7
 39c:	41 0e       	add	r4, r17
 39e:	0b 98       	cbi	0x01, 3	; 1
 3a0:	0a 41       	sbci	r16, 0x1A	; 26
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
 3a2:	0e 0c       	add	r0, r14
 3a4:	99 0b       	sbc	r25, r25
    twi_txBuffer[twi_txBufferLength+i] = data[i];
 3a6:	41 0e       	add	r4, r17
 3a8:	0d 9a       	sbi	0x01, 5	; 1
 3aa:	0c 41       	sbci	r16, 0x1C	; 28
 3ac:	0e 0e       	add	r0, r30
 3ae:	9b 0d       	add	r25, r11
 3b0:	41 0e       	add	r4, r17
 3b2:	0f 9e       	mul	r0, r31
 3b4:	0e 41       	sbci	r16, 0x1E	; 30
 3b6:	0e 10       	cpse	r0, r14
 3b8:	9f 0f       	add	r25, r31
	...

Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	61 76       	andi	r22, 0x61	; 97
   2:	72 2d       	mov	r23, r2
   4:	6c 69       	ori	r22, 0x9C	; 156
   6:	62 63       	ori	r22, 0x32	; 50
   8:	20 32       	cpi	r18, 0x20	; 32
   a:	2e 30       	cpi	r18, 0x0E	; 14
   c:	2e 30       	cpi	r18, 0x0E	; 14
   e:	00 75       	andi	r16, 0x50	; 80
  10:	69 6e       	ori	r22, 0xE9	; 233
  12:	74 38       	cpi	r23, 0x84	; 132
  14:	5f 74       	andi	r21, 0x4F	; 79
  16:	00 75       	andi	r16, 0x50	; 80
  18:	69 6e       	ori	r22, 0xE9	; 233
  1a:	74 31       	cpi	r23, 0x14	; 20
  1c:	36 5f       	subi	r19, 0xF6	; 246
  1e:	74 00       	.word	0x0074	; ????
  20:	5f 5f       	subi	r21, 0xFF	; 255
  22:	65 65       	ori	r22, 0x55	; 85
  24:	70 72       	andi	r23, 0x20	; 32
  26:	6f 6d       	ori	r22, 0xDF	; 223
  28:	00 55       	subi	r16, 0x50	; 80
  2a:	44 52       	subi	r20, 0x24	; 36
  2c:	30 00       	.word	0x0030	; ????
  2e:	55 43       	sbci	r21, 0x35	; 53
  30:	53 52       	subi	r21, 0x23	; 35
  32:	30 41       	sbci	r19, 0x10	; 16
  34:	00 55       	subi	r16, 0x50	; 80
  36:	43 53       	subi	r20, 0x33	; 51
  38:	52 30       	cpi	r21, 0x02	; 2
  3a:	42 00       	.word	0x0042	; ????
  3c:	55 43       	sbci	r21, 0x35	; 53
  3e:	53 52       	subi	r21, 0x23	; 35
  40:	30 43       	sbci	r19, 0x30	; 48
  42:	00 55       	subi	r16, 0x50	; 80
  44:	42 52       	subi	r20, 0x22	; 34
  46:	52 30       	cpi	r21, 0x02	; 2
  48:	00 54       	subi	r16, 0x40	; 64
  4a:	57 41       	sbci	r21, 0x17	; 23
  4c:	4d 52       	subi	r20, 0x2D	; 45
  4e:	00 54       	subi	r16, 0x40	; 64
  50:	57 42       	sbci	r21, 0x27	; 39
  52:	52 00       	.word	0x0052	; ????
  54:	54 57       	subi	r21, 0x74	; 116
  56:	43 52       	subi	r20, 0x23	; 35
  58:	00 54       	subi	r16, 0x40	; 64
  5a:	57 53       	subi	r21, 0x37	; 55
  5c:	52 00       	.word	0x0052	; ????
  5e:	54 57       	subi	r21, 0x74	; 116
  60:	44 52       	subi	r20, 0x24	; 36
  62:	00 54       	subi	r16, 0x40	; 64
  64:	57 41       	sbci	r21, 0x17	; 23
  66:	52 00       	.word	0x0052	; ????
  68:	54 49       	sbci	r21, 0x94	; 148
  6a:	4d 53       	subi	r20, 0x3D	; 61
  6c:	4b 31       	cpi	r20, 0x1B	; 27
  6e:	00 54       	subi	r16, 0x40	; 64
  70:	49 46       	sbci	r20, 0x69	; 105
  72:	52 31       	cpi	r21, 0x12	; 18
  74:	00 54       	subi	r16, 0x40	; 64
  76:	43 43       	sbci	r20, 0x33	; 51
  78:	52 31       	cpi	r21, 0x12	; 18
  7a:	41 00       	.word	0x0041	; ????
  7c:	54 43       	sbci	r21, 0x34	; 52
  7e:	43 52       	subi	r20, 0x23	; 35
  80:	31 42       	sbci	r19, 0x21	; 33
  82:	00 54       	subi	r16, 0x40	; 64
  84:	43 43       	sbci	r20, 0x33	; 51
  86:	52 31       	cpi	r21, 0x12	; 18
  88:	43 00       	.word	0x0043	; ????
  8a:	54 43       	sbci	r21, 0x34	; 52
  8c:	4e 54       	subi	r20, 0x4E	; 78
  8e:	31 00       	.word	0x0031	; ????
  90:	4f 43       	sbci	r20, 0x3F	; 63
  92:	52 31       	cpi	r21, 0x12	; 18
  94:	41 00       	.word	0x0041	; ????
  96:	4f 43       	sbci	r20, 0x3F	; 63
  98:	52 31       	cpi	r21, 0x12	; 18
  9a:	42 00       	.word	0x0042	; ????
  9c:	49 43       	sbci	r20, 0x39	; 57
  9e:	52 31       	cpi	r21, 0x12	; 18
  a0:	00 47       	sbci	r16, 0x70	; 112
  a2:	54 43       	sbci	r21, 0x34	; 52
  a4:	43 52       	subi	r20, 0x23	; 35
  a6:	00 54       	subi	r16, 0x40	; 64
  a8:	49 4d       	sbci	r20, 0xD9	; 217
  aa:	53 4b       	sbci	r21, 0xB3	; 179
  ac:	32 00       	.word	0x0032	; ????
  ae:	54 49       	sbci	r21, 0x94	; 148
  b0:	46 52       	subi	r20, 0x26	; 38
  b2:	32 00       	.word	0x0032	; ????
  b4:	54 43       	sbci	r21, 0x34	; 52
  b6:	43 52       	subi	r20, 0x23	; 35
  b8:	32 41       	sbci	r19, 0x12	; 18
  ba:	00 54       	subi	r16, 0x40	; 64
  bc:	43 43       	sbci	r20, 0x33	; 51
  be:	52 32       	cpi	r21, 0x22	; 34
  c0:	42 00       	.word	0x0042	; ????
  c2:	54 43       	sbci	r21, 0x34	; 52
  c4:	4e 54       	subi	r20, 0x4E	; 78
  c6:	32 00       	.word	0x0032	; ????
  c8:	4f 43       	sbci	r20, 0x3F	; 63
  ca:	52 32       	cpi	r21, 0x22	; 34
  cc:	42 00       	.word	0x0042	; ????
  ce:	4f 43       	sbci	r20, 0x3F	; 63
  d0:	52 32       	cpi	r21, 0x22	; 34
  d2:	41 00       	.word	0x0041	; ????
  d4:	41 53       	subi	r20, 0x31	; 49
  d6:	53 52       	subi	r21, 0x23	; 35
  d8:	00 47       	sbci	r16, 0x70	; 112
  da:	54 43       	sbci	r21, 0x34	; 52
  dc:	43 52       	subi	r20, 0x23	; 35
  de:	00 41       	sbci	r16, 0x10	; 16
  e0:	44 4d       	sbci	r20, 0xD4	; 212
  e2:	55 58       	subi	r21, 0x85	; 133
  e4:	00 41       	sbci	r16, 0x10	; 16
  e6:	44 43       	sbci	r20, 0x34	; 52
  e8:	00 41       	sbci	r16, 0x10	; 16
  ea:	44 43       	sbci	r20, 0x34	; 52
  ec:	53 52       	subi	r21, 0x23	; 35
  ee:	41 00       	.word	0x0041	; ????
  f0:	41 44       	sbci	r20, 0x41	; 65
  f2:	43 53       	subi	r20, 0x33	; 51
  f4:	52 42       	sbci	r21, 0x22	; 34
  f6:	00 44       	sbci	r16, 0x40	; 64
  f8:	49 44       	sbci	r20, 0x49	; 73
  fa:	52 30       	cpi	r21, 0x02	; 2
  fc:	00 41       	sbci	r16, 0x10	; 16
  fe:	43 53       	subi	r20, 0x33	; 51
 100:	52 00       	.word	0x0052	; ????
 102:	44 49       	sbci	r20, 0x94	; 148
 104:	44 52       	subi	r20, 0x24	; 36
 106:	31 00       	.word	0x0031	; ????
 108:	50 4f       	sbci	r21, 0xF0	; 240
 10a:	52 54       	subi	r21, 0x42	; 66
 10c:	42 00       	.word	0x0042	; ????
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 10e:	44 44       	sbci	r20, 0x44	; 68
 110:	52 42       	sbci	r21, 0x22	; 34
 112:	00 50       	subi	r16, 0x00	; 0
 114:	49 4e       	sbci	r20, 0xE9	; 233
 116:	42 00       	.word	0x0042	; ????
	uint8_t port = digitalPinToPort(pin);
 118:	50 4f       	sbci	r21, 0xF0	; 240
 11a:	52 54       	subi	r21, 0x42	; 66
 11c:	43 00       	.word	0x0043	; ????
 11e:	44 44       	sbci	r20, 0x44	; 68
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 120:	52 43       	sbci	r21, 0x32	; 50
 122:	00 50       	subi	r16, 0x00	; 0

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 124:	49 4e       	sbci	r20, 0xE9	; 233
 126:	43 00       	.word	0x0043	; ????
 128:	50 4f       	sbci	r21, 0xF0	; 240
 12a:	52 54       	subi	r21, 0x42	; 66
 12c:	44 00       	.word	0x0044	; ????
 12e:	44 44       	sbci	r20, 0x44	; 68
 130:	52 44       	sbci	r21, 0x42	; 66
 132:	00 50       	subi	r16, 0x00	; 0
	out = portOutputRegister(port);
 134:	49 4e       	sbci	r20, 0xE9	; 233
 136:	44 00       	.word	0x0044	; ????
 138:	4f 43       	sbci	r20, 0x3F	; 63
 13a:	52 30       	cpi	r21, 0x02	; 2
 13c:	42 00       	.word	0x0042	; ????
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 13e:	4f 43       	sbci	r20, 0x3F	; 63
                cli();
 140:	52 30       	cpi	r21, 0x02	; 2
		*reg |= bit;
 142:	41 00       	.word	0x0041	; ????
 144:	54 43       	sbci	r21, 0x34	; 52
 146:	4e 54       	subi	r20, 0x4E	; 78
		SREG = oldSREG;
 148:	30 00       	.word	0x0030	; ????
 14a:	54 43       	sbci	r21, 0x34	; 52
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 14c:	43 52       	subi	r20, 0x23	; 35
 14e:	30 42       	sbci	r19, 0x20	; 32
 150:	00 54       	subi	r16, 0x40	; 64
 152:	43 43       	sbci	r20, 0x33	; 51
 154:	52 30       	cpi	r21, 0x02	; 2
	uint8_t bit = digitalPinToBitMask(pin);
 156:	41 00       	.word	0x0041	; ????
 158:	54 49       	sbci	r21, 0x94	; 148
 15a:	4d 53       	subi	r20, 0x3D	; 61
 15c:	4b 30       	cpi	r20, 0x0B	; 11
	uint8_t port = digitalPinToPort(pin);
 15e:	00 54       	subi	r16, 0x40	; 64
 160:	49 46       	sbci	r20, 0x69	; 105
 162:	52 30       	cpi	r21, 0x02	; 2
 164:	00 47       	sbci	r16, 0x70	; 112
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 166:	54 43       	sbci	r21, 0x34	; 52
 168:	43 52       	subi	r20, 0x23	; 35
 16a:	00 45       	sbci	r16, 0x50	; 80

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 16c:	49 43       	sbci	r20, 0x39	; 57
 16e:	52 41       	sbci	r21, 0x12	; 18
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 170:	00 45       	sbci	r16, 0x50	; 80
 172:	49 4d       	sbci	r20, 0xD9	; 217
 174:	53 4b       	sbci	r21, 0xB3	; 179
 176:	00 45       	sbci	r16, 0x50	; 80
 178:	49 46       	sbci	r20, 0x69	; 105
 17a:	52 00       	.word	0x0052	; ????
 17c:	50 43       	sbci	r21, 0x30	; 48
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 17e:	49 43       	sbci	r20, 0x39	; 57
 180:	52 00       	.word	0x0052	; ????
 182:	50 43       	sbci	r21, 0x30	; 48
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 184:	4d 53       	subi	r20, 0x3D	; 61
 186:	4b 32       	cpi	r20, 0x2B	; 43
 188:	00 50       	subi	r16, 0x00	; 0
 18a:	43 4d       	sbci	r20, 0xD3	; 211
 18c:	53 4b       	sbci	r21, 0xB3	; 179
 18e:	31 00       	.word	0x0031	; ????
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 190:	50 43       	sbci	r21, 0x30	; 48
 192:	4d 53       	subi	r20, 0x3D	; 61
 194:	4b 30       	cpi	r20, 0x0B	; 11
 196:	00 50       	subi	r16, 0x00	; 0
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 198:	43 49       	sbci	r20, 0x93	; 147
 19a:	46 52       	subi	r20, 0x26	; 38
 19c:	00 53       	subi	r16, 0x30	; 48
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 19e:	50 44       	sbci	r21, 0x40	; 64
 1a0:	52 00       	.word	0x0052	; ????
 1a2:	53 50       	subi	r21, 0x03	; 3
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 1a4:	53 52       	subi	r21, 0x23	; 35
 1a6:	00 53       	subi	r16, 0x30	; 48
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 1a8:	50 43       	sbci	r21, 0x30	; 48
 1aa:	52 00       	.word	0x0052	; ????
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 1ac:	57 44       	sbci	r21, 0x47	; 71
 1ae:	54 43       	sbci	r21, 0x34	; 52
 1b0:	53 52       	subi	r21, 0x23	; 35
 1b2:	00 50       	subi	r16, 0x00	; 0
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 1b4:	52 52       	subi	r21, 0x22	; 34
 1b6:	00 4f       	sbci	r16, 0xF0	; 240
 1b8:	53 43       	sbci	r21, 0x33	; 51
 1ba:	43 41       	sbci	r20, 0x13	; 19
 1bc:	4c 00       	.word	0x004c	; ????

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 1be:	43 4c       	sbci	r20, 0xC3	; 195
 1c0:	4b 50       	subi	r20, 0x0B	; 11
 1c2:	52 00       	.word	0x0052	; ????
 1c4:	53 52       	subi	r21, 0x23	; 35
 1c6:	45 47       	sbci	r20, 0x75	; 117
 1c8:	00 53       	subi	r16, 0x30	; 48
 1ca:	50 00       	.word	0x0050	; ????

	uint8_t oldSREG = SREG;
 1cc:	53 50       	subi	r21, 0x03	; 3
	cli();
 1ce:	4d 43       	sbci	r20, 0x3D	; 61

	if (val == LOW) {
 1d0:	53 52       	subi	r21, 0x23	; 35
 1d2:	00 4d       	sbci	r16, 0xD0	; 208
		*out &= ~bit;
 1d4:	43 55       	subi	r20, 0x53	; 83
 1d6:	43 52       	subi	r20, 0x23	; 35
 1d8:	00 4d       	sbci	r16, 0xD0	; 208
 1da:	43 55       	subi	r20, 0x53	; 83
	} else {
		*out |= bit;
 1dc:	53 52       	subi	r21, 0x23	; 35
 1de:	00 53       	subi	r16, 0x30	; 48
 1e0:	4d 43       	sbci	r20, 0x3D	; 61
	}

	SREG = oldSREG;
 1e2:	52 00       	.word	0x0052	; ????
 1e4:	47 50       	subi	r20, 0x07	; 7
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
 1e6:	49 4f       	sbci	r20, 0xF9	; 249
 1e8:	52 32       	cpi	r21, 0x22	; 34
 1ea:	00 47       	sbci	r16, 0x70	; 112
 1ec:	50 49       	sbci	r21, 0x90	; 144
 1ee:	4f 52       	subi	r20, 0x2F	; 47
 1f0:	31 00       	.word	0x0031	; ????
 1f2:	47 50       	subi	r20, 0x07	; 7
 1f4:	49 4f       	sbci	r20, 0xF9	; 249
 1f6:	52 30       	cpi	r21, 0x02	; 2
 1f8:	00 45       	sbci	r16, 0x50	; 80
 1fa:	45 41       	sbci	r20, 0x15	; 21
 1fc:	52 00       	.word	0x0052	; ????
 1fe:	45 45       	sbci	r20, 0x55	; 85
 200:	44 52       	subi	r20, 0x24	; 36
 202:	00 45       	sbci	r16, 0x50	; 80
 204:	45 43       	sbci	r20, 0x35	; 53
 206:	52 00       	.word	0x0052	; ????
 208:	6e 75       	andi	r22, 0x5E	; 94
 20a:	6d 42       	sbci	r22, 0x2D	; 45
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 20c:	69 74       	andi	r22, 0x49	; 73
 20e:	73 00       	.word	0x0073	; ????

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
 210:	74 77       	andi	r23, 0x74	; 116
 212:	69 5f       	subi	r22, 0xF9	; 249
 214:	73 74       	andi	r23, 0x43	; 67
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
 216:	61 74       	andi	r22, 0x41	; 65
 218:	65 00       	.word	0x0065	; ????
 21a:	5f 64       	ori	r21, 0x4F	; 79
 21c:	69 73       	andi	r22, 0x39	; 57
 21e:	70 6c       	ori	r23, 0xC0	; 192
 220:	61 79       	andi	r22, 0x91	; 145
 222:	6d 6f       	ori	r22, 0xFD	; 253
 224:	64 65       	ori	r22, 0x54	; 84
 226:	00 77       	andi	r16, 0x70	; 112
 228:	72 69       	ori	r23, 0x92	; 146
 22a:	74 65       	ori	r23, 0x54	; 84
 22c:	00 65       	ori	r16, 0x50	; 80
 22e:	6e 61       	ori	r22, 0x1E	; 30
 230:	62 6c       	ori	r22, 0xC2	; 194
 232:	65 00       	.word	0x0065	; ????
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
 234:	66 6c       	ori	r22, 0xC6	; 198
 236:	75 73       	andi	r23, 0x35	; 53
 238:	68 00       	.word	0x0068	; ????
 23a:	73 65       	ori	r23, 0x53	; 83
 23c:	6e 64       	ori	r22, 0x4E	; 78
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 23e:	00 74       	andi	r16, 0x40	; 64
 240:	69 6d       	ori	r22, 0xD9	; 217
 242:	65 72       	andi	r22, 0x25	; 37
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
 244:	30 5f       	subi	r19, 0xF0	; 240
 246:	66 72       	andi	r22, 0x26	; 38
 248:	61 63       	ori	r22, 0x31	; 49
 24a:	74 00       	.word	0x0074	; ????
 24c:	77 72       	andi	r23, 0x27	; 39
 24e:	69 74       	andi	r22, 0x49	; 73
 250:	65 5f       	subi	r22, 0xF5	; 245
 252:	65 72       	andi	r22, 0x25	; 37
 254:	72 6f       	ori	r23, 0xF2	; 242
 256:	72 00       	.word	0x0072	; ????
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
 258:	64 69       	ori	r22, 0x94	; 148
 25a:	67 69       	ori	r22, 0x97	; 151
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
 25c:	74 61       	ori	r23, 0x14	; 20
	
	cli();
 25e:	6c 5f       	subi	r22, 0xFC	; 252
	m = timer0_overflow_count;
 260:	70 69       	ori	r23, 0x90	; 144
 262:	6e 5f       	subi	r22, 0xFE	; 254
 264:	74 6f       	ori	r23, 0xF4	; 244
 266:	5f 62       	ori	r21, 0x2F	; 47
 268:	69 74       	andi	r22, 0x49	; 73
 26a:	5f 6d       	ori	r21, 0xDF	; 223
 26c:	61 73       	andi	r22, 0x31	; 49
 26e:	6b 5f       	subi	r22, 0xFB	; 251
#if defined(TCNT0)
	t = TCNT0;
 270:	50 47       	sbci	r21, 0x70	; 112
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
 272:	4d 00       	.word	0x004d	; ????
 274:	74 77       	andi	r23, 0x74	; 116
 276:	69 5f       	subi	r22, 0xF9	; 249
 278:	6d 61       	ori	r22, 0x1D	; 29
		m++;
 27a:	73 74       	andi	r23, 0x43	; 67
 27c:	65 72       	andi	r22, 0x25	; 37
 27e:	42 75       	andi	r20, 0x52	; 82
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
 280:	66 66       	ori	r22, 0x66	; 102
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
 282:	65 72       	andi	r22, 0x25	; 37
 284:	4c 65       	ori	r20, 0x5C	; 92
 286:	6e 67       	ori	r22, 0x7E	; 126
 288:	74 68       	ori	r23, 0x84	; 132
 28a:	00 5f       	subi	r16, 0xF0	; 240
 28c:	64 61       	ori	r22, 0x14	; 20
 28e:	74 61       	ori	r23, 0x14	; 20
 290:	5f 70       	andi	r21, 0x0F	; 15
 292:	69 6e       	ori	r22, 0xE9	; 233
 294:	73 00       	.word	0x0073	; ????
 296:	73 69       	ori	r23, 0x93	; 147
 298:	7a 65       	ori	r23, 0x5A	; 90
 29a:	5f 74       	andi	r21, 0x4F	; 79
 29c:	00 73       	andi	r16, 0x30	; 48
 29e:	69 7a       	andi	r22, 0xA9	; 169
 2a0:	65 74       	andi	r22, 0x45	; 69
 2a2:	79 70       	andi	r23, 0x09	; 9
}
 2a4:	65 00       	.word	0x0065	; ????

void delay(unsigned long ms)
{
 2a6:	50 4f       	sbci	r21, 0xF0	; 240
 2a8:	53 49       	sbci	r21, 0x93	; 147
 2aa:	54 49       	sbci	r21, 0x94	; 148
 2ac:	56 45       	sbci	r21, 0x56	; 86
 2ae:	00 5f       	subi	r16, 0xF0	; 240
 2b0:	5f 65       	ori	r21, 0x5F	; 95
 2b2:	6d 70       	andi	r22, 0x0D	; 13
 2b4:	74 79       	andi	r23, 0x94	; 148
 2b6:	00 62       	ori	r16, 0x20	; 32
 2b8:	65 67       	ori	r22, 0x75	; 117
	uint32_t start = micros();
 2ba:	69 6e       	ori	r22, 0xE9	; 233
 2bc:	00 69       	ori	r16, 0x90	; 144
 2be:	6e 69       	ori	r22, 0x9E	; 158
 2c0:	74 56       	subi	r23, 0x64	; 100

	while (ms > 0) {
 2c2:	61 72       	andi	r22, 0x21	; 33
 2c4:	69 61       	ori	r22, 0x19	; 25
 2c6:	6e 74       	andi	r22, 0x4E	; 78
 2c8:	00 74       	andi	r16, 0x40	; 64
 2ca:	77 69       	ori	r23, 0x97	; 151
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2cc:	5f 73       	andi	r21, 0x3F	; 63
 2ce:	65 6e       	ori	r22, 0xE5	; 229
 2d0:	64 53       	subi	r22, 0x34	; 52
 2d2:	74 6f       	ori	r23, 0xF4	; 244
 2d4:	70 00       	.word	0x0070	; ????
 2d6:	6d 61       	ori	r22, 0x1D	; 29
 2d8:	69 6e       	ori	r22, 0xE9	; 233
 2da:	00 64       	ori	r16, 0x40	; 64
 2dc:	61 74       	andi	r22, 0x41	; 65
 2de:	61 00       	.word	0x0061	; ????
 2e0:	64 65       	ori	r22, 0x54	; 84
 2e2:	6c 61       	ori	r22, 0x1C	; 28
 2e4:	79 00       	.word	0x0079	; ????
			ms--;
 2e6:	76 61       	ori	r23, 0x16	; 22
 2e8:	6c 75       	andi	r22, 0x5C	; 92
 2ea:	65 00       	.word	0x0065	; ????
 2ec:	5f 64       	ori	r21, 0x4F	; 79
 2ee:	69 73       	andi	r22, 0x39	; 57
			start += 1000;
 2f0:	70 6c       	ori	r23, 0xC0	; 192
 2f2:	61 79       	andi	r22, 0x91	; 145
 2f4:	66 75       	andi	r22, 0x56	; 86
 2f6:	6e 63       	ori	r22, 0x3E	; 62
 2f8:	74 69       	ori	r23, 0x94	; 148
 2fa:	6f 6e       	ori	r22, 0xEF	; 239
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2fc:	00 65       	ori	r16, 0x50	; 80
 2fe:	6e 64       	ori	r22, 0x4E	; 78
 300:	54 69       	ori	r21, 0x94	; 148
 302:	6d 65       	ori	r22, 0x5D	; 93
 304:	5f 6d       	ori	r21, 0xDF	; 223
 306:	73 00       	.word	0x0073	; ????
			ms--;
			start += 1000;
		}
	}
}
 308:	74 77       	andi	r23, 0x74	; 116
 30a:	69 5f       	subi	r22, 0xF9	; 249
 30c:	72 78       	andi	r23, 0x82	; 130
 30e:	42 75       	andi	r20, 0x52	; 82
 310:	66 66       	ori	r22, 0x66	; 102
 312:	65 72       	andi	r22, 0x25	; 37
 314:	49 6e       	ori	r20, 0xE9	; 233
 316:	64 65       	ori	r22, 0x54	; 84
 318:	78 00       	.word	0x0078	; ????

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 31a:	75 69       	ori	r23, 0x95	; 149
 31c:	6e 74       	andi	r22, 0x4E	; 78
 31e:	38 5f       	subi	r19, 0xF8	; 248
 320:	74 00       	.word	0x0074	; ????
 322:	5f 5a       	subi	r21, 0xAF	; 175
 324:	4e 35       	cpi	r20, 0x5E	; 94
 326:	50 72       	andi	r21, 0x20	; 32
 328:	69 6e       	ori	r22, 0xE9	; 233
 32a:	74 43       	sbci	r23, 0x34	; 52
 32c:	32 45       	sbci	r19, 0x52	; 82
 32e:	76 00       	.word	0x0076	; ????
  size_t n = 0;
 330:	5f 6c       	ori	r21, 0xCF	; 207
 332:	6f 6f       	ori	r22, 0xFF	; 255
  while (size--) {
 334:	70 43       	sbci	r23, 0x30	; 48
 336:	6f 75       	andi	r22, 0x5F	; 95
 338:	6e 74       	andi	r22, 0x4E	; 78
    if (write(*buffer++)) n++;
 33a:	65 72       	andi	r22, 0x25	; 37
 33c:	00 73       	andi	r16, 0x30	; 48
 33e:	65 74       	andi	r22, 0x45	; 69
 340:	75 70       	andi	r23, 0x05	; 5
 342:	00 71       	andi	r16, 0x10	; 16
 344:	75 61       	ori	r23, 0x15	; 21
 346:	6e 74       	andi	r22, 0x4E	; 78
 348:	69 74       	andi	r22, 0x49	; 73
 34a:	79 00       	.word	0x0079	; ????
 34c:	62 6f       	ori	r22, 0xF2	; 242
 34e:	6f 6c       	ori	r22, 0xCF	; 207
 350:	00 5f       	subi	r16, 0xF0	; 240
 352:	5f 63       	ori	r21, 0x3F	; 63
 354:	78 61       	ori	r23, 0x18	; 24
 356:	5f 70       	andi	r21, 0x0F	; 15
 358:	75 72       	andi	r23, 0x25	; 37
    else break;
  }
  return n;
}
 35a:	65 5f       	subi	r22, 0xF5	; 245
 35c:	76 69       	ori	r23, 0x96	; 150
 35e:	72 74       	andi	r23, 0x42	; 66
 360:	75 61       	ori	r23, 0x15	; 21
 362:	6c 00       	.word	0x006c	; ????
 364:	5f 5f       	subi	r21, 0xFF	; 255
 366:	61 64       	ori	r22, 0x41	; 65
 368:	64 72       	andi	r22, 0x24	; 36
 36a:	31 36       	cpi	r19, 0x61	; 97
 36c:	00 6c       	ori	r16, 0xC0	; 192
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 36e:	65 6e       	ori	r22, 0xE5	; 229
 370:	67 74       	andi	r22, 0x47	; 71
 372:	68 00       	.word	0x0068	; ????

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
 374:	74 75       	andi	r23, 0x54	; 84
 376:	72 6e       	ori	r23, 0xE2	; 226
 378:	4f 66       	ori	r20, 0x6F	; 111
 37a:	66 50       	subi	r22, 0x06	; 6
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
 37c:	57 4d       	sbci	r21, 0xD7	; 215
 37e:	00 72       	andi	r16, 0x20	; 32
 380:	65 61       	ori	r22, 0x15	; 21
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
 382:	64 00       	.word	0x0064	; ????
 384:	74 77       	andi	r23, 0x74	; 116
 386:	69 5f       	subi	r22, 0xF9	; 249
 388:	74 72       	andi	r23, 0x24	; 36
 38a:	61 6e       	ori	r22, 0xE1	; 225
 38c:	73 6d       	ori	r23, 0xD3	; 211
 38e:	69 74       	andi	r22, 0x49	; 73
 390:	2e 70       	andi	r18, 0x0E	; 14
 392:	61 72       	andi	r22, 0x21	; 33
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
 394:	74 2e       	mov	r7, r20
 396:	32 00       	.word	0x0032	; ????
 398:	77 72       	andi	r23, 0x27	; 39
 39a:	69 74       	andi	r22, 0x49	; 73
 39c:	65 4e       	sbci	r22, 0xE5	; 229
 39e:	62 69       	ori	r22, 0x92	; 146
 3a0:	74 73       	andi	r23, 0x34	; 52
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
 3a2:	00 70       	andi	r16, 0x00	; 0
 3a4:	69 6e       	ori	r22, 0xE9	; 233
    twi_txBuffer[twi_txBufferLength+i] = data[i];
 3a6:	4d 6f       	ori	r20, 0xFD	; 253
 3a8:	64 65       	ori	r22, 0x54	; 84
 3aa:	00 64       	ori	r16, 0x40	; 64
 3ac:	69 67       	ori	r22, 0x79	; 121
 3ae:	69 74       	andi	r22, 0x49	; 73
 3b0:	61 6c       	ori	r22, 0xC1	; 193
 3b2:	5f 70       	andi	r21, 0x0F	; 15
 3b4:	69 6e       	ori	r22, 0xE9	; 233
 3b6:	5f 74       	andi	r21, 0x4F	; 79
 3b8:	6f 5f       	subi	r22, 0xFF	; 255
 3ba:	70 6f       	ori	r23, 0xF0	; 240
  }
  twi_txBufferLength += length;
 3bc:	72 74       	andi	r23, 0x42	; 66
 3be:	5f 50       	subi	r21, 0x0F	; 15
 3c0:	47 4d       	sbci	r20, 0xD7	; 215
 3c2:	00 5f       	subi	r16, 0xF0	; 240
 3c4:	5f 62       	ori	r21, 0x2F	; 47
 3c6:	61 73       	andi	r22, 0x31	; 49
 3c8:	65 5f       	subi	r22, 0xF5	; 245
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
 3ca:	63 74       	andi	r22, 0x43	; 67
 3cc:	6f 72       	andi	r22, 0x2F	; 47
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
 3ce:	20 00       	.word	0x0020	; ????
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
 3d0:	70 65       	ori	r23, 0x50	; 80

  return value;
}

void TwoWire::flush(void)
{
 3d2:	65 6b       	ori	r22, 0xB5	; 181
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
 3d4:	00 74       	andi	r16, 0x40	; 64
 3d6:	69 6d       	ori	r22, 0xD9	; 217
 3d8:	65 72       	andi	r22, 0x25	; 37
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
 3da:	30 5f       	subi	r19, 0xF0	; 240
 3dc:	6d 69       	ori	r22, 0x9D	; 157
 3de:	6c 6c       	ori	r22, 0xCC	; 204
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
 3e0:	69 73       	andi	r22, 0x39	; 57
 3e2:	00 61       	ori	r16, 0x10	; 16
 3e4:	76 61       	ori	r23, 0x16	; 22
}
 3e6:	69 6c       	ori	r22, 0xC9	; 201
 3e8:	61 62       	ori	r22, 0x21	; 33
 3ea:	6c 65       	ori	r22, 0x5C	; 92
 3ec:	46 6f       	ori	r20, 0xF6	; 246

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 3ee:	72 57       	subi	r23, 0x72	; 114
 3f0:	72 69       	ori	r23, 0x92	; 146
 3f2:	74 65       	ori	r23, 0x54	; 84
 3f4:	00 63       	ori	r16, 0x30	; 48
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
 3f6:	6c 65       	ori	r22, 0x5C	; 92
 3f8:	61 72       	andi	r22, 0x21	; 33
 3fa:	00 66       	ori	r16, 0x60	; 96
  }
  return quantity;
}
 3fc:	6f 75       	andi	r22, 0x5F	; 95
 3fe:	72 62       	ori	r23, 0x22	; 34
 400:	69 74       	andi	r22, 0x49	; 73
 402:	6d 6f       	ori	r22, 0xFD	; 253

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
 404:	64 65       	ori	r22, 0x54	; 84
 406:	00 70       	andi	r16, 0x00	; 0
 408:	6f 72       	andi	r22, 0x2F	; 47
 40a:	74 5f       	subi	r23, 0xF4	; 244
 40c:	74 6f       	ori	r23, 0xF4	; 244
 40e:	5f 6d       	ori	r21, 0xDF	; 223
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
 410:	6f 64       	ori	r22, 0x4F	; 79
 412:	65 5f       	subi	r22, 0xF5	; 245
 414:	50 47       	sbci	r21, 0x70	; 112
 416:	4d 00       	.word	0x004d	; ????
 418:	3c 61       	ori	r19, 0x1C	; 28
  }
  return 1;
}
 41a:	72 74       	andi	r23, 0x42	; 66
 41c:	69 66       	ori	r22, 0x69	; 105
 41e:	69 63       	ori	r22, 0x39	; 57
 420:	69 61       	ori	r22, 0x19	; 25
 422:	6c 3e       	cpi	r22, 0xEC	; 236
 424:	00 74       	andi	r16, 0x40	; 64
#endif

//
// setBackligh
void LiquidCrystal::setBacklight ( uint8_t value )
{
 426:	69 6d       	ori	r22, 0xD9	; 217
   // Check if there is a pin assigned to the backlight
   // ---------------------------------------------------
   if ( _backlightPin != LCD_NOBACKLIGHT )
 428:	65 72       	andi	r22, 0x25	; 37
 42a:	30 5f       	subi	r19, 0xF0	; 240
 42c:	6f 76       	andi	r22, 0x6F	; 111
 42e:	65 72       	andi	r22, 0x25	; 37
 430:	66 6c       	ori	r22, 0xC6	; 198
         }
      }
      // Not a PWM pin, set the backlight pin for POSI or NEG
      // polarity
      // --------------------------------------------------------
      else if (((value > 0) && (_polarity == POSITIVE)) ||
 432:	6f 77       	andi	r22, 0x7F	; 127
 434:	5f 63       	ori	r21, 0x3F	; 63
 436:	6f 75       	andi	r22, 0x5F	; 95
 438:	6e 74       	andi	r22, 0x4E	; 78
 43a:	00 72       	andi	r16, 0x20	; 32
               ((value == 0) && (_polarity == NEGATIVE)))
 43c:	6f 77       	andi	r22, 0x7F	; 127
 43e:	5f 6f       	ori	r21, 0xFF	; 255
 440:	66 66       	ori	r22, 0x66	; 102
      {
         digitalWrite( _backlightPin, HIGH);
 442:	73 65       	ori	r23, 0x53	; 83
 444:	74 73       	andi	r23, 0x34	; 52
      }
      else
      {
         digitalWrite( _backlightPin, LOW);
 446:	4c 61       	ori	r20, 0x1C	; 28
 448:	72 67       	ori	r23, 0x72	; 114
 44a:	65 00       	.word	0x0065	; ????
 44c:	62 79       	andi	r22, 0x92	; 146
}

//
// setBacklightPin
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
 44e:	74 65       	ori	r23, 0x54	; 84
 450:	00 6f       	ori	r16, 0xF0	; 240
 452:	6c 64       	ori	r22, 0x4C	; 76
 454:	53 52       	subi	r21, 0x23	; 35
 456:	45 47       	sbci	r20, 0x75	; 117
 458:	00 70       	andi	r16, 0x00	; 0
 45a:	72 69       	ori	r23, 0x92	; 146
 45c:	6e 74       	andi	r22, 0x4E	; 78
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
 45e:	4e 75       	andi	r20, 0x5E	; 94
 460:	6d 62       	ori	r22, 0x2D	; 45
 462:	65 72       	andi	r22, 0x25	; 37
   _backlightPin = pin;
 464:	00 74       	andi	r16, 0x40	; 64
   _polarity = pol;
 466:	77 69       	ori	r23, 0x97	; 151
 468:	5f 74       	andi	r21, 0x4F	; 79
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
 46a:	78 42       	sbci	r23, 0x28	; 40
 46c:	75 66       	ori	r23, 0x65	; 101
 46e:	66 65       	ori	r22, 0x56	; 86
 470:	72 4c       	sbci	r23, 0xC2	; 194
 472:	65 6e       	ori	r22, 0xE5	; 229
 474:	67 74       	andi	r22, 0x47	; 71
 476:	68 00       	.word	0x0068	; ????
}
 478:	5f 63       	ori	r21, 0x3F	; 63
 47a:	6f 6c       	ori	r22, 0xCF	; 207
 47c:	73 00       	.word	0x0073	; ????
 47e:	5f 5a       	subi	r21, 0xAF	; 175
 480:	4e 31       	cpi	r20, 0x1E	; 30
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
   _backlightPin = pin;
   _polarity = pol;
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
 482:	33 4c       	sbci	r19, 0xC3	; 195

/************ low level data pushing commands **********/
//
// send
void LiquidCrystal::send(uint8_t value, uint8_t mode) 
{
 484:	69 71       	andi	r22, 0x19	; 25
 486:	75 69       	ori	r23, 0x95	; 149
 488:	64 43       	sbci	r22, 0x34	; 52
 48a:	72 79       	andi	r23, 0x92	; 146
 48c:	73 74       	andi	r23, 0x43	; 67
 48e:	61 6c       	ori	r22, 0xC1	; 193
 490:	34 73       	andi	r19, 0x34	; 52
   // Only interested in COMMAND or DATA
   digitalWrite( _rs_pin, ( mode == LCD_DATA ) );
 492:	65 6e       	ori	r22, 0xE5	; 229
 494:	64 45       	sbci	r22, 0x54	; 84
 496:	68 68       	ori	r22, 0x88	; 136
 498:	2e 70       	andi	r18, 0x0E	; 14
 49a:	61 72       	andi	r22, 0x21	; 33
 49c:	74 2e       	mov	r7, r20
 49e:	31 00       	.word	0x0031	; ????
   
   // if there is a RW pin indicated, set it low to Write
   // ---------------------------------------------------
   if (_rw_pin != 255) 
 4a0:	5f 64       	ori	r21, 0x4F	; 79
 4a2:	69 73       	andi	r22, 0x39	; 57
 4a4:	70 6c       	ori	r23, 0xC0	; 192
   { 
      digitalWrite(_rw_pin, LOW);
 4a6:	61 79       	andi	r22, 0x91	; 145
 4a8:	63 6f       	ori	r22, 0xF3	; 243
 4aa:	6e 74       	andi	r22, 0x4E	; 78
   }
   
   if ( mode != FOUR_BITS )
 4ac:	72 6f       	ori	r23, 0xF2	; 242
 4ae:	6c 00       	.word	0x006c	; ????
   {   
      if ( (_displayfunction & LCD_8BITMODE ) )
 4b0:	61 76       	andi	r22, 0x61	; 97
 4b2:	61 69       	ori	r22, 0x91	; 145
 4b4:	6c 61       	ori	r22, 0x1C	; 28
      {
         writeNbits(value, 8); 
 4b6:	62 6c       	ori	r22, 0xC2	; 194
 4b8:	65 00       	.word	0x0065	; ????
      } 
      else 
      {
         writeNbits ( value >> 4, 4 );
 4ba:	64 69       	ori	r22, 0x94	; 148
 4bc:	73 70       	andi	r23, 0x03	; 3
 4be:	6c 61       	ori	r22, 0x1C	; 28
 4c0:	79 00       	.word	0x0079	; ????
 4c2:	74 77       	andi	r23, 0x74	; 116
 4c4:	69 5f       	subi	r22, 0xF9	; 249
 4c6:	6d 61       	ori	r22, 0x1D	; 29
 4c8:	73 74       	andi	r23, 0x43	; 67
 4ca:	65 72       	andi	r22, 0x25	; 37
 4cc:	42 75       	andi	r20, 0x52	; 82
 4ce:	66 66       	ori	r22, 0x66	; 102
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
 4d0:	65 72       	andi	r22, 0x25	; 37
 4d2:	00 75       	andi	r16, 0x50	; 80
 4d4:	6e 73       	andi	r22, 0x3E	; 62
   }
   waitUsec ( EXEC_TIME ); // wait for the command to execute by the LCD
}
 4d6:	69 67       	ori	r22, 0x79	; 121
 4d8:	6e 65       	ori	r22, 0x5E	; 94
 4da:	64 20       	and	r6, r4
 4dc:	63 68       	ori	r22, 0x83	; 131
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
 4de:	61 72       	andi	r22, 0x21	; 33
 4e0:	00 74       	andi	r16, 0x40	; 64
   send(value, LCD_DATA);
}
#else
size_t LCD::write(uint8_t value) 
{
   send(value, LCD_DATA);
 4e2:	77 69       	ori	r23, 0x97	; 151
 4e4:	5f 73       	andi	r21, 0x3F	; 63
 4e6:	6c 61       	ori	r22, 0x1C	; 28
 4e8:	72 77       	andi	r23, 0x72	; 114
 4ea:	00 5f       	subi	r16, 0xF0	; 240
 4ec:	5f 69       	ori	r21, 0x9F	; 159
 4ee:	6e 69       	ori	r22, 0x9E	; 158
 4f0:	74 69       	ori	r23, 0x94	; 148
   return 1;             // assume OK
}
 4f2:	61 6c       	ori	r22, 0xC1	; 193
 4f4:	69 7a       	andi	r22, 0xA9	; 169
 4f6:	65 5f       	subi	r22, 0xF5	; 245

// General LCD commands - generic methods used by the rest of the commands
// ---------------------------------------------------------------------------
void LCD::command(uint8_t value) 
{
   send(value, COMMAND);
 4f8:	70 00       	.word	0x0070	; ????
 4fa:	47 4e       	sbci	r20, 0xE7	; 231
 4fc:	55 20       	and	r5, r5
 4fe:	47 49       	sbci	r20, 0x97	; 151
 500:	4d 50       	subi	r20, 0x0D	; 13
 502:	4c 45       	sbci	r20, 0x5C	; 92
 504:	20 35       	cpi	r18, 0x50	; 80
 506:	2e 34       	cpi	r18, 0x4E	; 78
{
   command(LCD_RETURNHOME);             // set cursor position to zero
   delayMicroseconds(HOME_CLEAR_EXEC);  // This command is time consuming
}

void LCD::setCursor(uint8_t col, uint8_t row)
 508:	2e 30       	cpi	r18, 0x0E	; 14
 50a:	20 2d       	mov	r18, r0
 50c:	6d 6e       	ori	r22, 0xED	; 237
 50e:	2d 66       	ori	r18, 0x6D	; 109
 510:	6c 61       	ori	r22, 0x1C	; 28
 512:	73 68       	ori	r23, 0x83	; 131
 514:	3d 31       	cpi	r19, 0x1D	; 29
 516:	20 2d       	mov	r18, r0
 518:	6d 6d       	ori	r22, 0xDD	; 221
 51a:	63 75       	andi	r22, 0x53	; 83
{
   const byte row_offsetsDef[]   = { 0x00, 0x40, 0x14, 0x54 }; // For regular LCDs
 51c:	3d 61       	ori	r19, 0x1D	; 29
 51e:	76 72       	andi	r23, 0x26	; 38
 520:	35 20       	and	r3, r5
 522:	2d 6d       	ori	r18, 0xDD	; 221
 524:	6e 2d       	mov	r22, r14
 526:	66 6c       	ori	r22, 0xC6	; 198
 528:	61 73       	andi	r22, 0x31	; 49
 52a:	68 3d       	cpi	r22, 0xD8	; 216
 52c:	31 20       	and	r3, r1
 52e:	2d 6d       	ori	r18, 0xDD	; 221
 530:	6e 6f       	ori	r22, 0xFE	; 254
 532:	2d 73       	andi	r18, 0x3D	; 61
   const byte row_offsetsLarge[] = { 0x00, 0x40, 0x10, 0x50 }; // For 16x4 LCDs
 534:	6b 69       	ori	r22, 0x9B	; 155
 536:	70 2d       	mov	r23, r0
 538:	62 75       	andi	r22, 0x52	; 82
 53a:	67 20       	and	r6, r7
 53c:	2d 6d       	ori	r18, 0xDD	; 221
 53e:	6d 63       	ori	r22, 0x3D	; 61
 540:	75 3d       	cpi	r23, 0xD5	; 213
 542:	61 76       	andi	r22, 0x61	; 97
 544:	72 35       	cpi	r23, 0x52	; 82
 546:	20 2d       	mov	r18, r0
 548:	67 20       	and	r6, r7
 54a:	2d 4f       	sbci	r18, 0xFD	; 253
   
   if ( row >= _numlines ) 
 54c:	73 20       	and	r7, r3
 54e:	2d 4f       	sbci	r18, 0xFD	; 253
 550:	73 20       	and	r7, r3
 552:	2d 66       	ori	r18, 0x6D	; 109
   {
      row = _numlines-1;    // rows start at 0
 554:	6d 61       	ori	r22, 0x1D	; 29
 556:	74 68       	ori	r23, 0x84	; 132
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
 558:	2d 65       	ori	r18, 0x5D	; 93
 55a:	72 72       	andi	r23, 0x22	; 34
 55c:	6e 6f       	ori	r22, 0xFE	; 254
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
 55e:	20 2d       	mov	r18, r0
 560:	66 73       	andi	r22, 0x36	; 54
 562:	69 67       	ori	r22, 0x79	; 121
      row = _numlines-1;    // rows start at 0
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
 564:	6e 65       	ori	r22, 0x5E	; 94
 566:	64 2d       	mov	r22, r4
 568:	7a 65       	ori	r23, 0x5A	; 90
 56a:	72 6f       	ori	r23, 0xF2	; 242
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
 56c:	73 20       	and	r7, r3
 56e:	2d 66       	ori	r18, 0x6D	; 109
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
 570:	74 72       	andi	r23, 0x24	; 36
 572:	61 70       	andi	r22, 0x01	; 1
 574:	70 69       	ori	r23, 0x90	; 144
 576:	6e 67       	ori	r22, 0x7E	; 126
   }
   
}
 578:	2d 6d       	ori	r18, 0xDD	; 221
 57a:	61 74       	andi	r22, 0x41	; 65
 57c:	68 20       	and	r6, r8
 57e:	2d 66       	ori	r18, 0x6D	; 109
 580:	6e 6f       	ori	r22, 0xFE	; 254
 582:	2d 74       	andi	r18, 0x4D	; 77
 584:	72 61       	ori	r23, 0x12	; 18
 586:	70 76       	andi	r23, 0x60	; 96
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
 588:	20 2d       	mov	r18, r0
 58a:	66 6e       	ori	r22, 0xE6	; 230
// can't assume that its in that state when a application starts (and the
// LiquidCrystal constructor is called).
// A call to begin() will reinitialize the LCD.
//
void LCD::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) 
{
 58c:	6f 2d       	mov	r22, r15
 58e:	6f 70       	andi	r22, 0x0F	; 15
 590:	65 6e       	ori	r22, 0xE5	; 229
 592:	6d 70       	andi	r22, 0x0D	; 13
 594:	20 2d       	mov	r18, r0
   if (lines > 1) 
 596:	66 6e       	ori	r22, 0xE6	; 230
 598:	6f 2d       	mov	r22, r15
   {
      _displayfunction |= LCD_2LINE;
 59a:	6f 70       	andi	r22, 0x0F	; 15
 59c:	65 6e       	ori	r22, 0xE5	; 229
 59e:	61 63       	ori	r22, 0x31	; 49
   }
   _numlines = lines;
 5a0:	63 20       	and	r6, r3
   _cols = cols;
 5a2:	2d 66       	ori	r18, 0x6D	; 109
   
   // for some 1 line displays you can select a 10 pixel high font
   // ------------------------------------------------------------
   if ((dotsize != LCD_5x8DOTS) && (lines == 1)) 
 5a4:	6e 6f       	ori	r22, 0xFE	; 254
 5a6:	2d 65       	ori	r18, 0x5D	; 93
 5a8:	78 63       	ori	r23, 0x38	; 56
 5aa:	65 70       	andi	r22, 0x05	; 5
   {
      _displayfunction |= LCD_5x10DOTS;
 5ac:	74 69       	ori	r23, 0x94	; 148
 5ae:	6f 6e       	ori	r22, 0xEF	; 239
 5b0:	73 20       	and	r7, r3
   // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
   // according to datasheet, we need at least 40ms after power rises above 2.7V
   // before sending commands. Arduino can turn on way before 4.5V so we'll wait 
   // 50
   // ---------------------------------------------------------------------------
   delay (100); // 100ms delay
 5b2:	2d 66       	ori	r18, 0x6D	; 109
 5b4:	75 73       	andi	r23, 0x35	; 53
 5b6:	65 2d       	mov	r22, r5
 5b8:	6c 69       	ori	r22, 0x9C	; 156
 5ba:	6e 6b       	ori	r22, 0xBE	; 190
 5bc:	65 72       	andi	r22, 0x25	; 37
   
   //put the LCD into 4 bit or 8 bit mode
   // -------------------------------------
   if (! (_displayfunction & LCD_8BITMODE)) 
 5be:	2d 70       	andi	r18, 0x0D	; 13
 5c0:	6c 75       	andi	r22, 0x5C	; 92
 5c2:	67 69       	ori	r22, 0x97	; 151
      // this is according to the hitachi HD44780 datasheet
      // figure 24, pg 46
      
      // we start in 8bit mode, try to set 4 bit mode
      // Special case of "Function Set"
      send(0x03, FOUR_BITS);
 5c4:	6e 20       	and	r6, r14
 5c6:	2d 66       	ori	r18, 0x6D	; 109
 5c8:	6c 74       	andi	r22, 0x4C	; 76
 5ca:	72 61       	ori	r23, 0x12	; 18
 5cc:	6e 73       	andi	r22, 0x3E	; 62
 5ce:	00 6c       	ori	r16, 0xC0	; 192
 5d0:	6f 6f       	ori	r22, 0xFF	; 255
 5d2:	70 00       	.word	0x0070	; ????
 5d4:	70 6f       	ori	r23, 0xF0	; 240
	

#endif

	// busy wait
	__asm__ __volatile__ (
 5d6:	72 74       	andi	r23, 0x42	; 66
 5d8:	5f 74       	andi	r21, 0x4F	; 79
 5da:	6f 5f       	subi	r22, 0xFF	; 255
 5dc:	6f 75       	andi	r22, 0x5F	; 95
      delayMicroseconds(4500); // wait min 4.1ms
      
      // second try
      send ( 0x03, FOUR_BITS );
 5de:	74 70       	andi	r23, 0x04	; 4
 5e0:	75 74       	andi	r23, 0x45	; 69
 5e2:	5f 50       	subi	r21, 0x0F	; 15
 5e4:	47 4d       	sbci	r20, 0xD7	; 215
 5e6:	00 74       	andi	r16, 0x40	; 64
 5e8:	77 69       	ori	r23, 0x97	; 151
 5ea:	5f 69       	ori	r21, 0x9F	; 159
 5ec:	6e 52       	subi	r22, 0x2E	; 46
 5ee:	65 70       	andi	r22, 0x05	; 5
 5f0:	53 74       	andi	r21, 0x43	; 67
 5f2:	61 72       	andi	r22, 0x21	; 33
 5f4:	74 00       	.word	0x0074	; ????
 5f6:	70 72       	andi	r23, 0x20	; 32
 5f8:	69 6e       	ori	r22, 0xE9	; 233
      delayMicroseconds(150); // wait min 100us
      
      // third go!
      send( 0x03, FOUR_BITS );
 5fa:	74 00       	.word	0x0074	; ????
 5fc:	75 69       	ori	r23, 0x95	; 149
 5fe:	6e 74       	andi	r22, 0x4E	; 78
 600:	33 32       	cpi	r19, 0x23	; 35
 602:	5f 74       	andi	r21, 0x4F	; 79
 604:	00 75       	andi	r16, 0x50	; 80
 606:	69 6e       	ori	r22, 0xE9	; 233
 608:	74 31       	cpi	r23, 0x14	; 20
 60a:	36 5f       	subi	r19, 0xF6	; 246
 60c:	74 00       	.word	0x0074	; ????
 60e:	5f 76       	andi	r21, 0x6F	; 111
 610:	70 74       	andi	r23, 0x40	; 64
      delayMicroseconds(150); // wait min of 100us
      
      // finally, set to 4-bit interface
      send ( 0x02, FOUR_BITS );
 612:	72 2e       	mov	r7, r18
 614:	50 72       	andi	r21, 0x20	; 32
 616:	69 6e       	ori	r22, 0xE9	; 233
 618:	74 00       	.word	0x0074	; ????
 61a:	5f 5f       	subi	r21, 0xFF	; 255
 61c:	72 65       	ori	r23, 0x52	; 82
 61e:	73 75       	andi	r23, 0x53	; 83
 620:	6c 74       	andi	r22, 0x4C	; 76
 622:	00 6c       	ori	r16, 0xC0	; 192
 624:	6f 6e       	ori	r22, 0xEF	; 239
   {
      // this is according to the hitachi HD44780 datasheet
      // page 45 figure 23
      
      // Send function set command sequence
      command(LCD_FUNCTIONSET | _displayfunction);
 626:	67 20       	and	r6, r7
 628:	75 6e       	ori	r23, 0xE5	; 229
 62a:	73 69       	ori	r23, 0x93	; 147
 62c:	67 6e       	ori	r22, 0xE7	; 231
 62e:	65 64       	ori	r22, 0x45	; 69
 630:	20 69       	ori	r18, 0x90	; 144
 632:	6e 74       	andi	r22, 0x4E	; 78
 634:	00 74       	andi	r16, 0x40	; 64
      delayMicroseconds(4500);  // wait more than 4.1ms
      
      // second try
      command(LCD_FUNCTIONSET | _displayfunction);
 636:	77 69       	ori	r23, 0x97	; 151
 638:	5f 72       	andi	r21, 0x2F	; 47
 63a:	65 6c       	ori	r22, 0xC5	; 197
 63c:	65 61       	ori	r22, 0x15	; 21
 63e:	73 65       	ori	r23, 0x53	; 83
 640:	42 75       	andi	r20, 0x52	; 82
 642:	73 00       	.word	0x0073	; ????
 644:	73 74       	andi	r23, 0x43	; 67
 646:	61 72       	andi	r22, 0x21	; 33
 648:	74 00       	.word	0x0074	; ????
      delayMicroseconds(150);
      
      // third go
      command(LCD_FUNCTIONSET | _displayfunction);
 64a:	53 74       	andi	r21, 0x43	; 67
 64c:	72 65       	ori	r23, 0x52	; 82
 64e:	61 6d       	ori	r22, 0xD1	; 209
 650:	00 74       	andi	r16, 0x40	; 64
 652:	69 6d       	ori	r22, 0xD9	; 217
 654:	65 72       	andi	r22, 0x25	; 37
 656:	00 73       	andi	r16, 0x30	; 48
 658:	65 74       	andi	r22, 0x45	; 69
      delayMicroseconds(150);

   }
   
   // finally, set # lines, font size, etc.
   command(LCD_FUNCTIONSET | _displayfunction);
 65a:	42 61       	ori	r20, 0x12	; 18
 65c:	63 6b       	ori	r22, 0xB3	; 179
 65e:	6c 69       	ori	r22, 0x9C	; 156
 660:	67 68       	ori	r22, 0x87	; 135
 662:	74 00       	.word	0x0074	; ????
 664:	74 77       	andi	r23, 0x74	; 116
 666:	69 5f       	subi	r22, 0xF9	; 249
 668:	74 78       	andi	r23, 0x84	; 132
 66a:	42 75       	andi	r20, 0x52	; 82
   delayMicroseconds ( 60 );  // wait more
   
   // turn the display on with no cursor or blinking default
   _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
 66c:	66 66       	ori	r22, 0x66	; 102
 66e:	65 72       	andi	r22, 0x25	; 37
}

void LCD::display() 
{
   _displaycontrol |= LCD_DISPLAYON;
   command(LCD_DISPLAYCONTROL | _displaycontrol);
 670:	49 6e       	ori	r20, 0xE9	; 233
 672:	64 65       	ori	r22, 0x54	; 84
 674:	78 00       	.word	0x0078	; ????
 676:	5f 72       	andi	r21, 0x2F	; 47

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
 678:	77 5f       	subi	r23, 0xF7	; 247
 67a:	70 69       	ori	r23, 0x90	; 144
 67c:	6e 00       	.word	0x006e	; ????
 67e:	69 6e       	ori	r22, 0xE9	; 233
 680:	69 74       	andi	r22, 0x49	; 73
 682:	00 74       	andi	r16, 0x40	; 64
 684:	77 69       	ori	r23, 0x97	; 151
 686:	5f 74       	andi	r21, 0x4F	; 79
   
   // clear the LCD
   clear();
   
   // Initialize to default text direction (for romance languages)
   _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
 688:	72 61       	ori	r23, 0x12	; 18
 68a:	6e 73       	andi	r22, 0x3E	; 62
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);
 68c:	6d 69       	ori	r22, 0x9D	; 157
 68e:	74 00       	.word	0x0074	; ????
 690:	70 75       	andi	r23, 0x50	; 80
 692:	6c 73       	andi	r22, 0x3C	; 60

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
 694:	65 45       	sbci	r22, 0x55	; 85
 696:	6e 61       	ori	r22, 0x1E	; 30
 698:	62 6c       	ori	r22, 0xC2	; 194
 69a:	65 00       	.word	0x0065	; ????
 69c:	74 77       	andi	r23, 0x74	; 116
 69e:	69 5f       	subi	r22, 0xF9	; 249
 6a0:	73 74       	andi	r23, 0x43	; 67
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);

   backlight();

}
 6a2:	6f 70       	andi	r22, 0x0F	; 15
 6a4:	00 62       	ori	r16, 0x20	; 32
 6a6:	75 66       	ori	r23, 0x65	; 101
 6a8:	66 65       	ori	r22, 0x56	; 86

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
 6aa:	72 00       	.word	0x0072	; ????
    
    @param      0..255 - the value is very dependent on the LCD. However, 
    BACKLIGHT_OFF will be interpreted as off and BACKLIGHT_ON will drive the
    backlight on.
    */
   virtual void setBacklight ( uint8_t value ) { };
 6ac:	5f 72       	andi	r21, 0x2F	; 47
    empty function call is provided that does nothing.
    
    @param      value: pin associated to backlight control.
    @param      pol: backlight polarity control (POSITIVE, NEGATIVE)
    */
   virtual void setBacklightPin ( uint8_t value, t_backlightPol pol ) { };
 6ae:	73 5f       	subi	r23, 0xF3	; 243
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
 6b0:	70 69       	ori	r23, 0x90	; 144
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 6b2:	6e 00       	.word	0x006e	; ????
 6b4:	5f 5f       	subi	r21, 0xFF	; 255
 6b6:	70 72       	andi	r23, 0x20	; 32
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 6b8:	69 6f       	ori	r22, 0xF9	; 249
 6ba:	72 69       	ori	r23, 0x92	; 146
      return write((const uint8_t *)str, strlen(str));
 6bc:	74 79       	andi	r23, 0x94	; 148
 6be:	00 74       	andi	r16, 0x40	; 64
 6c0:	68 69       	ori	r22, 0x98	; 152
 6c2:	73 00       	.word	0x0073	; ????
 6c4:	5f 62       	ori	r21, 0x2F	; 47
 6c6:	61 63       	ori	r22, 0x31	; 49
 6c8:	6b 6c       	ori	r22, 0xCB	; 203
 6ca:	69 67       	ori	r22, 0x79	; 121
 6cc:	68 74       	andi	r22, 0x48	; 72
 6ce:	50 69       	ori	r21, 0x90	; 144
 6d0:	6e 00       	.word	0x006e	; ????
 6d2:	5f 47       	sbci	r21, 0x7F	; 127
 6d4:	4c 4f       	sbci	r20, 0xFC	; 252
    }
 6d6:	42 41       	sbci	r20, 0x12	; 18
 6d8:	4c 5f       	subi	r20, 0xFC	; 252
 6da:	5f 73       	andi	r21, 0x3F	; 63
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
 6dc:	75 62       	ori	r23, 0x25	; 37
 6de:	5f 49       	sbci	r21, 0x9F	; 159
 6e0:	5f 5f       	subi	r21, 0xFF	; 255
 6e2:	5a 4e       	sbci	r21, 0xEA	; 234
 6e4:	37 54       	subi	r19, 0x47	; 71
 6e6:	77 6f       	ori	r23, 0xF7	; 247
 6e8:	57 69       	ori	r21, 0x97	; 151
 6ea:	72 65       	ori	r23, 0x52	; 82
 6ec:	38 72       	andi	r19, 0x28	; 40
 6ee:	78 42       	sbci	r23, 0x28	; 40
 6f0:	75 66       	ori	r23, 0x65	; 101
 6f2:	66 65       	ori	r22, 0x56	; 86
 6f4:	72 45       	sbci	r23, 0x52	; 82
 6f6:	00 74       	andi	r16, 0x40	; 64
 6f8:	77 69       	ori	r23, 0x97	; 151
 6fa:	5f 6d       	ori	r21, 0xDF	; 223
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 6fc:	61 73       	andi	r22, 0x31	; 49

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 6fe:	74 65       	ori	r23, 0x54	; 84
 700:	72 42       	sbci	r23, 0x22	; 34
 702:	75 66       	ori	r23, 0x65	; 101
 704:	66 65       	ori	r22, 0x56	; 86
 706:	72 49       	sbci	r23, 0x92	; 146
 708:	6e 64       	ori	r22, 0x4E	; 78

  do {
    char c = n % base;
 70a:	65 78       	andi	r22, 0x85	; 133
 70c:	00 5f       	subi	r16, 0xF0	; 240
 70e:	5f 73       	andi	r21, 0x3F	; 63
 710:	74 61       	ori	r23, 0x14	; 20
 712:	74 69       	ori	r23, 0x94	; 148
 714:	63 5f       	subi	r22, 0xF3	; 243
 716:	69 6e       	ori	r22, 0xE9	; 233
 718:	69 74       	andi	r22, 0x49	; 73
 71a:	69 61       	ori	r22, 0x19	; 25
    n /= base;
 71c:	6c 69       	ori	r22, 0x9C	; 156
 71e:	7a 61       	ori	r23, 0x1A	; 26

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 720:	74 69       	ori	r23, 0x94	; 148
 722:	6f 6e       	ori	r22, 0xEF	; 239
 724:	5f 61       	ori	r21, 0x1F	; 31
 726:	6e 64       	ori	r22, 0x4E	; 78
 728:	5f 64       	ori	r21, 0x4F	; 79
 72a:	65 73       	andi	r22, 0x35	; 53
 72c:	74 72       	andi	r23, 0x24	; 36
 72e:	75 63       	ori	r23, 0x35	; 53
 730:	74 69       	ori	r23, 0x94	; 148
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 732:	6f 6e       	ori	r22, 0xEF	; 239
 734:	5f 30       	cpi	r21, 0x0F	; 15
 736:	00 64       	ori	r16, 0x40	; 64
 738:	69 67       	ori	r22, 0x79	; 121
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 73a:	69 74       	andi	r22, 0x49	; 73
 73c:	61 6c       	ori	r22, 0xC1	; 193
 73e:	57 72       	andi	r21, 0x27	; 39
}
 740:	69 74       	andi	r22, 0x49	; 73
 742:	65 00       	.word	0x0065	; ????
 744:	70 6f       	ori	r23, 0xF0	; 240
 746:	72 74       	andi	r23, 0x42	; 66
 748:	00 74       	andi	r16, 0x40	; 64
 74a:	77 69       	ori	r23, 0x97	; 151
 74c:	5f 72       	andi	r21, 0x2F	; 47
 74e:	78 42       	sbci	r23, 0x28	; 40
 750:	75 66       	ori	r23, 0x65	; 101
 752:	66 65       	ori	r22, 0x56	; 86
 754:	72 00       	.word	0x0072	; ????
 756:	74 75       	andi	r23, 0x54	; 84
 758:	72 6e       	ori	r23, 0xE2	; 226
 75a:	4f 66       	ori	r20, 0x6F	; 111
 75c:	66 50       	subi	r22, 0x06	; 6
 75e:	57 4d       	sbci	r21, 0xD7	; 215
 760:	2e 70       	andi	r18, 0x0E	; 14
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 762:	61 72       	andi	r22, 0x21	; 33
 764:	74 2e       	mov	r7, r20
 766:	30 00       	.word	0x0030	; ????
 768:	5f 5f       	subi	r21, 0xFF	; 255
 76a:	76 74       	andi	r23, 0x46	; 70
 76c:	62 6c       	ori	r22, 0xC2	; 194
 76e:	5f 70       	andi	r21, 0x0F	; 15
 770:	74 72       	andi	r23, 0x24	; 36
 772:	5f 74       	andi	r21, 0x4F	; 79
 774:	79 70       	andi	r23, 0x09	; 9
 776:	65 00       	.word	0x0065	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 778:	4e 45       	sbci	r20, 0x5E	; 94
 77a:	47 41       	sbci	r20, 0x17	; 23
 77c:	54 49       	sbci	r21, 0x94	; 148
 77e:	56 45       	sbci	r21, 0x56	; 86
 780:	00 73       	andi	r16, 0x30	; 48
 782:	65 74       	andi	r22, 0x45	; 69
 784:	43 75       	andi	r20, 0x53	; 83
 786:	72 73       	andi	r23, 0x32	; 50
	unsigned char f = timer0_fract;
 788:	6f 72       	andi	r22, 0x2F	; 47
 78a:	00 5f       	subi	r16, 0xF0	; 240

	m += MILLIS_INC;
	f += FRACT_INC;
 78c:	74 69       	ori	r23, 0x94	; 148
 78e:	6d 65       	ori	r22, 0x5D	; 93
	if (f >= FRACT_MAX) {
 790:	6f 75       	andi	r22, 0x5F	; 95
 792:	74 00       	.word	0x0074	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 794:	5f 65       	ori	r21, 0x5F	; 95
 796:	6e 61       	ori	r22, 0x1E	; 30
 798:	62 6c       	ori	r22, 0xC2	; 194
 79a:	65 5f       	subi	r22, 0xF5	; 245
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 79c:	70 69       	ori	r23, 0x90	; 144
 79e:	6e 00       	.word	0x006e	; ????
		m += 1;
 7a0:	64 6f       	ori	r22, 0xF4	; 244
 7a2:	74 73       	andi	r23, 0x34	; 52
 7a4:	69 7a       	andi	r22, 0xA9	; 169
	}

	timer0_fract = f;
 7a6:	65 00       	.word	0x0065	; ????
 7a8:	5f 47       	sbci	r21, 0x7F	; 127
	timer0_millis = m;
 7aa:	4c 4f       	sbci	r20, 0xFC	; 252
 7ac:	42 41       	sbci	r20, 0x12	; 18
 7ae:	4c 5f       	subi	r20, 0xFC	; 252
 7b0:	5f 49       	sbci	r21, 0x9F	; 159
 7b2:	5f 36       	cpi	r21, 0x6F	; 111
 7b4:	35 35       	cpi	r19, 0x55	; 85
 7b6:	33 35       	cpi	r19, 0x53	; 83
 7b8:	5f 30       	cpi	r21, 0x0F	; 15
	timer0_overflow_count++;
 7ba:	5f 4a       	sbci	r21, 0xAF	; 175
 7bc:	42 5f       	subi	r20, 0xF2	; 242
 7be:	43 50       	subi	r20, 0x03	; 3
 7c0:	55 5f       	subi	r21, 0xF5	; 245
 7c2:	55 73       	andi	r21, 0x35	; 53
 7c4:	61 67       	ori	r22, 0x71	; 113
 7c6:	65 5f       	subi	r22, 0xF5	; 245
 7c8:	42 61       	ori	r20, 0x12	; 18
 7ca:	73 69       	ori	r23, 0x93	; 147
 7cc:	63 2e       	mov	r6, r19
 7ce:	69 6e       	ori	r22, 0xE9	; 233
 7d0:	6f 2e       	mov	r6, r31
 7d2:	63 70       	andi	r22, 0x03	; 3
 7d4:	70 2e       	mov	r7, r16
 7d6:	6f 00       	.word	0x006f	; ????
 7d8:	74 77       	andi	r23, 0x74	; 116
 7da:	69 5f       	subi	r22, 0xF9	; 249
 7dc:	65 72       	andi	r22, 0x25	; 37
 7de:	72 6f       	ori	r23, 0xF2	; 242
}
 7e0:	72 00       	.word	0x0072	; ????
 7e2:	5f 6e       	ori	r21, 0xEF	; 239
 7e4:	75 6d       	ori	r23, 0xD5	; 213
 7e6:	6c 69       	ori	r22, 0x9C	; 156
 7e8:	6e 65       	ori	r22, 0x5E	; 94
 7ea:	73 00       	.word	0x0073	; ????
 7ec:	62 61       	ori	r22, 0x12	; 18
 7ee:	63 6b       	ori	r22, 0xB3	; 179
 7f0:	6c 69       	ori	r22, 0x9C	; 156
 7f2:	67 68       	ori	r22, 0x87	; 135
 7f4:	74 00       	.word	0x0074	; ????
  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
 7f6:	5f 5f       	subi	r21, 0xFF	; 255
 7f8:	76 65       	ori	r23, 0x56	; 86
 7fa:	63 74       	andi	r22, 0x43	; 67
 7fc:	6f 72       	andi	r22, 0x2F	; 47
 7fe:	5f 32       	cpi	r21, 0x2F	; 47
 800:	34 00       	.word	0x0034	; ????
 802:	74 5f       	subi	r23, 0xF4	; 244
 804:	62 61       	ori	r22, 0x12	; 18
 806:	63 6b       	ori	r22, 0xB3	; 179
 808:	6c 69       	ori	r22, 0x9C	; 156
 80a:	67 68       	ori	r22, 0x87	; 135
 80c:	74 50       	subi	r23, 0x04	; 4
 80e:	6f 6c       	ori	r22, 0xCF	; 207
 810:	00 5f       	subi	r16, 0xF0	; 240
 812:	70 6f       	ori	r23, 0xF0	; 240
 814:	6c 61       	ori	r22, 0x1C	; 28
 816:	72 69       	ori	r23, 0x92	; 146
  switch(TW_STATUS){
 818:	74 79       	andi	r23, 0x94	; 148
 81a:	00 6c       	ori	r16, 0xC0	; 192
 81c:	6f 6f       	ori	r22, 0xFF	; 255
 81e:	70 2e       	mov	r7, r16
 820:	70 61       	ori	r23, 0x10	; 16
 822:	72 74       	andi	r23, 0x42	; 66
 824:	2e 30       	cpi	r18, 0x0E	; 14
 826:	00 5f       	subi	r16, 0xF0	; 240
 828:	47 4c       	sbci	r20, 0xC7	; 199
 82a:	4f 42       	sbci	r20, 0x2F	; 47
 82c:	41 4c       	sbci	r20, 0xC1	; 193
 82e:	5f 5f       	subi	r21, 0xFF	; 255
 830:	73 75       	andi	r23, 0x53	; 83
 832:	62 5f       	subi	r22, 0xF2	; 242
 834:	49 5f       	subi	r20, 0xF9	; 249
 836:	6c 63       	ori	r22, 0x3C	; 60
 838:	64 00       	.word	0x0064	; ????
 83a:	5f 73       	andi	r21, 0x3F	; 63
 83c:	74 61       	ori	r23, 0x14	; 20
 83e:	72 74       	andi	r23, 0x42	; 66
 840:	4d 69       	ori	r20, 0x9D	; 157
 842:	6c 6c       	ori	r22, 0xCC	; 204
 844:	69 73       	andi	r22, 0x39	; 57
 846:	00 74       	andi	r16, 0x40	; 64
 848:	77 69       	ori	r23, 0x97	; 151
 84a:	5f 74       	andi	r21, 0x4F	; 79
 84c:	78 42       	sbci	r23, 0x28	; 40
 84e:	75 66       	ori	r23, 0x65	; 101
 850:	66 65       	ori	r22, 0x56	; 86
 852:	72 00       	.word	0x0072	; ????
 854:	5f 5f       	subi	r21, 0xFF	; 255
 856:	76 65       	ori	r23, 0x56	; 86
 858:	63 74       	andi	r22, 0x43	; 67
 85a:	6f 72       	andi	r22, 0x2F	; 47
 85c:	5f 31       	cpi	r21, 0x1F	; 31
 85e:	36 00       	.word	0x0036	; ????
 860:	72 6f       	ori	r23, 0xF2	; 242
 862:	77 5f       	subi	r23, 0xF7	; 247
 864:	6f 66       	ori	r22, 0x6F	; 111
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
 866:	66 73       	andi	r22, 0x36	; 54
 868:	65 74       	andi	r22, 0x45	; 69
 86a:	73 44       	sbci	r23, 0x43	; 67
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 86c:	65 66       	ori	r22, 0x65	; 101
 86e:	00 64       	ori	r16, 0x40	; 64
 870:	69 67       	ori	r22, 0x79	; 121
 872:	69 74       	andi	r22, 0x49	; 73
 874:	61 6c       	ori	r22, 0xC1	; 193
 876:	5f 70       	andi	r21, 0x0F	; 15
 878:	69 6e       	ori	r22, 0xE9	; 233
 87a:	5f 74       	andi	r21, 0x4F	; 79
 87c:	6f 5f       	subi	r22, 0xFF	; 255
 87e:	74 69       	ori	r23, 0x94	; 148
 880:	6d 65       	ori	r22, 0x5D	; 93
 882:	72 5f       	subi	r23, 0xF2	; 242
 884:	50 47       	sbci	r21, 0x70	; 112
 886:	4d 00       	.word	0x004d	; ????
 888:	64 65       	ori	r22, 0x54	; 84
 88a:	6c 61       	ori	r22, 0x1C	; 28
 88c:	79 4d       	sbci	r23, 0xD9	; 217
 88e:	69 63       	ori	r22, 0x39	; 57
 890:	72 6f       	ori	r23, 0xF2	; 242
 892:	73 65       	ori	r23, 0x53	; 83
 894:	63 6f       	ori	r22, 0xF3	; 243
 896:	6e 64       	ori	r22, 0x4E	; 78
 898:	73 00       	.word	0x0073	; ????
 89a:	54 77       	andi	r21, 0x74	; 116
 89c:	6f 57       	subi	r22, 0x7F	; 127
 89e:	69 72       	andi	r22, 0x29	; 41
 8a0:	65 00       	.word	0x0065	; ????
 8a2:	62 61       	ori	r22, 0x12	; 18
 8a4:	73 65       	ori	r23, 0x53	; 83
 8a6:	00 4c       	sbci	r16, 0xC0	; 192
 8a8:	69 71       	andi	r22, 0x19	; 25
 8aa:	75 69       	ori	r23, 0x95	; 149
 8ac:	64 43       	sbci	r22, 0x34	; 52
 8ae:	72 79       	andi	r23, 0x92	; 146
 8b0:	73 74       	andi	r23, 0x43	; 67
 8b2:	61 6c       	ori	r22, 0xC1	; 193
 8b4:	00 6d       	ori	r16, 0xD0	; 208
 8b6:	69 63       	ori	r22, 0x39	; 57
 8b8:	72 6f       	ori	r23, 0xF2	; 242
 8ba:	73 00       	.word	0x0073	; ????
 8bc:	5f 73       	andi	r21, 0x3F	; 63
 8be:	74 61       	ori	r23, 0x14	; 20
 8c0:	72 74       	andi	r23, 0x42	; 66
 8c2:	54 69       	ori	r21, 0x94	; 148
 8c4:	6d 65       	ori	r22, 0x5D	; 93
 8c6:	5f 6d       	ori	r21, 0xDF	; 223
 8c8:	73 00       	.word	0x0073	; ????
 8ca:	74 77       	andi	r23, 0x74	; 116
 8cc:	69 5f       	subi	r22, 0xF9	; 249
 8ce:	72 65       	ori	r23, 0x52	; 82
 8d0:	70 6c       	ori	r23, 0xC0	; 192
 8d2:	79 00       	.word	0x0079	; ????
 8d4:	73 65       	ori	r23, 0x53	; 83
 8d6:	74 42       	sbci	r23, 0x24	; 36
 8d8:	61 63       	ori	r22, 0x31	; 49
 8da:	6b 6c       	ori	r22, 0xCB	; 203
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
 8dc:	69 67       	ori	r22, 0x79	; 121
 8de:	68 74       	andi	r22, 0x48	; 72
 8e0:	50 69       	ori	r21, 0x90	; 144

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
 8e2:	6e 00       	.word	0x006e	; ????
 8e4:	63 6f       	ori	r22, 0xF3	; 243
 8e6:	6d 6d       	ori	r22, 0xDD	; 221
 8e8:	61 6e       	ori	r22, 0xE1	; 225
 8ea:	64 00       	.word	0x0064	; ????

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	0e 01       	movw	r0, r28
       2:	00 00       	nop
       4:	20 01       	movw	r4, r0
       6:	00 00       	nop
       8:	01 00       	.word	0x0001	; ????
       a:	68 20       	and	r6, r8
       c:	01 00       	.word	0x0001	; ????
       e:	00 4c       	sbci	r16, 0xC0	; 192
      10:	01 00       	.word	0x0001	; ????
      12:	00 04       	cpc	r0, r0
      14:	00 f3       	brcs	.-64     	; 0xffffffd6 <__eeprom_end+0xff7effd6>
      16:	01 68       	ori	r16, 0x81	; 129
      18:	9f 00       	.word	0x009f	; ????
      1a:	00 00       	nop
      1c:	00 00       	nop
      1e:	00 00       	nop
      20:	00 20       	and	r0, r0
      22:	01 00       	.word	0x0001	; ????
      24:	00 2a       	or	r0, r16
      26:	01 00       	.word	0x0001	; ????
      28:	00 01       	movw	r0, r0
      2a:	00 68       	ori	r16, 0x80	; 128
	...
      34:	34 01       	movw	r6, r8
      36:	00 00       	nop
      38:	4a 01       	movw	r8, r20
      3a:	00 00       	nop
      3c:	06 00       	.word	0x0006	; ????
      3e:	6a 93       	st	-Y, r22
      40:	01 6b       	ori	r16, 0xB1	; 177
      42:	93 01       	movw	r18, r6
	...
      4c:	10 01       	movw	r2, r0
      4e:	00 00       	nop
      50:	16 01       	movw	r2, r12
      52:	00 00       	nop
      54:	09 00       	.word	0x0009	; ????
      56:	88 00       	.word	0x0088	; ????
      58:	03 a4       	ldd	r0, Z+43	; 0x2b
      5a:	00 00       	nop
      5c:	00 22       	and	r0, r16
      5e:	9f 16       	cp	r9, r31
      60:	01 00       	.word	0x0001	; ????
      62:	00 1a       	sub	r0, r16
      64:	01 00       	.word	0x0001	; ????
      66:	00 06       	cpc	r0, r16
      68:	00 6e       	ori	r16, 0xE0	; 224
      6a:	93 01       	movw	r18, r6
      6c:	6f 93       	push	r22
      6e:	01 1a       	sub	r0, r17
      70:	01 00       	.word	0x0001	; ????
      72:	00 20       	and	r0, r0
      74:	01 00       	.word	0x0001	; ????
      76:	00 09       	sbc	r16, r0
      78:	00 88       	ldd	r0, Z+16	; 0x10
      7a:	00 03       	mulsu	r16, r16
      7c:	a4 00       	.word	0x00a4	; ????
      7e:	00 00       	nop
      80:	22 9f       	mul	r18, r18
      82:	20 01       	movw	r4, r0
      84:	00 00       	nop
      86:	2c 01       	movw	r4, r24
      88:	00 00       	nop
      8a:	0f 00       	.word	0x000f	; ????
      8c:	8e 00       	.word	0x008e	; ????
      8e:	03 a4       	ldd	r0, Z+43	; 0x2b
      90:	00 00       	nop
      92:	00 22       	and	r0, r16
      94:	03 90       	.word	0x9003	; ????
      96:	00 00       	nop
      98:	00 1c       	adc	r0, r0
      9a:	9f 00       	.word	0x009f	; ????
      9c:	00 00       	nop
      9e:	00 00       	nop
      a0:	00 00       	nop
      a2:	00 18       	sub	r0, r0
      a4:	01 00       	.word	0x0001	; ????
      a6:	00 1e       	adc	r0, r16
      a8:	01 00       	.word	0x0001	; ????
      aa:	00 09       	sbc	r16, r0
      ac:	00 88       	ldd	r0, Z+16	; 0x10
      ae:	00 03       	mulsu	r16, r16
      b0:	90 00       	.word	0x0090	; ????
      b2:	00 00       	nop
      b4:	22 9f       	mul	r18, r18
      b6:	1e 01       	movw	r2, r28
      b8:	00 00       	nop
      ba:	2c 01       	movw	r4, r24
      bc:	00 00       	nop
      be:	06 00       	.word	0x0006	; ????
      c0:	6e 93       	st	-X, r22
      c2:	01 6f       	ori	r16, 0xF1	; 241
      c4:	93 01       	movw	r18, r6
	...
      ce:	30 01       	movw	r6, r0
      d0:	00 00       	nop
      d2:	34 01       	movw	r6, r8
      d4:	00 00       	nop
      d6:	06 00       	.word	0x0006	; ????
      d8:	6e 93       	st	-X, r22
      da:	01 6f       	ori	r16, 0xF1	; 241
      dc:	93 01       	movw	r18, r6
	...
      e6:	3a 01       	movw	r6, r20
      e8:	00 00       	nop
      ea:	3e 01       	movw	r6, r28
      ec:	00 00       	nop
      ee:	06 00       	.word	0x0006	; ????
      f0:	6e 93       	st	-X, r22
      f2:	01 6f       	ori	r16, 0xF1	; 241
      f4:	93 01       	movw	r18, r6
	...
      fe:	40 01       	movw	r8, r0
     100:	00 00       	nop
     102:	4a 01       	movw	r8, r20
     104:	00 00       	nop
     106:	01 00       	.word	0x0001	; ????
     108:	68 00       	.word	0x0068	; ????
     10a:	00 00       	nop
     10c:	00 00       	nop
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
     10e:	00 00       	nop
     110:	00 4c       	sbci	r16, 0xC0	; 192
     112:	01 00       	.word	0x0001	; ????
     114:	00 80       	ld	r0, Z
     116:	01 00       	.word	0x0001	; ????
	uint8_t port = digitalPinToPort(pin);
     118:	00 01       	movw	r0, r0
     11a:	00 68       	ori	r16, 0x80	; 128
     11c:	80 01       	movw	r16, r0
     11e:	00 00       	nop
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     120:	84 01       	movw	r16, r8
     122:	00 00       	nop

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     124:	04 00       	.word	0x0004	; ????
     126:	f3 01       	movw	r30, r6
     128:	68 9f       	mul	r22, r24
     12a:	84 01       	movw	r16, r8
     12c:	00 00       	nop
     12e:	94 01       	movw	r18, r8
     130:	00 00       	nop
     132:	01 00       	.word	0x0001	; ????
	out = portOutputRegister(port);
     134:	68 94       	set
     136:	01 00       	.word	0x0001	; ????
     138:	00 98       	cbi	0x00, 0	; 0
     13a:	01 00       	.word	0x0001	; ????
     13c:	00 04       	cpc	r0, r0
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
     13e:	00 f3       	brcs	.-64     	; 0x100 <__do_global_ctors+0x14>
                cli();
     140:	01 68       	ori	r16, 0x81	; 129
		*reg |= bit;
     142:	9f 98       	cbi	0x13, 7	; 19
     144:	01 00       	.word	0x0001	; ????
     146:	00 9c       	mul	r0, r0
		SREG = oldSREG;
     148:	01 00       	.word	0x0001	; ????
     14a:	00 01       	movw	r0, r0
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
     14c:	00 68       	ori	r16, 0x80	; 128
     14e:	9c 01       	movw	r18, r24
     150:	00 00       	nop
     152:	a4 01       	movw	r20, r8
     154:	00 00       	nop
	uint8_t bit = digitalPinToBitMask(pin);
     156:	04 00       	.word	0x0004	; ????
     158:	f3 01       	movw	r30, r6
     15a:	68 9f       	mul	r22, r24
     15c:	a4 01       	movw	r20, r8
	uint8_t port = digitalPinToPort(pin);
     15e:	00 00       	nop
     160:	a6 01       	movw	r20, r12
     162:	00 00       	nop
     164:	01 00       	.word	0x0001	; ????
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     166:	68 a6       	std	Y+40, r6	; 0x28
     168:	01 00       	.word	0x0001	; ????
     16a:	00 ac       	ldd	r0, Z+56	; 0x38

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     16c:	01 00       	.word	0x0001	; ????
     16e:	00 04       	cpc	r0, r0
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     170:	00 f3       	brcs	.-64     	; 0x132 <pinMode.constprop.41+0x24>
     172:	01 68       	ori	r16, 0x81	; 129
     174:	9f ac       	ldd	r9, Y+63	; 0x3f
     176:	01 00       	.word	0x0001	; ????
     178:	00 b0       	in	r0, 0x00	; 0
     17a:	01 00       	.word	0x0001	; ????
     17c:	00 01       	movw	r0, r0
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     17e:	00 68       	ori	r16, 0x80	; 128
     180:	b0 01       	movw	r22, r0
     182:	00 00       	nop
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     184:	b4 01       	movw	r22, r8
     186:	00 00       	nop
     188:	04 00       	.word	0x0004	; ????
     18a:	f3 01       	movw	r30, r6
     18c:	68 9f       	mul	r22, r24
     18e:	b4 01       	movw	r22, r8
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     190:	00 00       	nop
     192:	b8 01       	movw	r22, r16
     194:	00 00       	nop
     196:	01 00       	.word	0x0001	; ????
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     198:	68 b8       	out	0x08, r6	; 8
     19a:	01 00       	.word	0x0001	; ????
     19c:	00 e6       	ldi	r16, 0x60	; 96
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     19e:	01 00       	.word	0x0001	; ????
     1a0:	00 04       	cpc	r0, r0
     1a2:	00 f3       	brcs	.-64     	; 0x164 <digitalWrite+0x18>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     1a4:	01 68       	ori	r16, 0x81	; 129
     1a6:	9f 00       	.word	0x009f	; ????
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     1a8:	00 00       	nop
     1aa:	00 00       	nop
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     1ac:	00 00       	nop
     1ae:	00 5e       	subi	r16, 0xE0	; 224
     1b0:	01 00       	.word	0x0001	; ????
     1b2:	00 d8       	rcall	.-4096   	; 0xfffff1b4 <__eeprom_end+0xff7ef1b4>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     1b4:	01 00       	.word	0x0001	; ????
     1b6:	00 01       	movw	r0, r0
     1b8:	00 63       	ori	r16, 0x30	; 48
     1ba:	d8 01       	movw	r26, r16
     1bc:	00 00       	nop

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
     1be:	da 01       	movw	r26, r20
     1c0:	00 00       	nop
     1c2:	04 00       	.word	0x0004	; ????
     1c4:	83 00       	.word	0x0083	; ????
     1c6:	20 9f       	mul	r18, r16
     1c8:	dc 01       	movw	r26, r24
     1ca:	00 00       	nop

	uint8_t oldSREG = SREG;
     1cc:	e0 01       	movw	r28, r0
	cli();
     1ce:	00 00       	nop

	if (val == LOW) {
     1d0:	01 00       	.word	0x0001	; ????
     1d2:	63 00       	.word	0x0063	; ????
		*out &= ~bit;
     1d4:	00 00       	nop
     1d6:	00 00       	nop
     1d8:	00 00       	nop
     1da:	00 66       	ori	r16, 0x60	; 96
	} else {
		*out |= bit;
     1dc:	01 00       	.word	0x0001	; ????
     1de:	00 c4       	rjmp	.+2048   	; 0x9e0 <__stack+0xe1>
     1e0:	01 00       	.word	0x0001	; ????
	}

	SREG = oldSREG;
     1e2:	00 01       	movw	r0, r0
     1e4:	00 6e       	ori	r16, 0xE0	; 224
	...
   digitalWrite(_enable_pin, LOW);
}

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
     1ee:	cc 01       	movw	r24, r24
     1f0:	00 00       	nop
     1f2:	e4 01       	movw	r28, r8
     1f4:	00 00       	nop
     1f6:	06 00       	.word	0x0006	; ????
     1f8:	6a 93       	st	-Y, r22
     1fa:	01 6b       	ori	r16, 0xB1	; 177
     1fc:	93 01       	movw	r18, r6
	...
     206:	ce 01       	movw	r24, r28
     208:	00 00       	nop
     20a:	e4 01       	movw	r28, r8
{
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
     20c:	00 00       	nop
     20e:	01 00       	.word	0x0001	; ????

//
// write4bits
void LiquidCrystal::writeNbits(uint8_t value, uint8_t numBits) 
{
   for (uint8_t i = 0; i < numBits; i++) 
     210:	69 00       	.word	0x0069	; ????
     212:	00 00       	nop
     214:	00 00       	nop
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
     216:	00 00       	nop
     218:	00 4e       	sbci	r16, 0xE0	; 224
     21a:	01 00       	.word	0x0001	; ????
     21c:	00 54       	subi	r16, 0x40	; 64
     21e:	01 00       	.word	0x0001	; ????
     220:	00 09       	sbc	r16, r0
     222:	00 88       	ldd	r0, Z+16	; 0x10
     224:	00 03       	mulsu	r16, r16
     226:	68 00       	.word	0x0068	; ????
     228:	00 00       	nop
     22a:	22 9f       	mul	r18, r18
     22c:	54 01       	movw	r10, r8
     22e:	00 00       	nop
     230:	58 01       	movw	r10, r16
     232:	00 00       	nop
// pulseEnable
void LiquidCrystal::pulseEnable(void) 
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
     234:	06 00       	.word	0x0006	; ????
     236:	6e 93       	st	-X, r22
     238:	01 6f       	ori	r16, 0xF1	; 241
     23a:	93 01       	movw	r18, r6
     23c:	58 01       	movw	r10, r16
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
     23e:	00 00       	nop
     240:	80 01       	movw	r16, r0
     242:	00 00       	nop
   for (uint8_t i = 0; i < numBits; i++) 
   {
      digitalWrite(_data_pins[i], (value >> i) & 0x01);
   }
   pulseEnable();
}
     244:	09 00       	.word	0x0009	; ????
     246:	88 00       	.word	0x0088	; ????
     248:	03 68       	ori	r16, 0x83	; 131
     24a:	00 00       	nop
     24c:	00 22       	and	r0, r16
     24e:	9f 84       	ldd	r9, Y+15	; 0x0f
     250:	01 00       	.word	0x0001	; ????
     252:	00 94       	com	r0
     254:	01 00       	.word	0x0001	; ????
     256:	00 09       	sbc	r16, r0
{
   // There is no need for the delays, since the digitalWrite operation
   // takes longer.
   digitalWrite(_enable_pin, HIGH);   
   waitUsec(1);          // enable pulse must be > 450ns   
   digitalWrite(_enable_pin, LOW);
     258:	00 88       	ldd	r0, Z+16	; 0x10
     25a:	00 03       	mulsu	r16, r16
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     25c:	68 00       	.word	0x0068	; ????
	
	cli();
     25e:	00 00       	nop
	m = timer0_overflow_count;
     260:	22 9f       	mul	r18, r18
     262:	98 01       	movw	r18, r16
     264:	00 00       	nop
     266:	9c 01       	movw	r18, r24
     268:	00 00       	nop
     26a:	09 00       	.word	0x0009	; ????
     26c:	88 00       	.word	0x0088	; ????
     26e:	03 68       	ori	r16, 0x83	; 131
#if defined(TCNT0)
	t = TCNT0;
     270:	00 00       	nop
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     272:	00 22       	and	r0, r16
     274:	9f a4       	ldd	r9, Y+47	; 0x2f
     276:	01 00       	.word	0x0001	; ????
     278:	00 a6       	std	Z+40, r0	; 0x28
		m++;
     27a:	01 00       	.word	0x0001	; ????
     27c:	00 09       	sbc	r16, r0
     27e:	00 88       	ldd	r0, Z+16	; 0x10
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     280:	00 03       	mulsu	r16, r16
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     282:	68 00       	.word	0x0068	; ????
     284:	00 00       	nop
     286:	22 9f       	mul	r18, r18
     288:	ac 01       	movw	r20, r24
     28a:	00 00       	nop
     28c:	b0 01       	movw	r22, r0
     28e:	00 00       	nop
     290:	09 00       	.word	0x0009	; ????
     292:	88 00       	.word	0x0088	; ????
     294:	03 68       	ori	r16, 0x83	; 131
     296:	00 00       	nop
     298:	00 22       	and	r0, r16
     29a:	9f b4       	in	r9, 0x2f	; 47
     29c:	01 00       	.word	0x0001	; ????
     29e:	00 b8       	out	0x00, r0	; 0
     2a0:	01 00       	.word	0x0001	; ????
     2a2:	00 09       	sbc	r16, r0
}
     2a4:	00 88       	ldd	r0, Z+16	; 0x10

void delay(unsigned long ms)
{
     2a6:	00 03       	mulsu	r16, r16
     2a8:	68 00       	.word	0x0068	; ????
     2aa:	00 00       	nop
     2ac:	22 9f       	mul	r18, r18
	...
     2b6:	56 01       	movw	r10, r12
     2b8:	00 00       	nop
	uint32_t start = micros();
     2ba:	5c 01       	movw	r10, r24
     2bc:	00 00       	nop
     2be:	09 00       	.word	0x0009	; ????
     2c0:	88 00       	.word	0x0088	; ????

	while (ms > 0) {
     2c2:	03 a4       	ldd	r0, Z+43	; 0x2b
     2c4:	00 00       	nop
     2c6:	00 22       	and	r0, r16
     2c8:	9f 5c       	subi	r25, 0xCF	; 207
     2ca:	01 00       	.word	0x0001	; ????
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     2cc:	00 60       	ori	r16, 0x00	; 0
     2ce:	01 00       	.word	0x0001	; ????
     2d0:	00 06       	cpc	r0, r16
     2d2:	00 6e       	ori	r16, 0xE0	; 224
     2d4:	93 01       	movw	r18, r6
     2d6:	6f 93       	push	r22
     2d8:	01 60       	ori	r16, 0x01	; 1
     2da:	01 00       	.word	0x0001	; ????
     2dc:	00 80       	ld	r0, Z
     2de:	01 00       	.word	0x0001	; ????
     2e0:	00 09       	sbc	r16, r0
     2e2:	00 88       	ldd	r0, Z+16	; 0x10
     2e4:	00 03       	mulsu	r16, r16
			ms--;
     2e6:	a4 00       	.word	0x00a4	; ????
     2e8:	00 00       	nop
     2ea:	22 9f       	mul	r18, r18
     2ec:	84 01       	movw	r16, r8
     2ee:	00 00       	nop
			start += 1000;
     2f0:	94 01       	movw	r18, r8
     2f2:	00 00       	nop
     2f4:	09 00       	.word	0x0009	; ????
     2f6:	88 00       	.word	0x0088	; ????
     2f8:	03 a4       	ldd	r0, Z+43	; 0x2b
     2fa:	00 00       	nop
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     2fc:	00 22       	and	r0, r16
     2fe:	9f 98       	cbi	0x13, 7	; 19
     300:	01 00       	.word	0x0001	; ????
     302:	00 9c       	mul	r0, r0
     304:	01 00       	.word	0x0001	; ????
     306:	00 09       	sbc	r16, r0
			ms--;
			start += 1000;
		}
	}
}
     308:	00 88       	ldd	r0, Z+16	; 0x10
     30a:	00 03       	mulsu	r16, r16
     30c:	a4 00       	.word	0x00a4	; ????
     30e:	00 00       	nop
     310:	22 9f       	mul	r18, r18
     312:	a4 01       	movw	r20, r8
     314:	00 00       	nop
     316:	a6 01       	movw	r20, r12
     318:	00 00       	nop

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     31a:	09 00       	.word	0x0009	; ????
     31c:	88 00       	.word	0x0088	; ????
     31e:	03 a4       	ldd	r0, Z+43	; 0x2b
     320:	00 00       	nop
     322:	00 22       	and	r0, r16
     324:	9f ac       	ldd	r9, Y+63	; 0x3f
     326:	01 00       	.word	0x0001	; ????
     328:	00 b0       	in	r0, 0x00	; 0
     32a:	01 00       	.word	0x0001	; ????
     32c:	00 09       	sbc	r16, r0
     32e:	00 88       	ldd	r0, Z+16	; 0x10
  size_t n = 0;
     330:	00 03       	mulsu	r16, r16
     332:	a4 00       	.word	0x00a4	; ????
  while (size--) {
     334:	00 00       	nop
     336:	22 9f       	mul	r18, r18
     338:	b4 01       	movw	r22, r8
    if (write(*buffer++)) n++;
     33a:	00 00       	nop
     33c:	b8 01       	movw	r22, r16
     33e:	00 00       	nop
     340:	09 00       	.word	0x0009	; ????
     342:	88 00       	.word	0x0088	; ????
     344:	03 a4       	ldd	r0, Z+43	; 0x2b
     346:	00 00       	nop
     348:	00 22       	and	r0, r16
     34a:	9f 00       	.word	0x009f	; ????
     34c:	00 00       	nop
     34e:	00 00       	nop
     350:	00 00       	nop
     352:	00 5e       	subi	r16, 0xE0	; 224
     354:	01 00       	.word	0x0001	; ????
     356:	00 64       	ori	r16, 0x40	; 64
     358:	01 00       	.word	0x0001	; ????
    else break;
  }
  return n;
}
     35a:	00 09       	sbc	r16, r0
     35c:	00 88       	ldd	r0, Z+16	; 0x10
     35e:	00 03       	mulsu	r16, r16
     360:	90 00       	.word	0x0090	; ????
     362:	00 00       	nop
     364:	22 9f       	mul	r18, r18
     366:	64 01       	movw	r12, r8
     368:	00 00       	nop
     36a:	66 01       	movw	r12, r12
     36c:	00 00       	nop
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
     36e:	06 00       	.word	0x0006	; ????
     370:	6e 93       	st	-X, r22
     372:	01 6f       	ori	r16, 0xF1	; 241

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
     374:	93 01       	movw	r18, r6
     376:	66 01       	movw	r12, r12
     378:	00 00       	nop
     37a:	80 01       	movw	r16, r0
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
     37c:	00 00       	nop
     37e:	09 00       	.word	0x0009	; ????
     380:	88 00       	.word	0x0088	; ????
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
     382:	03 90       	.word	0x9003	; ????
     384:	00 00       	nop
     386:	00 22       	and	r0, r16
     388:	9f 84       	ldd	r9, Y+15	; 0x0f
     38a:	01 00       	.word	0x0001	; ????
     38c:	00 94       	com	r0
     38e:	01 00       	.word	0x0001	; ????
     390:	00 09       	sbc	r16, r0
     392:	00 88       	ldd	r0, Z+16	; 0x10
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
     394:	00 03       	mulsu	r16, r16
     396:	90 00       	.word	0x0090	; ????
     398:	00 00       	nop
     39a:	22 9f       	mul	r18, r18
     39c:	98 01       	movw	r18, r16
     39e:	00 00       	nop
     3a0:	9c 01       	movw	r18, r24
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
     3a2:	00 00       	nop
     3a4:	09 00       	.word	0x0009	; ????
    twi_txBuffer[twi_txBufferLength+i] = data[i];
     3a6:	88 00       	.word	0x0088	; ????
     3a8:	03 90       	.word	0x9003	; ????
     3aa:	00 00       	nop
     3ac:	00 22       	and	r0, r16
     3ae:	9f a4       	ldd	r9, Y+47	; 0x2f
     3b0:	01 00       	.word	0x0001	; ????
     3b2:	00 a6       	std	Z+40, r0	; 0x28
     3b4:	01 00       	.word	0x0001	; ????
     3b6:	00 09       	sbc	r16, r0
     3b8:	00 88       	ldd	r0, Z+16	; 0x10
     3ba:	00 03       	mulsu	r16, r16
  }
  twi_txBufferLength += length;
     3bc:	90 00       	.word	0x0090	; ????
     3be:	00 00       	nop
     3c0:	22 9f       	mul	r18, r18
     3c2:	ac 01       	movw	r20, r24
     3c4:	00 00       	nop
     3c6:	b0 01       	movw	r22, r0
     3c8:	00 00       	nop
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
     3ca:	09 00       	.word	0x0009	; ????
     3cc:	88 00       	.word	0x0088	; ????
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
     3ce:	03 90       	.word	0x9003	; ????
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
     3d0:	00 00       	nop

  return value;
}

void TwoWire::flush(void)
{
     3d2:	00 22       	and	r0, r16
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     3d4:	9f b4       	in	r9, 0x2f	; 47
     3d6:	01 00       	.word	0x0001	; ????
     3d8:	00 b8       	out	0x00, r0	; 0
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
     3da:	01 00       	.word	0x0001	; ????
     3dc:	00 09       	sbc	r16, r0
     3de:	00 88       	ldd	r0, Z+16	; 0x10
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
     3e0:	00 03       	mulsu	r16, r16
     3e2:	90 00       	.word	0x0090	; ????
     3e4:	00 00       	nop
}
     3e6:	22 9f       	mul	r18, r18
	...

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     3f0:	70 01       	movw	r14, r0
     3f2:	00 00       	nop
     3f4:	be 01       	movw	r22, r28
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
     3f6:	00 00       	nop
     3f8:	01 00       	.word	0x0001	; ????
     3fa:	62 00       	.word	0x0062	; ????
  }
  return quantity;
}
     3fc:	00 00       	nop
     3fe:	00 00       	nop
     400:	00 00       	nop
     402:	00 c8       	rjmp	.-4096   	; 0xfffff404 <__eeprom_end+0xff7ef404>

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
     404:	01 00       	.word	0x0001	; ????
     406:	00 cc       	rjmp	.-2048   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
     408:	01 00       	.word	0x0001	; ????
     40a:	00 06       	cpc	r0, r16
     40c:	00 6e       	ori	r16, 0xE0	; 224
     40e:	93 01       	movw	r18, r6
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
     410:	6f 93       	push	r22
     412:	01 00       	.word	0x0001	; ????
     414:	00 00       	nop
     416:	00 00       	nop
     418:	00 00       	nop
  }
  return 1;
}
     41a:	00 e6       	ldi	r16, 0x60	; 96
     41c:	01 00       	.word	0x0001	; ????
     41e:	00 e8       	ldi	r16, 0x80	; 128
     420:	01 00       	.word	0x0001	; ????
     422:	00 03       	mulsu	r16, r16
     424:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
// setBackligh
void LiquidCrystal::setBacklight ( uint8_t value )
{
   // Check if there is a pin assigned to the backlight
   // ---------------------------------------------------
   if ( _backlightPin != LCD_NOBACKLIGHT )
     428:	e8 01       	movw	r28, r16
     42a:	00 00       	nop
     42c:	ea 01       	movw	r28, r20
     42e:	00 00       	nop
     430:	03 00       	.word	0x0003	; ????
         }
      }
      // Not a PWM pin, set the backlight pin for POSI or NEG
      // polarity
      // --------------------------------------------------------
      else if (((value > 0) && (_polarity == POSITIVE)) ||
     432:	92 20       	and	r9, r2
     434:	03 ea       	ldi	r16, 0xA3	; 163
     436:	01 00       	.word	0x0001	; ????
     438:	00 ec       	ldi	r16, 0xC0	; 192
     43a:	01 00       	.word	0x0001	; ????
               ((value == 0) && (_polarity == NEGATIVE)))
     43c:	00 03       	mulsu	r16, r16
     43e:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
      {
         digitalWrite( _backlightPin, HIGH);
     442:	ec 01       	movw	r28, r24
     444:	00 00       	nop
      }
      else
      {
         digitalWrite( _backlightPin, LOW);
     446:	ee 01       	movw	r28, r28
     448:	00 00       	nop
     44a:	03 00       	.word	0x0003	; ????
     44c:	92 20       	and	r9, r2
}

//
// setBacklightPin
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
     44e:	05 ee       	ldi	r16, 0xE5	; 229
     450:	01 00       	.word	0x0001	; ????
     452:	00 f0       	brcs	.+0      	; 0x454 <_ZN13LiquidCrystal15setBacklightPinEh14t_backlightPol+0x6>
     454:	01 00       	.word	0x0001	; ????
     456:	00 03       	mulsu	r16, r16
     458:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>
     45c:	f0 01       	movw	r30, r0
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
     45e:	00 00       	nop
     460:	f2 01       	movw	r30, r4
     462:	00 00       	nop
   _backlightPin = pin;
     464:	03 00       	.word	0x0003	; ????
   _polarity = pol;
     466:	92 20       	and	r9, r2
     468:	07 f2       	brie	.-128    	; 0x3ea <_ZN7TwoWire9availableEv+0xa>
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
     46a:	01 00       	.word	0x0001	; ????
     46c:	00 f4       	brcc	.+0      	; 0x46e <_ZN13LiquidCrystal15setBacklightPinEh14t_backlightPol+0x20>
     46e:	01 00       	.word	0x0001	; ????
     470:	00 03       	mulsu	r16, r16
     472:	00 92 20 08 	sts	0x0820, r0	; 0x800820 <__bss_end+0x63f>
     476:	f4 01       	movw	r30, r8
}
     478:	00 00       	nop
     47a:	f6 01       	movw	r30, r12
     47c:	00 00       	nop
     47e:	03 00       	.word	0x0003	; ????
     480:	92 20       	and	r9, r2
void LiquidCrystal::setBacklightPin ( uint8_t pin, t_backlightPol pol )
{
   pinMode ( pin, OUTPUT );       // Difine the backlight pin as output
   _backlightPin = pin;
   _polarity = pol;
   setBacklight(BACKLIGHT_OFF);   // Set the backlight low by default
     482:	09 f6       	brne	.-126    	; 0x406 <_ZN7TwoWire5writeEh+0x2>

/************ low level data pushing commands **********/
//
// send
void LiquidCrystal::send(uint8_t value, uint8_t mode) 
{
     484:	01 00       	.word	0x0001	; ????
     486:	00 f8       	bld	r0, 0
     488:	01 00       	.word	0x0001	; ????
     48a:	00 03       	mulsu	r16, r16
     48c:	00 92 20 0a 	sts	0x0A20, r0	; 0x800a20 <__bss_end+0x83f>
     490:	f8 01       	movw	r30, r16
   // Only interested in COMMAND or DATA
   digitalWrite( _rs_pin, ( mode == LCD_DATA ) );
     492:	00 00       	nop
     494:	fa 01       	movw	r30, r20
     496:	00 00       	nop
     498:	03 00       	.word	0x0003	; ????
     49a:	92 20       	and	r9, r2
     49c:	0b fa       	.word	0xfa0b	; ????
     49e:	01 00       	.word	0x0001	; ????
   
   // if there is a RW pin indicated, set it low to Write
   // ---------------------------------------------------
   if (_rw_pin != 255) 
     4a0:	00 5c       	subi	r16, 0xC0	; 192
     4a2:	02 00       	.word	0x0002	; ????
     4a4:	00 03       	mulsu	r16, r16
   { 
      digitalWrite(_rw_pin, LOW);
     4a6:	00 92 20 0c 	sts	0x0C20, r0	; 0x800c20 <__bss_end+0xa3f>
	...
   }
   
   if ( mode != FOUR_BITS )
   {   
      if ( (_displayfunction & LCD_8BITMODE ) )
     4b2:	e6 01       	movw	r28, r12
     4b4:	00 00       	nop
      {
         writeNbits(value, 8); 
     4b6:	04 02       	muls	r16, r20
     4b8:	00 00       	nop
      } 
      else 
      {
         writeNbits ( value >> 4, 4 );
     4ba:	06 00       	.word	0x0006	; ????
     4bc:	68 93       	.word	0x9368	; ????
     4be:	01 69       	ori	r16, 0x91	; 145
     4c0:	93 01       	movw	r18, r6
     4c2:	04 02       	muls	r16, r20
     4c4:	00 00       	nop
     4c6:	4c 02       	muls	r20, r28
     4c8:	00 00       	nop
     4ca:	06 00       	.word	0x0006	; ????
     4cc:	60 93 01 61 	sts	0x6101, r22	; 0x806101 <__bss_end+0x5f20>
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
     4d0:	93 01       	movw	r18, r6
     4d2:	4c 02       	muls	r20, r28
     4d4:	00 00       	nop
   }
   waitUsec ( EXEC_TIME ); // wait for the command to execute by the LCD
}
     4d6:	5b 02       	muls	r21, r27
     4d8:	00 00       	nop
     4da:	06 00       	.word	0x0006	; ????
     4dc:	6e 93       	st	-X, r22
         writeNbits ( value, 4 );
      }
   } 
   else 
   {
      writeNbits ( value, 4 );
     4de:	01 6f       	ori	r16, 0xF1	; 241
     4e0:	93 01       	movw	r18, r6
   send(value, LCD_DATA);
}
#else
size_t LCD::write(uint8_t value) 
{
   send(value, LCD_DATA);
     4e2:	5b 02       	muls	r21, r27
     4e4:	00 00       	nop
     4e6:	5c 02       	muls	r21, r28
     4e8:	00 00       	nop
     4ea:	04 00       	.word	0x0004	; ????
     4ec:	f3 01       	movw	r30, r6
     4ee:	68 9f       	mul	r22, r24
	...

// General LCD commands - generic methods used by the rest of the commands
// ---------------------------------------------------------------------------
void LCD::command(uint8_t value) 
{
   send(value, COMMAND);
     4f8:	e6 01       	movw	r28, r12
     4fa:	00 00       	nop
     4fc:	10 02       	muls	r17, r16
     4fe:	00 00       	nop
     500:	01 00       	.word	0x0001	; ????
     502:	66 10       	cpse	r6, r6
     504:	02 00       	.word	0x0002	; ????
     506:	00 50       	subi	r16, 0x00	; 0
{
   command(LCD_RETURNHOME);             // set cursor position to zero
   delayMicroseconds(HOME_CLEAR_EXEC);  // This command is time consuming
}

void LCD::setCursor(uint8_t col, uint8_t row)
     508:	02 00       	.word	0x0002	; ????
     50a:	00 01       	movw	r0, r0
     50c:	00 5e       	subi	r16, 0xE0	; 224
     50e:	50 02       	muls	r21, r16
     510:	00 00       	nop
     512:	5c 02       	muls	r21, r28
     514:	00 00       	nop
     516:	04 00       	.word	0x0004	; ????
     518:	f3 01       	movw	r30, r6
     51a:	66 9f       	mul	r22, r22
	...
{
   const byte row_offsetsDef[]   = { 0x00, 0x40, 0x14, 0x54 }; // For regular LCDs
     524:	e6 01       	movw	r28, r12
     526:	00 00       	nop
     528:	10 02       	muls	r17, r16
     52a:	00 00       	nop
     52c:	01 00       	.word	0x0001	; ????
     52e:	64 10       	cpse	r6, r4
     530:	02 00       	.word	0x0002	; ????
     532:	00 54       	subi	r16, 0x40	; 64
   const byte row_offsetsLarge[] = { 0x00, 0x40, 0x10, 0x50 }; // For 16x4 LCDs
     534:	02 00       	.word	0x0002	; ????
     536:	00 01       	movw	r0, r0
     538:	00 5c       	subi	r16, 0xC0	; 192
     53a:	54 02       	muls	r21, r20
     53c:	00 00       	nop
     53e:	5c 02       	muls	r21, r28
     540:	00 00       	nop
     542:	04 00       	.word	0x0004	; ????
     544:	f3 01       	movw	r30, r6
     546:	64 9f       	mul	r22, r20
	...
   
   if ( row >= _numlines ) 
     550:	10 02       	muls	r17, r16
     552:	00 00       	nop
   {
      row = _numlines-1;    // rows start at 0
     554:	30 02       	muls	r19, r16
     556:	00 00       	nop
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
     558:	01 00       	.word	0x0001	; ????
     55a:	6c 30       	cpi	r22, 0x0C	; 12
     55c:	02 00       	.word	0x0002	; ????
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
     55e:	00 32       	cpi	r16, 0x20	; 32
     560:	02 00       	.word	0x0002	; ????
     562:	00 03       	mulsu	r16, r16
      row = _numlines-1;    // rows start at 0
   }
   
   // 16x4 LCDs have special memory map layout
   // ----------------------------------------
   if ( _cols == 16 && _numlines == 4 )
     564:	00 8c       	ldd	r0, Z+24	; 0x18
     566:	01 9f       	mul	r16, r17
     568:	32 02       	muls	r19, r18
     56a:	00 00       	nop
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
     56c:	48 02       	muls	r20, r24
     56e:	00 00       	nop
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
     570:	01 00       	.word	0x0001	; ????
     572:	6c 00       	.word	0x006c	; ????
     574:	00 00       	nop
     576:	00 00       	nop
   }
   
}
     578:	00 00       	nop
     57a:	00 34       	cpi	r16, 0x40	; 64
     57c:	02 00       	.word	0x0002	; ????
     57e:	00 4c       	sbci	r16, 0xC0	; 192
     580:	02 00       	.word	0x0002	; ????
     582:	00 06       	cpc	r0, r16
     584:	00 60       	ori	r16, 0x00	; 0
     586:	93 01       	movw	r18, r6
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsLarge[row]));
   }
   else 
   {
      command(LCD_SETDDRAMADDR | (col + row_offsetsDef[row]));
     588:	61 93       	st	Z+, r22
     58a:	01 4c       	sbci	r16, 0xC1	; 193
// can't assume that its in that state when a application starts (and the
// LiquidCrystal constructor is called).
// A call to begin() will reinitialize the LCD.
//
void LCD::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) 
{
     58c:	02 00       	.word	0x0002	; ????
     58e:	00 5b       	subi	r16, 0xB0	; 176
     590:	02 00       	.word	0x0002	; ????
     592:	00 06       	cpc	r0, r16
     594:	00 6e       	ori	r16, 0xE0	; 224
   if (lines > 1) 
     596:	93 01       	movw	r18, r6
     598:	6f 93       	push	r22
   {
      _displayfunction |= LCD_2LINE;
     59a:	01 5b       	subi	r16, 0xB1	; 177
     59c:	02 00       	.word	0x0002	; ????
     59e:	00 5c       	subi	r16, 0xC0	; 192
   }
   _numlines = lines;
     5a0:	02 00       	.word	0x0002	; ????
   _cols = cols;
     5a2:	00 04       	cpc	r0, r0
   
   // for some 1 line displays you can select a 10 pixel high font
   // ------------------------------------------------------------
   if ((dotsize != LCD_5x8DOTS) && (lines == 1)) 
     5a4:	00 f3       	brcs	.-64     	; 0x566 <_ZN3LCD9setCursorEhh.constprop.36+0x5e>
     5a6:	01 68       	ori	r16, 0x81	; 129
     5a8:	9f 00       	.word	0x009f	; ????
     5aa:	00 00       	nop
   {
      _displayfunction |= LCD_5x10DOTS;
     5ac:	00 00       	nop
     5ae:	00 00       	nop
     5b0:	00 70       	andi	r16, 0x00	; 0
   // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
   // according to datasheet, we need at least 40ms after power rises above 2.7V
   // before sending commands. Arduino can turn on way before 4.5V so we'll wait 
   // 50
   // ---------------------------------------------------------------------------
   delay (100); // 100ms delay
     5b2:	02 00       	.word	0x0002	; ????
     5b4:	00 8a       	std	Z+16, r0	; 0x10
     5b6:	02 00       	.word	0x0002	; ????
     5b8:	00 0c       	add	r0, r0
     5ba:	00 68       	ori	r16, 0x80	; 128
     5bc:	93 01       	movw	r18, r6
   
   //put the LCD into 4 bit or 8 bit mode
   // -------------------------------------
   if (! (_displayfunction & LCD_8BITMODE)) 
     5be:	69 93       	st	Y+, r22
     5c0:	01 6a       	ori	r16, 0xA1	; 161
     5c2:	93 01       	movw	r18, r6
      // this is according to the hitachi HD44780 datasheet
      // figure 24, pg 46
      
      // we start in 8bit mode, try to set 4 bit mode
      // Special case of "Function Set"
      send(0x03, FOUR_BITS);
     5c4:	6b 93       	.word	0x936b	; ????
     5c6:	01 00       	.word	0x0001	; ????
     5c8:	00 00       	nop
     5ca:	00 00       	nop
     5cc:	00 00       	nop
     5ce:	00 5e       	subi	r16, 0xE0	; 224
     5d0:	02 00       	.word	0x0002	; ????
     5d2:	00 8a       	std	Z+16, r0	; 0x10
     5d4:	02 00       	.word	0x0002	; ????
	

#endif

	// busy wait
	__asm__ __volatile__ (
     5d6:	00 01       	movw	r0, r0
     5d8:	00 63       	ori	r16, 0x30	; 48
     5da:	8a 02       	muls	r24, r26
     5dc:	00 00       	nop
      delayMicroseconds(4500); // wait min 4.1ms
      
      // second try
      send ( 0x03, FOUR_BITS );
     5de:	a6 02       	muls	r26, r22
     5e0:	00 00       	nop
     5e2:	02 00       	.word	0x0002	; ????
     5e4:	08 5f       	subi	r16, 0xF8	; 248
	...
     5ee:	a6 02       	muls	r26, r22
     5f0:	00 00       	nop
     5f2:	a8 02       	muls	r26, r24
     5f4:	00 00       	nop
     5f6:	03 00       	.word	0x0003	; ????
     5f8:	92 20       	and	r9, r2
      delayMicroseconds(150); // wait min 100us
      
      // third go!
      send( 0x03, FOUR_BITS );
     5fa:	02 a8       	ldd	r0, Z+50	; 0x32
     5fc:	02 00       	.word	0x0002	; ????
     5fe:	00 aa       	std	Z+48, r0	; 0x30
     600:	02 00       	.word	0x0002	; ????
     602:	00 03       	mulsu	r16, r16
     604:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x13f>
     608:	aa 02       	muls	r26, r26
     60a:	00 00       	nop
     60c:	ac 02       	muls	r26, r28
     60e:	00 00       	nop
     610:	03 00       	.word	0x0003	; ????
      delayMicroseconds(150); // wait min of 100us
      
      // finally, set to 4-bit interface
      send ( 0x02, FOUR_BITS );
     612:	92 20       	and	r9, r2
     614:	04 ac       	ldd	r0, Z+60	; 0x3c
     616:	02 00       	.word	0x0002	; ????
     618:	00 ae       	std	Z+56, r0	; 0x38
     61a:	02 00       	.word	0x0002	; ????
     61c:	00 03       	mulsu	r16, r16
     61e:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x33f>
     622:	ae 02       	muls	r26, r30
     624:	00 00       	nop
   {
      // this is according to the hitachi HD44780 datasheet
      // page 45 figure 23
      
      // Send function set command sequence
      command(LCD_FUNCTIONSET | _displayfunction);
     626:	b0 02       	muls	r27, r16
     628:	00 00       	nop
     62a:	03 00       	.word	0x0003	; ????
     62c:	92 20       	and	r9, r2
     62e:	06 b0       	in	r0, 0x06	; 6
     630:	02 00       	.word	0x0002	; ????
     632:	00 b2       	in	r0, 0x10	; 16
     634:	02 00       	.word	0x0002	; ????
      delayMicroseconds(4500);  // wait more than 4.1ms
      
      // second try
      command(LCD_FUNCTIONSET | _displayfunction);
     636:	00 03       	mulsu	r16, r16
     638:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x53f>
     63c:	b2 02       	muls	r27, r18
     63e:	00 00       	nop
     640:	b4 02       	muls	r27, r20
     642:	00 00       	nop
     644:	03 00       	.word	0x0003	; ????
     646:	92 20       	and	r9, r2
     648:	08 b4       	in	r0, 0x28	; 40
      delayMicroseconds(150);
      
      // third go
      command(LCD_FUNCTIONSET | _displayfunction);
     64a:	02 00       	.word	0x0002	; ????
     64c:	00 b6       	in	r0, 0x30	; 48
     64e:	02 00       	.word	0x0002	; ????
     650:	00 03       	mulsu	r16, r16
     652:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x73f>
     656:	b6 02       	muls	r27, r22
     658:	00 00       	nop
      delayMicroseconds(150);

   }
   
   // finally, set # lines, font size, etc.
   command(LCD_FUNCTIONSET | _displayfunction);
     65a:	1a 03       	fmul	r17, r18
     65c:	00 00       	nop
     65e:	03 00       	.word	0x0003	; ????
     660:	92 20       	and	r9, r2
     662:	0a 00       	.word	0x000a	; ????
     664:	00 00       	nop
     666:	00 00       	nop
     668:	00 00       	nop
     66a:	00 a6       	std	Z+40, r0	; 0x28
   delayMicroseconds ( 60 );  // wait more
   
   // turn the display on with no cursor or blinking default
   _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
     66c:	02 00       	.word	0x0002	; ????
     66e:	00 bd       	out	0x20, r16	; 32
}

void LCD::display() 
{
   _displaycontrol |= LCD_DISPLAYON;
   command(LCD_DISPLAYCONTROL | _displaycontrol);
     670:	02 00       	.word	0x0002	; ????
     672:	00 0c       	add	r0, r0
     674:	00 66       	ori	r16, 0x60	; 96
     676:	93 01       	movw	r18, r6

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
     678:	67 93       	lat	Z, r22
     67a:	01 68       	ori	r16, 0x81	; 129
     67c:	93 01       	movw	r18, r6
     67e:	69 93       	st	Y+, r22
     680:	01 bd       	out	0x21, r16	; 33
     682:	02 00       	.word	0x0002	; ????
     684:	00 10       	cpse	r0, r0
     686:	03 00       	.word	0x0003	; ????
   
   // clear the LCD
   clear();
   
   // Initialize to default text direction (for romance languages)
   _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
     688:	00 0c       	add	r0, r0
     68a:	00 5c       	subi	r16, 0xC0	; 192
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);
     68c:	93 01       	movw	r18, r6
     68e:	5d 93       	st	X+, r21
     690:	01 5e       	subi	r16, 0xE1	; 225
     692:	93 01       	movw	r18, r6

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
     694:	5f 93       	push	r21
     696:	01 00       	.word	0x0001	; ????
     698:	00 00       	nop
     69a:	00 00       	nop
     69c:	00 00       	nop
     69e:	00 c2       	rjmp	.+1024   	; 0xaa0 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x56>
     6a0:	02 00       	.word	0x0002	; ????
   // set the entry mode
   command(LCD_ENTRYMODESET | _displaymode);

   backlight();

}
     6a2:	00 f0       	brcs	.+0      	; 0x6a4 <_ZN3LCD5beginEhhh+0x118>
     6a4:	02 00       	.word	0x0002	; ????
     6a6:	00 0c       	add	r0, r0
     6a8:	00 58       	subi	r16, 0x80	; 128

//
// Switch on the backlight
void LCD::backlight ( void )
{
   setBacklight(255);
     6aa:	93 01       	movw	r18, r6
    
    @param      0..255 - the value is very dependent on the LCD. However, 
    BACKLIGHT_OFF will be interpreted as off and BACKLIGHT_ON will drive the
    backlight on.
    */
   virtual void setBacklight ( uint8_t value ) { };
     6ac:	59 93       	st	Y+, r21
    empty function call is provided that does nothing.
    
    @param      value: pin associated to backlight control.
    @param      pol: backlight polarity control (POSITIVE, NEGATIVE)
    */
   virtual void setBacklightPin ( uint8_t value, t_backlightPol pol ) { };
     6ae:	01 5a       	subi	r16, 0xA1	; 161
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     6b0:	93 01       	movw	r18, r6
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     6b2:	5b 93       	.word	0x935b	; ????
     6b4:	01 f0       	breq	.+0      	; 0x6b6 <_ZN5Print17availableForWriteEv+0x4>
     6b6:	02 00       	.word	0x0002	; ????
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     6b8:	00 fc       	sbrc	r0, 0
     6ba:	02 00       	.word	0x0002	; ????
      return write((const uint8_t *)str, strlen(str));
     6bc:	00 04       	cpc	r0, r0
     6be:	00 78       	andi	r16, 0x80	; 128
     6c0:	e8 07       	cpc	r30, r24
     6c2:	9f fc       	.word	0xfc9f	; ????
     6c4:	02 00       	.word	0x0002	; ????
     6c6:	00 18       	sub	r0, r0
     6c8:	03 00       	.word	0x0003	; ????
     6ca:	00 0c       	add	r0, r0
     6cc:	00 58       	subi	r16, 0x80	; 128
     6ce:	93 01       	movw	r18, r6
     6d0:	59 93       	st	Y+, r21
     6d2:	01 5a       	subi	r16, 0xA1	; 161
     6d4:	93 01       	movw	r18, r6
    }
     6d6:	5b 93       	.word	0x935b	; ????
     6d8:	01 00       	.word	0x0001	; ????
     6da:	00 00       	nop
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
     6dc:	00 00       	nop
     6de:	00 00       	nop
     6e0:	00 1a       	sub	r0, r16
     6e2:	03 00       	.word	0x0003	; ????
     6e4:	00 1c       	adc	r0, r0
     6e6:	03 00       	.word	0x0003	; ????
     6e8:	00 03       	mulsu	r16, r16
     6ea:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
     6ee:	1c 03       	fmul	r17, r20
     6f0:	00 00       	nop
     6f2:	1e 03       	fmul	r17, r22
     6f4:	00 00       	nop
     6f6:	03 00       	.word	0x0003	; ????
     6f8:	92 20       	and	r9, r2
     6fa:	03 1e       	adc	r0, r19
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     6fc:	03 00       	.word	0x0003	; ????

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     6fe:	00 20       	and	r0, r0
     700:	03 00       	.word	0x0003	; ????
     702:	00 03       	mulsu	r16, r16
     704:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
     708:	20 03       	mulsu	r18, r16

  do {
    char c = n % base;
     70a:	00 00       	nop
     70c:	22 03       	mulsu	r18, r18
     70e:	00 00       	nop
     710:	03 00       	.word	0x0003	; ????
     712:	92 20       	and	r9, r2
     714:	05 22       	and	r0, r21
     716:	03 00       	.word	0x0003	; ????
     718:	00 24       	eor	r0, r0
     71a:	03 00       	.word	0x0003	; ????
    n /= base;
     71c:	00 03       	mulsu	r16, r16
     71e:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     722:	24 03       	mulsu	r18, r20
     724:	00 00       	nop
     726:	26 03       	mulsu	r18, r22
     728:	00 00       	nop
     72a:	03 00       	.word	0x0003	; ????
     72c:	92 20       	and	r9, r2
     72e:	07 26       	eor	r0, r23
     730:	03 00       	.word	0x0003	; ????
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
     732:	00 28       	or	r0, r0
     734:	03 00       	.word	0x0003	; ????
     736:	00 03       	mulsu	r16, r16
     738:	00 92 20 08 	sts	0x0820, r0	; 0x800820 <__bss_end+0x63f>
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
     73c:	28 03       	fmul	r18, r16
     73e:	00 00       	nop
}
     740:	2a 03       	fmul	r18, r18
     742:	00 00       	nop
     744:	03 00       	.word	0x0003	; ????
     746:	92 20       	and	r9, r2
     748:	09 2a       	or	r0, r25
     74a:	03 00       	.word	0x0003	; ????
     74c:	00 6e       	ori	r16, 0xE0	; 224
     74e:	03 00       	.word	0x0003	; ????
     750:	00 03       	mulsu	r16, r16
     752:	00 92 20 0a 	sts	0x0A20, r0	; 0x800a20 <__bss_end+0x83f>
	...
     75e:	1a 03       	fmul	r17, r18
     760:	00 00       	nop
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     762:	34 03       	mulsu	r19, r20
     764:	00 00       	nop
     766:	06 00       	.word	0x0006	; ????
     768:	68 93       	.word	0x9368	; ????
     76a:	01 69       	ori	r16, 0x91	; 145
     76c:	93 01       	movw	r18, r6
     76e:	34 03       	mulsu	r19, r20
     770:	00 00       	nop
     772:	6c 03       	fmul	r22, r20
     774:	00 00       	nop
     776:	06 00       	.word	0x0006	; ????
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     778:	5c 93       	st	X, r21
     77a:	01 5d       	subi	r16, 0xD1	; 209
     77c:	93 01       	movw	r18, r6
     77e:	6c 03       	fmul	r22, r20
     780:	00 00       	nop
     782:	6e 03       	fmul	r22, r22
     784:	00 00       	nop
     786:	04 00       	.word	0x0004	; ????
	unsigned char f = timer0_fract;
     788:	f3 01       	movw	r30, r6
     78a:	68 9f       	mul	r22, r24
	...

	m += MILLIS_INC;
     794:	1a 03       	fmul	r17, r18
     796:	00 00       	nop
     798:	34 03       	mulsu	r19, r20
     79a:	00 00       	nop
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
     79c:	06 00       	.word	0x0006	; ????
     79e:	66 93       	lac	Z, r22
		m += 1;
     7a0:	01 67       	ori	r16, 0x71	; 113
     7a2:	93 01       	movw	r18, r6
     7a4:	34 03       	mulsu	r19, r20
	}

	timer0_fract = f;
     7a6:	00 00       	nop
     7a8:	3a 03       	fmul	r19, r18
	timer0_millis = m;
     7aa:	00 00       	nop
     7ac:	07 00       	.word	0x0007	; ????
     7ae:	f3 01       	movw	r30, r6
     7b0:	66 8c       	ldd	r6, Z+30	; 0x1e
     7b2:	00 22       	and	r0, r16
     7b4:	9f 3a       	cpi	r25, 0xAF	; 175
     7b6:	03 00       	.word	0x0003	; ????
     7b8:	00 56       	subi	r16, 0x60	; 96
	timer0_overflow_count++;
     7ba:	03 00       	.word	0x0003	; ????
     7bc:	00 09       	sbc	r16, r0
     7be:	00 f3       	brcs	.-64     	; 0x780 <__vector_16+0x1e>
     7c0:	01 66       	ori	r16, 0x61	; 97
     7c2:	8c 00       	.word	0x008c	; ????
     7c4:	22 23       	and	r18, r18
     7c6:	01 9f       	mul	r16, r17
     7c8:	56 03       	mulsu	r21, r22
     7ca:	00 00       	nop
     7cc:	58 03       	fmul	r21, r16
     7ce:	00 00       	nop
     7d0:	07 00       	.word	0x0007	; ????
     7d2:	8c 00       	.word	0x008c	; ????
     7d4:	f3 01       	movw	r30, r6
     7d6:	66 22       	and	r6, r22
     7d8:	9f 58       	subi	r25, 0x8F	; 143
     7da:	03 00       	.word	0x0003	; ????
     7dc:	00 5a       	subi	r16, 0xA0	; 160
     7de:	03 00       	.word	0x0003	; ????
}
     7e0:	00 09       	sbc	r16, r0
     7e2:	00 f3       	brcs	.-64     	; 0x7a4 <__vector_16+0x42>
     7e4:	01 66       	ori	r16, 0x61	; 97
     7e6:	8c 00       	.word	0x008c	; ????
     7e8:	22 23       	and	r18, r18
     7ea:	01 9f       	mul	r16, r17
	...
     7f4:	1a 03       	fmul	r17, r18
  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
     7f6:	00 00       	nop
     7f8:	34 03       	mulsu	r19, r20
     7fa:	00 00       	nop
     7fc:	06 00       	.word	0x0006	; ????
     7fe:	64 93       	xch	Z, r22
     800:	01 65       	ori	r16, 0x51	; 81
     802:	93 01       	movw	r18, r6
     804:	34 03       	mulsu	r19, r20
     806:	00 00       	nop
     808:	56 03       	mulsu	r21, r22
     80a:	00 00       	nop
     80c:	07 00       	.word	0x0007	; ????
     80e:	8c 00       	.word	0x008c	; ????
     810:	20 7e       	andi	r18, 0xE0	; 224
     812:	00 22       	and	r0, r16
     814:	9f 56       	subi	r25, 0x6F	; 111
     816:	03 00       	.word	0x0003	; ????
  switch(TW_STATUS){
     818:	00 58       	subi	r16, 0x80	; 128
     81a:	03 00       	.word	0x0003	; ????
     81c:	00 06       	cpc	r0, r16
     81e:	00 7e       	andi	r16, 0xE0	; 224
     820:	00 8c       	ldd	r0, Z+24	; 0x18
     822:	00 1c       	adc	r0, r0
     824:	9f 58       	subi	r25, 0x8F	; 143
     826:	03 00       	.word	0x0003	; ????
     828:	00 5a       	subi	r16, 0xA0	; 160
     82a:	03 00       	.word	0x0003	; ????
     82c:	00 07       	cpc	r16, r16
     82e:	00 8c       	ldd	r0, Z+24	; 0x18
     830:	00 20       	and	r0, r0
     832:	7e 00       	.word	0x007e	; ????
     834:	22 9f       	mul	r18, r18
     836:	5a 03       	fmul	r21, r18
     838:	00 00       	nop
     83a:	60 03       	mulsu	r22, r16
     83c:	00 00       	nop
     83e:	08 00       	.word	0x0008	; ????
     840:	8c 00       	.word	0x008c	; ????
     842:	20 f3       	brcs	.-56     	; 0x80c <__vector_24+0x16>
     844:	01 64       	ori	r16, 0x41	; 65
     846:	22 9f       	mul	r18, r18
	...
     850:	2e 03       	fmul	r18, r22
     852:	00 00       	nop
     854:	34 03       	mulsu	r19, r20
     856:	00 00       	nop
     858:	02 00       	.word	0x0002	; ????
     85a:	30 9f       	mul	r19, r16
     85c:	34 03       	mulsu	r19, r20
     85e:	00 00       	nop
     860:	60 03       	mulsu	r22, r16
     862:	00 00       	nop
     864:	06 00       	.word	0x0006	; ????
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
     866:	6c 93       	st	X, r22
     868:	01 6d       	ori	r16, 0xD1	; 209
     86a:	93 01       	movw	r18, r6
	...
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     874:	82 03       	fmuls	r16, r18
     876:	00 00       	nop
     878:	a2 03       	fmuls	r18, r18
     87a:	00 00       	nop
     87c:	06 00       	.word	0x0006	; ????
     87e:	68 93       	.word	0x9368	; ????
     880:	01 69       	ori	r16, 0x91	; 145
     882:	93 01       	movw	r18, r6
     884:	a2 03       	fmuls	r18, r18
     886:	00 00       	nop
     888:	ca 03       	fmulsu	r20, r18
     88a:	00 00       	nop
     88c:	04 00       	.word	0x0004	; ????
     88e:	f3 01       	movw	r30, r6
     890:	68 9f       	mul	r22, r24
     892:	ca 03       	fmulsu	r20, r18
     894:	00 00       	nop
     896:	cc 03       	fmulsu	r20, r20
     898:	00 00       	nop
     89a:	06 00       	.word	0x0006	; ????
     89c:	68 93       	.word	0x9368	; ????
     89e:	01 69       	ori	r16, 0x91	; 145
     8a0:	93 01       	movw	r18, r6
     8a2:	cc 03       	fmulsu	r20, r20
     8a4:	00 00       	nop
     8a6:	ce 03       	fmulsu	r20, r22
     8a8:	00 00       	nop
     8aa:	04 00       	.word	0x0004	; ????
     8ac:	f3 01       	movw	r30, r6
     8ae:	68 9f       	mul	r22, r24
     8b0:	ce 03       	fmulsu	r20, r22
     8b2:	00 00       	nop
     8b4:	d0 03       	fmuls	r21, r16
     8b6:	00 00       	nop
     8b8:	06 00       	.word	0x0006	; ????
     8ba:	68 93       	.word	0x9368	; ????
     8bc:	01 69       	ori	r16, 0x91	; 145
     8be:	93 01       	movw	r18, r6
     8c0:	d0 03       	fmuls	r21, r16
     8c2:	00 00       	nop
     8c4:	d2 03       	fmuls	r21, r18
     8c6:	00 00       	nop
     8c8:	04 00       	.word	0x0004	; ????
     8ca:	f3 01       	movw	r30, r6
     8cc:	68 9f       	mul	r22, r24
	...
     8d6:	82 03       	fmuls	r16, r18
     8d8:	00 00       	nop
     8da:	c2 03       	fmuls	r20, r18
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
     8dc:	00 00       	nop
     8de:	01 00       	.word	0x0001	; ????
     8e0:	66 c2       	rjmp	.+1228   	; 0xdae <__data_load_end+0x22>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
     8e2:	03 00       	.word	0x0003	; ????
     8e4:	00 ca       	rjmp	.-3072   	; 0xfffffce6 <__eeprom_end+0xff7efce6>
     8e6:	03 00       	.word	0x0003	; ????
     8e8:	00 04       	cpc	r0, r0
     8ea:	00 f3       	brcs	.-64     	; 0x8ac <__vector_24+0xb6>
     8ec:	01 66       	ori	r16, 0x61	; 97
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
     8ee:	9f ca       	rjmp	.-2754   	; 0xfffffe2e <__eeprom_end+0xff7efe2e>
     8f0:	03 00       	.word	0x0003	; ????
     8f2:	00 d2       	rcall	.+1024   	; 0xcf4 <__udivmodsi4_loop>
     8f4:	03 00       	.word	0x0003	; ????
     8f6:	00 01       	movw	r0, r0
     8f8:	00 66       	ori	r16, 0x60	; 96
	...
     902:	a2 03       	fmuls	r18, r18
     904:	00 00       	nop
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     906:	b8 03       	fmulsu	r19, r16
     908:	00 00       	nop
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
     90a:	01 00       	.word	0x0001	; ????
     90c:	68 b8       	out	0x08, r6	; 8
     90e:	03 00       	.word	0x0003	; ????
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     910:	00 ba       	out	0x10, r0	; 16
     912:	03 00       	.word	0x0003	; ????
     914:	00 03       	mulsu	r16, r16
     916:	00 88       	ldd	r0, Z+16	; 0x10
     918:	01 9f       	mul	r16, r17
     91a:	ba 03       	fmulsu	r19, r18
     91c:	00 00       	nop
     91e:	c0 03       	fmuls	r20, r16
     920:	00 00       	nop
     922:	01 00       	.word	0x0001	; ????
     924:	68 00       	.word	0x0068	; ????
     926:	00 00       	nop
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
     928:	00 00       	nop
     92a:	00 00       	nop
     92c:	00 d4       	rcall	.+2048   	; 0x112e <__data_load_end+0x3a2>
     92e:	03 00       	.word	0x0003	; ????
     930:	00 d8       	rcall	.-4096   	; 0xfffff932 <__eeprom_end+0xff7ef932>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     932:	03 00       	.word	0x0003	; ????
     934:	00 06       	cpc	r0, r16
     936:	00 68       	ori	r16, 0x80	; 128
     938:	93 01       	movw	r18, r6
     93a:	69 93       	st	Y+, r22
     93c:	01 d8       	rcall	.-4094   	; 0xfffff940 <__eeprom_end+0xff7ef940>
     93e:	03 00       	.word	0x0003	; ????
     940:	00 da       	rcall	.-3072   	; 0xfffffd42 <__eeprom_end+0xff7efd42>
     942:	03 00       	.word	0x0003	; ????
     944:	00 04       	cpc	r0, r0
     946:	00 f3       	brcs	.-64     	; 0x908 <__stack+0x9>
     948:	01 68       	ori	r16, 0x81	; 129
	if (twi_sendStop)
     94a:	9f 00       	.word	0x009f	; ????
     94c:	00 00       	nop
     94e:	00 00       	nop
     950:	00 00       	nop
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
     952:	00 da       	rcall	.-3072   	; 0xfffffd54 <__eeprom_end+0xff7efd54>
     954:	03 00       	.word	0x0003	; ????
     956:	00 de       	rcall	.-1024   	; 0x558 <_ZN3LCD9setCursorEhh.constprop.36+0x50>
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
     958:	03 00       	.word	0x0003	; ????
     95a:	00 06       	cpc	r0, r16
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
     95c:	00 68       	ori	r16, 0x80	; 128
     95e:	93 01       	movw	r18, r6
     960:	69 93       	st	Y+, r22
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
     962:	01 de       	rcall	.-1022   	; 0x566 <_ZN3LCD9setCursorEhh.constprop.36+0x5e>
     964:	03 00       	.word	0x0003	; ????
     966:	00 e0       	ldi	r16, 0x00	; 0
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     968:	03 00       	.word	0x0003	; ????
     96a:	00 04       	cpc	r0, r0
     96c:	00 f3       	brcs	.-64     	; 0x92e <__stack+0x2f>
     96e:	01 68       	ori	r16, 0x81	; 129
     970:	9f 00       	.word	0x009f	; ????
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
     972:	00 00       	nop
     974:	00 00       	nop
     976:	00 00       	nop
     978:	00 e0       	ldi	r16, 0x00	; 0
     97a:	03 00       	.word	0x0003	; ????
     97c:	00 e4       	ldi	r16, 0x40	; 64
     97e:	03 00       	.word	0x0003	; ????
     980:	00 06       	cpc	r0, r16
     982:	00 68       	ori	r16, 0x80	; 128
     984:	93 01       	movw	r18, r6
     986:	69 93       	st	Y+, r22
     988:	01 e4       	ldi	r16, 0x41	; 65
     98a:	03 00       	.word	0x0003	; ????
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
     98c:	00 ee       	ldi	r16, 0xE0	; 224
     98e:	03 00       	.word	0x0003	; ????
     990:	00 04       	cpc	r0, r0

  // update twi state
  twi_state = TWI_READY;
     992:	00 f3       	brcs	.-64     	; 0x954 <__stack+0x55>
     994:	01 68       	ori	r16, 0x81	; 129
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
     996:	9f 00       	.word	0x009f	; ????
     998:	00 00       	nop
     99a:	00 00       	nop
     99c:	00 00       	nop
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
     99e:	00 ee       	ldi	r16, 0xE0	; 224
     9a0:	03 00       	.word	0x0003	; ????
     9a2:	00 f0       	brcs	.+0      	; 0x9a4 <__stack+0xa5>
     9a4:	03 00       	.word	0x0003	; ????
     9a6:	00 03       	mulsu	r16, r16
     9a8:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
     9ac:	f0 03       	fmuls	r23, r16
     9ae:	00 00       	nop
     9b0:	f2 03       	fmuls	r23, r18
     9b2:	00 00       	nop
     9b4:	03 00       	.word	0x0003	; ????
     9b6:	92 20       	and	r9, r2
     9b8:	03 f2       	brvs	.-128    	; 0x93a <__stack+0x3b>
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
     9ba:	03 00       	.word	0x0003	; ????
     9bc:	00 04       	cpc	r0, r0
     9be:	04 00       	.word	0x0004	; ????
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
     9c0:	00 03       	mulsu	r16, r16
     9c2:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
	...
      twi_txBufferIndex = 0;
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
     9ce:	ee 03       	fmulsu	r22, r22
     9d0:	00 00       	nop
     9d2:	f4 03       	fmuls	r23, r20
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
     9d4:	00 00       	nop
     9d6:	06 00       	.word	0x0006	; ????
     9d8:	68 93       	.word	0x9368	; ????
     9da:	01 69       	ori	r16, 0x91	; 145
        twi_txBufferLength = 1;
     9dc:	93 01       	movw	r18, r6
     9de:	f4 03       	fmuls	r23, r20
     9e0:	00 00       	nop
        twi_txBuffer[0] = 0x00;
     9e2:	04 04       	cpc	r0, r4
     9e4:	00 00       	nop
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
     9e6:	04 00       	.word	0x0004	; ????
     9e8:	f3 01       	movw	r30, r6
     9ea:	68 9f       	mul	r22, r24
	...
     9f4:	ee 03       	fmulsu	r22, r22
     9f6:	00 00       	nop
     9f8:	f8 03       	fmulsu	r23, r16
     9fa:	00 00       	nop
     9fc:	06 00       	.word	0x0006	; ????
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
     9fe:	66 93       	lac	Z, r22
     a00:	01 67       	ori	r16, 0x71	; 113
     a02:	93 01       	movw	r18, r6
     a04:	f8 03       	fmulsu	r23, r16
     a06:	00 00       	nop
     a08:	fb 03       	fmulsu	r23, r19
     a0a:	00 00       	nop
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
     a0c:	06 00       	.word	0x0006	; ????
     a0e:	68 93       	.word	0x9368	; ????
     a10:	01 69       	ori	r16, 0x91	; 145
     a12:	93 01       	movw	r18, r6
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     a14:	fb 03       	fmulsu	r23, r19
     a16:	00 00       	nop
     a18:	04 04       	cpc	r0, r4
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
     a1a:	00 00       	nop
     a1c:	04 00       	.word	0x0004	; ????
     a1e:	f3 01       	movw	r30, r6

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
     a20:	66 9f       	mul	r22, r22
	...
      twi_stop();
      break;
  }
}
     a2a:	ee 03       	fmulsu	r22, r22
     a2c:	00 00       	nop
     a2e:	fb 03       	fmulsu	r23, r19
     a30:	00 00       	nop
     a32:	06 00       	.word	0x0006	; ????
     a34:	64 93       	xch	Z, r22
     a36:	01 65       	ori	r16, 0x51	; 81
     a38:	93 01       	movw	r18, r6
     a3a:	fb 03       	fmulsu	r23, r19
     a3c:	00 00       	nop
     a3e:	02 04       	cpc	r0, r2
     a40:	00 00       	nop
     a42:	06 00       	.word	0x0006	; ????
     a44:	6c 93       	st	X, r22
     a46:	01 6d       	ori	r16, 0xD1	; 209
     a48:	93 01       	movw	r18, r6
     a4a:	02 04       	cpc	r0, r2
     a4c:	00 00       	nop
     a4e:	04 04       	cpc	r0, r4
     a50:	00 00       	nop
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     a52:	06 00       	.word	0x0006	; ????
     a54:	68 93       	.word	0x9368	; ????
     a56:	01 69       	ori	r16, 0x91	; 145
     a58:	93 01       	movw	r18, r6
	...
     a62:	04 04       	cpc	r0, r4
     a64:	00 00       	nop
     a66:	06 04       	cpc	r0, r6
     a68:	00 00       	nop
     a6a:	03 00       	.word	0x0003	; ????
     a6c:	92 20       	and	r9, r2
     a6e:	02 06       	cpc	r0, r18
     a70:	04 00       	.word	0x0004	; ????
void (*TwoWire::user_onRequest)(void);
void (*TwoWire::user_onReceive)(int);

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire()
     a72:	00 08       	sbc	r0, r0
     a74:	04 00       	.word	0x0004	; ????
     a76:	00 03       	mulsu	r16, r16
     a78:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x13f>
     a7c:	08 04       	cpc	r0, r8
     a7e:	00 00       	nop
     a80:	0a 04       	cpc	r0, r10
     a82:	00 00       	nop
     a84:	03 00       	.word	0x0003	; ????
// CONSTRUCTORS
// ---------------------------------------------------------------------------

LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
                             uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
                             uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
     a86:	92 20       	and	r9, r2
     a88:	04 0a       	sbc	r0, r20
     a8a:	04 00       	.word	0x0004	; ????
     a8c:	00 0e       	add	r0, r16
     a8e:	04 00       	.word	0x0004	; ????
     a90:	00 03       	mulsu	r16, r16
   uint8_t i;
   
   // Initialize the IO pins
   // -----------------------
   
   _rs_pin = rs;
     a92:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x33f>
     a96:	0e 04       	cpc	r0, r14
   _rw_pin = rw;
     a98:	00 00       	nop
     a9a:	26 04       	cpc	r2, r6
     a9c:	00 00       	nop
   _enable_pin = enable;
     a9e:	02 00       	.word	0x0002	; ????
     aa0:	8c 05       	cpc	r24, r12
	...
   
   _data_pins[0] = d0;
   _data_pins[1] = d1;
     aaa:	04 04       	cpc	r0, r4
     aac:	00 00       	nop
     aae:	14 04       	cpc	r1, r4
   _data_pins[2] = d2;
     ab0:	00 00       	nop
     ab2:	06 00       	.word	0x0006	; ????
     ab4:	68 93       	.word	0x9368	; ????
   _data_pins[3] = d3; 
     ab6:	01 69       	ori	r16, 0x91	; 145
     ab8:	93 01       	movw	r18, r6
     aba:	14 04       	cpc	r1, r4
   _data_pins[4] = d4;
     abc:	00 00       	nop
     abe:	26 04       	cpc	r2, r6
     ac0:	00 00       	nop
   _data_pins[5] = d5;
     ac2:	04 00       	.word	0x0004	; ????
     ac4:	f3 01       	movw	r30, r6
     ac6:	68 9f       	mul	r22, r24
	...
   _data_pins[6] = d6;
   _data_pins[7] = d7;
     ad0:	04 04       	cpc	r0, r4
     ad2:	00 00       	nop
     ad4:	12 04       	cpc	r1, r2
     ad6:	00 00       	nop
     ad8:	01 00       	.word	0x0001	; ????
     ada:	66 12       	cpse	r6, r22
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
   {
      pinMode ( _data_pins[i], OUTPUT );
     adc:	04 00       	.word	0x0004	; ????
     ade:	00 24       	eor	r0, r0
     ae0:	04 00       	.word	0x0004	; ????
     ae2:	00 02       	muls	r16, r16
     ae4:	00 8c       	ldd	r0, Z+24	; 0x18
   _data_pins[7] = d7;
   
   // Initialize the IO port direction to OUTPUT
   // ------------------------------------------
   
   for ( i = 0; i < 4; i++ )
     ae6:	01 24       	eor	r0, r1
     ae8:	04 00       	.word	0x0004	; ????
     aea:	00 26       	eor	r0, r16
     aec:	04 00       	.word	0x0004	; ????
     aee:	00 03       	mulsu	r16, r16
   
   if ( !fourbitmode )
   {
      for ( i = 4; i < 8; i++ )
      {
         pinMode ( _data_pins[i], OUTPUT );
     af0:	00 92 20 7e 	sts	0x7E20, r0	; 0x807e20 <__bss_end+0x7c3f>
	...
      }
   }
   pinMode(_rs_pin, OUTPUT);
     afc:	26 04       	cpc	r2, r6
     afe:	00 00       	nop
     b00:	2a 04       	cpc	r2, r10
     b02:	00 00       	nop
   
   // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
   if (_rw_pin != 255) 
     b04:	06 00       	.word	0x0006	; ????
     b06:	68 93       	.word	0x9368	; ????
     b08:	01 69       	ori	r16, 0x91	; 145
     b0a:	93 01       	movw	r18, r6
   { 
      pinMode(_rw_pin, OUTPUT);
     b0c:	2a 04       	cpc	r2, r10
     b0e:	00 00       	nop
   }
   
   pinMode(_enable_pin, OUTPUT);
     b10:	4b 04       	cpc	r4, r11
     b12:	00 00       	nop
     b14:	06 00       	.word	0x0006	; ????
     b16:	6e 93       	st	-X, r22
   // Initialise displaymode functions to defaults: LCD_1LINE and LCD_5x8DOTS
   // -------------------------------------------------------------------------
   if (fourbitmode)
      _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
   else 
      _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
     b18:	01 6f       	ori	r16, 0xF1	; 241
     b1a:	93 01       	movw	r18, r6
     b1c:	4b 04       	cpc	r4, r11
   
   // Now we pull both RS and R/W low to begin commands
   digitalWrite(_rs_pin, LOW);
     b1e:	00 00       	nop
     b20:	4c 04       	cpc	r4, r12
     b22:	00 00       	nop
     b24:	04 00       	.word	0x0004	; ????
     b26:	f3 01       	movw	r30, r6
   digitalWrite(_enable_pin, LOW);
     b28:	68 9f       	mul	r22, r24
     b2a:	4c 04       	cpc	r4, r12
     b2c:	00 00       	nop
     b2e:	4e 04       	cpc	r4, r14
     b30:	00 00       	nop
   
   if (_rw_pin != 255) 
     b32:	06 00       	.word	0x0006	; ????
     b34:	6e 93       	st	-X, r22
     b36:	01 6f       	ori	r16, 0xF1	; 241
     b38:	93 01       	movw	r18, r6
	...
   { 
      digitalWrite(_rw_pin, LOW);
   }
   
   // Initialise the backlight pin no nothing
   _backlightPin = LCD_NOBACKLIGHT;
     b42:	26 04       	cpc	r2, r6
     b44:	00 00       	nop
   _polarity = POSITIVE;
     b46:	44 04       	cpc	r4, r4
     b48:	00 00       	nop
     b4a:	01 00       	.word	0x0001	; ????
     b4c:	66 44       	sbci	r22, 0x46	; 70
     b4e:	04 00       	.word	0x0004	; ????
     b50:	00 46       	sbci	r16, 0x60	; 96
     b52:	04 00       	.word	0x0004	; ????
     b54:	00 04       	cpc	r0, r0
     b56:	00 f3       	brcs	.-64     	; 0xb18 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0xce>

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     b58:	01 66       	ori	r16, 0x61	; 97
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     b5a:	9f 46       	sbci	r25, 0x6F	; 111
     b5c:	04 00       	.word	0x0004	; ????
     b5e:	00 48       	sbci	r16, 0x80	; 128
	sbi(TCCR0A, WGM00);
     b60:	04 00       	.word	0x0004	; ????
     b62:	00 01       	movw	r0, r0
     b64:	00 66       	ori	r16, 0x60	; 96
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     b66:	48 04       	cpc	r4, r8
     b68:	00 00       	nop
     b6a:	4c 04       	cpc	r4, r12
	sbi(TCCR0B, CS00);
     b6c:	00 00       	nop
     b6e:	04 00       	.word	0x0004	; ????
     b70:	f3 01       	movw	r30, r6

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     b72:	66 9f       	mul	r22, r22
     b74:	4c 04       	cpc	r4, r12
     b76:	00 00       	nop
     b78:	4e 04       	cpc	r4, r14
     b7a:	00 00       	nop
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     b7c:	01 00       	.word	0x0001	; ????
     b7e:	66 00       	.word	0x0066	; ????

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     b80:	00 00       	nop
     b82:	00 00       	nop
     b84:	00 00       	nop
     b86:	00 4e       	sbci	r16, 0xE0	; 224
     b88:	04 00       	.word	0x0004	; ????
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     b8a:	00 50       	subi	r16, 0x00	; 0
     b8c:	04 00       	.word	0x0004	; ????
     b8e:	00 03       	mulsu	r16, r16
     b90:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     b94:	50 04       	cpc	r5, r0
     b96:	00 00       	nop
     b98:	52 04       	cpc	r5, r2
     b9a:	00 00       	nop
     b9c:	03 00       	.word	0x0003	; ????

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     b9e:	92 20       	and	r9, r2
     ba0:	03 52       	subi	r16, 0x23	; 35
     ba2:	04 00       	.word	0x0004	; ????
     ba4:	00 54       	subi	r16, 0x40	; 64
     ba6:	04 00       	.word	0x0004	; ????

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     ba8:	00 03       	mulsu	r16, r16
     baa:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
     bae:	54 04       	cpc	r5, r4
     bb0:	00 00       	nop
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     bb2:	56 04       	cpc	r5, r6
     bb4:	00 00       	nop
     bb6:	03 00       	.word	0x0003	; ????
     bb8:	92 20       	and	r9, r2
     bba:	05 56       	subi	r16, 0x65	; 101
		sbi(ADCSRA, ADPS1);
     bbc:	04 00       	.word	0x0004	; ????
     bbe:	00 58       	subi	r16, 0x80	; 128
     bc0:	04 00       	.word	0x0004	; ????
     bc2:	00 03       	mulsu	r16, r16
     bc4:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>
		sbi(ADCSRA, ADPS0);
     bc8:	58 04       	cpc	r5, r8
     bca:	00 00       	nop
     bcc:	84 04       	cpc	r8, r4
     bce:	00 00       	nop
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     bd0:	03 00       	.word	0x0003	; ????
     bd2:	92 20       	and	r9, r2
     bd4:	07 00       	.word	0x0007	; ????
     bd6:	00 00       	nop
     bd8:	00 00       	nop
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     bda:	00 00       	nop
     bdc:	00 4e       	sbci	r16, 0xE0	; 224
// ----------

void setup()
{
  // some displays need time to initialize
  delay(1000);
     bde:	04 00       	.word	0x0004	; ????
     be0:	00 60       	ori	r16, 0x00	; 0
     be2:	04 00       	.word	0x0004	; ????
     be4:	00 06       	cpc	r0, r16
     be6:	00 68       	ori	r16, 0x80	; 128
     be8:	93 01       	movw	r18, r6
  // initialize LCD and set up the number of columns and rows
  lcd.begin(16, 2);
     bea:	69 93       	st	Y+, r22
     bec:	01 60       	ori	r16, 0x01	; 1
     bee:	04 00       	.word	0x0004	; ????
     bf0:	00 7c       	andi	r16, 0xC0	; 192
     bf2:	04 00       	.word	0x0004	; ????
     bf4:	00 06       	cpc	r0, r16
     bf6:	00 6c       	ori	r16, 0xC0	; 192
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     bf8:	93 01       	movw	r18, r6

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     bfa:	6d 93       	st	X+, r22
	m = timer0_millis;
     bfc:	01 7c       	andi	r16, 0xC1	; 193
     bfe:	04 00       	.word	0x0004	; ????
     c00:	00 83       	st	Z, r16
     c02:	04 00       	.word	0x0004	; ????
     c04:	00 06       	cpc	r0, r16
     c06:	00 68       	ori	r16, 0x80	; 128
     c08:	93 01       	movw	r18, r6
     c0a:	69 93       	st	Y+, r22
	SREG = oldSREG;
     c0c:	01 83       	std	Z+1, r16	; 0x01

  _startTime_ms = millis();
     c0e:	04 00       	.word	0x0004	; ????
     c10:	00 84       	ldd	r0, Z+8	; 0x08
     c12:	04 00       	.word	0x0004	; ????
     c14:	00 04       	cpc	r0, r0
     c16:	00 f3       	brcs	.-64     	; 0xbd8 <main+0x80>
     c18:	01 68       	ori	r16, 0x81	; 129
     c1a:	9f 00       	.word	0x009f	; ????
     c1c:	00 00       	nop
	

#endif

	// busy wait
	__asm__ __volatile__ (
     c1e:	00 00       	nop
     c20:	00 00       	nop
     c22:	00 4e       	sbci	r16, 0xE0	; 224
     c24:	04 00       	.word	0x0004	; ????
}

void loop() 
{
  if (0 == _loopCounter--) {
     c26:	00 63       	ori	r16, 0x30	; 48
     c28:	04 00       	.word	0x0004	; ????
     c2a:	00 01       	movw	r0, r0
     c2c:	00 66       	ori	r16, 0x60	; 96
     c2e:	63 04       	cpc	r6, r3
     c30:	00 00       	nop
     c32:	7e 04       	cpc	r7, r14
     c34:	00 00       	nop
     c36:	01 00       	.word	0x0001	; ????
     c38:	61 7e       	andi	r22, 0xE1	; 225
     c3a:	04 00       	.word	0x0004	; ????
     c3c:	00 83       	st	Z, r16
     c3e:	04 00       	.word	0x0004	; ????
     c40:	00 02       	muls	r16, r16
     c42:	00 88       	ldd	r0, Z+16	; 0x10
     c44:	16 83       	std	Z+6, r17	; 0x06
     c46:	04 00       	.word	0x0004	; ????
     c48:	00 84       	ldd	r0, Z+8	; 0x08
     c4a:	04 00       	.word	0x0004	; ????
     c4c:	00 04       	cpc	r0, r0
     c4e:	00 f3       	brcs	.-64     	; 0xc10 <main+0xb8>
     c50:	01 66       	ori	r16, 0x61	; 97
     c52:	9f 00       	.word	0x009f	; ????
     c54:	00 00       	nop
     c56:	00 00       	nop
     c58:	00 00       	nop
     c5a:	00 4e       	sbci	r16, 0xE0	; 224
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     c5c:	04 00       	.word	0x0004	; ????

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     c5e:	00 63       	ori	r16, 0x30	; 48
	m = timer0_millis;
     c60:	04 00       	.word	0x0004	; ????
     c62:	00 06       	cpc	r0, r16
     c64:	00 64       	ori	r16, 0x40	; 64
     c66:	93 01       	movw	r18, r6
     c68:	65 93       	las	Z, r22
     c6a:	01 63       	ori	r16, 0x31	; 49
     c6c:	04 00       	.word	0x0004	; ????
     c6e:	00 82       	st	Z, r0
	SREG = oldSREG;
     c70:	04 00       	.word	0x0004	; ????

// Common LCD Commands
// ---------------------------------------------------------------------------
void LCD::clear()
{
   command(LCD_CLEARDISPLAY);             // clear display, set cursor position to zero
     c72:	00 06       	cpc	r0, r16
     c74:	00 5e       	subi	r16, 0xE0	; 224
     c76:	93 01       	movw	r18, r6
     c78:	5f 93       	push	r21
     c7a:	01 82       	std	Z+1, r0	; 0x01
	

#endif

	// busy wait
	__asm__ __volatile__ (
     c7c:	04 00       	.word	0x0004	; ????
     c7e:	00 83       	st	Z, r16
     c80:	04 00       	.word	0x0004	; ????
    // 3000000 loops in 6225 [ms]
    unsigned long endTime_ms = millis();
  
    lcd.clear();
    lcd.setCursor(0, 0);
     c82:	00 02       	muls	r16, r16
     c84:	00 88       	ldd	r0, Z+16	; 0x10
     c86:	09 83       	std	Y+1, r16	; 0x01
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     c88:	04 00       	.word	0x0004	; ????
     c8a:	00 84       	ldd	r0, Z+8	; 0x08
     c8c:	04 00       	.word	0x0004	; ????
     c8e:	00 04       	cpc	r0, r0
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     c90:	00 f3       	brcs	.-64     	; 0xc52 <main+0xfa>
     c92:	01 64       	ori	r16, 0x41	; 65
     c94:	9f 00       	.word	0x009f	; ????
     c96:	00 00       	nop
     c98:	00 00       	nop
     c9a:	00 00       	nop
     c9c:	00 84       	ldd	r0, Z+8	; 0x08
    lcd.print("Loops: ");
    lcd.print(C_LOOP_COUNT);
  
    lcd.setCursor(0, 1);
     c9e:	04 00       	.word	0x0004	; ????
     ca0:	00 86       	std	Z+8, r0	; 0x08
     ca2:	04 00       	.word	0x0004	; ????
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     ca4:	00 03       	mulsu	r16, r16
     ca6:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
     caa:	86 04       	cpc	r8, r6
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     cac:	00 00       	nop
     cae:	88 04       	cpc	r8, r8
     cb0:	00 00       	nop
     cb2:	03 00       	.word	0x0003	; ????
     cb4:	92 20       	and	r9, r2
     cb6:	03 88       	ldd	r0, Z+19	; 0x13
     cb8:	04 00       	.word	0x0004	; ????
     cba:	00 8a       	std	Z+16, r0	; 0x10
     cbc:	04 00       	.word	0x0004	; ????
     cbe:	00 03       	mulsu	r16, r16
     cc0:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
     cc4:	8a 04       	cpc	r8, r10
     cc6:	00 00       	nop
     cc8:	8c 04       	cpc	r8, r12
     cca:	00 00       	nop
     ccc:	03 00       	.word	0x0003	; ????
     cce:	92 20       	and	r9, r2
     cd0:	05 8c       	ldd	r0, Z+29	; 0x1d
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
     cd2:	04 00       	.word	0x0004	; ????
     cd4:	00 e2       	ldi	r16, 0x20	; 32
     cd6:	04 00       	.word	0x0004	; ????
     cd8:	00 03       	mulsu	r16, r16
     cda:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>
	...
     ce6:	84 04       	cpc	r8, r4
     ce8:	00 00       	nop
     cea:	9c 04       	cpc	r9, r12
     cec:	00 00       	nop
     cee:	06 00       	.word	0x0006	; ????
     cf0:	68 93       	.word	0x9368	; ????
     cf2:	01 69       	ori	r16, 0x91	; 145
     cf4:	93 01       	movw	r18, r6
     cf6:	9c 04       	cpc	r9, r12
     cf8:	00 00       	nop
     cfa:	da 04       	cpc	r13, r10
     cfc:	00 00       	nop
     cfe:	06 00       	.word	0x0006	; ????
     d00:	6c 93       	st	X, r22
     d02:	01 6d       	ori	r16, 0xD1	; 209
     d04:	93 01       	movw	r18, r6
     d06:	da 04       	cpc	r13, r10
     d08:	00 00       	nop
     d0a:	e1 04       	cpc	r14, r1
     d0c:	00 00       	nop
     d0e:	06 00       	.word	0x0006	; ????
     d10:	68 93       	.word	0x9368	; ????
     d12:	01 69       	ori	r16, 0x91	; 145
     d14:	93 01       	movw	r18, r6
     d16:	e1 04       	cpc	r14, r1
     d18:	00 00       	nop
     d1a:	e2 04       	cpc	r14, r2
     d1c:	00 00       	nop
     d1e:	04 00       	.word	0x0004	; ????
     d20:	f3 01       	movw	r30, r6
     d22:	68 9f       	mul	r22, r24
	...
     d2c:	84 04       	cpc	r8, r4
     d2e:	00 00       	nop
     d30:	94 04       	cpc	r9, r4
     d32:	00 00       	nop
     d34:	01 00       	.word	0x0001	; ????
     d36:	66 94       	lsr	r6
     d38:	04 00       	.word	0x0004	; ????
     d3a:	00 dc       	rcall	.-2048   	; 0x53c <_ZN3LCD9setCursorEhh.constprop.36+0x34>
     d3c:	04 00       	.word	0x0004	; ????
     d3e:	00 01       	movw	r0, r0
     d40:	00 61       	ori	r16, 0x10	; 16
     d42:	dc 04       	cpc	r13, r12
     d44:	00 00       	nop
     d46:	e1 04       	cpc	r14, r1
     d48:	00 00       	nop
     d4a:	01 00       	.word	0x0001	; ????
     d4c:	66 e1       	ldi	r22, 0x16	; 22
     d4e:	04 00       	.word	0x0004	; ????
     d50:	00 e2       	ldi	r16, 0x20	; 32
     d52:	04 00       	.word	0x0004	; ????
     d54:	00 04       	cpc	r0, r0
     d56:	00 f3       	brcs	.-64     	; 0xd18 <__udivmodsi4_ep+0xa>
     d58:	01 66       	ori	r16, 0x61	; 97
     d5a:	9f 00       	.word	0x009f	; ????
     d5c:	00 00       	nop
     d5e:	00 00       	nop
     d60:	00 00       	nop
     d62:	00 84       	ldd	r0, Z+8	; 0x08
     d64:	04 00       	.word	0x0004	; ????
     d66:	00 9f       	mul	r16, r16
     d68:	04 00       	.word	0x0004	; ????
     d6a:	00 01       	movw	r0, r0
     d6c:	00 64       	ori	r16, 0x40	; 64
     d6e:	9f 04       	cpc	r9, r15
     d70:	00 00       	nop
     d72:	de 04       	cpc	r13, r14
     d74:	00 00       	nop
     d76:	01 00       	.word	0x0001	; ????
     d78:	60 de       	rcall	.-832    	; 0xa3a <__stack+0x13b>
     d7a:	04 00       	.word	0x0004	; ????
     d7c:	00 e2       	ldi	r16, 0x20	; 32
     d7e:	04 00       	.word	0x0004	; ????
     d80:	00 04       	cpc	r0, r0
     d82:	00 f3       	brcs	.-64     	; 0xd44 <__stop_program>
     d84:	01 64       	ori	r16, 0x41	; 65
     d86:	9f 00       	.word	0x009f	; ????
     d88:	00 00       	nop
     d8a:	00 00       	nop
     d8c:	00 00       	nop
     d8e:	00 ba       	out	0x10, r0	; 16
     d90:	04 00       	.word	0x0004	; ????
     d92:	00 d0       	rcall	.+0      	; 0xd94 <__data_load_end+0x8>
     d94:	04 00       	.word	0x0004	; ????
     d96:	00 01       	movw	r0, r0
     d98:	00 61       	ori	r16, 0x10	; 16
	...
     da2:	ba 04       	cpc	r11, r10
     da4:	00 00       	nop
     da6:	d0 04       	cpc	r13, r0
     da8:	00 00       	nop
     daa:	06 00       	.word	0x0006	; ????
     dac:	6c 93       	st	X, r22
     dae:	01 6d       	ori	r16, 0xD1	; 209
     db0:	93 01       	movw	r18, r6
	...
     dba:	e2 04       	cpc	r14, r2
     dbc:	00 00       	nop
     dbe:	f1 04       	cpc	r15, r1
     dc0:	00 00       	nop
     dc2:	06 00       	.word	0x0006	; ????
     dc4:	68 93       	.word	0x9368	; ????
     dc6:	01 69       	ori	r16, 0x91	; 145
     dc8:	93 01       	movw	r18, r6
     dca:	f1 04       	cpc	r15, r1
     dcc:	00 00       	nop
     dce:	f8 04       	cpc	r15, r8
     dd0:	00 00       	nop
     dd2:	04 00       	.word	0x0004	; ????
     dd4:	f3 01       	movw	r30, r6
     dd6:	68 9f       	mul	r22, r24
	...
     de0:	e2 04       	cpc	r14, r2
     de2:	00 00       	nop
     de4:	f1 04       	cpc	r15, r1
     de6:	00 00       	nop
     de8:	01 00       	.word	0x0001	; ????
     dea:	66 f1       	brts	.+88     	; 0xe44 <__data_load_end+0xb8>
     dec:	04 00       	.word	0x0004	; ????
     dee:	00 f8       	bld	r0, 0
     df0:	04 00       	.word	0x0004	; ????
     df2:	00 04       	cpc	r0, r0
     df4:	00 f3       	brcs	.-64     	; 0xdb6 <__data_load_end+0x2a>
     df6:	01 66       	ori	r16, 0x61	; 97
     df8:	9f 00       	.word	0x009f	; ????
     dfa:	00 00       	nop
     dfc:	00 00       	nop
     dfe:	00 00       	nop
     e00:	00 f8       	bld	r0, 0
     e02:	04 00       	.word	0x0004	; ????
     e04:	00 07       	cpc	r16, r16
     e06:	05 00       	.word	0x0005	; ????
     e08:	00 06       	cpc	r0, r16
     e0a:	00 68       	ori	r16, 0x80	; 128
     e0c:	93 01       	movw	r18, r6
     e0e:	69 93       	st	Y+, r22
     e10:	01 07       	cpc	r16, r17
     e12:	05 00       	.word	0x0005	; ????
     e14:	00 08       	sbc	r0, r0
     e16:	05 00       	.word	0x0005	; ????
     e18:	00 04       	cpc	r0, r0
     e1a:	00 f3       	brcs	.-64     	; 0xddc <__data_load_end+0x50>
     e1c:	01 68       	ori	r16, 0x81	; 129
     e1e:	9f 00       	.word	0x009f	; ????
     e20:	00 00       	nop
     e22:	00 00       	nop
     e24:	00 00       	nop
     e26:	00 f8       	bld	r0, 0
     e28:	04 00       	.word	0x0004	; ????
     e2a:	00 07       	cpc	r16, r16
     e2c:	05 00       	.word	0x0005	; ????
     e2e:	00 01       	movw	r0, r0
     e30:	00 66       	ori	r16, 0x60	; 96
     e32:	07 05       	cpc	r16, r7
     e34:	00 00       	nop
     e36:	08 05       	cpc	r16, r8
     e38:	00 00       	nop
     e3a:	04 00       	.word	0x0004	; ????
     e3c:	f3 01       	movw	r30, r6
     e3e:	66 9f       	mul	r22, r22
	...
     e48:	08 05       	cpc	r16, r8
     e4a:	00 00       	nop
     e4c:	0a 05       	cpc	r16, r10
     e4e:	00 00       	nop
     e50:	03 00       	.word	0x0003	; ????
     e52:	92 20       	and	r9, r2
     e54:	02 0a       	sbc	r0, r18
     e56:	05 00       	.word	0x0005	; ????
     e58:	00 0c       	add	r0, r0
     e5a:	05 00       	.word	0x0005	; ????
     e5c:	00 03       	mulsu	r16, r16
     e5e:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x13f>
     e62:	0c 05       	cpc	r16, r12
     e64:	00 00       	nop
     e66:	10 05       	cpc	r17, r0
     e68:	00 00       	nop
     e6a:	03 00       	.word	0x0003	; ????
     e6c:	92 20       	and	r9, r2
     e6e:	04 10       	cpse	r0, r4
     e70:	05 00       	.word	0x0005	; ????
     e72:	00 12       	cpse	r0, r16
     e74:	05 00       	.word	0x0005	; ????
     e76:	00 02       	muls	r16, r16
     e78:	00 8c       	ldd	r0, Z+24	; 0x18
     e7a:	04 12       	cpse	r0, r20
     e7c:	05 00       	.word	0x0005	; ????
     e7e:	00 8c       	ldd	r0, Z+24	; 0x18
     e80:	05 00       	.word	0x0005	; ????
     e82:	00 02       	muls	r16, r16
     e84:	00 8c       	ldd	r0, Z+24	; 0x18
     e86:	0c 00       	.word	0x000c	; ????
     e88:	00 00       	nop
     e8a:	00 00       	nop
     e8c:	00 00       	nop
     e8e:	00 08       	sbc	r0, r0
     e90:	05 00       	.word	0x0005	; ????
     e92:	00 56       	subi	r16, 0x60	; 96
     e94:	05 00       	.word	0x0005	; ????
     e96:	00 01       	movw	r0, r0
     e98:	00 68       	ori	r16, 0x80	; 128
     e9a:	56 05       	cpc	r21, r6
     e9c:	00 00       	nop
     e9e:	58 05       	cpc	r21, r8
     ea0:	00 00       	nop
     ea2:	04 00       	.word	0x0004	; ????
     ea4:	f3 01       	movw	r30, r6
     ea6:	68 9f       	mul	r22, r24
     ea8:	58 05       	cpc	r21, r8
     eaa:	00 00       	nop
     eac:	78 05       	cpc	r23, r8
     eae:	00 00       	nop
     eb0:	01 00       	.word	0x0001	; ????
     eb2:	68 00       	.word	0x0068	; ????
     eb4:	00 00       	nop
     eb6:	00 00       	nop
     eb8:	00 00       	nop
     eba:	00 8c       	ldd	r0, Z+24	; 0x18
     ebc:	05 00       	.word	0x0005	; ????
     ebe:	00 8e       	std	Z+24, r0	; 0x18
     ec0:	05 00       	.word	0x0005	; ????
     ec2:	00 03       	mulsu	r16, r16
     ec4:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
     ec8:	8e 05       	cpc	r24, r14
     eca:	00 00       	nop
     ecc:	90 05       	cpc	r25, r0
     ece:	00 00       	nop
     ed0:	03 00       	.word	0x0003	; ????
     ed2:	92 20       	and	r9, r2
     ed4:	03 90       	.word	0x9003	; ????
     ed6:	05 00       	.word	0x0005	; ????
     ed8:	00 92 05 00 	sts	0x0005, r0	; 0x800005 <__TEXT_REGION_LENGTH__+0x7e0005>
     edc:	00 03       	mulsu	r16, r16
     ede:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
     ee2:	92 05       	cpc	r25, r2
     ee4:	00 00       	nop
     ee6:	94 05       	cpc	r25, r4
     ee8:	00 00       	nop
     eea:	03 00       	.word	0x0003	; ????
     eec:	92 20       	and	r9, r2
     eee:	05 94       	asr	r0
     ef0:	05 00       	.word	0x0005	; ????
     ef2:	00 ac       	ldd	r0, Z+56	; 0x38
     ef4:	06 00       	.word	0x0006	; ????
     ef6:	00 03       	mulsu	r16, r16
     ef8:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>
	...
     f04:	8c 05       	cpc	r24, r12
     f06:	00 00       	nop
     f08:	9c 05       	cpc	r25, r12
     f0a:	00 00       	nop
     f0c:	06 00       	.word	0x0006	; ????
     f0e:	68 93       	.word	0x9368	; ????
     f10:	01 69       	ori	r16, 0x91	; 145
     f12:	93 01       	movw	r18, r6
     f14:	9c 05       	cpc	r25, r12
     f16:	00 00       	nop
     f18:	a6 06       	cpc	r10, r22
     f1a:	00 00       	nop
     f1c:	06 00       	.word	0x0006	; ????
     f1e:	6c 93       	st	X, r22
     f20:	01 6d       	ori	r16, 0xD1	; 209
     f22:	93 01       	movw	r18, r6
     f24:	a6 06       	cpc	r10, r22
     f26:	00 00       	nop
     f28:	ab 06       	cpc	r10, r27
     f2a:	00 00       	nop
     f2c:	06 00       	.word	0x0006	; ????
     f2e:	68 93       	.word	0x9368	; ????
     f30:	01 69       	ori	r16, 0x91	; 145
     f32:	93 01       	movw	r18, r6
     f34:	ab 06       	cpc	r10, r27
     f36:	00 00       	nop
     f38:	ac 06       	cpc	r10, r28
     f3a:	00 00       	nop
     f3c:	04 00       	.word	0x0004	; ????
     f3e:	f3 01       	movw	r30, r6
     f40:	68 9f       	mul	r22, r24
	...
     f4a:	8c 05       	cpc	r24, r12
     f4c:	00 00       	nop
     f4e:	ba 05       	cpc	r27, r10
     f50:	00 00       	nop
     f52:	01 00       	.word	0x0001	; ????
     f54:	66 ba       	out	0x16, r6	; 22
     f56:	05 00       	.word	0x0005	; ????
     f58:	00 bd       	out	0x20, r16	; 32
     f5a:	05 00       	.word	0x0005	; ????
     f5c:	00 02       	muls	r16, r16
     f5e:	00 8c       	ldd	r0, Z+24	; 0x18
     f60:	08 bd       	out	0x28, r16	; 40
     f62:	05 00       	.word	0x0005	; ????
     f64:	00 ac       	ldd	r0, Z+56	; 0x38
     f66:	06 00       	.word	0x0006	; ????
     f68:	00 04       	cpc	r0, r0
     f6a:	00 f3       	brcs	.-64     	; 0xf2c <__data_load_end+0x1a0>
     f6c:	01 66       	ori	r16, 0x61	; 97
     f6e:	9f 00       	.word	0x009f	; ????
     f70:	00 00       	nop
     f72:	00 00       	nop
     f74:	00 00       	nop
     f76:	00 8c       	ldd	r0, Z+24	; 0x18
     f78:	05 00       	.word	0x0005	; ????
     f7a:	00 bd       	out	0x20, r16	; 32
     f7c:	05 00       	.word	0x0005	; ????
     f7e:	00 01       	movw	r0, r0
     f80:	00 64       	ori	r16, 0x40	; 64
     f82:	bd 05       	cpc	r27, r13
     f84:	00 00       	nop
     f86:	ac 06       	cpc	r10, r28
     f88:	00 00       	nop
     f8a:	04 00       	.word	0x0004	; ????
     f8c:	f3 01       	movw	r30, r6
     f8e:	64 9f       	mul	r22, r20
	...
     f98:	8c 05       	cpc	r24, r12
     f9a:	00 00       	nop
     f9c:	bd 05       	cpc	r27, r13
     f9e:	00 00       	nop
     fa0:	01 00       	.word	0x0001	; ????
     fa2:	62 bd       	out	0x22, r22	; 34
     fa4:	05 00       	.word	0x0005	; ????
     fa6:	00 ac       	ldd	r0, Z+56	; 0x38
     fa8:	06 00       	.word	0x0006	; ????
     faa:	00 04       	cpc	r0, r0
     fac:	00 f3       	brcs	.-64     	; 0xf6e <__data_load_end+0x1e2>
     fae:	01 62       	ori	r16, 0x21	; 33
     fb0:	9f 00       	.word	0x009f	; ????
     fb2:	00 00       	nop
     fb4:	00 00       	nop
     fb6:	00 00       	nop
     fb8:	00 d6       	rcall	.+3072   	; 0x1bba <__data_load_end+0xe2e>
     fba:	05 00       	.word	0x0005	; ????
     fbc:	00 de       	rcall	.-1024   	; 0xbbe <main+0x66>
     fbe:	05 00       	.word	0x0005	; ????
     fc0:	00 04       	cpc	r0, r0
     fc2:	00 0a       	sbc	r0, r16
     fc4:	4b 46       	sbci	r20, 0x6B	; 107
     fc6:	9f 00       	.word	0x009f	; ????
     fc8:	00 00       	nop
     fca:	00 00       	nop
     fcc:	00 00       	nop
     fce:	00 f0       	brcs	.+0      	; 0xfd0 <__data_load_end+0x244>
     fd0:	05 00       	.word	0x0005	; ????
     fd2:	00 fa       	bst	r0, 0
     fd4:	05 00       	.word	0x0005	; ????
     fd6:	00 04       	cpc	r0, r0
     fd8:	00 0a       	sbc	r0, r16
     fda:	53 02       	muls	r21, r19
     fdc:	9f 00       	.word	0x009f	; ????
     fde:	00 00       	nop
     fe0:	00 00       	nop
     fe2:	00 00       	nop
     fe4:	00 0c       	add	r0, r0
     fe6:	06 00       	.word	0x0006	; ????
     fe8:	00 12       	cpse	r0, r16
     fea:	06 00       	.word	0x0006	; ????
     fec:	00 04       	cpc	r0, r0
     fee:	00 0a       	sbc	r0, r16
     ff0:	53 02       	muls	r21, r19
     ff2:	9f 00       	.word	0x009f	; ????
     ff4:	00 00       	nop
     ff6:	00 00       	nop
     ff8:	00 00       	nop
     ffa:	00 2e       	mov	r0, r16
     ffc:	06 00       	.word	0x0006	; ????
     ffe:	00 36       	cpi	r16, 0x60	; 96
    1000:	06 00       	.word	0x0006	; ????
    1002:	00 04       	cpc	r0, r0
    1004:	00 0a       	sbc	r0, r16
    1006:	4b 46       	sbci	r20, 0x6B	; 107
    1008:	9f 00       	.word	0x009f	; ????
    100a:	00 00       	nop
    100c:	00 00       	nop
    100e:	00 00       	nop
    1010:	00 40       	sbci	r16, 0x00	; 0
    1012:	06 00       	.word	0x0006	; ????
    1014:	00 4a       	sbci	r16, 0xA0	; 160
    1016:	06 00       	.word	0x0006	; ????
    1018:	00 04       	cpc	r0, r0
    101a:	00 0a       	sbc	r0, r16
    101c:	53 02       	muls	r21, r19
    101e:	9f 00       	.word	0x009f	; ????
    1020:	00 00       	nop
    1022:	00 00       	nop
    1024:	00 00       	nop
    1026:	00 54       	subi	r16, 0x40	; 64
    1028:	06 00       	.word	0x0006	; ????
    102a:	00 5a       	subi	r16, 0xA0	; 160
    102c:	06 00       	.word	0x0006	; ????
    102e:	00 04       	cpc	r0, r0
    1030:	00 0a       	sbc	r0, r16
    1032:	53 02       	muls	r21, r19
    1034:	9f 00       	.word	0x009f	; ????
    1036:	00 00       	nop
    1038:	00 00       	nop
    103a:	00 00       	nop
    103c:	00 64       	ori	r16, 0x40	; 64
    103e:	06 00       	.word	0x0006	; ????
    1040:	00 6c       	ori	r16, 0xC0	; 192
    1042:	06 00       	.word	0x0006	; ????
    1044:	00 03       	mulsu	r16, r16
    1046:	00 08       	sbc	r0, r0
    1048:	eb 9f       	mul	r30, r27
	...
    1052:	70 06       	cpc	r7, r16
    1054:	00 00       	nop
    1056:	78 06       	cpc	r7, r24
    1058:	00 00       	nop
    105a:	06 00       	.word	0x0006	; ????
    105c:	6c 93       	st	X, r22
    105e:	01 6d       	ori	r16, 0xD1	; 209
    1060:	93 01       	movw	r18, r6
	...
    106a:	78 06       	cpc	r7, r24
    106c:	00 00       	nop
    106e:	88 06       	cpc	r8, r24
    1070:	00 00       	nop
    1072:	06 00       	.word	0x0006	; ????
    1074:	6c 93       	st	X, r22
    1076:	01 6d       	ori	r16, 0xD1	; 209
    1078:	93 01       	movw	r18, r6
	...
    1082:	80 06       	cpc	r8, r16
    1084:	00 00       	nop
    1086:	88 06       	cpc	r8, r24
    1088:	00 00       	nop
    108a:	04 00       	.word	0x0004	; ????
    108c:	0a 3b       	cpi	r16, 0xBA	; 186
    108e:	1f 9f       	mul	r17, r31
	...
    1098:	94 06       	cpc	r9, r20
    109a:	00 00       	nop
    109c:	a6 06       	cpc	r10, r22
    109e:	00 00       	nop
    10a0:	06 00       	.word	0x0006	; ????
    10a2:	6c 93       	st	X, r22
    10a4:	01 6d       	ori	r16, 0xD1	; 209
    10a6:	93 01       	movw	r18, r6
    10a8:	a6 06       	cpc	r10, r22
    10aa:	00 00       	nop
    10ac:	ab 06       	cpc	r10, r27
    10ae:	00 00       	nop
    10b0:	06 00       	.word	0x0006	; ????
    10b2:	68 93       	.word	0x9368	; ????
    10b4:	01 69       	ori	r16, 0x91	; 145
    10b6:	93 01       	movw	r18, r6
    10b8:	ab 06       	cpc	r10, r27
    10ba:	00 00       	nop
    10bc:	ac 06       	cpc	r10, r28
    10be:	00 00       	nop
    10c0:	04 00       	.word	0x0004	; ????
    10c2:	f3 01       	movw	r30, r6
    10c4:	68 9f       	mul	r22, r24
	...
    10ce:	b2 06       	cpc	r11, r18
    10d0:	00 00       	nop
    10d2:	b6 06       	cpc	r11, r22
    10d4:	00 00       	nop
    10d6:	06 00       	.word	0x0006	; ????
    10d8:	68 93       	.word	0x9368	; ????
    10da:	01 69       	ori	r16, 0x91	; 145
    10dc:	93 01       	movw	r18, r6
    10de:	b6 06       	cpc	r11, r22
    10e0:	00 00       	nop
    10e2:	b8 06       	cpc	r11, r24
    10e4:	00 00       	nop
    10e6:	04 00       	.word	0x0004	; ????
    10e8:	f3 01       	movw	r30, r6
    10ea:	68 9f       	mul	r22, r24
	...
    10f4:	b8 06       	cpc	r11, r24
    10f6:	00 00       	nop
    10f8:	d2 06       	cpc	r13, r18
    10fa:	00 00       	nop
    10fc:	06 00       	.word	0x0006	; ????
    10fe:	68 93       	.word	0x9368	; ????
    1100:	01 69       	ori	r16, 0x91	; 145
    1102:	93 01       	movw	r18, r6
    1104:	d2 06       	cpc	r13, r18
    1106:	00 00       	nop
    1108:	d5 06       	cpc	r13, r21
    110a:	00 00       	nop
    110c:	06 00       	.word	0x0006	; ????
    110e:	66 93       	lac	Z, r22
    1110:	01 67       	ori	r16, 0x71	; 113
    1112:	93 01       	movw	r18, r6
    1114:	d5 06       	cpc	r13, r21
    1116:	00 00       	nop
    1118:	d6 06       	cpc	r13, r22
    111a:	00 00       	nop
    111c:	04 00       	.word	0x0004	; ????
    111e:	f3 01       	movw	r30, r6
    1120:	68 9f       	mul	r22, r24
    1122:	d6 06       	cpc	r13, r22
    1124:	00 00       	nop
    1126:	da 06       	cpc	r13, r26
    1128:	00 00       	nop
    112a:	06 00       	.word	0x0006	; ????
    112c:	68 93       	.word	0x9368	; ????
    112e:	01 69       	ori	r16, 0x91	; 145
    1130:	93 01       	movw	r18, r6
    1132:	da 06       	cpc	r13, r26
    1134:	00 00       	nop
    1136:	dc 06       	cpc	r13, r28
    1138:	00 00       	nop
    113a:	04 00       	.word	0x0004	; ????
    113c:	f3 01       	movw	r30, r6
    113e:	68 9f       	mul	r22, r24
	...
    1148:	dc 06       	cpc	r13, r28
    114a:	00 00       	nop
    114c:	de 06       	cpc	r13, r30
    114e:	00 00       	nop
    1150:	03 00       	.word	0x0003	; ????
    1152:	92 20       	and	r9, r2
    1154:	02 de       	rcall	.-1020   	; 0xd5a <__data_load_start+0x14>
    1156:	06 00       	.word	0x0006	; ????
    1158:	00 e0       	ldi	r16, 0x00	; 0
    115a:	06 00       	.word	0x0006	; ????
    115c:	00 03       	mulsu	r16, r16
    115e:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x13f>
    1162:	e0 06       	cpc	r14, r16
    1164:	00 00       	nop
    1166:	e2 06       	cpc	r14, r18
    1168:	00 00       	nop
    116a:	03 00       	.word	0x0003	; ????
    116c:	92 20       	and	r9, r2
    116e:	04 e2       	ldi	r16, 0x24	; 36
    1170:	06 00       	.word	0x0006	; ????
    1172:	00 e4       	ldi	r16, 0x40	; 64
    1174:	06 00       	.word	0x0006	; ????
    1176:	00 03       	mulsu	r16, r16
    1178:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x33f>
    117c:	e4 06       	cpc	r14, r20
    117e:	00 00       	nop
    1180:	e6 06       	cpc	r14, r22
    1182:	00 00       	nop
    1184:	03 00       	.word	0x0003	; ????
    1186:	92 20       	and	r9, r2
    1188:	06 e6       	ldi	r16, 0x66	; 102
    118a:	06 00       	.word	0x0006	; ????
    118c:	00 e8       	ldi	r16, 0x80	; 128
    118e:	06 00       	.word	0x0006	; ????
    1190:	00 03       	mulsu	r16, r16
    1192:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x53f>
    1196:	e8 06       	cpc	r14, r24
    1198:	00 00       	nop
    119a:	ea 06       	cpc	r14, r26
    119c:	00 00       	nop
    119e:	03 00       	.word	0x0003	; ????
    11a0:	92 20       	and	r9, r2
    11a2:	08 ea       	ldi	r16, 0xA8	; 168
    11a4:	06 00       	.word	0x0006	; ????
    11a6:	00 ec       	ldi	r16, 0xC0	; 192
    11a8:	06 00       	.word	0x0006	; ????
    11aa:	00 03       	mulsu	r16, r16
    11ac:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x73f>
    11b0:	ec 06       	cpc	r14, r28
    11b2:	00 00       	nop
    11b4:	f0 06       	cpc	r15, r16
    11b6:	00 00       	nop
    11b8:	03 00       	.word	0x0003	; ????
    11ba:	92 20       	and	r9, r2
    11bc:	0a f0       	brmi	.+2      	; 0x11c0 <__data_load_end+0x434>
    11be:	06 00       	.word	0x0006	; ????
    11c0:	00 f2       	brcs	.-128    	; 0x1142 <__data_load_end+0x3b6>
    11c2:	06 00       	.word	0x0006	; ????
    11c4:	00 02       	muls	r16, r16
    11c6:	00 8c       	ldd	r0, Z+24	; 0x18
    11c8:	0a f2       	brmi	.-126    	; 0x114c <__data_load_end+0x3c0>
    11ca:	06 00       	.word	0x0006	; ????
    11cc:	00 5e       	subi	r16, 0xE0	; 224
    11ce:	07 00       	.word	0x0007	; ????
    11d0:	00 02       	muls	r16, r16
    11d2:	00 8c       	ldd	r0, Z+24	; 0x18
    11d4:	2b 00       	.word	0x002b	; ????
    11d6:	00 00       	nop
    11d8:	00 00       	nop
    11da:	00 00       	nop
    11dc:	00 dc       	rcall	.-2048   	; 0x9de <__stack+0xdf>
    11de:	06 00       	.word	0x0006	; ????
    11e0:	00 12       	cpse	r0, r16
    11e2:	07 00       	.word	0x0007	; ????
    11e4:	00 0c       	add	r0, r0
    11e6:	00 66       	ori	r16, 0x60	; 96
    11e8:	93 01       	movw	r18, r6
    11ea:	67 93       	lat	Z, r22
    11ec:	01 68       	ori	r16, 0x81	; 129
    11ee:	93 01       	movw	r18, r6
    11f0:	69 93       	st	Y+, r22
    11f2:	01 12       	cpse	r0, r17
    11f4:	07 00       	.word	0x0007	; ????
    11f6:	00 1a       	sub	r0, r16
    11f8:	07 00       	.word	0x0007	; ????
    11fa:	00 0c       	add	r0, r0
    11fc:	00 66       	ori	r16, 0x60	; 96
    11fe:	93 01       	movw	r18, r6
    1200:	67 93       	lat	Z, r22
    1202:	01 68       	ori	r16, 0x81	; 129
    1204:	93 01       	movw	r18, r6
    1206:	69 93       	st	Y+, r22
    1208:	01 20       	and	r0, r1
    120a:	07 00       	.word	0x0007	; ????
    120c:	00 3f       	cpi	r16, 0xF0	; 240
    120e:	07 00       	.word	0x0007	; ????
    1210:	00 0c       	add	r0, r0
    1212:	00 62       	ori	r16, 0x20	; 32
    1214:	93 01       	movw	r18, r6
    1216:	63 93       	.word	0x9363	; ????
    1218:	01 64       	ori	r16, 0x41	; 65
    121a:	93 01       	movw	r18, r6
    121c:	65 93       	las	Z, r22
    121e:	01 00       	.word	0x0001	; ????
    1220:	00 00       	nop
    1222:	00 00       	nop
    1224:	00 00       	nop
    1226:	00 dc       	rcall	.-2048   	; 0xa28 <__stack+0x129>
    1228:	06 00       	.word	0x0006	; ????
    122a:	00 04       	cpc	r0, r0
    122c:	07 00       	.word	0x0007	; ????
    122e:	00 01       	movw	r0, r0
    1230:	00 64       	ori	r16, 0x40	; 64
    1232:	04 07       	cpc	r16, r20
    1234:	00 00       	nop
    1236:	12 07       	cpc	r17, r18
    1238:	00 00       	nop
    123a:	04 00       	.word	0x0004	; ????
    123c:	f3 01       	movw	r30, r6
    123e:	64 9f       	mul	r22, r20
	...
    1248:	fc 06       	cpc	r15, r28
    124a:	00 00       	nop
    124c:	12 07       	cpc	r17, r18
    124e:	00 00       	nop
    1250:	03 00       	.word	0x0003	; ????
    1252:	91 76       	andi	r25, 0x61	; 97
    1254:	9f 12       	cpse	r9, r31
    1256:	07 00       	.word	0x0007	; ????
    1258:	00 54       	subi	r16, 0x40	; 64
    125a:	07 00       	.word	0x0007	; ????
    125c:	00 06       	cpc	r0, r16
    125e:	00 60       	ori	r16, 0x00	; 0
    1260:	93 01       	movw	r18, r6
    1262:	61 93       	st	Z+, r22
    1264:	01 00       	.word	0x0001	; ????
    1266:	00 00       	nop
    1268:	00 00       	nop
    126a:	00 00       	nop
    126c:	00 1c       	adc	r0, r0
    126e:	07 00       	.word	0x0007	; ????
    1270:	00 1e       	adc	r0, r16
    1272:	07 00       	.word	0x0007	; ????
    1274:	00 01       	movw	r0, r0
    1276:	00 66       	ori	r16, 0x60	; 96
    1278:	1e 07       	cpc	r17, r30
    127a:	00 00       	nop
    127c:	2a 07       	cpc	r18, r26
    127e:	00 00       	nop
    1280:	01 00       	.word	0x0001	; ????
    1282:	6e 2a       	or	r6, r30
    1284:	07 00       	.word	0x0007	; ????
    1286:	00 2c       	mov	r0, r0
    1288:	07 00       	.word	0x0007	; ????
    128a:	00 03       	mulsu	r16, r16
    128c:	00 8e       	std	Z+24, r0	; 0x18
    128e:	50 9f       	mul	r21, r16
    1290:	2c 07       	cpc	r18, r28
    1292:	00 00       	nop
    1294:	2e 07       	cpc	r18, r30
    1296:	00 00       	nop
    1298:	01 00       	.word	0x0001	; ????
    129a:	6e 00       	.word	0x006e	; ????
    129c:	00 00       	nop
    129e:	00 00       	nop
    12a0:	00 00       	nop
    12a2:	00 4a       	sbci	r16, 0xA0	; 160
    12a4:	0a 00       	.word	0x000a	; ????
    12a6:	00 4c       	sbci	r16, 0xC0	; 192
    12a8:	0a 00       	.word	0x000a	; ????
    12aa:	00 03       	mulsu	r16, r16
    12ac:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
    12b0:	4c 0a       	sbc	r4, r28
    12b2:	00 00       	nop
    12b4:	4e 0a       	sbc	r4, r30
    12b6:	00 00       	nop
    12b8:	03 00       	.word	0x0003	; ????
    12ba:	92 20       	and	r9, r2
    12bc:	03 4e       	sbci	r16, 0xE3	; 227
    12be:	0a 00       	.word	0x000a	; ????
    12c0:	00 50       	subi	r16, 0x00	; 0
    12c2:	0a 00       	.word	0x000a	; ????
    12c4:	00 03       	mulsu	r16, r16
    12c6:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
    12ca:	50 0a       	sbc	r5, r16
    12cc:	00 00       	nop
    12ce:	52 0a       	sbc	r5, r18
    12d0:	00 00       	nop
    12d2:	03 00       	.word	0x0003	; ????
    12d4:	92 20       	and	r9, r2
    12d6:	05 52       	subi	r16, 0x25	; 37
    12d8:	0a 00       	.word	0x000a	; ????
    12da:	00 58       	subi	r16, 0x80	; 128
    12dc:	0b 00       	.word	0x000b	; ????
    12de:	00 03       	mulsu	r16, r16
    12e0:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>
	...
    12ec:	52 0a       	sbc	r5, r18
    12ee:	00 00       	nop
    12f0:	7e 0a       	sbc	r7, r30
    12f2:	00 00       	nop
    12f4:	03 00       	.word	0x0003	; ????
    12f6:	09 ff       	.word	0xff09	; ????
    12f8:	9f 00       	.word	0x009f	; ????
    12fa:	00 00       	nop
    12fc:	00 00       	nop
    12fe:	00 00       	nop
    1300:	00 52       	subi	r16, 0x20	; 32
    1302:	0a 00       	.word	0x000a	; ????
    1304:	00 7e       	andi	r16, 0xE0	; 224
    1306:	0a 00       	.word	0x000a	; ????
    1308:	00 02       	muls	r16, r16
    130a:	00 31       	cpi	r16, 0x10	; 16
    130c:	9f 00       	.word	0x009f	; ????
    130e:	00 00       	nop
    1310:	00 00       	nop
    1312:	00 00       	nop
    1314:	00 7e       	andi	r16, 0xE0	; 224
    1316:	0a 00       	.word	0x000a	; ????
    1318:	00 4e       	sbci	r16, 0xE0	; 224
    131a:	0b 00       	.word	0x000b	; ????
    131c:	00 02       	muls	r16, r16
    131e:	00 31       	cpi	r16, 0x10	; 16
    1320:	9f 00       	.word	0x009f	; ????
    1322:	00 00       	nop
    1324:	00 00       	nop
    1326:	00 00       	nop
    1328:	00 7e       	andi	r16, 0xE0	; 224
    132a:	0a 00       	.word	0x000a	; ????
    132c:	00 4e       	sbci	r16, 0xE0	; 224
    132e:	0b 00       	.word	0x000b	; ????
    1330:	00 03       	mulsu	r16, r16
    1332:	00 09       	sbc	r16, r0
    1334:	ff 9f       	mul	r31, r31
	...
    133e:	7e 0a       	sbc	r7, r30
    1340:	00 00       	nop
    1342:	4e 0b       	sbc	r20, r30
    1344:	00 00       	nop
    1346:	02 00       	.word	0x0002	; ????
    1348:	3e 9f       	mul	r19, r30
	...
    1352:	7e 0a       	sbc	r7, r30
    1354:	00 00       	nop
    1356:	4e 0b       	sbc	r20, r30
    1358:	00 00       	nop
    135a:	02 00       	.word	0x0002	; ????
    135c:	3c 9f       	mul	r19, r28
	...
    1366:	7e 0a       	sbc	r7, r30
    1368:	00 00       	nop
    136a:	4e 0b       	sbc	r20, r30
    136c:	00 00       	nop
    136e:	02 00       	.word	0x0002	; ????
    1370:	34 9f       	mul	r19, r20
	...
    137a:	7e 0a       	sbc	r7, r30
    137c:	00 00       	nop
    137e:	4e 0b       	sbc	r20, r30
    1380:	00 00       	nop
    1382:	02 00       	.word	0x0002	; ????
    1384:	35 9f       	mul	r19, r21
	...
    138e:	7e 0a       	sbc	r7, r30
    1390:	00 00       	nop
    1392:	4e 0b       	sbc	r20, r30
    1394:	00 00       	nop
    1396:	02 00       	.word	0x0002	; ????
    1398:	36 9f       	mul	r19, r22
	...
    13a2:	7e 0a       	sbc	r7, r30
    13a4:	00 00       	nop
    13a6:	4e 0b       	sbc	r20, r30
    13a8:	00 00       	nop
    13aa:	02 00       	.word	0x0002	; ????
    13ac:	37 9f       	mul	r19, r23
	...
    13b6:	7e 0a       	sbc	r7, r30
    13b8:	00 00       	nop
    13ba:	4e 0b       	sbc	r20, r30
    13bc:	00 00       	nop
    13be:	02 00       	.word	0x0002	; ????
    13c0:	38 9f       	mul	r19, r24
	...
    13ca:	7e 0a       	sbc	r7, r30
    13cc:	00 00       	nop
    13ce:	4e 0b       	sbc	r20, r30
    13d0:	00 00       	nop
    13d2:	02 00       	.word	0x0002	; ????
    13d4:	39 9f       	mul	r19, r25
	...
    13de:	7e 0a       	sbc	r7, r30
    13e0:	00 00       	nop
    13e2:	4e 0b       	sbc	r20, r30
    13e4:	00 00       	nop
    13e6:	02 00       	.word	0x0002	; ????
    13e8:	3a 9f       	mul	r19, r26
	...
    13f2:	7e 0a       	sbc	r7, r30
    13f4:	00 00       	nop
    13f6:	4e 0b       	sbc	r20, r30
    13f8:	00 00       	nop
    13fa:	02 00       	.word	0x0002	; ????
    13fc:	3b 9f       	mul	r19, r27
	...
    1406:	92 0a       	sbc	r9, r18
    1408:	00 00       	nop
    140a:	4e 0b       	sbc	r20, r30
    140c:	00 00       	nop
    140e:	02 00       	.word	0x0002	; ????
    1410:	30 9f       	mul	r19, r16
	...
    141a:	92 0a       	sbc	r9, r18
    141c:	00 00       	nop
    141e:	4e 0b       	sbc	r20, r30
    1420:	00 00       	nop
    1422:	02 00       	.word	0x0002	; ????
    1424:	3e 9f       	mul	r19, r30
	...
    142e:	92 0a       	sbc	r9, r18
    1430:	00 00       	nop
    1432:	4e 0b       	sbc	r20, r30
    1434:	00 00       	nop
    1436:	03 00       	.word	0x0003	; ????
    1438:	09 ff       	.word	0xff09	; ????
    143a:	9f 00       	.word	0x009f	; ????
    143c:	00 00       	nop
    143e:	00 00       	nop
    1440:	00 00       	nop
    1442:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    1446:	00 4e       	sbci	r16, 0xE0	; 224
    1448:	0b 00       	.word	0x000b	; ????
    144a:	00 02       	muls	r16, r16
    144c:	00 3c       	cpi	r16, 0xC0	; 192
    144e:	9f 00       	.word	0x009f	; ????
    1450:	00 00       	nop
    1452:	00 00       	nop
    1454:	00 00       	nop
    1456:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    145a:	00 4e       	sbci	r16, 0xE0	; 224
    145c:	0b 00       	.word	0x000b	; ????
    145e:	00 02       	muls	r16, r16
    1460:	00 34       	cpi	r16, 0x40	; 64
    1462:	9f 00       	.word	0x009f	; ????
    1464:	00 00       	nop
    1466:	00 00       	nop
    1468:	00 00       	nop
    146a:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    146e:	00 4e       	sbci	r16, 0xE0	; 224
    1470:	0b 00       	.word	0x000b	; ????
    1472:	00 02       	muls	r16, r16
    1474:	00 35       	cpi	r16, 0x50	; 80
    1476:	9f 00       	.word	0x009f	; ????
    1478:	00 00       	nop
    147a:	00 00       	nop
    147c:	00 00       	nop
    147e:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    1482:	00 4e       	sbci	r16, 0xE0	; 224
    1484:	0b 00       	.word	0x000b	; ????
    1486:	00 02       	muls	r16, r16
    1488:	00 36       	cpi	r16, 0x60	; 96
    148a:	9f 00       	.word	0x009f	; ????
    148c:	00 00       	nop
    148e:	00 00       	nop
    1490:	00 00       	nop
    1492:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    1496:	00 4e       	sbci	r16, 0xE0	; 224
    1498:	0b 00       	.word	0x000b	; ????
    149a:	00 02       	muls	r16, r16
    149c:	00 37       	cpi	r16, 0x70	; 112
    149e:	9f 00       	.word	0x009f	; ????
    14a0:	00 00       	nop
    14a2:	00 00       	nop
    14a4:	00 00       	nop
    14a6:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    14aa:	00 4e       	sbci	r16, 0xE0	; 224
    14ac:	0b 00       	.word	0x000b	; ????
    14ae:	00 02       	muls	r16, r16
    14b0:	00 38       	cpi	r16, 0x80	; 128
    14b2:	9f 00       	.word	0x009f	; ????
    14b4:	00 00       	nop
    14b6:	00 00       	nop
    14b8:	00 00       	nop
    14ba:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    14be:	00 4e       	sbci	r16, 0xE0	; 224
    14c0:	0b 00       	.word	0x000b	; ????
    14c2:	00 02       	muls	r16, r16
    14c4:	00 39       	cpi	r16, 0x90	; 144
    14c6:	9f 00       	.word	0x009f	; ????
    14c8:	00 00       	nop
    14ca:	00 00       	nop
    14cc:	00 00       	nop
    14ce:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    14d2:	00 4e       	sbci	r16, 0xE0	; 224
    14d4:	0b 00       	.word	0x000b	; ????
    14d6:	00 02       	muls	r16, r16
    14d8:	00 3a       	cpi	r16, 0xA0	; 160
    14da:	9f 00       	.word	0x009f	; ????
    14dc:	00 00       	nop
    14de:	00 00       	nop
    14e0:	00 00       	nop
    14e2:	00 92 0a 00 	sts	0x000A, r0	; 0x80000a <__TEXT_REGION_LENGTH__+0x7e000a>
    14e6:	00 4e       	sbci	r16, 0xE0	; 224
    14e8:	0b 00       	.word	0x000b	; ????
    14ea:	00 02       	muls	r16, r16
    14ec:	00 3b       	cpi	r16, 0xB0	; 176
    14ee:	9f 00       	.word	0x009f	; ????
    14f0:	00 00       	nop
    14f2:	00 00       	nop
    14f4:	00 00       	nop
    14f6:	00 d4       	rcall	.+2048   	; 0x1cf8 <__data_load_end+0xf6c>
    14f8:	0a 00       	.word	0x000a	; ????
    14fa:	00 dc       	rcall	.-2048   	; 0xcfc <__udivmodsi4_loop+0x8>
    14fc:	0a 00       	.word	0x000a	; ????
    14fe:	00 02       	muls	r16, r16
    1500:	00 30       	cpi	r16, 0x00	; 0
    1502:	9f dc       	rcall	.-1730   	; 0xe42 <__data_load_end+0xb6>
    1504:	0a 00       	.word	0x000a	; ????
    1506:	00 e2       	ldi	r16, 0x20	; 32
    1508:	0a 00       	.word	0x000a	; ????
    150a:	00 09       	sbc	r16, r0
    150c:	00 80       	ld	r0, Z
    150e:	00 03       	mulsu	r16, r16
    1510:	d8 01       	movw	r26, r16
    1512:	80 00       	.word	0x0080	; ????
    1514:	1c 9f       	mul	r17, r28
    1516:	e2 0a       	sbc	r14, r18
    1518:	00 00       	nop
    151a:	e6 0a       	sbc	r14, r22
    151c:	00 00       	nop
    151e:	0a 00       	.word	0x000a	; ????
    1520:	03 d8       	rcall	.-4090   	; 0x528 <_ZN3LCD9setCursorEhh.constprop.36+0x20>
    1522:	01 80       	ldd	r0, Z+1	; 0x01
    1524:	00 20       	and	r0, r0
    1526:	80 00       	.word	0x0080	; ????
    1528:	22 9f       	mul	r18, r18
    152a:	e6 0a       	sbc	r14, r22
    152c:	00 00       	nop
    152e:	f0 0a       	sbc	r15, r16
    1530:	00 00       	nop
    1532:	09 00       	.word	0x0009	; ????
    1534:	80 00       	.word	0x0080	; ????
    1536:	03 d8       	rcall	.-4090   	; 0x53e <_ZN3LCD9setCursorEhh.constprop.36+0x36>
    1538:	01 80       	ldd	r0, Z+1	; 0x01
    153a:	00 1c       	adc	r0, r0
    153c:	9f f0       	brie	.+38     	; 0x1564 <__data_load_end+0x7d8>
    153e:	0a 00       	.word	0x000a	; ????
    1540:	00 f2       	brcs	.-128    	; 0x14c2 <__data_load_end+0x736>
    1542:	0a 00       	.word	0x000a	; ????
    1544:	00 0b       	sbc	r16, r16
    1546:	00 8c       	ldd	r0, Z+24	; 0x18
    1548:	00 03       	mulsu	r16, r16
    154a:	dc 01       	movw	r26, r24
    154c:	80 00       	.word	0x0080	; ????
    154e:	1c 23       	and	r17, r28
    1550:	04 9f       	mul	r16, r20
    1552:	f2 0a       	sbc	r15, r18
    1554:	00 00       	nop
    1556:	f6 0a       	sbc	r15, r22
    1558:	00 00       	nop
    155a:	0b 00       	.word	0x000b	; ????
    155c:	8c 00       	.word	0x008c	; ????
    155e:	03 dc       	rcall	.-2042   	; 0xd66 <__data_load_start+0x20>
    1560:	01 80       	ldd	r0, Z+1	; 0x01
    1562:	00 1c       	adc	r0, r0
    1564:	23 03       	mulsu	r18, r19
    1566:	9f f6       	brid	.-90     	; 0x150e <__data_load_end+0x782>
    1568:	0a 00       	.word	0x000a	; ????
    156a:	00 4e       	sbci	r16, 0xE0	; 224
    156c:	0b 00       	.word	0x000b	; ????
    156e:	00 0b       	sbc	r16, r16
    1570:	00 8c       	ldd	r0, Z+24	; 0x18
    1572:	00 03       	mulsu	r16, r16
    1574:	dc 01       	movw	r26, r24
    1576:	80 00       	.word	0x0080	; ????
    1578:	1c 23       	and	r17, r28
    157a:	04 9f       	mul	r16, r20
	...
    1584:	62 07       	cpc	r22, r18
    1586:	00 00       	nop
    1588:	64 07       	cpc	r22, r20
    158a:	00 00       	nop
    158c:	03 00       	.word	0x0003	; ????
    158e:	92 20       	and	r9, r2
    1590:	02 64       	ori	r16, 0x42	; 66
    1592:	07 00       	.word	0x0007	; ????
    1594:	00 66       	ori	r16, 0x60	; 96
    1596:	07 00       	.word	0x0007	; ????
    1598:	00 03       	mulsu	r16, r16
    159a:	00 92 20 03 	sts	0x0320, r0	; 0x800320 <__bss_end+0x13f>
    159e:	66 07       	cpc	r22, r22
    15a0:	00 00       	nop
    15a2:	6e 07       	cpc	r22, r30
    15a4:	00 00       	nop
    15a6:	03 00       	.word	0x0003	; ????
    15a8:	92 20       	and	r9, r2
    15aa:	04 6e       	ori	r16, 0xE4	; 228
    15ac:	07 00       	.word	0x0007	; ????
    15ae:	00 70       	andi	r16, 0x00	; 0
    15b0:	07 00       	.word	0x0007	; ????
    15b2:	00 03       	mulsu	r16, r16
    15b4:	00 92 20 05 	sts	0x0520, r0	; 0x800520 <__bss_end+0x33f>
    15b8:	70 07       	cpc	r23, r16
    15ba:	00 00       	nop
    15bc:	72 07       	cpc	r23, r18
    15be:	00 00       	nop
    15c0:	03 00       	.word	0x0003	; ????
    15c2:	92 20       	and	r9, r2
    15c4:	06 72       	andi	r16, 0x26	; 38
    15c6:	07 00       	.word	0x0007	; ????
    15c8:	00 74       	andi	r16, 0x40	; 64
    15ca:	07 00       	.word	0x0007	; ????
    15cc:	00 03       	mulsu	r16, r16
    15ce:	00 92 20 07 	sts	0x0720, r0	; 0x800720 <__bss_end+0x53f>
    15d2:	74 07       	cpc	r23, r20
    15d4:	00 00       	nop
    15d6:	76 07       	cpc	r23, r22
    15d8:	00 00       	nop
    15da:	03 00       	.word	0x0003	; ????
    15dc:	92 20       	and	r9, r2
    15de:	08 76       	andi	r16, 0x68	; 104
    15e0:	07 00       	.word	0x0007	; ????
    15e2:	00 78       	andi	r16, 0x80	; 128
    15e4:	07 00       	.word	0x0007	; ????
    15e6:	00 03       	mulsu	r16, r16
    15e8:	00 92 20 09 	sts	0x0920, r0	; 0x800920 <__bss_end+0x73f>
    15ec:	78 07       	cpc	r23, r24
    15ee:	00 00       	nop
    15f0:	f6 07       	cpc	r31, r22
    15f2:	00 00       	nop
    15f4:	03 00       	.word	0x0003	; ????
    15f6:	92 20       	and	r9, r2
    15f8:	0a 00       	.word	0x000a	; ????
    15fa:	00 00       	nop
    15fc:	00 00       	nop
    15fe:	00 00       	nop
    1600:	00 88       	ldd	r0, Z+16	; 0x10
    1602:	07 00       	.word	0x0007	; ????
    1604:	00 8c       	ldd	r0, Z+24	; 0x18
    1606:	07 00       	.word	0x0007	; ????
    1608:	00 0c       	add	r0, r0
    160a:	00 68       	ori	r16, 0x80	; 128
    160c:	93 01       	movw	r18, r6
    160e:	69 93       	st	Y+, r22
    1610:	01 6a       	ori	r16, 0xA1	; 161
    1612:	93 01       	movw	r18, r6
    1614:	6b 93       	.word	0x936b	; ????
    1616:	01 8c       	ldd	r0, Z+25	; 0x19
    1618:	07 00       	.word	0x0007	; ????
    161a:	00 9a       	sbi	0x00, 0	; 0
    161c:	07 00       	.word	0x0007	; ????
    161e:	00 03       	mulsu	r16, r16
    1620:	00 88       	ldd	r0, Z+16	; 0x10
    1622:	01 9f       	mul	r16, r17
    1624:	9a 07       	cpc	r25, r26
    1626:	00 00       	nop
    1628:	9c 07       	cpc	r25, r28
    162a:	00 00       	nop
    162c:	0c 00       	.word	0x000c	; ????
    162e:	68 93       	.word	0x9368	; ????
    1630:	01 69       	ori	r16, 0x91	; 145
    1632:	93 01       	movw	r18, r6
    1634:	6a 93       	st	-Y, r22
    1636:	01 6b       	ori	r16, 0xB1	; 177
    1638:	93 01       	movw	r18, r6
    163a:	9c 07       	cpc	r25, r28
    163c:	00 00       	nop
    163e:	a6 07       	cpc	r26, r22
    1640:	00 00       	nop
    1642:	03 00       	.word	0x0003	; ????
    1644:	88 01       	movw	r16, r16
    1646:	9f a6       	std	Y+47, r9	; 0x2f
    1648:	07 00       	.word	0x0007	; ????
    164a:	00 ca       	rjmp	.-3072   	; 0xa4c <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x2>
    164c:	07 00       	.word	0x0007	; ????
    164e:	00 0c       	add	r0, r0
    1650:	00 68       	ori	r16, 0x80	; 128
    1652:	93 01       	movw	r18, r6
    1654:	69 93       	st	Y+, r22
    1656:	01 6a       	ori	r16, 0xA1	; 161
    1658:	93 01       	movw	r18, r6
    165a:	6b 93       	.word	0x936b	; ????
    165c:	01 ca       	rjmp	.-3070   	; 0xa60 <_GLOBAL__I_65535_0_JB_CPU_Usage_Basic.ino.cpp.o.2580+0x16>
    165e:	07 00       	.word	0x0007	; ????
    1660:	00 e0       	ldi	r16, 0x00	; 0
    1662:	07 00       	.word	0x0007	; ????
    1664:	00 05       	cpc	r16, r0
    1666:	00 03       	mulsu	r16, r16
    1668:	b6 01       	movw	r22, r12
    166a:	80 00       	.word	0x0080	; ????
	...
    1674:	8c 07       	cpc	r24, r28
    1676:	00 00       	nop
    1678:	90 07       	cpc	r25, r16
    167a:	00 00       	nop
    167c:	01 00       	.word	0x0001	; ????
    167e:	63 90       	.word	0x9063	; ????
    1680:	07 00       	.word	0x0007	; ????
    1682:	00 9e       	mul	r0, r16
    1684:	07 00       	.word	0x0007	; ????
    1686:	00 01       	movw	r0, r0
    1688:	00 62       	ori	r16, 0x20	; 32
    168a:	9e 07       	cpc	r25, r30
    168c:	00 00       	nop
    168e:	a0 07       	cpc	r26, r16
    1690:	00 00       	nop
    1692:	03 00       	.word	0x0003	; ????
    1694:	83 03       	fmuls	r16, r19
    1696:	9f a0       	ldd	r9, Y+39	; 0x27
    1698:	07 00       	.word	0x0007	; ????
    169a:	00 ec       	ldi	r16, 0xC0	; 192
    169c:	07 00       	.word	0x0007	; ????
    169e:	00 01       	movw	r0, r0
    16a0:	00 62       	ori	r16, 0x20	; 32
    16a2:	ec 07       	cpc	r30, r28
    16a4:	00 00       	nop
    16a6:	f0 07       	cpc	r31, r16
    16a8:	00 00       	nop
    16aa:	05 00       	.word	0x0005	; ????
    16ac:	03 b5       	in	r16, 0x23	; 35
    16ae:	01 80       	ldd	r0, Z+1	; 0x01
	...
    16b8:	00 0c       	add	r0, r0
    16ba:	0c 00       	.word	0x000c	; ????
    16bc:	00 0e       	add	r0, r16
    16be:	0c 00       	.word	0x000c	; ????
    16c0:	00 0c       	add	r0, r0
    16c2:	00 68       	ori	r16, 0x80	; 128
    16c4:	93 01       	movw	r18, r6
    16c6:	69 93       	st	Y+, r22
    16c8:	01 6a       	ori	r16, 0xA1	; 161
    16ca:	93 01       	movw	r18, r6
    16cc:	6b 93       	.word	0x936b	; ????
    16ce:	01 00       	.word	0x0001	; ????
    16d0:	00 00       	nop
    16d2:	00 00       	nop
    16d4:	00 00       	nop
    16d6:	00 fa       	bst	r0, 0
    16d8:	0b 00       	.word	0x000b	; ????
    16da:	00 0e       	add	r0, r16
    16dc:	0c 00       	.word	0x000c	; ????
    16de:	00 01       	movw	r0, r0
    16e0:	00 62       	ori	r16, 0x20	; 32
	...
    16ea:	7c 0c       	add	r7, r12
    16ec:	00 00       	nop
    16ee:	82 0c       	add	r8, r2
    16f0:	00 00       	nop
    16f2:	04 00       	.word	0x0004	; ????
    16f4:	0a 3b       	cpi	r16, 0xBA	; 186
    16f6:	1f 9f       	mul	r17, r31
	...
    1700:	70 0c       	add	r7, r0
    1702:	00 00       	nop
    1704:	72 0c       	add	r7, r2
    1706:	00 00       	nop
    1708:	0c 00       	.word	0x000c	; ????
    170a:	5c 93       	st	X, r21
    170c:	01 5d       	subi	r16, 0xD1	; 209
    170e:	93 01       	movw	r18, r6
    1710:	5e 93       	st	-X, r21
    1712:	01 5f       	subi	r16, 0xF1	; 241
    1714:	93 01       	movw	r18, r6
	...
    171e:	5e 0c       	add	r5, r14
    1720:	00 00       	nop
    1722:	72 0c       	add	r7, r2
    1724:	00 00       	nop
    1726:	01 00       	.word	0x0001	; ????
    1728:	68 00       	.word	0x0068	; ????
    172a:	00 00       	nop
    172c:	00 00       	nop
    172e:	00 00       	nop
    1730:	00 90 0c 00 	lds	r0, 0x000C	; 0x80000c <__TEXT_REGION_LENGTH__+0x7e000c>
    1734:	00 9e       	mul	r0, r16
    1736:	0c 00       	.word	0x000c	; ????
    1738:	00 02       	muls	r16, r16
    173a:	00 3a       	cpi	r16, 0xA0	; 160
    173c:	9f 00       	.word	0x009f	; ????
    173e:	00 00       	nop
    1740:	00 00       	nop
    1742:	00 00       	nop
    1744:	00 90 0c 00 	lds	r0, 0x000C	; 0x80000c <__TEXT_REGION_LENGTH__+0x7e000c>
    1748:	00 9e       	mul	r0, r16
    174a:	0c 00       	.word	0x000c	; ????
    174c:	00 06       	cpc	r0, r16
    174e:	00 0c       	add	r0, r0
    1750:	c0 c6       	rjmp	.+3456   	; 0x24d2 <__data_load_end+0x1746>
    1752:	2d 00       	.word	0x002d	; ????
    1754:	9f 00       	.word	0x009f	; ????
    1756:	00 00       	nop
    1758:	00 00       	nop
    175a:	00 00       	nop
    175c:	00 ac       	ldd	r0, Z+56	; 0x38
    175e:	0c 00       	.word	0x000c	; ????
    1760:	00 d2       	rcall	.+1024   	; 0x1b62 <__data_load_end+0xdd6>
    1762:	0c 00       	.word	0x000c	; ????
    1764:	00 02       	muls	r16, r16
    1766:	00 3a       	cpi	r16, 0xA0	; 160
    1768:	9f 00       	.word	0x009f	; ????
    176a:	00 00       	nop
    176c:	00 00       	nop
    176e:	00 00       	nop
    1770:	00 ac       	ldd	r0, Z+56	; 0x38
    1772:	0c 00       	.word	0x000c	; ????
    1774:	00 c8       	rjmp	.-4096   	; 0x776 <__vector_16+0x14>
    1776:	0c 00       	.word	0x000c	; ????
    1778:	00 0a       	sbc	r0, r16
    177a:	00 7c       	andi	r16, 0xC0	; 192
    177c:	00 03       	mulsu	r16, r16
    177e:	b1 01       	movw	r22, r2
    1780:	80 00       	.word	0x0080	; ????
    1782:	06 1c       	adc	r0, r6
    1784:	9f c8       	rjmp	.-3778   	; 0x8c4 <__vector_24+0xce>
    1786:	0c 00       	.word	0x000c	; ????
    1788:	00 d1       	rcall	.+512    	; 0x198a <__data_load_end+0xbfe>
    178a:	0c 00       	.word	0x000c	; ????
    178c:	00 0c       	add	r0, r0
    178e:	00 62       	ori	r16, 0x20	; 32
    1790:	93 01       	movw	r18, r6
    1792:	63 93       	.word	0x9363	; ????
    1794:	01 64       	ori	r16, 0x41	; 65
    1796:	93 01       	movw	r18, r6
    1798:	65 93       	las	Z, r22
    179a:	01 00       	.word	0x0001	; ????
    179c:	00 00       	nop
    179e:	00 00       	nop
    17a0:	00 00       	nop
    17a2:	00 f6       	brcc	.-128    	; 0x1724 <__data_load_end+0x998>
    17a4:	07 00       	.word	0x0007	; ????
    17a6:	00 f8       	bld	r0, 0
    17a8:	07 00       	.word	0x0007	; ????
    17aa:	00 03       	mulsu	r16, r16
    17ac:	00 92 20 02 	sts	0x0220, r0	; 0x800220 <__bss_end+0x3f>
    17b0:	f8 07       	cpc	r31, r24
    17b2:	00 00       	nop
    17b4:	fa 07       	cpc	r31, r26
    17b6:	00 00       	nop
    17b8:	03 00       	.word	0x0003	; ????
    17ba:	92 20       	and	r9, r2
    17bc:	03 fa       	bst	r0, 3
    17be:	07 00       	.word	0x0007	; ????
    17c0:	00 02       	muls	r16, r16
    17c2:	08 00       	.word	0x0008	; ????
    17c4:	00 03       	mulsu	r16, r16
    17c6:	00 92 20 04 	sts	0x0420, r0	; 0x800420 <__bss_end+0x23f>
    17ca:	02 08       	sbc	r0, r2
    17cc:	00 00       	nop
    17ce:	04 08       	sbc	r0, r4
    17d0:	00 00       	nop
    17d2:	03 00       	.word	0x0003	; ????
    17d4:	92 20       	and	r9, r2
    17d6:	05 04       	cpc	r0, r5
    17d8:	08 00       	.word	0x0008	; ????
    17da:	00 06       	cpc	r0, r16
    17dc:	08 00       	.word	0x0008	; ????
    17de:	00 03       	mulsu	r16, r16
    17e0:	00 92 20 06 	sts	0x0620, r0	; 0x800620 <__bss_end+0x43f>
    17e4:	06 08       	sbc	r0, r6
    17e6:	00 00       	nop
    17e8:	08 08       	sbc	r0, r8
    17ea:	00 00       	nop
    17ec:	03 00       	.word	0x0003	; ????
    17ee:	92 20       	and	r9, r2
    17f0:	07 08       	sbc	r0, r7
    17f2:	08 00       	.word	0x0008	; ????
    17f4:	00 0a       	sbc	r0, r16
    17f6:	08 00       	.word	0x0008	; ????
    17f8:	00 03       	mulsu	r16, r16
    17fa:	00 92 20 08 	sts	0x0820, r0	; 0x800820 <__bss_end+0x63f>
    17fe:	0a 08       	sbc	r0, r10
    1800:	00 00       	nop
    1802:	0c 08       	sbc	r0, r12
    1804:	00 00       	nop
    1806:	03 00       	.word	0x0003	; ????
    1808:	92 20       	and	r9, r2
    180a:	09 0c       	add	r0, r9
    180c:	08 00       	.word	0x0008	; ????
    180e:	00 0e       	add	r0, r16
    1810:	08 00       	.word	0x0008	; ????
    1812:	00 03       	mulsu	r16, r16
    1814:	00 92 20 0a 	sts	0x0A20, r0	; 0x800a20 <__bss_end+0x83f>
    1818:	0e 08       	sbc	r0, r14
    181a:	00 00       	nop
    181c:	10 08       	sbc	r1, r0
    181e:	00 00       	nop
    1820:	03 00       	.word	0x0003	; ????
    1822:	92 20       	and	r9, r2
    1824:	0b 10       	cpse	r0, r11
    1826:	08 00       	.word	0x0008	; ????
    1828:	00 12       	cpse	r0, r16
    182a:	08 00       	.word	0x0008	; ????
    182c:	00 03       	mulsu	r16, r16
    182e:	00 92 20 0c 	sts	0x0C20, r0	; 0x800c20 <__bss_end+0xa3f>
    1832:	12 08       	sbc	r1, r2
    1834:	00 00       	nop
    1836:	14 08       	sbc	r1, r4
    1838:	00 00       	nop
    183a:	03 00       	.word	0x0003	; ????
    183c:	92 20       	and	r9, r2
    183e:	0d 14       	cp	r0, r13
    1840:	08 00       	.word	0x0008	; ????
    1842:	00 16       	cp	r0, r16
    1844:	08 00       	.word	0x0008	; ????
    1846:	00 03       	mulsu	r16, r16
    1848:	00 92 20 0e 	sts	0x0E20, r0	; 0x800e20 <__bss_end+0xc3f>
    184c:	16 08       	sbc	r1, r6
    184e:	00 00       	nop
    1850:	18 08       	sbc	r1, r8
    1852:	00 00       	nop
    1854:	03 00       	.word	0x0003	; ????
    1856:	92 20       	and	r9, r2
    1858:	0f 18       	sub	r0, r15
    185a:	08 00       	.word	0x0008	; ????
    185c:	00 4a       	sbci	r16, 0xA0	; 160
    185e:	0a 00       	.word	0x000a	; ????
    1860:	00 03       	mulsu	r16, r16
    1862:	00 92 20 10 	sts	0x1020, r0	; 0x801020 <__bss_end+0xe3f>
	...
    186e:	06 09       	sbc	r16, r6
    1870:	00 00       	nop
    1872:	0a 09       	sbc	r16, r10
    1874:	00 00       	nop
    1876:	02 00       	.word	0x0002	; ????
    1878:	31 9f       	mul	r19, r17
	...
    1882:	0c 0a       	sbc	r0, r28
    1884:	00 00       	nop
    1886:	0e 0a       	sbc	r0, r30
    1888:	00 00       	nop
    188a:	02 00       	.word	0x0002	; ????
    188c:	30 9f       	mul	r19, r16
	...
    1896:	14 0a       	sbc	r1, r20
    1898:	00 00       	nop
    189a:	16 0a       	sbc	r1, r22
    189c:	00 00       	nop
    189e:	02 00       	.word	0x0002	; ????
    18a0:	31 9f       	mul	r19, r17
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	34 02       	muls	r19, r20
   2:	00 00       	nop
   4:	44 02       	muls	r20, r20
   6:	00 00       	nop
   8:	58 02       	muls	r21, r24
   a:	00 00       	nop
   c:	5c 02       	muls	r21, r28
	...
  16:	00 00       	nop
  18:	94 06       	cpc	r9, r20
  1a:	00 00       	nop
  1c:	a2 06       	cpc	r10, r18
  1e:	00 00       	nop
  20:	aa 06       	cpc	r10, r26
  22:	00 00       	nop
  24:	ac 06       	cpc	r10, r28
	...
  2e:	00 00       	nop
  30:	1e 0c       	add	r1, r14
  32:	00 00       	nop
  34:	22 0c       	add	r2, r2
  36:	00 00       	nop
  38:	26 0c       	add	r2, r6
  3a:	00 00       	nop
  3c:	da 0c       	add	r13, r10
	...
  46:	00 00       	nop
  48:	1e 0c       	add	r1, r14
  4a:	00 00       	nop
  4c:	22 0c       	add	r2, r2
  4e:	00 00       	nop
  50:	5c 0c       	add	r5, r12
  52:	00 00       	nop
  54:	da 0c       	add	r13, r10
	...
  5e:	00 00       	nop
  60:	1e 0c       	add	r1, r14
  62:	00 00       	nop
  64:	22 0c       	add	r2, r2
  66:	00 00       	nop
  68:	72 0c       	add	r7, r2
  6a:	00 00       	nop
  6c:	82 0c       	add	r8, r2
	...
  76:	00 00       	nop
  78:	1e 0c       	add	r1, r14
  7a:	00 00       	nop
  7c:	22 0c       	add	r2, r2
  7e:	00 00       	nop
  80:	7c 0c       	add	r7, r12
  82:	00 00       	nop
  84:	82 0c       	add	r8, r2
	...
  8e:	00 00       	nop
  90:	0e 01       	movw	r0, r28
  92:	00 00       	nop
  94:	4a 0a       	sbc	r4, r26
  96:	00 00       	nop
  98:	4a 0a       	sbc	r4, r26
  9a:	00 00       	nop
  9c:	58 0b       	sbc	r21, r24
  9e:	00 00       	nop
  a0:	58 0b       	sbc	r21, r24
  a2:	00 00       	nop
  a4:	e8 0c       	add	r14, r8
	...
